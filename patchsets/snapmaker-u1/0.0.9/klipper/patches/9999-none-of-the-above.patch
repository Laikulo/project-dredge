--- a/klippy/configfile.py
+++ b/klippy/configfile.py
@@ -395,6 +395,7 @@ class PrinterConfig:
         if not self.autosave.fileconfig.sections():
             return
         gcode = self.printer.lookup_object('gcode')
+        is_restart = gcmd.get_int('RESTART', 1)
         # Create string containing autosave data
         autosave_data = self._build_config_string(self.autosave)
         lines = [('#*# ' + l).strip()
@@ -436,4 +437,5 @@ class PrinterConfig:
             logging.exception(msg)
             raise gcode.error(msg)
         # Request a restart
-        gcode.request_restart('restart')
+        if is_restart :
+            gcode.request_restart('restart')
--- /dev/null
+++ b/klippy/extras/adc_current_sensor.py
@@ -0,0 +1,50 @@
+class ADCCurrentSensor:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.name = config.get_name().split()[-1]  # Get the last part of config name
+
+        # Current sensing parameters
+        self.sense_resistor = config.getfloat('sense_resistor', above=0.0)
+        self.scale = config.getfloat('scale', 1.0, above=0.0)
+        self.adc_reference = config.getfloat('adc_reference_voltage', 3.3, above=0.0)
+        self.voltage_offset = config.getfloat('voltage_offset', 0.0)
+        self.last_current = None
+
+        # Setup ADC pin
+        ppins = self.printer.lookup_object('pins')
+        self.mcu_adc = ppins.setup_pin('adc', config.get('pin'))
+        self.report_time = config.getfloat('report_time', 0.300, above=0.0)
+        self.mcu_adc.setup_adc_sample(
+            config.getfloat('sample_time', 0.001, above=0.0),
+            config.getint('sample_count', 8, minval=1))
+        self.mcu_adc.setup_adc_callback(self.report_time, self.adc_callback)
+
+        # Register mux command
+        self.gcode = self.printer.lookup_object('gcode')
+        self.gcode.register_mux_command(
+            "QUERY_ADC_CURRENT", "SENSOR", self.name,
+            self.cmd_QUERY_ADC_CURRENT,
+            desc=self.cmd_QUERY_ADC_CURRENT_help)
+
+    def adc_callback(self, read_time, read_value):
+        """Convert ADC voltage to current using Ohm's law"""
+        voltage = read_value * self.adc_reference  # read_value is already normalized (0-1)
+        self.last_current = (voltage + self.voltage_offset) / (self.sense_resistor * self.scale)
+
+    def get_status(self, eventtime):
+        """Return sensor status dictionary"""
+        return {
+            'current': self.last_current,
+            'sense_resistor': self.sense_resistor,
+            'adc_reference': self.adc_reference,
+            'voltage_offset': self.voltage_offset,
+            'scale': self.scale
+        }
+
+    cmd_QUERY_ADC_CURRENT_help = "Query current ADC current reading"
+    def cmd_QUERY_ADC_CURRENT(self, gcmd):
+        gcmd.respond_info("Sensor %s current: %.3fA (Sense resistor: %.3fÎ©, Reference voltage: %.1fV)" % (
+            self.name, self.last_current, self.sense_resistor, self.adc_reference))
+
+def load_config_prefix(config):
+    return ADCCurrentSensor(config)
--- a/klippy/extras/adc_temperature.py
+++ b/klippy/extras/adc_temperature.py
@@ -21,13 +21,17 @@ class PrinterADCtoTemperature:
         self.adc_convert = adc_convert
         ppins = config.get_printer().lookup_object('pins')
         self.mcu_adc = ppins.setup_pin('adc', config.get('sensor_pin'))
-        self.mcu_adc.setup_adc_callback(REPORT_TIME, self.adc_callback)
+        self.report_time_delta = config.getfloat('report_time_delta', REPORT_TIME, above=0.)
+        self.mcu_adc.setup_adc_callback(self.report_time_delta, self.adc_callback)
         self.diag_helper = HelperTemperatureDiagnostics(
             config, self.mcu_adc, adc_convert.calc_temp)
     def setup_callback(self, temperature_callback):
         self.temperature_callback = temperature_callback
     def get_report_time_delta(self):
-        return REPORT_TIME
+        return self.report_time_delta
+        # return REPORT_TIME
+    def set_read_tolerance(self, read_time_tol, min_update_ratio):
+        self.mcu_adc.set_read_tolerance(read_time_tol, min_update_ratio)
     def adc_callback(self, read_time, read_value):
         temp = self.adc_convert.calc_temp(read_value)
         self.temperature_callback(read_time + SAMPLE_COUNT * SAMPLE_TIME, temp)
--- /dev/null
+++ b/klippy/extras/auto_screws_tilt_adjust.py
@@ -0,0 +1,607 @@
+# Helper script to automatically adjust bed screws tilt using Z probe
+import math, logging
+from . import probe_inductance_coil
+
+
+class AutoScrewsTiltAdjustError(Exception):
+    pass
+
+class AutoScrewsTiltAdjustAbort(Exception):
+    pass
+
+class AutoScrewsTiltAdjustPass(Exception):
+    pass
+
+class AutoScrewsTiltAdjustLimit(Exception):
+    """Exception raised when screw adjustment attempts exceed the limit"""
+    pass
+
+class AutoScrewsTiltAdjustStep:
+    IDLE = "adjust_idle"
+    PROBING_START = "adjust_start"
+    PROBING_HOMING = "adjust_homing"
+    PROBING_HOMING_DONE = "adjust_homing_done"
+    PROBING_HOMING_ERR = "adjust_homing_failed"
+    PLATE_DETECTING = 'adjust_plate_detecting'
+    PLATE_DETECTED = 'adjust_plate_detected'
+    PLATE_DETECTION_ERROR = 'adjust_plate_detection_error'
+    RESET_TO_INITIAL = 'adjust_reset_to_initial'
+    PROBING_REFPOINT = "adjust_probe_refpoint"
+    PROBING_REFPOINT_COMPLETED = "adjust_refpoint_done"
+    PROBING_ABORTED = "adjust_aborted"
+    PROBING_ABORTING = "adjust_aborting"
+    PROBING_BED = "adjust_probing"
+    WAIT_MANUAL_ADJUST_SCREWS = "adjust_wait_manual"
+    NEXT_POINT_ADJUST = "adjust_next_point_adjust"
+    PROBING_ADJUST_VERIFY = "adjust_verify"
+    SCREWS_TILT_ADJUST_OK = "adjust_complete"
+    SCREWS_TILT_ADJUST_FAIL = "adjust_failed"
+
+class AutoScrewsTiltAdjust:
+    def __init__(self, config):
+        self.config = config
+        self.printer = config.get_printer()
+        self.screws = []
+        self.max_diff = None
+        self.current_point = 0
+        self.abort_flag = False
+        self.state = AutoScrewsTiltAdjustStep.IDLE
+        self.base_points = [None, None, None, None]  # Changed to list
+        self.min_z, self.max_z, self.target_z = (None, None, None)
+        self.probe_after_delay = 0
+        self.need_adjusted_z = None
+        self.lock = self.printer.get_reactor().mutex()
+
+        # Read exactly 4 screw positions from config
+        for i in range(4):
+            prefix = "screw%d" % (i + 1,)
+            if config.get(prefix, None) is None:
+                raise config.error("auto_screws_tilt_adjust: Must have exactly four screws")
+            screw_coord = config.getfloatlist(prefix, count=2)
+            screw_name = "screw at %.3f,%.3f" % screw_coord
+            screw_name = config.get(prefix + "_name", screw_name)
+            self.screws.append((screw_coord, screw_name))
+
+        # Read screw adjustment order (default: 1,2,3,4)
+        self.screw_order = config.getintlist('screw_order', [1,2,3,4], count=4)
+        # Validate order (must contain 1-4 exactly once each)
+        if len(self.screw_order) != 4:
+            raise config.error("auto_screws_tilt_adjust: screw_order must have exactly 4 values")
+        if any(x < 1 or x > 4 for x in self.screw_order):
+            raise config.error("auto_screws_tilt_adjust: screw_order values must be between 1-4")
+        if len(set(self.screw_order)) != 4:
+            raise config.error("auto_screws_tilt_adjust: screw_order values must be unique")
+        if sorted(self.screw_order) != [1,2,3,4]:
+            raise config.error("auto_screws_tilt_adjust: screw_order must contain values 1-4 exactly once each")
+        self.screw_adjust_threshold = config.getfloat('screw_adjust_threshold', 0.1, above=0.)
+        self.adjust_tolerance = config.getfloat('adjust_tolerance', 0.05, maxval=self.screw_adjust_threshold)
+        self.probe_interval = config.getfloat('probe_interval', 10, minval=0.)
+        self.adjust_probe_samples = config.getint('adjust_probe_samples', 2, minval=1)
+        self.adjust_probe_tolerance = config.getfloat('adjust_probe_tolerance', None, minval=0.)
+        self.max_adjust_times = config.getint('max_adjust_times', 30, minval=1)
+        self.max_verify_attempts = config.getint('max_verify_attempts', 10, minval=1)
+        self.samples = config.getint("samples", 3, minval=1)
+        self.sample_retract_dist = config.getfloat("sample_retract_dist", 0.3, above=0)
+
+        # Initialize ProbePointsHelper
+        self.points = [coord for coord, name in self.screws]
+        self.probe_helper = probe_inductance_coil.ProbePointsHelper(
+            self.config,
+            self.probe_finalize,
+            default_points=self.points,
+            probe_point_callback=self.probe_point_callback
+        )
+        self.probe_helper.minimum_points(4)
+
+        # Register commands
+        self.gcode = self.printer.lookup_object('gcode')
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST,
+            desc=self.cmd_AUTO_SCREWS_TILT_ADJUST_help
+        )
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST_ENTRY",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST_ENTRY
+        )
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST_HOMING",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST_HOMING
+        )
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST_DETECT_PLATE",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST_DETECT_PLATE
+        )
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST_RESET_TO_INITIAL",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST_RESET_TO_INITIAL
+        )
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST_PROBE_REFERENCE_POINTS",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST_PROBE_REFERENCE_POINTS
+        )
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST_MANUAL_TUNING",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST_MANUAL_TUNING
+        )
+        self.gcode.register_command(
+            "AUTO_SCREWS_TILT_ADJUST_EXIT",
+            self.cmd_AUTO_SCREWS_TILT_ADJUST_EXIT
+        )
+
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint(
+            "auto_screws_tilt_adjust/abort_screws_adjust", self._handle_abort_screws_adjust)
+        webhooks.register_endpoint(
+            "auto_screws_tilt_adjust/next_point_adjust", self._handle_next_point_adjust)
+
+    cmd_AUTO_SCREWS_TILT_ADJUST_help = """
+    Automatically adjust bed leveling screws by probing until within tolerance.
+    """
+
+    def _move(self, coord, speed):
+        self.printer.lookup_object('toolhead').manual_move(coord, speed)
+
+    def get_status(self, eventtime):
+        return {
+            'probe_step': self.state,
+            'screw_order': self.screw_order,
+            'probe_after_delay': self.probe_after_delay,
+            'min_z': round(self.min_z, 5) if self.min_z is not None else None,
+            'max_z': round(self.max_z, 5) if self.max_z is not None else None,
+            'target_z': round(self.target_z, 5) if self.target_z is not None else None,
+            'base_point1': round(self.base_points[0], 5) if self.base_points[0] is not None else None,
+            'base_point2': round(self.base_points[1], 5) if self.base_points[1] is not None else None,
+            'base_point3': round(self.base_points[2], 5) if self.base_points[2] is not None else None,
+            'base_point4': round(self.base_points[3], 5) if self.base_points[3] is not None else None,
+            'current_point': self.current_point,
+            'need_adjusted_z': round(self.need_adjusted_z, 5) if self.need_adjusted_z is not None else None,
+            'adjust_tolerance': self.adjust_tolerance,
+            'screw_adjust_threshold': self.screw_adjust_threshold
+        }
+
+    def _handle_abort_screws_adjust(self, web_request):
+        try:
+            with self.lock:
+                self.abort_flag = True
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to abort screws adjust: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
+
+    def _handle_next_point_adjust(self, web_request):
+        try:
+            if self.state == AutoScrewsTiltAdjustStep.WAIT_MANUAL_ADJUST_SCREWS:
+                self._set_state(AutoScrewsTiltAdjustStep.NEXT_POINT_ADJUST)
+            else:
+                raise self.printer.command_error('Not in wait manual adjust screws state')
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            web_request.send({'state': 'error', 'message': str(e)})
+    def _probe_abort_check(self):
+        if self.abort_flag:
+            with self.lock:
+                self.state = AutoScrewsTiltAdjustStep.PROBING_ABORTING
+            logging.info("abort_flag set, can't continue")
+            raise AutoScrewsTiltAdjustAbort
+
+    def _check_level_diff(self):
+        """Check if all reference points height difference is within tolerance"""
+        if None in self.base_points:
+            return False
+
+        self.max_z = max(self.base_points)
+        self.min_z = min(self.base_points)
+        level_diff = self.max_z - self.min_z
+
+        self.gcode.respond_info(
+            "Current height difference: %.3fmm (max allowed: %.3fmm)" %
+            (level_diff, self.screw_adjust_threshold))
+        return level_diff < self.screw_adjust_threshold
+
+    def probe_finalize(self, offsets, positions):
+        toolhead = self.printer.lookup_object('toolhead')
+        self.max_diff_error = False
+
+        # Calculate target Z height (average of all points)
+        z_values = [pos[2] for pos in positions]
+        self.target_z = sum(z_values) / len(z_values)
+        self.min_z = min(z_values)
+        self.max_z = max(z_values)
+
+        # Assign base points
+        self.base_points = z_values[:4]  # Store as list
+        with self.lock:
+            self.state = AutoScrewsTiltAdjustStep.PROBING_REFPOINT_COMPLETED
+
+        # Bed level summary
+        self.gcode.respond_info("Bed level summary:")
+        self.gcode.respond_info("Target height=%.5f (lowest=%.5f, highest=%.5f, difference=%.5f)" %
+            (self.target_z, self.min_z, self.max_z, self.max_z-self.min_z))
+
+        if abs(self.max_z - self.min_z) < self.screw_adjust_threshold:
+            self.gcode.respond_info("All 4 points meet requirements, no further adjustment needed")
+            raise AutoScrewsTiltAdjustPass
+
+    def probe_point_callback(self, points):
+        if self.abort_flag:
+            with self.lock:
+                self.state = AutoScrewsTiltAdjustStep.PROBING_ABORTING
+            raise AutoScrewsTiltAdjustAbort
+        if not points or len(points) < 2:
+            return
+        with self.lock:
+            self.current_point = min(points[0] + 1, points[1])
+
+    def _verify_level(self, probe_cmd, toolhead, probe_object):
+        if probe_object is None:
+            raise AutoScrewsTiltAdjustError("Probe object not found")
+
+        with self.lock:
+            self.state = AutoScrewsTiltAdjustStep.PROBING_ADJUST_VERIFY
+
+        self.gcode.respond_info("Verifying overall leveling...")
+        for i, (coord, name) in enumerate(self.screws):
+            self._probe_abort_check()
+            self._move([None, None, self.probe_helper.default_horizontal_move_z],
+                      self.probe_helper.lift_speed)
+            self._move([coord[0], coord[1], None],
+                      self.probe_helper.speed)
+            toolhead.wait_moves()
+            self.gcode.run_script_from_command(probe_cmd)
+            toolhead.wait_moves()
+            self.base_points[i] = probe_object.get_status(0)['last_z_result']
+
+        return self._check_level_diff()
+
+    def adjust_screws(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead')
+        probe_object = self.printer.lookup_object('probe', None)
+        if probe_object is None:
+            raise gcmd.error("Probe object not found")
+
+        # Initial probing results and adjustment instructions
+        self.gcode.respond_info("Initial probing results:")
+        for i, (z, screw) in enumerate(zip(self.base_points, self.screws)):
+            coord, name = screw
+            diff = self.target_z - z
+            direction = "CW" if diff > 0 else "CCW"
+            self.gcode.respond_info(
+                "%s : x=%.5f, y=%.5f, z=%.5f (turn %s %.5fmm)" %
+                (name, coord[0], coord[1], z, direction, abs(diff)))
+
+        params = gcmd.get_command_parameters()
+        adjust_probe_samples = None
+        adjust_probe_tolerance = None
+        if 'ADJUST_PROBE_SAMPLES' not in params and self.adjust_probe_samples is not None:
+            adjust_probe_samples = self.adjust_probe_samples
+        if 'ADJUST_PROBE_TOLERANCE' not in params and self.adjust_probe_tolerance is not None:
+            adjust_probe_tolerance = self.adjust_probe_tolerance
+        probe_cmd = "PROBE"
+        if adjust_probe_samples is not None:
+            probe_cmd += " SAMPLES={}".format(adjust_probe_samples)
+        if adjust_probe_tolerance is not None:
+            probe_cmd += " SAMPLES_TOLERANCE={:.3f}".format(adjust_probe_tolerance)
+        probe_interval = gcmd.get_int("ADJUST_PROBE_INTERVAL", self.probe_interval, minval=1)
+        max_adjust_times = gcmd.get_int('ADJUST_MAX_TIMES', self.max_adjust_times, minval=1)
+        max_verify_attempts = gcmd.get_int('MAX_VERIFY_ATTEMPTS', self.max_verify_attempts, minval=1)
+
+        verify_attempt = 0
+        while verify_attempt < max_verify_attempts:
+            verify_attempt += 1
+            self.gcode.respond_info("Starting adjustment round %d..." % verify_attempt)
+
+            # Adjust screws in specified order
+            for screw_num in self.screw_order:
+                i = screw_num - 1  # Convert to 0-based index
+                screw = self.screws[i]
+                coord, name = screw
+                adjust_count = 0
+                while True:
+                    # Check adjustment count limit
+                    adjust_count += 1
+                    if adjust_count > max_adjust_times:
+                        raise AutoScrewsTiltAdjustLimit(
+                            "%s adjustment exceeded max limit (%d times)" % (name, max_adjust_times))
+
+                    # Probe current point
+                    diff = self.target_z - self.base_points[i]
+                    if abs(diff) <= self.adjust_tolerance:
+                        self.gcode.respond_info(
+                            "%s is within tolerance (deviation: %.3fmm)" % (name, diff))
+                        break
+
+                    self._probe_abort_check()
+                    self._move([None, None, self.probe_helper.default_horizontal_move_z], self.probe_helper.lift_speed)
+                    self._move([coord[0], coord[1], None], self.probe_helper.speed)
+                    self.gcode.respond_info("Adjusting %s..., auto probing in %3fs" % (name, self.probe_interval))
+                    self.need_adjusted_z = self.target_z - self.base_points[i]
+                    direction = "CW" if diff > 0 else "CCW"
+                    self.gcode.respond_info("Turn %s %s (%.3fmm)" % (direction, name, diff))
+
+                    with self.lock:
+                        self.probe_after_delay = probe_interval
+                        self.state = AutoScrewsTiltAdjustStep.WAIT_MANUAL_ADJUST_SCREWS
+                        self.current_point = screw_num
+
+                    # Wait for probe interval
+                    toolhead.wait_moves()  # Ensure all moves complete
+                    remaining = probe_interval
+                    while remaining > 0:
+                        self._probe_abort_check()
+                        dwell_time = min(1.0, remaining)
+                        toolhead.dwell(dwell_time)
+                        remaining -= dwell_time
+                        self.probe_after_delay = remaining
+
+                    with self.lock:
+                        self.probe_after_delay = 0
+                        self.state = AutoScrewsTiltAdjustStep.PROBING_BED
+                    self.gcode.run_script_from_command(probe_cmd)
+                    toolhead.wait_moves()
+                    self.base_points[i] = probe_object.get_status(0)['last_z_result']
+
+            # Recalculate target height as average of max and min
+            self.max_z = max(self.base_points)
+            self.min_z = min(self.base_points)
+            self.target_z = (self.max_z + self.min_z) / 2
+            self.gcode.respond_info("Updated target height: %.5f (max:%.5f min:%.5f)" %
+                (self.target_z, self.max_z, self.min_z))
+
+            # Verify overall leveling
+            if self._verify_level(probe_cmd, toolhead, probe_object):
+                raise AutoScrewsTiltAdjustPass
+            elif verify_attempt < max_verify_attempts:
+                self.gcode.respond_info("Preparing for adjustment round %d..." % (verify_attempt + 1))
+            else:
+                raise AutoScrewsTiltAdjustLimit("Adjustment exceeded max verification attempts (%d)" % max_verify_attempts)
+    def _set_state(self, state):
+        with self.lock:
+            self.state = state
+    def _verify_screws_tilt_adjust_state(self, operation=None):
+        machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        if (machine_state_manager and
+            str(machine_state_manager.get_status()['main_state']) != "SCREWS_TILT_ADJUST"):
+            if operation:
+                raise self.printer.command_error(f"Operation '{operation}' requires SCREWS_TILT_ADJUST mode")
+            else:
+                raise self.printer.command_error("Operation requires SCREWS_TILT_ADJUST mode")
+    def cmd_AUTO_SCREWS_TILT_ADJUST(self, gcmd):
+        with self.lock:
+            self.base_points = [None, None, None, None]
+            self.min_z, self.max_z, self.target_z = (None, None, None)
+            self.current_point = 0
+            self.probe_after_delay = 0
+            self.need_adjusted_z = None
+            self.abort_flag = False
+            self.state = AutoScrewsTiltAdjustStep.PROBING_START
+
+        # Allow overriding screw order via GCODE parameter
+        if 'SCREW_ORDER' in gcmd.get_command_parameters():
+            try:
+                new_order = [int(x) for x in gcmd.get('SCREW_ORDER').split(',')]
+                if len(new_order) != 4:
+                    raise gcmd.error("SCREW_ORDER must have exactly 4 values")
+                if any(x < 1 or x > 4 for x in new_order):
+                    raise gcmd.error("SCREW_ORDER values must be between 1-4")
+                if len(set(new_order)) != 4:
+                    raise gcmd.error("SCREW_ORDER values must be unique")
+                if sorted(new_order) != [1,2,3,4]:
+                    raise gcmd.error("SCREW_ORDER must contain values 1-4 exactly once each")
+                self.screw_order = new_order
+                self.gcode.respond_info("Using custom screw adjustment order: %s" % self.screw_order)
+            except ValueError:
+                raise gcmd.error("Invalid SCREW_ORDER format - use comma-separated numbers (e.g. '1,2,3,4')")
+
+        adjust_tolerance = gcmd.get_float('ADJUST_TOLERANCE', self.adjust_tolerance)
+        screw_adjust_threshold = gcmd.get_float('SCREW_ADJUST_THRESHOLD', self.screw_adjust_threshold)
+        if adjust_tolerance > screw_adjust_threshold:
+            raise gcmd.error("ADJUST_TOLERANCE must not exceed SCREW_ADJUST_THRESHOLD")
+
+        self.adjust_tolerance = adjust_tolerance
+        self.screw_adjust_threshold = screw_adjust_threshold
+
+        force_homing = gcmd.get_int('FORCE_HOMING', 0)
+        curtime = self.printer.get_reactor().monotonic()
+        homed_axes_list = self.printer.lookup_object('toolhead').get_status(curtime)['homed_axes']
+        if not ('x' in homed_axes_list and 'y' in homed_axes_list and 'z' in homed_axes_list) or force_homing:
+            with self.lock:
+                self.state = AutoScrewsTiltAdjustStep.PROBING_HOMING
+            self.gcode.run_script_from_command("G28")
+        try:
+            with self.lock:
+                self.state = AutoScrewsTiltAdjustStep.PROBING_REFPOINT
+            self.probe_helper.start_probe(gcmd)
+            self.adjust_screws(gcmd)
+        except AutoScrewsTiltAdjustPass as e:
+            with self.lock:
+                self.state = AutoScrewsTiltAdjustStep.SCREWS_TILT_ADJUST_OK
+        except AutoScrewsTiltAdjustAbort as e:
+            with self.lock:
+                self.state = AutoScrewsTiltAdjustStep.PROBING_ABORTED
+        except (AutoScrewsTiltAdjustLimit, AutoScrewsTiltAdjustError, Exception) as e:
+            with self.lock:
+                self.state = AutoScrewsTiltAdjustStep.SCREWS_TILT_ADJUST_FAIL
+            raise gcmd.error(str(e))
+        finally:
+            self._move([None, None, self.probe_helper.default_horizontal_move_z], self.probe_helper.lift_speed)
+    def cmd_AUTO_SCREWS_TILT_ADJUST_ENTRY(self, gcmd):
+        try:
+            adjust_tolerance = gcmd.get_float('ADJUST_TOLERANCE', self.adjust_tolerance)
+            screw_adjust_threshold = gcmd.get_float('SCREW_ADJUST_THRESHOLD', self.screw_adjust_threshold)
+            if adjust_tolerance > screw_adjust_threshold:
+                raise gcmd.error("ADJUST_TOLERANCE must not exceed SCREW_ADJUST_THRESHOLD")
+            self.adjust_tolerance = adjust_tolerance
+            self.screw_adjust_threshold = screw_adjust_threshold
+            self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=SCREWS_TILT_ADJUST")
+            with self.lock:
+                self.base_points = [None, None, None, None]
+                self.min_z, self.max_z, self.target_z = (None, None, None)
+                self.current_point = 0
+                self.probe_after_delay = 0
+                self.need_adjusted_z = None
+                self.abort_flag = False
+            self._set_state(AutoScrewsTiltAdjustStep.PROBING_START)
+            timeout = 9999999999
+            idle_timeout = self.printer.lookup_object('idle_timeout', None)
+            if idle_timeout is not None and hasattr(idle_timeout, 'idle_timeout_on_pause'):
+                timeout = idle_timeout.idle_timeout_on_pause
+            self.gcode.run_script_from_command("SET_IDLE_TIMEOUT TIMEOUT={}".format(timeout))
+        except Exception as e:
+            raise gcmd.error(str(e))
+
+    def cmd_AUTO_SCREWS_TILT_ADJUST_HOMING(self, gcmd):
+        self._verify_screws_tilt_adjust_state("HOMING")
+        try:
+            self._set_state(AutoScrewsTiltAdjustStep.PROBING_HOMING)
+            self.gcode.run_script_from_command("G28 SAMPLES_TOLERANCE 0.1 ACTION 1")
+            toolhead = self.printer.lookup_object('toolhead')
+            curtime = self.printer.get_reactor().monotonic()
+            homed_axes_list = toolhead.get_status(curtime)['homed_axes']
+            pos = toolhead.get_position()
+            if ('x' in homed_axes_list and 'y' in homed_axes_list and 'z' in homed_axes_list) and pos[2] < 50:
+                self._move([None, None, 50], 20)
+            self._set_state(AutoScrewsTiltAdjustStep.PROBING_HOMING_DONE)
+        except Exception as e:
+            self._set_state(AutoScrewsTiltAdjustStep.PROBING_HOMING_ERR)
+            raise gcmd.error(str(e))
+
+    def cmd_AUTO_SCREWS_TILT_ADJUST_DETECT_PLATE(self, gcmd):
+        self._verify_screws_tilt_adjust_state("PLATE DETECTION")
+        try:
+            self._set_state(AutoScrewsTiltAdjustStep.PLATE_DETECTING)
+            self.gcode.run_script_from_command("DETECT_BED_PLATE")
+            self._set_state(AutoScrewsTiltAdjustStep.PLATE_DETECTED)
+        except Exception as e:
+            self._set_state(AutoScrewsTiltAdjustStep.PLATE_DETECTION_ERROR)
+            raise gcmd.error(str(e))
+
+    def cmd_AUTO_SCREWS_TILT_ADJUST_RESET_TO_INITIAL(self, gcmd):
+        self._verify_screws_tilt_adjust_state("RESET TO INITIAL")
+        try:
+            self._set_state(AutoScrewsTiltAdjustStep.RESET_TO_INITIAL)
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=RESET_TO_INITIAL")
+            self._move([None, None, self.probe_helper.default_horizontal_move_z], self.probe_helper.lift_speed)
+        except Exception as e:
+            pass
+
+    def cmd_AUTO_SCREWS_TILT_ADJUST_PROBE_REFERENCE_POINTS(self, gcmd):
+        self._verify_screws_tilt_adjust_state("PROBE REFERENCE POINTS")
+        try:
+            if 'SAMPLES' not in gcmd.get_command_parameters():
+                gcmd._params['SAMPLES'] = '{}'.format(self.samples)
+            if 'SAMPLE_RETRACT_DIST' not in gcmd.get_command_parameters():
+                gcmd._params['SAMPLE_RETRACT_DIST'] = '{}'.format(self.sample_retract_dist)
+            self._set_state(AutoScrewsTiltAdjustStep.PROBING_REFPOINT)
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=PROBE_REFERENCE_POINTS")
+            self.probe_helper.start_probe(gcmd)
+        except AutoScrewsTiltAdjustAbort as e:
+            self._set_state(AutoScrewsTiltAdjustStep.PROBING_ABORTED)
+        except AutoScrewsTiltAdjustPass:
+            self._set_state(AutoScrewsTiltAdjustStep.SCREWS_TILT_ADJUST_OK)
+        except (AutoScrewsTiltAdjustLimit, AutoScrewsTiltAdjustError, Exception) as e:
+            self._set_state(AutoScrewsTiltAdjustStep.SCREWS_TILT_ADJUST_FAIL)
+            raise gcmd.error(str(e))
+        finally:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+    def cmd_AUTO_SCREWS_TILT_ADJUST_MANUAL_TUNING(self, gcmd):
+        self._verify_screws_tilt_adjust_state("MANUAL TUNING")
+        if self.state != AutoScrewsTiltAdjustStep.PROBING_REFPOINT_COMPLETED:
+            raise gcmd.error("Must complete probing refpoint before manual tuning")
+
+        toolhead = self.printer.lookup_object('toolhead')
+        probe_object = self.printer.lookup_object('probe', None)
+        if probe_object is None:
+            raise gcmd.error("Probe object not found")
+        try:
+            verify_attempt = 0
+            while True:
+                verify_attempt += 1
+                self.gcode.respond_info("Starting adjustment round %d..." % verify_attempt)
+                self.gcode.respond_info("Initial probing results:")
+                for i, (z, screw) in enumerate(zip(self.base_points, self.screws)):
+                    coord, name = screw
+                    diff = self.target_z - z
+                    direction = "CW" if diff > 0 else "CCW"
+                    self.gcode.respond_info(
+                        "%s : x=%.5f, y=%.5f, z=%.5f (turn %s %.5fmm)" %
+                        (name, coord[0], coord[1], z, direction, abs(diff)))
+                self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=MANUAL_TUNING")
+                # Adjust screws in specified order
+                for screw_num in self.screw_order:
+                    i = screw_num - 1  # Convert to 0-based index
+                    screw = self.screws[i]
+                    coord, name = screw
+                    self._probe_abort_check()
+                    # Probe current point
+                    diff = self.target_z - self.base_points[i]
+                    self.need_adjusted_z = self.target_z - self.base_points[i]
+                    with self.lock:
+                        self.state = AutoScrewsTiltAdjustStep.WAIT_MANUAL_ADJUST_SCREWS
+                        self.current_point = screw_num
+
+                    # if abs(diff) <= self.adjust_tolerance:
+                    #     self.gcode.respond_info(
+                    #         "%s is within tolerance (deviation: %.3fmm)" % (name, diff))
+                    #     break
+
+                    self._move([None, None, self.probe_helper.default_horizontal_move_z], self.probe_helper.lift_speed)
+                    self._move([coord[0], coord[1], None], self.probe_helper.speed)
+                    self._move([None, None, self.base_points[i]+self.sample_retract_dist], self.probe_helper.lift_speed)
+                    probe_cmd = "PROBE SAMPLES=1 SAMPLE_RETRACT_DIST={}".format(self.sample_retract_dist)
+                    while True:
+                        self.need_adjusted_z = self.target_z - self.base_points[i]
+                        diff = self.target_z - self.base_points[i]
+                        direction = "CW" if diff > 0 else "CCW"
+                        self.gcode.respond_info("Turn %s %s (%.3fmm)" % (direction, name, diff))
+                        self._probe_abort_check()
+                        toolhead.wait_moves()  # Ensure all moves complete
+                        self.gcode.run_script_from_command(probe_cmd)
+                        toolhead.wait_moves()
+                        self.base_points[i] = probe_object.get_status(0)['last_z_result']
+                        self._move([None, None, self.base_points[i]+self.sample_retract_dist], self.probe_helper.lift_speed)
+                        # if self.state == AutoScrewsTiltAdjustStep.NEXT_POINT_ADJUST:
+                        if self.state != AutoScrewsTiltAdjustStep.WAIT_MANUAL_ADJUST_SCREWS:
+                            break
+
+                # Verify overall leveling
+                self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=PROBING_ADJUST_VERIFY")
+                probe_cmd = "PROBE SAMPLES=3 SAMPLE_RETRACT_DIST={}".format(self.sample_retract_dist)
+                if self._verify_level(probe_cmd, toolhead, probe_object):
+                    raise AutoScrewsTiltAdjustPass
+
+                # Recalculate target height as average of max and min
+                self.max_z = max(self.base_points)
+                self.min_z = min(self.base_points)
+                self.target_z = (self.max_z + self.min_z) / 2
+                self.gcode.respond_info("Updated target height: %.5f (max:%.5f min:%.5f)" %
+                    (self.target_z, self.max_z, self.min_z))
+        except AutoScrewsTiltAdjustPass as e:
+            self._set_state(AutoScrewsTiltAdjustStep.SCREWS_TILT_ADJUST_OK)
+        except AutoScrewsTiltAdjustAbort as e:
+            self._set_state(AutoScrewsTiltAdjustStep.PROBING_ABORTED)
+        except (AutoScrewsTiltAdjustLimit, AutoScrewsTiltAdjustError, Exception) as e:
+            self._set_state(AutoScrewsTiltAdjustStep.SCREWS_TILT_ADJUST_FAIL)
+            raise gcmd.error(str(e))
+        finally:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+            curtime = self.printer.get_reactor().monotonic()
+            homed_axes_list = self.printer.lookup_object('toolhead').get_status(curtime)['homed_axes']
+            if ('x' in homed_axes_list and 'y' in homed_axes_list and 'z' in homed_axes_list):
+                self._move([None, None, self.probe_helper.default_horizontal_move_z], self.probe_helper.lift_speed)
+    def cmd_AUTO_SCREWS_TILT_ADJUST_EXIT(self, gcmd):
+        self._verify_screws_tilt_adjust_state("EXIT")
+        try:
+            self.gcode.run_script_from_command("EXIT_TO_IDLE REQ_FROM_STATE=SCREWS_TILT_ADJUST")
+            self.gcode.run_script_from_command("SET_IDLE_TIMEOUT TIMEOUT=300")
+            self._set_state(AutoScrewsTiltAdjustStep.IDLE)
+            toolhead = self.printer.lookup_object('toolhead')
+            curtime = self.printer.get_reactor().monotonic()
+            homed_axes_list = toolhead.get_status(curtime)['homed_axes']
+            pos = toolhead.get_position()
+            if ('x' in homed_axes_list and 'y' in homed_axes_list and 'z' in homed_axes_list) and pos[2] < 50:
+                self._move([None, None, 50], 20)
+        except Exception as e:
+            logging.info("Auto Screws Tilt Adjust Exit Failed: %s" % str(e))
+def load_config(config):
+    return AutoScrewsTiltAdjust(config)
--- a/klippy/extras/bed_mesh.py
+++ b/klippy/extras/bed_mesh.py
@@ -3,8 +3,8 @@
 # Copyright (C) 2018-2019 Eric Callahan <arksine.code@gmail.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, math, json, collections
-from . import probe
+import logging, math, json, collections, os, queuefile
+from . import probe, probe_inductance_coil
 
 PROFILE_VERSION = 1
 PROFILE_OPTIONS = {
@@ -13,9 +13,15 @@ PROFILE_OPTIONS = {
     'algo': str, 'tension': float
 }
 
+BED_VERSION_202507_OEM   = "/oem/.bed_202507"
+BED_VERSION_202507_UDATA = "/userdata/.bed_202507"
+
 class BedMeshError(Exception):
     pass
 
+class BedMeshActiveAbort(Exception):
+    pass
+
 # PEP 485 isclose()
 def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
     return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)
@@ -112,6 +118,9 @@ class BedMesh:
         self.gcode.register_command(
             'BED_MESH_OUTPUT', self.cmd_BED_MESH_OUTPUT,
             desc=self.cmd_BED_MESH_OUTPUT_help)
+        self.gcode.register_command(
+            'BED_MESH_OUTPUT_FILE', self.cmd_BED_MESH_OUTPUT_FILE,
+            desc=self.cmd_BED_MESH_OUTPUT_FILE_help)
         self.gcode.register_command(
             'BED_MESH_MAP', self.cmd_BED_MESH_MAP,
             desc=self.cmd_BED_MESH_MAP_help)
@@ -126,11 +135,17 @@ class BedMesh:
         webhooks.register_endpoint(
             "bed_mesh/dump_mesh", self._handle_dump_request
         )
+        webhooks.register_endpoint(
+            "bed_mesh/abort_probe_mesh", self._handle_abort_probe_mesh
+        )
+        self.printer.register_event_handler("pause_resume:cancel", self._handle_cancel_print)
         # Register transform
         gcode_move = self.printer.load_object(config, 'gcode_move')
         gcode_move.set_move_transform(self)
         # initialize status dict
         self.update_status()
+    def _handle_cancel_print(self):
+        self.bmc.probe_mgr.abort_probe()
     def handle_connect(self):
         self.toolhead = self.printer.lookup_object('toolhead')
         self.bmc.print_generated_points(logging.info)
@@ -234,7 +249,12 @@ class BedMesh:
             "mesh_max": (0., 0.),
             "probed_matrix": [[]],
             "mesh_matrix": [[]],
-            "profiles": self.pmgr.get_profiles()
+            "profiles": self.pmgr.get_profiles(),
+            "progress": {
+                "current_point": self.bmc.probe_mgr.current_point,
+                "total_points": self.bmc.probe_mgr.total_points,
+                "probe_state": self.bmc.probe_mgr.state
+            }
         }
         if self.z_mesh is not None:
             params = self.z_mesh.get_mesh_params()
@@ -259,6 +279,31 @@ class BedMesh:
         else:
             self.z_mesh.print_probed_matrix(gcmd.respond_info)
             self.z_mesh.print_mesh(gcmd.respond_raw, self.horizontal_move_z)
+    cmd_BED_MESH_OUTPUT_FILE_help = "Retrieve interpolated grid of probed z-points to file"
+    def cmd_BED_MESH_OUTPUT_FILE(self, gcmd):
+        if self.z_mesh is None:
+            gcmd.respond_info("Bed has not been probed")
+        else:
+            import time, os
+            date_str = time.strftime("%Y-%m-%d %H:%M:%S")
+            vsd = self.printer.lookup_object('virtual_sdcard', None)
+            if vsd is None:
+                gcmd.respond_info("No virtual_sdcard dir to save bed_mesh data")
+                logdir = '/tmp/calibration_data'
+            else:
+                logdir = f'{vsd.sdcard_dirname}/calibration_data'
+            if not os.path.exists(logdir):
+                os.makedirs(logdir)
+            logfile = gcmd.get('FILE', "bed_mesh_output.txt")
+            logfile = os.path.join(logdir, logfile)
+            file_size = os.path.getsize(logfile) if os.path.exists(logfile) else 0
+            # if file size is larger than 5MiB, rename it to one with suffix '.old'
+            if file_size > 5 * 1024 * 1024:
+                os.rename(logfile, logfile + ".old")
+            content = "\nTest Date: %s\n" % date_str
+            content += self.z_mesh.print_probed_matrix()
+            content += self.z_mesh.print_mesh(move_z=self.horizontal_move_z)
+            queuefile.async_append_file(logfile, content)
     cmd_BED_MESH_MAP_help = "Serialize mesh and output to terminal"
     def cmd_BED_MESH_MAP(self, gcmd):
         if self.z_mesh is not None:
@@ -313,6 +358,15 @@ class BedMesh:
         result["axis_maximum"] = th_sts["axis_maximum"]
         web_request.send(result)
 
+    def _handle_abort_probe_mesh(self, web_request):
+        """Handle abort probe mesh request"""
+        try:
+            self.bmc.probe_mgr.abort_probe()
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to abort probe mesh: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
+
 
 class ZrefMode:
     DISABLED = 0  # Zero reference disabled
@@ -328,6 +382,21 @@ class BedMeshCalibrate:
         self.radius = self.origin = None
         self.mesh_min = self.mesh_max = (0., 0.)
         self.adaptive_margin = config.getfloat('adaptive_margin', 0.0)
+        # Corner offsets configuration
+        # offset_tl: Offset for the top-left corner (near XY=(0,0)).
+        # offset_tr: Offset for the top-right corner (near X=max, Y=0).
+        # offset_bl: Offset for the bottom-left corner (near X=0, Y=max).
+        # offset_br: Offset for the bottom-right corner (near XY=(max,max)).
+        if os.path.exists(BED_VERSION_202507_OEM) or os.path.exists(BED_VERSION_202507_UDATA):
+            default_corner_offsets = 0.03
+            logging.info("Using default corner offsets of 0.03 for bed-202507")
+        else:
+            default_corner_offsets = 0.0
+            logging.info("Using default corner offsets of 0.0 for bed")
+        self.offset_tl = config.getfloat('corner_offset_tl', default=default_corner_offsets, minval=-1.0, maxval=1.0)
+        self.offset_tr = config.getfloat('corner_offset_tr', default=default_corner_offsets, minval=-1.0, maxval=1.0)
+        self.offset_bl = config.getfloat('corner_offset_bl', default=default_corner_offsets, minval=-1.0, maxval=1.0)
+        self.offset_br = config.getfloat('corner_offset_br', default=default_corner_offsets, minval=-1.0, maxval=1.0)
         self.bedmesh = bedmesh
         self.mesh_config = collections.OrderedDict()
         self._init_mesh_config(config)
@@ -639,6 +708,13 @@ class BedMeshCalibrate:
         }
     cmd_BED_MESH_CALIBRATE_help = "Perform Mesh Bed Leveling"
     def cmd_BED_MESH_CALIBRATE(self, gcmd):
+        if self.probe_mgr.is_inductance_coil_probe:
+            print_config = self.printer.lookup_object('print_task_config', None)
+            print_stats = self.printer.lookup_object('print_stats', None)
+            if print_config is not None and print_stats is not None:
+                if print_stats.state == 'printing' and not print_config.get_status()['auto_bed_leveling']:
+                    gcmd.respond_info("print_task_config configuration does not do auto-leveling")
+                    return
         self._profile_name = gcmd.get('PROFILE', "default")
         if not self._profile_name.strip():
             raise gcmd.error("Value for parameter 'PROFILE' must be specified")
@@ -669,6 +745,10 @@ class BedMeshCalibrate:
         x_cnt = params['x_count']
         y_cnt = params['y_count']
 
+        cur_extruder = self.printer.lookup_object('toolhead').get_extruder()
+        if hasattr(cur_extruder, "gcode_offset") and cur_extruder.gcode_offset is not None:
+            z_offset += cur_extruder.gcode_offset[2]
+
         substitutes = self.probe_mgr.get_substitutes()
         probed_pts = positions
         if substitutes:
@@ -735,6 +815,17 @@ class BedMeshCalibrate:
         # append last row
         probed_matrix.append(row)
 
+        # Apply corner offsets
+        if probed_matrix:
+            # Top-left corner
+            probed_matrix[0][0] += self.offset_tl
+            # Top-right corner
+            probed_matrix[0][-1] += self.offset_tr
+            # Bottom-left corner
+            probed_matrix[-1][0] += self.offset_bl
+            # Bottom-right corner
+            probed_matrix[-1][-1] += self.offset_br
+
         # make sure the y-axis is the correct length
         if len(probed_matrix) != y_cnt:
             raise self.gcode.error(
@@ -783,6 +874,8 @@ class BedMeshCalibrate:
         self.gcode.respond_info("Mesh Bed Leveling Complete")
         if self._profile_name is not None:
             self.bedmesh.save_profile(self._profile_name)
+            # self.gcode.run_script_from_command("SAVE_CONFIG RESTART=0")
+        self.gcode.run_script_from_command("BED_MESH_OUTPUT_FILE")
     def _dump_points(self, probed_pts, corrected_pts, offsets):
         # logs generated points with offset applied, points received
         # from the finalize callback, and the list of corrected points
@@ -803,10 +896,26 @@ class BedMeshCalibrate:
             logging.info(
                 "  %-4d| %-17s| %-25s| %s" % (i, gen_pt, probed_pt, corr_pt))
 
+class BedMeshProbeState:
+    IDLE       = "idle"
+    PROBING    = "probing"
+    COMPLETED  = "completed"
+    ABORTING   = "aborting"
+    ABORTED    = "aborted"
+
 class ProbeManager:
     def __init__(self, config, orig_config, finalize_cb):
         self.printer = config.get_printer()
         self.cfg_overshoot = config.getfloat("scan_overshoot", 0, minval=1.)
+        self.move_accel = config.getfloat("move_accel", None, above=0)
+        self.samples = config.getint("samples", None, minval=1)
+        self.sample_retract_dist = config.getfloat("sample_retract_dist", None, above=0)
+        self.samples_tolerance = config.getfloat("samples_tolerance", None, minval=0.)
+        self.lift_speed = config.getfloat("lift_speed", None, minval=0.)
+        # Time to wait before setting up inductance coil probe trigger frequency
+        self.wait_before_setup = config.getfloat("wait_before_setup", None, minval=0.)
+        # Time to wait after setting up inductance coil probe trigger frequency
+        self.wait_after_setup = config.getfloat("wait_after_setup", None, minval=0.)
         self.orig_config = orig_config
         self.faulty_regions = []
         self.overshoot = self.cfg_overshoot
@@ -817,11 +926,44 @@ class ProbeManager:
         self.base_points = []
         self.substitutes = collections.OrderedDict()
         self.is_round = orig_config["radius"] is not None
-        self.probe_helper = probe.ProbePointsHelper(config, finalize_cb, [])
+       # Leveling information variables
+        self.is_inductance_coil_probe = False
+        if config.get_prefix_sections("inductance_coil"):
+            self.is_inductance_coil_probe = True
+        self.state = BedMeshProbeState.IDLE
+        self.total_points = None
+        self.current_point = None
+        self.abort_flag = False
+        self.lock = self.printer.get_reactor().mutex()
+        if self.is_inductance_coil_probe:
+            self.probe_helper = probe_inductance_coil.ProbePointsHelper(config, finalize_cb, [], self.probe_point_callback)
+        else:
+            self.probe_helper = probe.ProbePointsHelper(config, finalize_cb, [])
         self.probe_helper.use_xy_offsets(True)
         self.rapid_scan_helper = RapidScanHelper(config, self, finalize_cb)
         self._init_faulty_regions(config)
 
+        self.gcode = self.printer.lookup_object('gcode')
+        self.gcode.register_command('BED_MESH_CALIBRATE_PREPARE', self.cmd_BED_MESH_CALIBRATE_PREPARE)
+
+    def cmd_BED_MESH_CALIBRATE_PREPARE(self, gcmd):
+        if self.state == BedMeshProbeState.PROBING or self.state == BedMeshProbeState.ABORTING:
+            raise gcmd.error("bed_mesh: leveling is already in progress")
+        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=BED_LEVELING")
+        with self.lock:
+            self.state = BedMeshProbeState.IDLE
+            self.abort_flag = False
+
+    def probe_point_callback(self, points):
+        with self.lock:
+            if self.abort_flag:
+                raise BedMeshActiveAbort("Mesh Bed Leveling Abort")
+            self.current_point = points[0]+1 if points[0]+1 < points[1] else points[1]
+            self.total_points =  points[1]
+        bed_mesh = self.printer.lookup_object('bed_mesh', None)
+        if bed_mesh is not None:
+            bed_mesh.update_status()
+
     def _init_faulty_regions(self, config):
         for i in list(range(1, 100, 1)):
             start = config.getfloatlist("faulty_region_%d_min" % (i,), None,
@@ -860,17 +1002,104 @@ class ProbeManager:
                                j+1, repr([prev_c1, prev_c3])))
             self.faulty_regions.append((c1, c3))
 
+    def _load_default_bed_mesh_profile(self):
+        try:
+            self.gcode.run_script_from_command("BED_MESH_PROFILE LOAD=default")
+        except Exception:
+            pass
+
     def start_probe(self, gcmd):
         method = gcmd.get("METHOD", "automatic").lower()
         can_scan = False
         pprobe = self.printer.lookup_object("probe", None)
-        if pprobe is not None:
-            probe_name = pprobe.get_status(None).get("name", "")
-            can_scan = probe_name.startswith("probe_eddy_current")
-        if method == "rapid_scan" and can_scan:
-            self.rapid_scan_helper.perform_rapid_scan(gcmd)
+        bed_mesh = self.printer.lookup_object('bed_mesh', None)
+        toolhead = self.printer.lookup_object("toolhead")
+        if 'SAMPLES' not in gcmd.get_command_parameters() and self.samples is not None:
+            gcmd._params['SAMPLES'] = '{}'.format(self.samples)
+        if 'SAMPLE_RETRACT_DIST' not in gcmd.get_command_parameters() and self.sample_retract_dist is not None:
+            gcmd._params['SAMPLE_RETRACT_DIST'] = '{}'.format(self.sample_retract_dist)
+        if 'SAMPLES_TOLERANCE' not in gcmd.get_command_parameters() and self.samples_tolerance is not None:
+            gcmd._params['SAMPLES_TOLERANCE'] = '{}'.format(self.samples_tolerance)
+        if 'LIFT_SPEED' not in gcmd.get_command_parameters() and self.lift_speed is not None:
+            gcmd._params['LIFT_SPEED'] = '{}'.format(self.lift_speed)
+        if 'PROBE_ACCEL' not in gcmd.get_command_parameters() and self.move_accel is not None:
+            gcmd._params['PROBE_ACCEL'] = '{}'.format(self.move_accel)
+        if 'WAIT_BEFORE_SETUP' not in gcmd.get_command_parameters() and self.wait_before_setup is not None:
+            gcmd._params['WAIT_BEFORE_SETUP'] = '{}'.format(self.wait_before_setup)
+        if 'WAIT_AFTER_SETUP' not in gcmd.get_command_parameters() and self.wait_after_setup is not None:
+            gcmd._params['WAIT_AFTER_SETUP'] = '{}'.format(self.wait_after_setup)
+        if self.is_inductance_coil_probe and pprobe is not None and method == "automatic":
+            cur_accel = None
+            if self.state == BedMeshProbeState.PROBING:
+                raise gcmd.error("bed_mesh: leveling is already in progress")
+            try:
+                machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+                if machine_state_manager is not None:
+                    cur_sta = machine_state_manager.get_status()
+                    if str(cur_sta["main_state"]) == "PRINTING":
+                        self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=BED_LEVELING")
+                    else:
+                        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=BED_LEVELING ACTION=BED_LEVELING")
+                with self.lock:
+                    self.state = BedMeshProbeState.PROBING
+                    self.abort_flag = False
+                    self.total_points = len(self.probe_helper.probe_points)
+                    self.current_point = 1
+                    if bed_mesh is not None:
+                        bed_mesh.update_status()
+                if self.move_accel is not None:
+                    if self.move_accel != toolhead.max_accel:
+                        cur_accel = toolhead.max_accel
+                        toolhead.set_accel(self.move_accel)
+                self.printer.send_event("inductance_coil:probe_start")
+                self.probe_helper.start_probe(gcmd)
+            except BedMeshActiveAbort as e:
+                with self.lock:
+                    if self.abort_flag:
+                        self.state = BedMeshProbeState.ABORTED
+                self._load_default_bed_mesh_profile()
+                gcmd.respond_info("bed_mesh: abort leveling")
+            except Exception as e:
+                with self.lock:
+                    self.state = BedMeshProbeState.ABORTED
+                self._load_default_bed_mesh_profile()
+                raise
+            else:
+                with self.lock:
+                    self.state = BedMeshProbeState.COMPLETED
+            finally:
+                if cur_accel is not None:
+                    if cur_accel != toolhead.max_accel:
+                        toolhead.set_accel(cur_accel)
+                self.printer.send_event("inductance_coil:probe_end")
+                if bed_mesh is not None:
+                    bed_mesh.update_status()
+                if machine_state_manager is not None:
+                    cur_sta = machine_state_manager.get_status()
+                    if str(cur_sta["main_state"]) == "PRINTING":
+                        self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+                    elif str(cur_sta["main_state"]) == "BED_LEVELING":
+                        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE")
         else:
-            self.probe_helper.start_probe(gcmd)
+            if pprobe is not None:
+                probe_name = pprobe.get_status(None).get("name", "")
+                can_scan = probe_name.startswith("probe_eddy_current")
+            if method == "rapid_scan" and can_scan:
+                self.rapid_scan_helper.perform_rapid_scan(gcmd)
+            else:
+                self.probe_helper.start_probe(gcmd)
+
+    def abort_probe(self):
+        if self.is_inductance_coil_probe:
+            machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+            with self.lock:
+                if self.state == BedMeshProbeState.PROBING:
+                    self.abort_flag = True
+                    self.state = BedMeshProbeState.ABORTING
+                elif (machine_state_manager is not None and
+                      str(machine_state_manager.get_status()["main_state"]) == "BED_LEVELING"):
+                    self.gcode.run_script_from_command("EXIT_TO_IDLE REQ_FROM_STATE=BED_LEVELING")
+                    # self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE")
 
     def get_zero_ref_pos(self):
         return self.zero_ref_pos
@@ -1368,17 +1597,19 @@ class ZMesh:
         return self.mesh_params
     def get_profile_name(self):
         return self.profile_name
-    def print_probed_matrix(self, print_func):
+    def print_probed_matrix(self, print_func=None):
         if self.probed_matrix is not None:
             msg = "Mesh Leveling Probed Z positions:\n"
             for line in self.probed_matrix:
                 for x in line:
                     msg += " %f" % x
                 msg += "\n"
-            print_func(msg)
         else:
-            print_func("bed_mesh: bed has not been probed")
-    def print_mesh(self, print_func, move_z=None):
+            msg = "bed_mesh: bed has not been probed\n"
+        if print_func is not None:
+            print_func(msg)
+        return msg
+    def print_mesh(self, print_func=None, move_z=None):
         matrix = self.get_mesh_matrix()
         if matrix is not None:
             msg = "Mesh X,Y: %d,%d\n" % (self.mesh_x_count, self.mesh_y_count)
@@ -1396,13 +1627,15 @@ class ZMesh:
                 for z in matrix[y_line]:
                     msg += "  %f" % (z)
                 msg += "\n"
-            print_func(msg)
         else:
-            print_func("bed_mesh: Z Mesh not generated")
+            msg = "bed_mesh: Z Mesh not generated\n"
+        if print_func is not None:
+            print_func(msg)
+        return msg
     def build_mesh(self, z_matrix):
         self.probed_matrix = z_matrix
         self._sample(z_matrix)
-        self.print_mesh(logging.debug)
+        self.print_mesh(logging.info)
     def set_zero_reference(self, xpos, ypos):
         offset = self.calc_z(xpos, ypos)
         logging.info(
@@ -1629,6 +1862,13 @@ class ProfileManager:
         self.bedmesh = bedmesh
         self.profiles = {}
         self.incompatible_profiles = []
+        self.save_custom_path = config.getboolean('save_custom_path', True)
+        if self.save_custom_path:
+            self.config_dir = config.get('path', self.printer.get_snapmaker_config_dir())
+            if not self.config_dir:
+                raise config.error("Missing custom path configuration")
+        else:
+            self.config_dir = None
         # Fetch stored profiles from Config
         stored_profs = config.get_prefix_sections(self.name)
         stored_profs = [s for s in stored_profs
@@ -1672,7 +1912,18 @@ class ProfileManager:
                 "The SAVE_CONFIG command will update the printer config\n"
                 "file and restart the printer" %
                 (('\n').join(self.incompatible_profiles)))
+    def _save_profile_custom(self, file_path, data_dict={}):
+        if not data_dict:
+            return False
+        try:
+            json_content = json.dumps(data_dict, indent=4)
+            queuefile.async_write_file(file_path, json_content, safe_write=True)
+            return True
+        except Exception as e:
+            logging.exception(f"Failed to write bed_mesh_data file: {file_path}")
+            return False
     def save_profile(self, prof_name):
+        save_to_cfg = False
         z_mesh = self.bedmesh.get_mesh()
         if z_mesh is None:
             self.gcode.respond_info(
@@ -1681,19 +1932,6 @@ class ProfileManager:
             return
         probed_matrix = z_mesh.get_probed_matrix()
         mesh_params = z_mesh.get_mesh_params()
-        configfile = self.printer.lookup_object('configfile')
-        cfg_name = self.name + " " + prof_name
-        # set params
-        z_values = ""
-        for line in probed_matrix:
-            z_values += "\n  "
-            for p in line:
-                z_values += "%.6f, " % p
-            z_values = z_values[:-2]
-        configfile.set(cfg_name, 'version', PROFILE_VERSION)
-        configfile.set(cfg_name, 'points', z_values)
-        for key, value in mesh_params.items():
-            configfile.set(cfg_name, key, value)
         # save copy in local storage
         # ensure any self.profiles returned as status remains immutable
         profiles = dict(self.profiles)
@@ -1701,14 +1939,70 @@ class ProfileManager:
         profile['points'] = probed_matrix
         profile['mesh_params'] = collections.OrderedDict(mesh_params)
         self.profiles = profiles
+        if self.save_custom_path:
+            lower_prof_name = prof_name.lower()
+            bed_mesh_data = {}
+            bed_mesh_data['version'] = PROFILE_VERSION
+            bed_mesh_data['profile'] = profile
+            file_path = os.path.join(self.config_dir, f"bed_mesh_{lower_prof_name}.json")
+            save_to_cfg = not self._save_profile_custom(file_path, bed_mesh_data)
+
+        if not self.save_custom_path or save_to_cfg:
+            configfile = self.printer.lookup_object('configfile')
+            cfg_name = self.name + " " + prof_name
+            # set params
+            z_values = ""
+            for line in probed_matrix:
+                z_values += "\n  "
+                for p in line:
+                    z_values += "%.6f, " % p
+                z_values = z_values[:-2]
+            configfile.set(cfg_name, 'version', PROFILE_VERSION)
+            configfile.set(cfg_name, 'points', z_values)
+            for key, value in mesh_params.items():
+                configfile.set(cfg_name, key, value)
+            self.gcode.run_script_from_command("SAVE_CONFIG RESTART=0")
+
         self.bedmesh.update_status()
-        self.gcode.respond_info(
-            "Bed Mesh state has been saved to profile [%s]\n"
-            "for the current session.  The SAVE_CONFIG command will\n"
-            "update the printer config file and restart the printer."
-            % (prof_name))
+        if not self.save_custom_path or save_to_cfg:
+            self.gcode.respond_info(
+                "Bed Mesh state has been saved to profile [%s]\n"
+                "for the current session.  The SAVE_CONFIG command will\n"
+                "update the printer config file and restart the printer."
+                % (prof_name))
+    def _load_profile_custom(self, prof_name):
+        if not self.save_custom_path:
+            return None
+        lower_prof_name = prof_name.lower()
+        file_path = os.path.join(self.config_dir, f"bed_mesh_{lower_prof_name}.json")
+        if not os.path.exists(file_path):
+            return None
+        try:
+            with open(file_path, 'r') as f:
+                file_content = f.read().strip()
+                if not file_content:
+                    return None
+                return json.loads(file_content)
+        except Exception as e:
+            logging.exception("Failed to read {} from file".format(prof_name))
+            return None
     def load_profile(self, prof_name):
-        profile = self.profiles.get(prof_name, None)
+        profile = None
+        bed_mesh_data = self._load_profile_custom(prof_name)
+        if bed_mesh_data is None:
+            self.gcode.respond_info("bed_mesh: Failed to decode JSON from profile [%s]" % prof_name)
+        else:
+            try:
+                if 'profile' in bed_mesh_data and \
+                    'points' in bed_mesh_data['profile'] and \
+                    'mesh_params' in bed_mesh_data['profile']:
+                    profile = bed_mesh_data['profile']
+            except:
+                self.gcode.respond_info("bed_mesh: Profile [%s] has missing or incomplete parameters" % prof_name)
+
+        if profile is None:
+            profile = self.profiles.get(prof_name, None)
+
         if profile is None:
             raise self.gcode.error(
                 "bed_mesh: Unknown profile [%s]" % prof_name)
@@ -1720,7 +2014,23 @@ class ProfileManager:
         except BedMeshError as e:
             raise self.gcode.error(str(e))
         self.bedmesh.set_mesh(z_mesh)
+    def _remove_profile_custom(self, prof_name):
+        if not self.save_custom_path:
+            return False
+        lower_prof_name = prof_name.lower()
+        file_path = os.path.join(self.config_dir, f"bed_mesh_{lower_prof_name}.json")
+        if not os.path.exists(file_path):
+            logging.info(f"bed_mesh: Profile file {file_path} not found, skip removal")
+            return False
+        try:
+            os.remove(file_path)
+            logging.info(f"bed_mesh: Removed profile file {file_path}")
+            return True
+        except Exception as e:
+            logging.error(f"bed_mesh: Failed to remove profile file {file_path}, error: {str(e)}")
+            return False
     def remove_profile(self, prof_name):
+        self._remove_profile_custom(prof_name)
         if prof_name in self.profiles:
             configfile = self.printer.lookup_object('configfile')
             configfile.remove_section('bed_mesh ' + prof_name)
--- a/klippy/extras/buttons.py
+++ b/klippy/extras/buttons.py
@@ -86,7 +86,7 @@ class MCU_buttons:
 # ADC button tracking
 ######################################################################
 
-ADC_REPORT_TIME = 0.015
+ADC_REPORT_TIME = 0.100
 ADC_DEBOUNCE_TIME = 0.025
 ADC_SAMPLE_TIME = 0.001
 ADC_SAMPLE_COUNT = 6
@@ -102,6 +102,7 @@ class MCU_ADC_buttons:
         self.pin = pin
         self.min_value = 999999999999.9
         self.max_value = 0.
+        self.last_adc_value = 0
         ppins = printer.lookup_object('pins')
         self.mcu_adc = ppins.setup_pin('adc', self.pin)
         self.mcu_adc.setup_adc_sample(ADC_SAMPLE_TIME, ADC_SAMPLE_COUNT)
@@ -116,6 +117,7 @@ class MCU_ADC_buttons:
 
     def adc_callback(self, read_time, read_value):
         adc = max(.00001, min(.99999, read_value))
+        self.last_adc_value = adc
         value = self.pullup * adc / (1.0 - adc)
 
         # Determine button pressed
@@ -261,6 +263,7 @@ class PrinterButtons:
             self.adc_buttons[pin] = adc_buttons = MCU_ADC_buttons(
                 self.printer, pin, pullup)
         adc_buttons.setup_button(min_val, max_val, callback)
+        return adc_buttons
     def register_adc_button_push(self, pin, min_val, max_val, pullup, callback):
         def helper(eventtime, state, callback=callback):
             if state:
--- /dev/null
+++ b/klippy/extras/extruder_config_bak.py
@@ -0,0 +1,292 @@
+import json
+import os
+import tempfile
+import logging, queuefile
+
+EXTRUDER_CONFIG_FILE = "extruder_config.json"
+EXTRUDER_BASE_POSITION_FILE = "extruder_base_position.json"
+
+class ExtruderConfigBak:
+    def __init__(self, config):
+        self.config = config
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.config_path = os.path.join(self.printer.get_snapmaker_config_dir("persistent"),
+                                      EXTRUDER_CONFIG_FILE)
+        self.old_config_path = os.path.join(self.printer.get_snapmaker_config_dir(),
+                                          EXTRUDER_CONFIG_FILE)
+        self.base_position_config_path = os.path.join(self.printer.get_snapmaker_config_dir(),
+                                      EXTRUDER_BASE_POSITION_FILE)
+        if self.config_path == self.old_config_path:
+            raise config.error("Config path and old config path are identical: %s" % (self.config_path,))
+
+        # Register GCode commands
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_command('DELETE_EXTRUDER_BACKUP_CONFIG',
+                             self.cmd_DELETE_EXTRUDER_BACKUP_CONFIG,
+                             desc="Delete extruder backup config file")
+
+    def cmd_DELETE_EXTRUDER_BACKUP_CONFIG(self, gcmd):
+        # Check if deletion is permitted by checking for permission file
+        if not self.printer.check_extruder_config_permission():
+            raise gcmd.error("Deletion of extruder backup config files is not allowed.")
+
+        deleted_files = []
+        error_messages = []
+
+        # Files to delete
+        files_to_delete = [
+            self.config_path,
+            # self.base_position_config_path,
+            self.old_config_path
+        ]
+
+        # Delete config files
+        for file_path in files_to_delete:
+            if os.path.exists(file_path):
+                try:
+                    os.unlink(file_path)
+                    deleted_files.append(file_path)
+                except Exception as e:
+                    error_messages.append(f"Failed to delete config file {file_path}: {str(e)}")
+
+        # Respond with results
+        if deleted_files:
+            gcmd.respond_info("Extruder config files deleted successfully:")
+            for file_path in deleted_files:
+                logging.info(f"  - {file_path}")
+
+        if error_messages:
+            for error_msg in error_messages:
+                gcmd.respond_info(error_msg)
+
+        if not deleted_files and not error_messages:
+            gcmd.respond_info("No extruder config files found to delete")
+
+    def get_extruder_config(self, extruder_name, field_name=None):
+        """Get extruder configuration from JSON file"""
+        # Determine which config file to read based on field_name
+        config_file = self.config_path
+        if field_name == 'base_position':
+            config_file = self.base_position_config_path
+
+        if not os.path.exists(config_file):
+            return None
+        try:
+            with open(config_file, 'r') as f:
+                config_data = json.load(f)
+            if extruder_name not in config_data:
+                return None
+            extruder_config = config_data[extruder_name]
+            if field_name is None:
+                return extruder_config
+            value = extruder_config
+            for key in field_name.split('.'):
+                if isinstance(value, (list, tuple)) and key.isdigit():
+                    key = int(key)
+                    if key >= len(value):
+                        return None
+                    value = value[key]
+                elif isinstance(value, dict):
+                    if key not in value:
+                        return None
+                    value = value[key]
+                else:
+                    return None
+            return value
+        except json.JSONDecodeError:
+            logging.error(f"Error: The configuration file {config_file} is not valid JSON")
+            return None
+        except IOError:
+            logging.error(f"Error: Unable to read the configuration file {config_file}")
+            return None
+        except Exception as e:
+            logging.error(f"Unknown error: {str(e)}")
+            return None
+
+    def _save_config_atomically(self, config_path, data):
+        try:
+            json_content = json.dumps(data, indent=4)
+            queuefile.sync_write_file(self.reactor, config_path, json_content, flush=True, safe_write=True)
+            logging.info("Extruder config saved successfully to %s. \nData: %s", config_path, data)
+
+        except Exception as e:
+            logging.error(f"Failed to save extruder config to {config_path}: {str(e)}")
+            raise
+
+    def update_extruder_config(self, extruder_name, field_name=None, value=None):
+        """Update extruder configuration in JSON file with atomic write"""
+        config_file = self.config_path
+        if field_name == 'base_position':
+            config_file = self.base_position_config_path
+
+        if not os.path.exists(config_file):
+            logging.error(f"Config file {config_file} does not exist")
+            return False
+
+        try:
+            with open(config_file, 'r') as f:
+                config_data = json.load(f)
+                if not isinstance(config_data, dict):
+                    raise ValueError("Invalid config structure")
+        except (json.JSONDecodeError, ValueError, IOError) as e:
+            logging.error(f"Error processing config file {config_file}: {str(e)}")
+            return False
+
+        try:
+            if extruder_name not in config_data:
+                config_data[extruder_name] = {}
+
+            if field_name is None:
+                if value is None:
+                    logging.error("Both field_name and value cannot be None")
+                    return False
+                config_data[extruder_name] = value
+            else:
+                current = config_data[extruder_name]
+                keys = field_name.split('.')
+                last_key = keys[-1]
+                for key in keys[:-1]:
+                    if isinstance(current, (list, tuple)) and key.isdigit():
+                        key = int(key)
+                        if key >= len(current):
+                            raise IndexError("Index out of range")
+                        current = current[key]
+                    elif isinstance(current, dict):
+                        if key not in current:
+                            current[key] = {}
+                        current = current[key]
+                    else:
+                        raise TypeError("Invalid config structure")
+                if isinstance(current, (list, tuple)) and last_key.isdigit():
+                    last_key = int(last_key)
+                    if last_key >= len(current):
+                        raise IndexError("Index out of range")
+                    current[last_key] = value
+                elif isinstance(current, dict):
+                    current[last_key] = value
+                else:
+                    raise TypeError("Invalid config structure")
+            json.dumps(config_data)  # Validate JSON serialization
+        except (IndexError, TypeError, ValueError) as e:
+            logging.error(f"Invalid config update: {str(e)}")
+            return False
+
+        # Use atomic save method
+        try:
+            self._save_config_atomically(config_file, config_data)
+            return True
+        except Exception as e:
+            logging.error(f"Error during atomic update: {str(e)}")
+            return False
+
+    def extruder_config_bak(self, config):
+        """Backup all extruder configs to JSON file"""
+        if os.path.exists(self.old_config_path) and not os.path.exists(self.config_path):
+            self._migrate_existing_backup()
+
+        if os.path.exists(self.config_path) and os.path.exists(self.base_position_config_path):
+            return True
+
+        try:
+            extruder_park_data = {}
+            extruder_base_position_data = {}
+            for i in range(99):
+                section = 'extruder'
+                if i:
+                    section = 'extruder%d' % (i,)
+                if not config.has_section(section):
+                    break
+                extruder_config = config.getsection(section)
+                _xy_park_position = _y_idle_position = _base_position = None
+
+                xy_park_position = extruder_config.get("xy_park_position", None)
+                if xy_park_position is not None:
+                    xy_park_position = extruder_config.getlists(
+                        'xy_park_position', seps=(',', '\n'), count=2, parser=float)
+                    _xy_park_position = list(xy_park_position[0])
+                    _y_idle_position = extruder_config.getfloat(
+                        'y_idle_position', 50., minval=0.)
+
+                if extruder_config.get('base_position', None) is not None:
+                    base_position = extruder_config.getlists(
+                        'base_position', seps=(',', '\n'), parser=float)
+                    if base_position is not None and len(base_position[0]) == 3:
+                        _base_position = [base_position[0][i] for i in range(0, 3)]
+
+                if _xy_park_position is None or _y_idle_position is None:
+                    raise config.error(
+                        f"{section} _xy_park_position or _y_idle_position not configured")
+
+                # Store data in separate dictionaries
+                extruder_park_data[section] = {
+                    'xy_park_position': _xy_park_position,
+                    'y_idle_position': _y_idle_position
+                }
+
+
+                extruder_base_position_data[section] = {
+                    'base_position': _base_position
+                }
+
+            # Save park data to new location (persistent directory)
+            if extruder_park_data and not os.path.exists(self.config_path):
+                self._save_config_atomically(self.config_path, extruder_park_data)
+
+            # Save base position data to new file in old location (snapmaker directory)
+            if extruder_base_position_data and not os.path.exists(self.base_position_config_path):
+                self._save_config_atomically(self.base_position_config_path, extruder_base_position_data)
+
+        except Exception as e:
+            logging.error(f"Failed to prepare extruder config: {str(e)}")
+            return False
+        return True
+
+    def _migrate_existing_backup(self):
+        """Migrate existing backup from old format to new format"""
+        try:
+            # Load existing data from old config file
+            with open(self.old_config_path, 'r') as f:
+                old_config_data = json.load(f)
+
+            extruder_park_data = {}
+            extruder_base_position_data = {}
+
+            # Separate park data from base position data
+            for section_name, section_data in old_config_data.items():
+                if section_name.startswith('extruder'):
+                    # Extract park data
+                    if 'xy_park_position' in section_data and 'y_idle_position' in section_data:
+                        extruder_park_data[section_name] = {
+                            'xy_park_position': section_data['xy_park_position'],
+                            'y_idle_position': section_data['y_idle_position']
+                        }
+
+                    # Extract base position data
+                    if 'base_position' in section_data and section_data['base_position'] is not None:
+                        extruder_base_position_data[section_name] = {
+                            'base_position': section_data['base_position']
+                        }
+
+            # Save separated data to appropriate locations
+            if extruder_park_data:
+                self._save_config_atomically(self.config_path, extruder_park_data)
+            if extruder_base_position_data:
+                self._save_config_atomically(self.base_position_config_path, extruder_base_position_data)
+
+            # try:
+            #     os.rename(self.old_config_path, self.old_config_path + ".tmp")
+            #     logging.info("Successfully migrated existing backup to new format and renamed old file")
+            # except Exception as e:
+            #     logging.warning(f"Failed to rename old config file after migration: {e}")
+
+            logging.info("Successfully migrated existing backup to new format")
+
+        except Exception as e:
+            logging.warning(f"Failed to migrate existing backup: {e}")
+        return
+
+def load_config(config):
+    extruder_bak = ExtruderConfigBak(config)
+    extruder_bak.extruder_config_bak(config)
+    return extruder_bak
--- a/klippy/extras/fan.py
+++ b/klippy/extras/fan.py
@@ -3,6 +3,7 @@
 # Copyright (C) 2016-2020  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
+import logging, copy
 from . import pulse_counter
 
 FAN_MIN_TIME = 0.100
@@ -12,6 +13,7 @@ class Fan:
         self.printer = config.get_printer()
         self.last_fan_value = 0.
         self.last_fan_time = 0.
+        self.last_enable_value = 0.
         # Read config
         self.max_power = config.getfloat('max_power', 1., above=0., maxval=1.)
         self.kick_start_time = config.getfloat('kick_start_time', 0.1,
@@ -45,18 +47,29 @@ class Fan:
 
     def get_mcu(self):
         return self.mcu_fan.get_mcu()
-    def set_speed(self, print_time, value):
+    def set_speed(self, print_time, value, control_enable=True):
         if value < self.off_below:
             value = 0.
         value = max(0., min(self.max_power, value * self.max_power))
-        if value == self.last_fan_value:
+
+        enable_value = None
+        if value > 0 and self.last_fan_value == 0:
+            enable_value = 1
+        elif value == 0 and self.last_fan_value > 0:
+            enable_value = 0
+
+        if value == self.last_fan_value and (
+            not self.enable_pin
+            or (self.enable_pin and not control_enable)
+            or (self.enable_pin and control_enable and enable_value == self.last_enable_value)):
             return
+
         print_time = max(self.last_fan_time + FAN_MIN_TIME, print_time)
-        if self.enable_pin:
-            if value > 0 and self.last_fan_value == 0:
-                self.enable_pin.set_digital(print_time, 1)
-            elif value == 0 and self.last_fan_value > 0:
-                self.enable_pin.set_digital(print_time, 0)
+        if self.enable_pin and control_enable:
+            if value > 0 and self.last_fan_value == 0 or value == 0 and self.last_fan_value > 0 and enable_value is not None:
+                self.enable_pin.set_digital(print_time, enable_value)
+                self.last_enable_value = enable_value
+
         if (value and value < self.max_power and self.kick_start_time
             and (not self.last_fan_value or value - self.last_fan_value > .5)):
             # Run fan at full speed for specified kick_start_time
@@ -65,10 +78,10 @@ class Fan:
         self.mcu_fan.set_pwm(print_time, value)
         self.last_fan_time = print_time
         self.last_fan_value = value
-    def set_speed_from_command(self, value):
+    def set_speed_from_command(self, value, control_enable=True):
         toolhead = self.printer.lookup_object('toolhead')
         toolhead.register_lookahead_callback((lambda pt:
-                                              self.set_speed(pt, value)))
+                                              self.set_speed(pt, value, control_enable)))
     def _handle_request_restart(self, print_time):
         self.set_speed(print_time, 0.)
 
@@ -102,20 +115,131 @@ class FanTachometer:
 
 class PrinterFan:
     def __init__(self, config):
+        self.printer = config.get_printer()
         self.fan = Fan(config)
+        self.extendable_fan = {}
+
+        # Auxiliary cooling fan
+        aux_cool_fan = config.get("aux_cool_fan", None)
+        aux_cool_fan_id = config.getint("aux_cool_fan_id", None)
+        if aux_cool_fan is not None and aux_cool_fan_id is not None:
+            self.extendable_fan[aux_cool_fan_id] = aux_cool_fan
+
+        # exhaust fan / purifier fan
+        self.exhaust_fan_id = None
+        tmp_fan = config.get("exhaust_fan", None)
+        tmp_fan_id = config.getint("exhaust_fan_id", None)
+        if tmp_fan is not None and tmp_fan_id is not None:
+            if tmp_fan_id in self.extendable_fan:
+                raise config.error("fan_id is repetitive!")
+            self.extendable_fan[tmp_fan_id] = tmp_fan
+            self.exhaust_fan_id = tmp_fan_id
+
         # Register commands
         gcode = config.get_printer().lookup_object('gcode')
         gcode.register_command("M106", self.cmd_M106)
         gcode.register_command("M107", self.cmd_M107)
+        wh = config.get_printer().lookup_object('webhooks')
+        wh.register_endpoint("control/main_fan", self._handle_control_main_fan)
+    def _handle_control_main_fan(self, web_request):
+        try:
+            speed = web_request.get_float('S', 0)
+            if speed > 100:
+                speed = 100
+            if speed < 0:
+                speed = 0
+            self.fan.set_speed_from_command(speed / 100.0)
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to set fan speed of main fan{str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
+
+    def get_all_fan_speed(self):
+        fan_speed_dict = {}
+        fan_speed_dict['main_fan'] = self.fan.last_fan_value
+        fan_speed_dict['extendable_fan'] = {}
+        for fan_id in self.extendable_fan:
+            if fan_id == self.exhaust_fan_id:
+                fan_obj = self.printer.lookup_object(self.extendable_fan[fan_id], None)
+                if fan_obj is not None:
+                    fan_speed_dict['extendable_fan'][fan_id] = fan_obj.get_fan_speed()
+                else:
+                    logging.error("No fan found with ID {}".format(fan_id))
+            else:
+                fan_obj = self.printer.lookup_object("fan_generic {}".format(self.extendable_fan[fan_id]), None)
+                if fan_obj is not None:
+                    fan_speed_dict['extendable_fan'][fan_id] = fan_obj.fan.last_fan_value
+                else:
+                    logging.error("No fan found with ID {}".format(fan_id))
+        return copy.deepcopy(fan_speed_dict)
+
+    def resume_all_fan_speed(self, fan_speed_dict):
+        if 'main_fan' in fan_speed_dict:
+            self.fan.set_speed_from_command(fan_speed_dict['main_fan'])
+        if 'extendable_fan' in fan_speed_dict:
+            for fan_id, fan_speed in fan_speed_dict['extendable_fan'].items():
+                if fan_id == self.exhaust_fan_id:
+                    fan_obj = self.printer.lookup_object(self.extendable_fan[fan_id], None)
+                    if fan_obj is not None:
+                        fan_obj.fan_turn_on(fan_speed * 100)
+                    else:
+                        logging.error("No fan found with ID {}".format(fan_id))
+                else:
+                    fan_obj = self.printer.lookup_object("fan_generic {}".format(self.extendable_fan[fan_id]), None)
+                    if fan_obj is not None:
+                        fan_obj.fan.set_speed_from_command(fan_speed)
+                    else:
+                        logging.error("No fan found with ID {}".format(fan_id))
+
     def get_status(self, eventtime):
         return self.fan.get_status(eventtime)
     def cmd_M106(self, gcmd):
         # Set fan speed
         value = gcmd.get_float('S', 255., minval=0.) / 255.
-        self.fan.set_speed_from_command(value)
+        fan_id = gcmd.get_int('P', None)
+        if fan_id is not None:
+            if fan_id in self.extendable_fan:
+                # purifier fan
+                if fan_id == self.exhaust_fan_id:
+                    fan_obj = self.printer.lookup_object(self.extendable_fan[fan_id], None)
+                    if fan_obj is not None:
+                        fan_obj.fan_turn_on(value * 100)
+                    else:
+                        gcmd.respond_info("M106: No fan found with ID {}".format(fan_id))
+                # other generic fan
+                else:
+                    fan_obj = self.printer.lookup_object("fan_generic {}".format(self.extendable_fan[fan_id]), None)
+                    if fan_obj is not None:
+                        fan_obj.fan.set_speed_from_command(value)
+                    else:
+                        gcmd.respond_info("M106: No fan found with ID {}".format(fan_id))
+            else:
+                gcmd.respond_info("M106: Unsupported fan ID: {}".format(fan_id))
+        else:
+            self.fan.set_speed_from_command(value)
     def cmd_M107(self, gcmd):
         # Turn fan off
-        self.fan.set_speed_from_command(0.)
+        fan_id = gcmd.get_int('P', None)
+        if fan_id is not None:
+            if fan_id in self.extendable_fan:
+                # purifier fan
+                if fan_id == self.exhaust_fan_id:
+                    fan_obj = self.printer.lookup_object(self.extendable_fan[fan_id], None)
+                    if fan_obj is not None:
+                        fan_obj.fan_turn_off(0)
+                    else:
+                        gcmd.respond_info("M107: No fan found with ID {}".format(fan_id))
+                # other generic fan
+                else:
+                    fan_obj = self.printer.lookup_object("fan_generic {}".format(self.extendable_fan[fan_id]), None)
+                    if fan_obj is not None:
+                        fan_obj.fan.set_speed_from_command(0.)
+                    else:
+                        gcmd.respond_info("M107: No fan found with ID {}".format(fan_id))
+            else:
+                gcmd.respond_info("M107: Unsupported fan ID: {}".format(fan_id))
+        else:
+            self.fan.set_speed_from_command(0.)
 
 def load_config(config):
     return PrinterFan(config)
--- a/klippy/extras/fan_generic.py
+++ b/klippy/extras/fan_generic.py
@@ -4,6 +4,7 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 from . import fan
+import logging
 
 class PrinterFanGeneric:
     cmd_SET_FAN_SPEED_help = "Sets the speed of a fan"
@@ -17,7 +18,20 @@ class PrinterFanGeneric:
                                    self.fan_name,
                                    self.cmd_SET_FAN_SPEED,
                                    desc=self.cmd_SET_FAN_SPEED_help)
-
+        wh = self.printer.lookup_object('webhooks')
+        wh.register_mux_endpoint("control/generic_fan", 'fan', self.fan_name, self._handle_control_generic_fan)
+    def _handle_control_generic_fan(self, web_request):
+        try:
+            speed = web_request.get_int('S', 0)
+            if speed > 100:
+                speed = 100
+            if speed < 0:
+                speed = 0
+            self.fan.set_speed_from_command(speed / 100.0)
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to set fan: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
     def get_status(self, eventtime):
         return self.fan.get_status(eventtime)
     def cmd_SET_FAN_SPEED(self, gcmd):
--- /dev/null
+++ b/klippy/extras/filament_detect.py
@@ -0,0 +1,288 @@
+import logging, copy, os
+from . import filament_protocol
+from . import fm175xx_reader
+from . import filament_feed
+
+# Error code
+FILAMENT_DT_OK                                  = 0
+FILAMENT_DT_ERR                                 = -1
+FILAMENT_DT_PARAM_ERR                           = -2
+
+# State
+FILAMENT_DT_STATE_IDLE                          = 0
+FILAMENT_DT_STATE_DETECTING                     = 1
+FILAMENT_DT_STATE_SELF_TESTING                  = 2
+
+FILAMENT_DT_CHANNEL_NUMS                        = 4
+FILAMENT_DT_CONFIG_FILE                         = "filament_detect.json"
+
+DEFAULT_FILAMENT_DT_CONFIG = {
+    'startup_stay': False
+}
+
+class FilamentDetector:
+    def __init__(self, config) -> None:
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = FILAMENT_DT_CONFIG_FILE
+        self._config_path = os.path.join(config_dir, config_name)
+
+        self._config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_FILAMENT_DT_CONFIG)
+
+        self._channel_nums = FILAMENT_DT_CHANNEL_NUMS
+        self._filament_info = [copy.deepcopy(filament_protocol.FILAMENT_INFO_STRUCT) for i in range(self._channel_nums)]
+        self._state = [FILAMENT_DT_STATE_IDLE for i in range(self._channel_nums)]
+        self._notify_data_update_cb = []
+
+        self.filament_feed_objects = None
+        self._fm175xx_reader = None
+        self._self_test_success_cnt = 0
+
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_command('FILAMENT_DT_QUERY', self.cmd_FILAMENT_DT_QUERY)
+        gcode.register_command('FILAMENT_DT_UPDATE', self.cmd_FILAMENT_DT_UPDATE)
+        gcode.register_command('FILAMENT_DT_CLEAR', self.cmd_FILAMENT_DT_CLEAR)
+        gcode.register_command('FILAMENT_DT_SELF_TEST', self.cmd_FILAMENT_DT_SELF_TEST)
+        gcode.register_command('FILAMENT_DT_STARTUP_STAY', self.cmd_FILAMENT_DT_STARTUP_STAY)
+
+        self.printer.register_event_handler("klippy:ready", self._ready)
+        self.printer.register_event_handler("filament_feed:port", self._feed_port_evt_handle)
+        self.printer.register_event_handler("filament_switch_sensor:runout", self._runout_evt_handle)
+
+    def _ready(self):
+        self.filament_feed_objects = self.printer.lookup_objects('filament_feed')
+        self._fm175xx_reader = self.printer.lookup_object('fm175xx_reader')
+        if (self._fm175xx_reader is not None):
+            self._fm175xx_reader.register_cb_2_card_info_deal(self._fm175xx_card_info_deal_callback)
+
+        if self._config['startup_stay'] == False:
+            for i in range(self._channel_nums):
+                filament_sensor = self.printer.lookup_object('filament_motion_sensor e%d_filament' % (i))
+                if filament_sensor.get_status(0)['filament_detected'] and filament_sensor.get_status(0)['enabled']:
+                    self.request_update_filament_info(i)
+
+    def _feed_port_evt_handle(self, channel, detect):
+        filament_sensor = self.printer.lookup_object('filament_motion_sensor e%d_filament' % (channel))
+        filament_sensor_status = filament_sensor.get_status(0)
+
+        if filament_sensor_status['filament_detected'] and filament_sensor_status['enabled']:
+            pass
+        else:
+            if detect:
+                self.request_update_filament_info(channel)
+            else:
+                self.request_clear_filament_info(channel)
+
+    def _runout_evt_handle(self, extruder, present):
+        filament_feed_infos = {}
+        for obj_name, obj in self.filament_feed_objects:
+            status = obj.get_status(0)
+            filament_feed_infos.update(status)
+        e_obj = filament_feed_infos.get('extruder%d' % (extruder), None)
+
+        if e_obj is not None and e_obj['module_exist'] and not e_obj['disable_auto']:
+            if present:
+                self.request_update_filament_info(extruder)
+            else:
+                if e_obj['filament_detected'] == True:
+                    self.request_clear_filament_info(extruder)
+                    self.request_update_filament_info(extruder)
+                else:
+                    self.request_clear_filament_info(extruder)
+        else:
+            if present:
+                self.request_update_filament_info(extruder)
+            else:
+                self.request_clear_filament_info(extruder)
+
+
+    def _filament_info_update(self, channel, info, is_clear=False):
+        self._filament_info[channel] = info
+
+        # notify
+        if (0 != len(self._notify_data_update_cb)):
+            for i in range(len(self._notify_data_update_cb)):
+                self.reactor.register_async_callback(
+                    (lambda et, c=self._notify_data_update_cb[i],
+                        info=self._filament_info[channel]: c(channel, info, is_clear)))
+
+    def _fm175xx_card_info_deal_callback(self, channel, operation, result, card_type, card_data):
+        filament_info = None
+        is_clear = False
+
+        if channel < 0 or channel >= self._channel_nums:
+            return
+
+        if (fm175xx_reader.FM175XX_CARD_INFO_READ == operation):
+            if (fm175xx_reader.FM175XX_MIFARE_CARD_TYPE_M1 == card_type and  fm175xx_reader.FM175XX_OK == result):
+                logging.info("channel[%d] m1 card data parsing....", channel)
+                error, info = filament_protocol.m1_proto_data_parse(card_data)
+                if (error == filament_protocol.FILAMENT_PROTO_OK):
+                    logging.info("channel[%d] m1 parse ok....", channel)
+                    filament_info = info
+                else:
+                    logging.info("channel[%d] m1 parse err....", channel)
+        else:
+            is_clear = True
+
+        if (filament_info is None):
+            filament_info = copy.deepcopy(filament_protocol.FILAMENT_INFO_STRUCT)
+        else:
+            self._self_test_success_cnt += 1
+
+        self._state[channel] = FILAMENT_DT_STATE_IDLE
+        self._filament_info_update(channel, filament_info, is_clear)
+
+    def register_cb_2_update_filament_info(self, cb):
+        try:
+            if callable(cb):
+                self._notify_data_update_cb.append(cb)
+            else:
+                raise TypeError()
+        except Exception as e:
+            logging.error("Param[cb] is not a callable function")
+
+    def request_update_filament_info(self, channel):
+        if channel < 0 or channel >= self._channel_nums:
+            return
+
+        if self._fm175xx_reader is not None:
+            self._state[channel] = FILAMENT_DT_STATE_DETECTING
+            self._fm175xx_reader.request_read_card_info(channel)
+
+    def request_clear_filament_info(self, channel):
+        if channel < 0 or channel >= self._channel_nums:
+            return
+
+        if self._fm175xx_reader is not None:
+            self._state[channel] = FILAMENT_DT_STATE_DETECTING
+            self._fm175xx_reader.request_clear_card_info(channel)
+
+    def get_a_filament_info(self, channel):
+        error = FILAMENT_DT_ERR
+        info = None
+
+        if channel < 0 or channel >= self._channel_nums:
+            error = FILAMENT_DT_PARAM_ERR
+        else:
+            error = FILAMENT_DT_OK
+            info = self._filament_info[channel]
+
+        return error, info
+
+    def get_all_filament_info(self):
+        return self._filament_info
+
+    def is_startup_stay(self):
+        return self._config['startup_stay']
+
+    def cmd_FILAMENT_DT_QUERY(self, gcmd):
+        channel = gcmd.get_int('CHANNEL', None)
+
+        if (channel is None):
+            raise gcmd.error("CHANNEL must be specified!")
+
+        if (channel < 0 or channel >= self._channel_nums):
+            msg = ("channel[%d] is out of range[0, %d]" % (channel, self._channel_nums - 1))
+            raise gcmd.error(msg)
+
+        msg = ("channel[%d] vendor = %s, main_type: %s, sub_type= %s, rgba_color = %08X\n"
+                % (channel,
+                    self._filament_info[channel]['VENDOR'],
+                    self._filament_info[channel]['MAIN_TYPE'],
+                    self._filament_info[channel]['SUB_TYPE'],
+                    self._filament_info[channel]['ARGB_COLOR']))
+        gcmd.respond_info(msg, log=False)
+
+    def cmd_FILAMENT_DT_UPDATE(self, gcmd):
+        channel = gcmd.get_int('CHANNEL', None)
+
+        if (channel is None):
+            raise gcmd.error("CHANNEL must be specified!")
+
+        if (channel < 0 or channel >= self._channel_nums):
+            msg = ("channel[%d] is out of range[0, %d]" % (channel, self._channel_nums - 1))
+            raise gcmd.error(msg)
+
+        self.request_update_filament_info(channel)
+
+    def cmd_FILAMENT_DT_CLEAR(self, gcmd):
+        channel = gcmd.get_int('CHANNEL', None)
+
+        if (channel is None):
+            raise gcmd.error("CHANNEL must be specified!")
+
+        if (channel < 0 or channel >= self._channel_nums):
+            msg = ("channel[%d] is out of range[0, %d]" % (channel, self._channel_nums - 1))
+            raise gcmd.error(msg)
+
+        self.request_clear_filament_info(channel)
+
+    def cmd_FILAMENT_DT_SELF_TEST(self, gcmd):
+        channel = gcmd.get_int('CHANNEL', None)
+        times = gcmd.get_int('TIMES', 100)
+
+        if (channel is None):
+            raise gcmd.error("CHANNEL must be specified!")
+
+        if (channel < 0 or channel >= self._channel_nums):
+            msg = ("channel[%d] is out of range[0, %d]" % (channel, self._channel_nums - 1))
+            raise gcmd.error(msg)
+
+        self._state[channel] = FILAMENT_DT_STATE_SELF_TESTING
+        finish = False
+        test_times = 0
+        success_times = 0
+        self._self_test_success_cnt = 0
+        self._fm175xx_reader.self_test(channel, times)
+        while (1):
+            finish, test_times, success_times = self._fm175xx_reader.self_test_result()
+            if finish:
+                break
+            self.reactor.pause(self.reactor.monotonic() + 0.3)
+
+        msg = ("channel[%d] test times = %d, success times: %d\n" % (
+                channel, test_times, self._self_test_success_cnt))
+        gcmd.respond_info(msg, log=False)
+        msg = ("channel[%d] vendor = %s, main_type: %s, sub_type= %s, rgba_color = %08X\n"
+                % (channel,
+                    self._filament_info[channel]['VENDOR'],
+                    self._filament_info[channel]['MAIN_TYPE'],
+                    self._filament_info[channel]['SUB_TYPE'],
+                    self._filament_info[channel]['ARGB_COLOR']))
+        gcmd.respond_info(msg, log=False)
+        self._state[channel] = FILAMENT_DT_STATE_IDLE
+
+    def cmd_FILAMENT_DT_STARTUP_STAY(self, gcmd):
+        stay = gcmd.get_int('STAY', None)
+        need_save = gcmd.get_int('SAVE', 1, minval=0, maxval=1)
+        if (stay is None):
+            raise gcmd.error("STAY must be specified!")
+
+        self._config['startup_stay']= bool(stay)
+
+        if (need_save):
+            load_config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_FILAMENT_DT_CONFIG)
+            load_config['startup_stay'] = bool(stay)
+            ret = self.printer.update_snapmaker_config_file(self._config_path, load_config, DEFAULT_FILAMENT_DT_CONFIG)
+            if not ret:
+                raise gcmd.error("save startup stay failed!")
+
+    def get_status(self, eventtime=None):
+        return {
+            'info': copy.deepcopy(self._filament_info),
+            'state': copy.deepcopy(self._state),
+            'config': copy.deepcopy(self._config)}
+
+    def factory_reset(self):
+        self._config = copy.deepcopy(DEFAULT_FILAMENT_DT_CONFIG)
+        ret = self.printer.update_snapmaker_config_file(self._config_path, self._config, DEFAULT_FILAMENT_DT_CONFIG)
+        if not ret:
+            logging.error("save filament_detect config failed!")
+        return ret
+
+def load_config(config):
+    return FilamentDetector(config)
+
--- /dev/null
+++ b/klippy/extras/filament_entangle_detect.py
@@ -0,0 +1,253 @@
+import logging, os
+
+CHECK_ENTANGLE_INTERVAL                     = 0.1
+ENTANGLE_DETECT_LENGTH_DEFAULT              = 6.0
+ENTANGLE_DETECT_LENGTH_DEFAULT_SOFT         = 120.0
+ENTANGLE_DETECT_LENGTH_DEFAULT_TPU_85       = 180.0
+ENTANGLE_DETECT_LENGTH_DEFAULT_TPU_90       = 120.0
+ENTANGLE_DETECT_LENGTH_DEFAULT_TPU_95       = 60.0
+ENTANGLE_DETECT_FACTOR                      = 1.0
+ENTANGLE_DETECT_MIN_CNT                      = 6
+
+POSTFIX_CONFIG_FILE ='_entangle.json'
+DEFAULT_CONFIG = {
+    'detect_factor': ENTANGLE_DETECT_FACTOR,
+}
+
+class FilamentEntangleDetect:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.gcode = self.printer.lookup_object('gcode')
+
+        self.name = config.get_name().split()[-1]
+        self.extruder_name = config.get('extruder')
+        self.filament_feed_name = config.get('filament_feed')
+        self.skip_length = config.getfloat('skip_length', 20., above=0.)
+
+        self.extruder = None
+        self.extruder_index = None
+        self.check_entangle_timer = None
+        self.estimated_print_time = None
+        self.filament_feed_module = None
+        self.filament_feed_channel = None
+        self.print_task_config = None
+        self.print_stats = None
+        self.init_ok = False
+        self.last_position = 0
+        self.last_wheel_counts = 0
+        self.last_wheel_2_counts = 0
+        self.skip_check_flag = False
+        self.skip_length_remained = self.skip_length
+        self.detection_length = ENTANGLE_DETECT_LENGTH_DEFAULT
+        self.last_log_time = 0
+
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = self.name + POSTFIX_CONFIG_FILE
+        self.config_path = os.path.join(config_dir, config_name)
+        self.config = self.printer.load_snapmaker_config_file(self.config_path,
+                                                              DEFAULT_CONFIG,
+                                                              create_if_not_exist=True)
+
+        self.gcode.register_mux_command(
+            "SET_FILAMENT_ENTANGLE_DETECT_FACTOR", "SENSOR", self.name,
+            self.cmd_SET_FILAMENT_ENTANGLE_DETECT_FACTOR)
+
+        self.printer.register_event_handler('klippy:ready',
+                self._handle_ready)
+        self.printer.register_event_handler('klippy:shutdown',
+                self._handle_shutdown)
+
+        self.printer.register_event_handler('print_stats:start',
+                self._handle_start_print_job)
+        self.printer.register_event_handler('print_stats:stop',
+                self._handle_stop_print_job)
+        self.printer.register_event_handler('print_stats:paused',
+                self._handle_pause_print_job)
+        self.printer.register_event_handler('print_task_config:set_entangle_detect',
+                self._handle_set_entangle_detect)
+
+    def _handle_ready(self):
+        self.extruder = self.printer.lookup_object(self.extruder_name, None)
+        self.estimated_print_time = self.printer.lookup_object('mcu').estimated_print_time
+        self.filament_feed_module = self.printer.lookup_object(f"filament_feed {self.filament_feed_name}", None)
+        self.print_task_config = self.printer.lookup_object("print_task_config", None)
+        self.exception_manager = self.printer.lookup_object('exception_manager', None)
+        self.print_stats = self.printer.lookup_object('print_stats', None)
+        if self.extruder is None or self.filament_feed_module is None or \
+                self.print_task_config is None or self.exception_manager is None or\
+                self.print_stats is None:
+            self.init_ok = False
+            return
+        else:
+            self.init_ok = True
+
+        self.extruder_index = self.extruder.extruder_index
+        if self.filament_feed_module.filament_ch[0] == self.extruder_index:
+            self.filament_feed_channel = 0
+        else:
+            self.filament_feed_channel = 1
+
+        self.check_entangle_timer = self.reactor.register_timer(self._check_entangle_event)
+
+    def _handle_shutdown(self):
+        self.reactor.update_timer(self.check_entangle_timer, self.reactor.NEVER)
+        self.reactor.unregister_timer(self.check_entangle_timer)
+
+    def _handle_start_print_job(self):
+        if self.print_task_config.print_task_config['filament_soft'][self.extruder_index] == True:
+            self.detection_length = ENTANGLE_DETECT_LENGTH_DEFAULT_SOFT
+            if self.print_task_config.print_task_config['filament_type'][self.extruder_index] == 'TPU':
+                if self.print_task_config.print_task_config['filament_sub_type'][self.extruder_index].startswith('90'):
+                    self.detection_length = ENTANGLE_DETECT_LENGTH_DEFAULT_TPU_90
+                elif self.print_task_config.print_task_config['filament_sub_type'][self.extruder_index].startswith('95'):
+                    self.detection_length = ENTANGLE_DETECT_LENGTH_DEFAULT_TPU_95
+                elif self.print_task_config.print_task_config['filament_sub_type'][self.extruder_index].startswith('85'):
+                    self.detection_length = ENTANGLE_DETECT_LENGTH_DEFAULT_TPU_85
+        else:
+            self.detection_length = ENTANGLE_DETECT_LENGTH_DEFAULT
+        self.last_position = self._get_extruder_pos()
+        self.skip_length_remained = self.skip_length
+        self.last_wheel_counts = self.filament_feed_module.wheel[self.filament_feed_channel].get_counts()
+        self.last_wheel_2_counts = self.filament_feed_module.wheel_2[self.filament_feed_channel].get_counts()
+        self.reactor.update_timer(self.check_entangle_timer, self.reactor.monotonic() + 0.2 + 0.02 * self.extruder_index)
+    def _handle_stop_print_job(self):
+        self.reactor.update_timer(self.check_entangle_timer, self.reactor.NEVER)
+
+    def _handle_pause_print_job(self):
+        self.reactor.update_timer(self.check_entangle_timer, self.reactor.NEVER)
+
+    def _handle_set_entangle_detect(self, enable):
+        if enable:
+            self.skip_length_remained = self.skip_length
+        self.last_position = self._get_extruder_pos()
+        self.last_wheel_counts = self.filament_feed_module.wheel[self.filament_feed_channel].get_counts()
+        self.last_wheel_2_counts = self.filament_feed_module.wheel_2[self.filament_feed_channel].get_counts()
+
+    def _need_to_check_entanglement(self):
+        try:
+            if self.init_ok == False:
+                return False
+
+            if self.skip_check_flag == True:
+                return False
+
+            if self.print_task_config.print_task_config['filament_entangle_detect'] == False:
+                return False
+
+            if self.print_stats.get_status(self.reactor.monotonic())["state"] != 'printing':
+                return False
+
+            feed_module_status = self.filament_feed_module.get_status()
+            if self.extruder_index == 0:
+                feed_module_status = feed_module_status[self.extruder_name + "0"]
+            else:
+                feed_module_status = feed_module_status[self.extruder_name]
+            if feed_module_status['module_exist'] == False or \
+                    feed_module_status['disable_auto'] == True or \
+                    feed_module_status['filament_detected'] == False:
+                return False
+        except Exception as e:
+            logging.error("[filament_entangle_detect] %s", str(e))
+            return False
+
+        return True
+
+    def _get_extruder_pos(self):
+        print_time = self.estimated_print_time(self.reactor.monotonic())
+        position = self.extruder.find_past_position(print_time)
+        return position
+
+    def _check_entangle_event(self, eventtime):
+        if self._need_to_check_entanglement() == False:
+            return self.reactor.monotonic() + CHECK_ENTANGLE_INTERVAL
+
+        new_position = self._get_extruder_pos()
+        new_wheel_counts = self.filament_feed_module.wheel[self.filament_feed_channel].get_counts()
+        new_wheel_2_counts = self.filament_feed_module.wheel_2[self.filament_feed_channel].get_counts()
+        delta_position = new_position - self.last_position
+        delta_count = new_wheel_counts - self.last_wheel_counts
+        delta_count_2 = new_wheel_2_counts - self.last_wheel_2_counts
+
+        if self.reactor.monotonic() >= self.last_log_time + 5.0:
+            self.last_log_time = self.reactor.monotonic()
+            toolhead = self.printer.lookup_object('toolhead', None)
+            if toolhead and toolhead.get_extruder().extruder_index == self.extruder_index:
+                logging.info(f"[entangle] e[{self.extruder_index}], pos:{new_position}, whl:{new_wheel_counts}, whl2:{new_wheel_2_counts}")
+
+        check_wheel_counts = False
+        check_wheel_2_counts = False
+        if new_wheel_counts < ENTANGLE_DETECT_MIN_CNT and new_wheel_2_counts < ENTANGLE_DETECT_MIN_CNT:
+            return self.reactor.monotonic() + CHECK_ENTANGLE_INTERVAL
+        else:
+            if new_wheel_counts >= ENTANGLE_DETECT_MIN_CNT:
+                check_wheel_counts = True
+            if new_wheel_2_counts >= ENTANGLE_DETECT_MIN_CNT:
+                check_wheel_2_counts = True
+
+        if self.skip_length_remained >= 0:
+            self.skip_length_remained -= delta_position
+            self.last_position = new_position
+            self.last_wheel_counts = new_wheel_counts
+            self.last_wheel_2_counts = new_wheel_2_counts
+            return self.reactor.monotonic() + CHECK_ENTANGLE_INTERVAL
+
+        if delta_position >= (self.detection_length * self.config['detect_factor']):
+            dest_delta_count = int(delta_position / (self.detection_length * self.config['detect_factor']))
+            is_tangled = False
+            if check_wheel_counts == True:
+                if delta_count < dest_delta_count:
+                    is_tangled = True
+            if check_wheel_2_counts == True:
+                if delta_count_2 < dest_delta_count:
+                    is_tangled = True
+
+            if is_tangled:
+                pause_resume = self.printer.lookup_object('pause_resume')
+                pause_resume.send_pause_command()
+                self.printer.send_event("filament_entangle_detect:tangled", self.extruder_index)
+                self.gcode.respond_info("[filament_entangle_detect] extruder[%d] filament has tangled!" % (self.extruder_index))
+                logging.info(f"[filament_entangle_detect] extruder[{self.extruder_index}], length: {self.detection_length}, factor: {self.config['detect_factor']}, "
+                                f"last_pos: {self.last_position:0.4f}, new pos: {new_position:0.4f}, "
+                                f"last_cnt: {self.last_wheel_counts}, new_cnt: {new_wheel_counts}, "
+                                f"last_cnt2: {self.last_wheel_2_counts}, new_cnt2: {new_wheel_2_counts}")
+                self.last_position = new_position
+                self.last_wheel_counts = new_wheel_counts
+                self.last_wheel_2_counts = new_wheel_2_counts
+                self.exception_manager.raise_exception_async(
+                    id = 523,
+                    index = self.extruder_index,
+                    code = 38,
+                    message = "detect filament tangled!",
+                    oneshot = 1,
+                    level = 2)
+                self.gcode.run_script('\nPAUSE\nM400\n')
+
+                return self.reactor.NEVER
+            else:
+                self.last_position = new_position
+                self.last_wheel_counts = new_wheel_counts
+                self.last_wheel_2_counts = new_wheel_2_counts
+
+        return self.reactor.monotonic() + CHECK_ENTANGLE_INTERVAL
+
+    def skip_entangle_check(self, skip=False):
+        self.last_position = self._get_extruder_pos()
+        self.last_wheel_counts = self.filament_feed_module.wheel[self.filament_feed_channel].get_counts()
+        self.last_wheel_2_counts = self.filament_feed_module.wheel_2[self.filament_feed_channel].get_counts()
+        self.skip_check_flag = bool(skip)
+
+    def cmd_SET_FILAMENT_ENTANGLE_DETECT_FACTOR(self, gcmd):
+        detect_factor = gcmd.get_float('DETECT_FACTOR', None, minval=0.5)
+        if detect_factor is None:
+            raise gcmd.error('[filament_entangle_detect] missing DETECT_FACTOR!')
+
+        self.config['detect_factor'] = detect_factor
+        gcmd.respond_info("[filament_entangle_detect] set detect_factor: %f" % (self.config['detect_factor']))
+        ret = self.printer.update_snapmaker_config_file(self.config_path, self.config, DEFAULT_CONFIG)
+        if not ret:
+            raise gcmd.error("save filament_entangle_detect config failed!")
+
+def load_config_prefix(config):
+    return FilamentEntangleDetect(config)
+
--- /dev/null
+++ b/klippy/extras/filament_feed.py
@@ -0,0 +1,1910 @@
+import logging, copy, os
+from . import pulse_counter
+
+
+FEED_CHANNEL_NUMS                                   = 2
+FEED_CHANNEL_1                                      = 0
+FEED_CHANNEL_2                                      = 1
+
+FEED_OK                                             = 'ok'
+FEED_ERR                                            = 'general'
+FEED_ERR_PARAMETER                                  = 'parameter'
+FEED_ERR_TIMEOUT                                    = 'timeout'
+FEED_ERR_NO_FILAMENT                                = 'no_filament'
+FEED_ERR_RESIDUAL_FILAMENT                          = 'residual_filament'
+FEED_ERR_MOTOR_SPEED                                = 'motor_speed'
+FEED_ERR_WHEEL_SPEED                                = 'wheel_speed'
+FEED_ERR_MOVE                                       = 'move'
+FEED_ERR_MOVE_HOME                                  = 'move_home'
+FEED_ERR_MOVE_SWITCH                                = 'move_switch'
+FEED_ERR_MOVE_EXTRUDE                               = 'move_extrude'
+FEED_ERR_CUSTOM_GCODE                               = 'custom_gcode'
+FEED_ERR_DISTANCE                                   = 'distance'
+FEED_ERR_STATE_MISMATCH                             = 'state_mismatch'
+FEED_ERR_HEAT                                       = 'heat'
+
+FEED_ACT_PRELOAD                                    = 'preload'
+FEED_ACT_LOAD                                       = 'load'
+FEED_ACT_UNLOAD                                     = 'unload'
+FEED_ACT_MANUAL_FEED                                = 'manual_feed'
+FEED_ACT_UPDATE_AUTO_MODE                           = 'update_auto_mode'
+FEED_ACT_REMOVE_FILAMENT                            = 'remove_filament'
+FEED_ACT_FILAMENT_RUNOUT                            = 'filament_runout'
+
+FEED_STA_NONE                                       = 'none'
+FEED_STA_INITED                                     = 'inited'
+FEED_STA_WAIT_INSERT                                = 'wait_insert'
+FEED_STA_PRELOAD_PREPARE                            = 'preload_prepare'
+FEED_STA_PRELOAD_FEEDING                            = 'preload_feeding'
+FEED_STA_PRELOAD_FINISH                             = 'preload_finish'
+FEED_STA_PRELOAD_FAIL                               = 'preload_fail'
+FEED_STA_LOAD_PREPARE                               = 'load_prepare'
+FEED_STA_LOAD_HOMING                                = 'load_homing'
+FEED_STA_LOAD_PICKING                               = 'load_picking'
+FEED_STA_LOAD_HEATING                               = 'load_heating'
+FEED_STA_LOAD_FEEDING                               = 'load_feeding'
+FEED_STA_LOAD_EXTRUDING                             = 'load_extruding'
+FEED_STA_LOAD_FLUSHING                              = 'load_flushing'
+FEED_STA_LOAD_FINISH                                = 'load_finish'
+FEED_STA_LOAD_FAIL                                  = 'load_fail'
+FEED_STA_UNLOAD_PREPARE                             = 'unload_prepare'
+FEED_STA_UNLOAD_HOMING                              = 'unload_homing'
+FEED_STA_UNLOAD_PICKING                             = 'unload_picking'
+FEED_STA_UNLOAD_HEATING                             = 'unload_heating'
+FEED_STA_UNLOAD_HEAT_FINISH                         = 'unload_heat_finish'
+FEED_STA_UNLOAD_DOING                               = 'unload_doing'
+FEED_STA_UNLOAD_FINISH                              = 'unload_finish'
+FEED_STA_UNLOAD_FAIL                                = 'unload_fail'
+FEED_STA_MANUAL_PREPARE                             = 'manual_sta_prepare'
+FEED_STA_MANUAL_HOMING                              = 'manual_sta_homing'
+FEED_STA_MANUAL_PICKING                             = 'manual_sta_picking'
+FEED_STA_MANUAL_PREPARE_FINISH                      = 'manual_sta_prepare_finish'
+FEED_STA_MANUAL_PREPARE_FAIL                        = 'manual_sta_prepare_fail'
+FEED_STA_MANUAL_HEATING                             = 'manual_sta_heating'
+FEED_STA_MANUAL_EXTRUDING                           = 'manual_sta_extruding'
+FEED_STA_MANUAL_EXTRUDE_FINISH                      = 'manual_sta_extrude_finish'
+FEED_STA_MANUAL_EXTRUDE_FAIL                        = 'manual_sta_extrude_fail'
+FEED_STA_MANUAL_FLUSHING                            = 'manual_sta_flushing'
+FEED_STA_MANUAL_FLUSH_FINISH                        = 'manual_sta_flush_finish'
+FEED_STA_MANUAL_FLUSH_FAIL                          = 'manual_sta_flush_fail'
+FEED_STA_MANUAL_FINISH                              = 'manual_sta_finish'
+FEED_STA_MANUAL_FAIL                                = 'manual_sta_fail'
+FEED_STA_TEST                                       = 'test'
+
+FEED_MANUAL_STAGE_PREPARE                           = 'prepare'
+FEED_MANUAL_STAGE_EXTRUDE                           = 'extrude'
+FEED_MANUAL_STAGE_FLUSH                             = 'flush'
+FEED_MANUAL_STAGE_FINISH                            = 'finish'
+FEED_MANUAL_STAGE_CANCEL                            = 'cancel'
+FEED_UNLOAD_STAGE_PREPARE                           = 'prepare'
+FEED_UNLOAD_STAGE_DOING                             = 'doing'
+FEED_UNLOAD_STAGE_CANCEL                            = 'cancel'
+
+FEED_LIGHT_PWM_CYCLE_TIME                           = 1
+FEED_LIGHT_INDEXS                                   = ['RED', 'WHITE', 'ALL']
+
+FEED_PORT_ADC_SAMPLE_TIME                           = 0.05
+FEED_PORT_ADC_SAMPLE_COUNT                          = 4
+FEED_PORT_ADC_REPORT_TIME                           = 0.300
+FEED_PORT_ADC_VAL_THRESHOLD                         = 0.18
+FEED_PORT_ADC_VAL_MODULE_EXIST                      = 0.9
+
+FEED_MOTOR_DIR_IDLE                                 = 0
+FEED_MOTOR_DIR_A                                    = 1
+FEED_MOTOR_DIR_B                                    = 2
+
+FEED_MOTOR_HARD_PROTECT_TIME                        = 2.5
+FEED_MOTOR_SLIP_RATE                                = 0.7
+FEED_MOTOR_REDUCTION_R                              = 33.0
+FEED_WHEEL_CIRCUMFERENCE                            = 31.4159
+
+FEED_PRELOAD_LENGTH                                 = 950.0
+FEED_PRELOAD_TIMEOUT_TIME                           = 45
+FEED_PRELOAD_MOTOR_MIN_SPEED                        = 200
+FEED_PRELOAD_WHEEL_ERR_CNT_MAX                      = 3
+FEED_PRELOAD_MOTOR_ERR_CNT_MAX                      = 2
+FEED_LOAD_POSITION_X                                = 150
+FEED_LOAD_POSITION_Y                                = 5
+FEED_LOAD_LENGTH_MAX                                = 1100.0
+FEED_LOAD_TIMEOUT_TIME                              = 60
+FEED_LOAD_MOTOR_ERR_CNT_MAX                         = 20
+FEED_LOAD_WHEEL_ERR_CNT_MAX                         = 20
+FEED_LOAD_EXTRUDE_TIMES_MAX                         = 20
+
+FEED_MOTOR_SPEED_SLOW_SWITCHING                     = 0.45
+FEED_MOTOR_SPEED_PRELOAD                            = 0.7
+FEED_MOTOR_SPEED_LOAD                               = 0.7
+FEED_MOTOR_SPEED_EXTRUDE                            = 0.50
+FEED_MOTOR_SPEED_HANG_NEUTRAL_A                     = 1
+FEED_MOTOR_SPEED_HANG_NEUTRAL_B                     = 0.9
+FEED_MOTOR_HANG_NEUTRAL_TIME                        = 0.040
+
+FEED_COIL_FREQ_THERSHOLD_SOFT                       = 800
+FEED_COIL_FREQ_THERSHOLD_HARD                       = 1500
+
+FEED_MIN_TIME                                       = 0.100
+
+FEED_CONFIG_FILE_POSTFIX                            = '_filament_feed.json'
+FEED_DEFAULT_CONFIG = {
+    'auto_mode': [True] * FEED_CHANNEL_NUMS,
+    'load_finish': [False] * FEED_CHANNEL_NUMS
+}
+
+FEED_FILAMENT_TEMP_DEFAULT                          = 250
+
+class FeedLight:
+    def __init__(self, printer, reactor, red_pin, white_pin):
+        self.reactor = reactor
+        ppins = printer.lookup_object('pins')
+        self.red_light = ppins.setup_pin('pwm', red_pin)
+        self.red_light.setup_max_duration(0.)
+        self.red_light.setup_start_value(0, 0)
+        self.red_light.setup_cycle_time(FEED_LIGHT_PWM_CYCLE_TIME, False)
+        self.white_light = ppins.setup_pin('pwm', white_pin)
+        self.white_light.setup_max_duration(0.)
+        self.white_light.setup_start_value(0, 0)
+        self.white_light.setup_cycle_time(FEED_LIGHT_PWM_CYCLE_TIME, False)
+
+    def get_mcu(self):
+        return self.red_light.get_mcu()
+
+    def set_light_state(self, print_time, state, index=None, value=None):
+        if state in [FEED_STA_PRELOAD_PREPARE, FEED_STA_LOAD_PREPARE, FEED_STA_UNLOAD_PREPARE,
+                     FEED_STA_MANUAL_PREPARE]:
+            self.red_light.set_pwm(print_time, 0)
+            self.white_light.set_pwm(print_time, 0.2)
+        elif state in [FEED_STA_PRELOAD_FEEDING, FEED_STA_LOAD_HOMING, FEED_STA_LOAD_PICKING,
+                       FEED_STA_LOAD_HEATING, FEED_STA_LOAD_FEEDING, FEED_STA_LOAD_EXTRUDING,
+                       FEED_STA_LOAD_FLUSHING, FEED_STA_UNLOAD_HOMING, FEED_STA_UNLOAD_PICKING,
+                       FEED_STA_UNLOAD_HEAT_FINISH,
+                       FEED_STA_UNLOAD_HEATING, FEED_STA_UNLOAD_DOING, FEED_STA_MANUAL_HOMING,
+                       FEED_STA_MANUAL_PICKING, FEED_STA_MANUAL_PREPARE_FINISH, FEED_STA_MANUAL_HEATING,
+                       FEED_STA_MANUAL_EXTRUDING, FEED_STA_MANUAL_EXTRUDE_FINISH, FEED_STA_MANUAL_FLUSHING,
+                       FEED_STA_MANUAL_FLUSH_FINISH]:
+            self.red_light.set_pwm(print_time, 0)
+            self.white_light.set_pwm(print_time, 0.5)
+        elif state in [FEED_STA_PRELOAD_FINISH, FEED_STA_LOAD_FINISH, FEED_STA_UNLOAD_FINISH,
+                       FEED_STA_MANUAL_FINISH]:
+            self.red_light.set_pwm(print_time, 0)
+            self.white_light.set_pwm(print_time, 1)
+        elif state in [FEED_STA_PRELOAD_FAIL, FEED_STA_LOAD_FAIL, FEED_STA_UNLOAD_FAIL,
+                       FEED_STA_MANUAL_PREPARE_FAIL, FEED_STA_MANUAL_EXTRUDE_FAIL,
+                       FEED_STA_MANUAL_FLUSH_FAIL, FEED_STA_MANUAL_FAIL]:
+            self.red_light.set_pwm(print_time, 1)
+            self.white_light.set_pwm(print_time, 0)
+        elif state == FEED_STA_TEST:
+            if index == 'RED' and value is not None:
+                self.red_light.set_pwm(print_time, value)
+            elif index == 'WHITE' and value is not None:
+                self.white_light.set_pwm(print_time, value)
+            elif index == 'ALL' and value is not None:
+                self.red_light.set_pwm(print_time, value)
+                self.white_light.set_pwm(print_time, value)
+            else:
+                pass
+        else:
+            self.red_light.set_pwm(print_time, 0)
+            self.white_light.set_pwm(print_time, 0)
+
+class FeedPort:
+    def __init__(self, printer, reactor, pin, threshold):
+        self.reactor = reactor
+        ppins = printer.lookup_object('pins')
+        self._port = ppins.setup_pin('adc', pin)
+        self._port_adc_value = 0
+        self._threshold = threshold
+        self._filament_detected = True
+        self._last_filament_detected = True
+        self._port_event_callback = None
+
+        self._port.setup_adc_sample(FEED_PORT_ADC_SAMPLE_TIME, FEED_PORT_ADC_SAMPLE_COUNT)
+        self._port.setup_adc_callback(FEED_PORT_ADC_REPORT_TIME, self._adc_callback)
+
+    def get_mcu(self):
+        return self._port.get_mcu()
+
+    def register_cb_2_port_event(self, cb):
+        try:
+            if callable(cb):
+                self._port_event_callback = cb
+            else:
+                raise TypeError()
+        except:
+            logging.error("[feed][port]: param[cb] is not a callable function!")
+
+    def _adc_callback(self, read_time, read_value):
+        self._port_adc_value = read_value
+        if (self._port_adc_value < self._threshold):
+            self._filament_detected = True
+        else:
+            self._filament_detected = False
+
+        if (None != self._port_event_callback and self._last_filament_detected != self._filament_detected):
+            self._last_filament_detected = self._filament_detected
+            self._port_event_callback(self._filament_detected)
+
+    def get_adc_value(self):
+        return self._port_adc_value
+
+    def get_filament_detected(self):
+        return self._filament_detected
+
+class FeedTachometer:
+    def __init__(self, printer, pin, ppr, sample_time, poll_time):
+        self.frequence = pulse_counter.FrequencyCounter(printer, pin, sample_time, poll_time)
+        self.ppr = ppr
+
+    def get_rpm(self):
+        rpm = self.frequence.get_frequency()  * 30. / self.ppr
+        return rpm
+
+    def get_counts(self):
+        return self.frequence.get_count()
+
+class FeedMotorPwmCfg:
+    def __init__(self):
+        self.a_pin = None
+        self.b_pin = None
+        self.cycle_time = 0.010
+        self.max_value = 1.0
+
+class FeedMotor:
+    def __init__(self, printer, reactor, cfg:FeedMotorPwmCfg):
+        self.reactor = reactor
+        ppins = printer.lookup_object('pins')
+        self.max_value = cfg.max_value
+        self._motor_a = ppins.setup_pin('pwm', cfg.a_pin)
+        self._motor_a.setup_max_duration(0)
+        self._motor_a.setup_cycle_time(cfg.cycle_time, False)
+        self._motor_a.setup_start_value(0, 0)
+        self._motor_b = ppins.setup_pin('pwm', cfg.b_pin)
+        self._motor_b.setup_max_duration(0)
+        self._motor_b.setup_cycle_time(cfg.cycle_time, False)
+        self._motor_b.setup_start_value(0, 0)
+        self._mutex_lock = False
+        self._dir = FEED_MOTOR_DIR_IDLE
+
+    def get_mcu(self):
+        return self._motor_a.get_mcu()
+
+    def _run(self, dir, value):
+        systime = self.reactor.monotonic()
+        systime += FEED_MIN_TIME
+        print_time = self._motor_a.get_mcu().estimated_print_time(systime)
+        if FEED_MOTOR_DIR_A == dir:
+            self._motor_b.set_pwm(print_time, 0)
+            self._motor_a.set_pwm(print_time, value)
+        elif FEED_MOTOR_DIR_B == dir:
+            self._motor_a.set_pwm(print_time, 0)
+            self._motor_b.set_pwm(print_time, value)
+        else:
+            self._motor_b.set_pwm(print_time, 0)
+            self._motor_a.set_pwm(print_time, 0)
+        self._last_print_time = print_time = print_time
+
+    def _run_one_cycle(self, dir, value, time):
+        systime = self.reactor.monotonic()
+        systime += FEED_MIN_TIME
+        print_time = self._motor_a.get_mcu().estimated_print_time(systime)
+        delta = time
+        if FEED_MOTOR_DIR_A == dir:
+            self._motor_b.set_pwm(print_time, 0)
+            self._motor_a.set_pwm(print_time, value)
+            self._motor_a.set_pwm(print_time + delta, 0)
+        elif FEED_MOTOR_DIR_B == dir:
+            self._motor_a.set_pwm(print_time, 0)
+            self._motor_b.set_pwm(print_time, value)
+            self._motor_b.set_pwm(print_time + delta, 0)
+        self._last_print_time = print_time + delta
+
+    def run(self, dir, value):
+        while self._mutex_lock:
+            self.reactor.pause(self.reactor.monotonic() + 0.1)
+        self._mutex_lock = True
+
+        val = max(0, min(self.max_value, value))
+        if val == 0:
+            dir = FEED_MOTOR_DIR_IDLE
+
+        while 1:
+            if FEED_MOTOR_DIR_IDLE == self._dir:
+                if FEED_MOTOR_DIR_IDLE == dir:
+                    break
+                self._dir = dir
+                self._run(dir, val)
+                self.reactor.pause(self.reactor.monotonic() + 1.05 * FEED_MIN_TIME)
+            else:
+                if dir == self._dir:
+                    self._run(dir, val)
+                    self.reactor.pause(self.reactor.monotonic() + 1.05 * FEED_MIN_TIME)
+                else:
+                    self._run(FEED_MOTOR_DIR_IDLE, 0)
+                    self.reactor.pause(self.reactor.monotonic() + FEED_MOTOR_HARD_PROTECT_TIME)
+                    self._dir = FEED_MOTOR_DIR_IDLE
+                    if FEED_MOTOR_DIR_IDLE != dir:
+                        self._dir = dir
+                        self._run(dir, val)
+                        self.reactor.pause(self.reactor.monotonic() + 1.05 * FEED_MIN_TIME)
+            break
+        self._mutex_lock = False
+
+    def run_one_cycle(self, dir, value, time):
+        while self._mutex_lock:
+            self.reactor.pause(self.reactor.monotonic() + 0.1)
+        self._mutex_lock = True
+
+        val = max(0, min(self.max_value, value))
+        if val == 0:
+            dir = FEED_MOTOR_DIR_IDLE
+
+        while 1:
+            if FEED_MOTOR_DIR_IDLE == self._dir:
+                if FEED_MOTOR_DIR_IDLE == dir:
+                    break
+                self._dir = dir
+                self._run_one_cycle(dir, val, time)
+                self.reactor.pause(self.reactor.monotonic() + 1.05 * (FEED_MIN_TIME + time))
+                self._dir = FEED_MOTOR_DIR_IDLE
+            else:
+                self._run(FEED_MOTOR_DIR_IDLE, 0)
+                self.reactor.pause(self.reactor.monotonic() + FEED_MOTOR_HARD_PROTECT_TIME)
+                self._dir = FEED_MOTOR_DIR_IDLE
+                if FEED_MOTOR_DIR_IDLE != dir:
+                    self._dir = dir
+                    self._run_one_cycle(dir, val, time)
+                    self.reactor.pause(self.reactor.monotonic() + 1.05 * (FEED_MIN_TIME + time))
+                    self._dir = FEED_MOTOR_DIR_IDLE
+            break
+        self._mutex_lock = False
+
+class FilamentFeed:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.gcode = self.printer.lookup_object('gcode')
+        self.module_name = config.get_name().split()[1]
+
+        self.channel_active = None
+        self.channel_state = [FEED_STA_NONE] * FEED_CHANNEL_NUMS
+        self.channel_action_state = [FEED_STA_NONE] * FEED_CHANNEL_NUMS
+        self.channel_error_state = [FEED_STA_NONE] * FEED_CHANNEL_NUMS
+        self.channel_error = [FEED_OK] * FEED_CHANNEL_NUMS
+        self.module_exist = [False] * FEED_CHANNEL_NUMS
+        self.manual_feeding = [False] * FEED_CHANNEL_NUMS
+        self.exception_code = [0] * FEED_CHANNEL_NUMS
+
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = self.module_name + FEED_CONFIG_FILE_POSTFIX
+        self.config_path = os.path.join(config_dir, config_name)
+        self.config = self.printer.load_snapmaker_config_file(self.config_path, FEED_DEFAULT_CONFIG)
+
+        # extruder channel / filament channel
+        self.filament_ch = []
+        self.filament_ch.append(config.getint('filament_ch_1'))
+        self.filament_ch.append(config.getint('filament_ch_2'))
+
+        # runout sensor
+        self.runout_sensor = []
+        tmp_obj = self.printer.lookup_object('filament_motion_sensor e%d_filament' % (self.filament_ch[FEED_CHANNEL_1]), None)
+        self.runout_sensor.append(tmp_obj)
+        tmp_obj = self.printer.lookup_object('filament_motion_sensor e%d_filament' % (self.filament_ch[FEED_CHANNEL_2]), None)
+        self.runout_sensor.append(tmp_obj)
+        self.filament_detect = self.printer.lookup_object('filament_detect', None)
+
+        # light
+        self.light = []
+        white_pin = config.get('light_ch_1_white')
+        red_pin = config.get('light_ch_1_red')
+        tmp_obj = FeedLight(self.printer, self.reactor, white_pin, red_pin)
+        self.light.append(tmp_obj)
+        white_pin = config.get('light_ch_2_white')
+        red_pin = config.get('light_ch_2_red')
+        tmp_obj = FeedLight(self.printer, self.reactor, white_pin, red_pin)
+        self.light.append(tmp_obj)
+        self.gcode.register_mux_command("FEED_LIGHT", "MODULE",
+                                self.module_name,
+                                self.cmd_FEED_LIGHT)
+
+        # port
+        self._port = []
+        tmp_pin = config.get('port_ch_1_pin')
+        threshold = config.getfloat('port_ch_1_threshold')
+        tmp_obj = FeedPort(self.printer, self.reactor, tmp_pin, threshold)
+        tmp_obj.register_cb_2_port_event(self._port_ch1_event_handler)
+        self._port.append(tmp_obj)
+        tmp_pin = config.get('port_ch_2_pin')
+        threshold = config.getfloat('port_ch_2_threshold')
+        tmp_obj = FeedPort(self.printer, self.reactor, tmp_pin, threshold)
+        tmp_obj.register_cb_2_port_event(self._port_ch2_event_handler)
+        self._port.append(tmp_obj)
+        self.gcode.register_mux_command("FEED_PORT", "MODULE",
+                                self.module_name,
+                                self.cmd_FEED_PORT)
+
+        # wheel
+        self.wheel = []
+        self.wheel_2 = []
+        tmp_pin = config.get('wheel_tach_ch_1_1_pin')
+        wheel_tach_ppr = config.getint('wheel_tach_ppr', 6, minval=1)
+        poll_time = config.getfloat('wheel_tach_poll_interval', 0.0005, above=0.)
+        tmp_obj = FeedTachometer(
+                                self.printer,
+                                tmp_pin,
+                                wheel_tach_ppr,
+                                0.100,
+                                poll_time)
+        self.wheel.append(tmp_obj)
+
+        tmp_pin = config.get('wheel_tach_ch_2_1_pin')
+        tmp_obj = FeedTachometer(
+                                self.printer,
+                                tmp_pin,
+                                wheel_tach_ppr,
+                                0.100,
+                                poll_time)
+        self.wheel.append(tmp_obj)
+
+        tmp_pin = config.get('wheel_tach_ch_1_2_pin')
+        tmp_obj = FeedTachometer(
+                                self.printer,
+                                tmp_pin,
+                                wheel_tach_ppr,
+                                0.100,
+                                poll_time)
+        self.wheel_2.append(tmp_obj)
+
+        tmp_pin = config.get('wheel_tach_ch_2_2_pin')
+        tmp_obj = FeedTachometer(
+                                self.printer,
+                                tmp_pin,
+                                wheel_tach_ppr,
+                                0.100,
+                                poll_time)
+        self.wheel_2.append(tmp_obj)
+
+        self.gcode.register_mux_command("FEED_WHEEL_TACH", "MODULE",
+                                self.module_name,
+                                self.cmd_FEED_WHEEL_TACH)
+
+        # motor
+        motor_cfg = FeedMotorPwmCfg()
+        motor_cfg.a_pin = config.get('motor_ch_1_pin')
+        motor_cfg.b_pin = config.get('motor_ch_2_pin')
+        motor_cfg.cycle_time = config.getfloat('motor_cycle_time')
+        motor_cfg.max_value = config.getfloat('motor_max_value', maxval=1.0)
+        self.motor = FeedMotor(self.printer, self.reactor, motor_cfg)
+        self.gcode.register_mux_command("FEED_MOTOR", "MODULE",
+                                self.module_name,
+                                self.cmd_FEED_MOTOR)
+        self.gcode.register_mux_command("FEED_MOTOR_ONE_CYCLE", "MODULE",
+                                self.module_name,
+                                self.cmd_FEED_MOTOR_ONE_CYCLE)
+
+        # motor tachometer
+        tmp_pin = config.get('motor_tach_pin')
+        motor_tach_ppr = config.getint('motor_tach_ppr', 2, minval=1)
+        poll_time = config.getfloat('motor_tach_poll_interval', 0.0015, above=0.)
+        self.motor_tachometer = FeedTachometer(
+                                self.printer,
+                                tmp_pin,
+                                motor_tach_ppr,
+                                0.100,
+                                poll_time)
+        self.gcode.register_mux_command("FEED_MOTOR_TACH", "MODULE",
+                                self.module_name,
+                                self.cmd_FEED_MOTOR_TACH)
+
+        # other config
+        self._feed_load_position_x = config.getfloat('load_position_x', FEED_LOAD_POSITION_X, minval=2, maxval=265)
+        self._feed_load_position_y = config.getfloat('load_position_y', FEED_LOAD_POSITION_Y, minval=2, maxval=250)
+        self._feed_load_extrude_max_times = config.getint('load_extrude_max_times', FEED_LOAD_EXTRUDE_TIMES_MAX, minval=3, maxval=50)
+        preload_length = config.getfloat('preload_length', FEED_PRELOAD_LENGTH, minval=600.0, maxval=1500.0)
+        self.coil_freq_threshold_soft = config.getint('coil_freq_thershold_soft', FEED_COIL_FREQ_THERSHOLD_SOFT, minval=100)
+        self.coil_freq_threshold_hard = config.getint('coil_freq_thershold_hard', FEED_COIL_FREQ_THERSHOLD_HARD, minval=100)
+        self.check_wheel_data = config.getint('check_wheel_data', 1)
+        self.check_coil_freq = config.getint('check_coil_freq', 1)
+        if self.check_coil_freq == 0 and self.check_wheel_data == 0:
+            raise Exception("check_wheel_data and check_coil_freq can not be both 0")
+
+        # other gcode cmd
+        self.gcode.register_mux_command("FEED_AUTO", "MODULE",
+                        self.module_name,
+                        self.cmd_FEED_AUTO)
+        self.gcode.register_mux_command("FEED_MANUAL", "MODULE",
+                        self.module_name,
+                        self.cmd_FEED_MANUAL)
+        self.gcode.register_mux_command("FEED_RUNOUT_EVENT_HANDLE", "MODULE",
+                        self.module_name,
+                        self.cmd_FEED_RUNOUT_EVENT_HANDLE)
+
+        self.printer.register_event_handler("klippy:ready", self._ready)
+        self.printer.register_event_handler("filament_switch_sensor:runout", self._runout_evt_handle)
+        self._check_init_state_timer = self.reactor.register_timer(self._check_init_state_timer_handler)
+
+        self._feed_preload_counts = int(preload_length / FEED_WHEEL_CIRCUMFERENCE * 2)
+        self._feed_load_counts_max = int(FEED_LOAD_LENGTH_MAX / FEED_WHEEL_CIRCUMFERENCE * 2)
+
+        self.motor_speed_slow_switching = FEED_MOTOR_SPEED_SLOW_SWITCHING
+        self.motor_speed_preload = FEED_MOTOR_SPEED_PRELOAD
+        self.motor_speed_load = FEED_MOTOR_SPEED_LOAD
+        self.motor_speed_extrude = FEED_MOTOR_SPEED_EXTRUDE
+        self.motor_speed_hang_neutral_a = FEED_MOTOR_SPEED_HANG_NEUTRAL_A
+        self.motor_speed_hang_neutral_b = FEED_MOTOR_SPEED_HANG_NEUTRAL_B
+        self.motor_hang_neutral_time = FEED_MOTOR_HANG_NEUTRAL_TIME
+
+        self._last_print_time = 0
+        for ch in range(FEED_CHANNEL_NUMS):
+            self.channel_state[ch] = FEED_STA_INITED
+
+    def _ready(self):
+        self.toolhead = self.printer.lookup_object('toolhead')
+        self.gcode_move = self.printer.lookup_object('gcode_move')
+        self.exception_manager = self.printer.lookup_object('exception_manager', None)
+        self.reactor.update_timer(self._check_init_state_timer,
+                                  self.reactor.monotonic() + 2 * FEED_PORT_ADC_REPORT_TIME)
+
+    def _runout_evt_handle(self, extruder, present):
+        if present == True:
+            return
+
+        for ch in range(FEED_CHANNEL_NUMS):
+            if extruder == self.filament_ch[ch]:
+                self.reactor.register_async_callback(
+                    (lambda et, c=self._do_feed, ch=ch, action=FEED_ACT_FILAMENT_RUNOUT: c(ch, action)))
+                break
+
+    def _check_init_state_timer_handler(self, eventtime):
+        self.reactor.unregister_timer(self._check_init_state_timer)
+
+        for ch in range(FEED_CHANNEL_NUMS):
+            if self._port[ch].get_adc_value() < FEED_PORT_ADC_VAL_MODULE_EXIST:
+                self.module_exist[ch] = True
+            else:
+                self.module_exist[ch] = False
+
+            if self.config['auto_mode'][ch] == True and self.module_exist[ch] == True:
+                if self.filament_detect.is_startup_stay() == False:
+                    self.printer.send_event("filament_feed:port", self.filament_ch[ch],
+                                            self._port[ch].get_filament_detected())
+                if self._port[ch].get_filament_detected() == False:
+                    self._set_channel_state(ch, FEED_STA_WAIT_INSERT)
+                else:
+                    if self.config['load_finish'][ch] == True:
+                        self._set_channel_state(ch, FEED_STA_LOAD_FINISH)
+                    else:
+                        self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH)
+
+        return self.reactor.NEVER
+
+    def _set_channel_state(self, channel, state, save=False):
+        systime = self.reactor.monotonic()
+        systime += FEED_MIN_TIME
+        print_time = self.light[channel].get_mcu().estimated_print_time(systime)
+        if print_time - self._last_print_time < FEED_MIN_TIME:
+            print_time = self._last_print_time + FEED_MIN_TIME
+
+        if self.config['auto_mode'][channel] == False:
+            self.light[channel].set_light_state(print_time, FEED_STA_NONE)
+        else:
+            self.light[channel].set_light_state(print_time, state)
+        self.channel_state[channel] = state
+        self._last_print_time = print_time
+
+        if state not in [FEED_STA_INITED, FEED_STA_WAIT_INSERT, FEED_STA_TEST] and \
+                not state.startswith('preload_'):
+            self.channel_action_state[channel] = state
+
+        if save == True:
+            if state == FEED_STA_LOAD_FINISH:
+                self.config['load_finish'][channel] = True
+            else:
+                self.config['load_finish'][channel] = False
+            if not self.printer.update_snapmaker_config_file(self.config_path, self.config, FEED_DEFAULT_CONFIG):
+                logging.error("[feed] save config failed!")
+
+    def _set_light_state(self, channel, state):
+        systime = self.reactor.monotonic()
+        systime += FEED_MIN_TIME
+        print_time = self.light[channel].get_mcu().estimated_print_time(systime)
+        if print_time - self._last_print_time < FEED_MIN_TIME:
+            print_time = self._last_print_time + FEED_MIN_TIME
+
+        self.light[channel].set_light_state(print_time, state)
+        self._last_print_time = print_time
+
+    def _port_ch1_event_handler(self, detected):
+        self._port_event_handler(detected, FEED_CHANNEL_1)
+
+    def _port_ch2_event_handler(self, detected):
+        self._port_event_handler(detected, FEED_CHANNEL_2)
+
+    def _port_event_handler(self, detected, channel):
+        if self.config['auto_mode'][channel] == False or \
+                self.module_exist[channel] == False:
+            return
+
+        self.printer.send_event("filament_feed:port", self.filament_ch[channel], detected)
+
+        if self.runout_sensor[channel] is None or \
+                self.runout_sensor[channel].get_status(0)['enabled'] == False:
+            return
+
+        if self.manual_feeding[channel]:
+            return
+
+        if detected:
+            if self.channel_state[channel] == FEED_STA_PRELOAD_PREPARE:
+                self._set_light_state(channel, FEED_STA_PRELOAD_PREPARE)
+                return
+            else:
+                self._set_channel_state(channel, FEED_STA_PRELOAD_PREPARE)
+                self.reactor.register_async_callback(
+                    (lambda et, c=self._do_feed, ch=channel, action=FEED_ACT_PRELOAD: c(ch, action)))
+        else:
+            if self.channel_active != channel:
+                self._set_light_state(channel, FEED_STA_WAIT_INSERT)
+            self.reactor.register_async_callback(
+                (lambda et, c=self._do_feed, ch=channel, action=FEED_ACT_REMOVE_FILAMENT: c(ch, action)))
+
+    def _check_homing_xy(self):
+        curtime = self.reactor.monotonic()
+        homed_axes_list = self.toolhead.get_status(curtime)['homed_axes']
+        return ('x' in homed_axes_list and 'y' in homed_axes_list)
+
+    def _get_filament_temp(self, channel):
+        print_task_config = self.printer.lookup_object('print_task_config', None)
+        filament_parameters = self.printer.lookup_object('filament_parameters', None)
+        if print_task_config is None or filament_parameters is None:
+            return FEED_FILAMENT_TEMP_DEFAULT
+
+        status = print_task_config.get_status()
+        return filament_parameters.get_load_temp(
+                status['filament_vendor'][self.filament_ch[channel]],
+                status['filament_type'][self.filament_ch[channel]],
+                status['filament_sub_type'][self.filament_ch[channel]])
+    def _get_filament_soft(self, channel):
+        print_task_config = self.printer.lookup_object('print_task_config', None)
+        filament_parameters = self.printer.lookup_object('filament_parameters', None)
+        if print_task_config is None or filament_parameters is None:
+            return False
+
+        status = print_task_config.get_status()
+        return filament_parameters.get_is_soft(
+                status['filament_vendor'][self.filament_ch[channel]],
+                status['filament_type'][self.filament_ch[channel]],
+                status['filament_sub_type'][self.filament_ch[channel]])
+
+    def _hang_neutral(self, channel):
+        self.reactor.pause(self.reactor.monotonic() + 0.105)
+        motor_cnt_1 = self.motor_tachometer.get_counts()
+        for retry in range(2):
+            if channel == FEED_CHANNEL_1:
+                self.motor.run_one_cycle(FEED_MOTOR_DIR_B,
+                        self.motor_speed_hang_neutral_b,
+                        self.motor_hang_neutral_time)
+            else:
+                self.motor.run_one_cycle(FEED_MOTOR_DIR_A,
+                                        self.motor_speed_hang_neutral_a,
+                                        self.motor_hang_neutral_time)
+            self.reactor.pause(self.reactor.monotonic() + 0.105)
+            motor_cnt_2 = self.motor_tachometer.get_counts()
+            logging.info("[feed] extruder[%d] hanging neutral, try: %d, cnt1:%d, cnt2: %d\r\n",
+                         self.filament_ch[channel], retry, motor_cnt_1, motor_cnt_2)
+            if motor_cnt_2 - motor_cnt_1 > 5:
+                break
+
+    def _put_into_drive(self, channel):
+        logging.info("[feed] extruder[%d] putting into drive", self.filament_ch[channel])
+        if channel == FEED_CHANNEL_1:
+            self.motor.run_one_cycle(FEED_MOTOR_DIR_A,
+                                     self.motor_speed_hang_neutral_a,
+                                     self.motor_hang_neutral_time)
+        else:
+            self.motor.run_one_cycle(FEED_MOTOR_DIR_B,
+                                     self.motor_speed_hang_neutral_b,
+                                     self.motor_hang_neutral_time)
+
+    def _is_keep_raw_error_info(self, error=None):
+        if error in [FEED_ERR_MOVE, FEED_ERR_MOVE_HOME,
+                     FEED_ERR_MOVE_SWITCH, FEED_ERR_HEAT]:
+            return True
+        else:
+            return False
+
+    def _do_feed(self, ch, action=None, stage=None, auto_mode=None):
+        if ch < 0 or ch >= FEED_CHANNEL_NUMS or action == None:
+            logging.error("[feed] parameter error!")
+            return
+
+        if action == FEED_ACT_UPDATE_AUTO_MODE and auto_mode is None:
+            logging.error("[feed] parameter error!")
+            return
+
+        if action in [FEED_ACT_PRELOAD, FEED_ACT_LOAD] and \
+                (self.config['auto_mode'][ch] == False or self.module_exist[ch] == False):
+            return
+
+        wheel_cnt_a_1 = 0
+        wheel_cnt_b_1 = 0
+        motor_cnt_1 = 0
+        wheel_cnt_a_2 = 0
+        wheel_cnt_b_2 = 0
+        motor_cnt_2 = 0
+
+        if action == FEED_ACT_PRELOAD:
+            wheel_cnt_a_1 = self.wheel[ch].get_counts()
+            wheel_cnt_b_1 = self.wheel_2[ch].get_counts()
+
+        while self.channel_active != None:
+            self.reactor.pause(self.reactor.monotonic() + 0.1)
+        self.channel_active = ch
+        self.channel_error[ch] = FEED_OK
+        self.exception_code[ch] = 0
+
+        filament_feed_temp = self._get_filament_temp(ch)
+        filament_soft = self._get_filament_soft(ch)
+
+        motor_dir = FEED_MOTOR_DIR_A
+        if ch == FEED_CHANNEL_2:
+            motor_dir = FEED_MOTOR_DIR_B
+
+        try:
+            # update auto-mode
+            if action == FEED_ACT_UPDATE_AUTO_MODE:
+                self.config['auto_mode'][ch] = bool(auto_mode)
+                if self.config['auto_mode'][ch] == True:
+                    if self.module_exist[ch]:
+                        if self._port[ch].get_filament_detected() == False:
+                            self._set_channel_state(ch, FEED_STA_WAIT_INSERT, True)
+                        else:
+                            self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH, True)
+                else:
+                    self._set_channel_state(ch, FEED_STA_NONE, True)
+
+            # remove filament
+            elif action == FEED_ACT_REMOVE_FILAMENT:
+                if self._port[ch].get_filament_detected() == False:
+                    self._set_channel_state(ch, FEED_STA_WAIT_INSERT, True)
+                else:
+                    self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH, True)
+
+            # filament runout
+            elif action == FEED_ACT_FILAMENT_RUNOUT:
+                if self._port[ch].get_filament_detected() == True:
+                    self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH, True)
+                else:
+                    self._set_channel_state(ch, FEED_STA_WAIT_INSERT, True)
+
+            # preload
+            elif action == FEED_ACT_PRELOAD:
+                has_put_into_drive = False
+                try:
+                    self.exception_code[ch] = 10
+                    self.channel_error_state[ch] = FEED_STA_NONE
+                    self._set_channel_state(ch, FEED_STA_PRELOAD_PREPARE, True)
+
+                    if self._port[ch].get_filament_detected() == False:
+                        self.channel_error[ch] = FEED_ERR_NO_FILAMENT
+                        self.exception_code[ch] = 13
+                        raise
+
+                    if self.runout_sensor[ch].get_status(0)['filament_detected']:
+                        self.channel_error[ch] = FEED_ERR_RESIDUAL_FILAMENT
+                        self.exception_code[ch] = 15
+                        raise
+
+                    self.reactor.pause(self.reactor.monotonic() + 1)
+
+                    motor_cnt_1 = self.motor_tachometer.get_counts()
+                    logging.info("[feed_preload] extruder[%d], start, wheel_cnt_a: %d, wheel_cnt_b: %d, motor_cnt: %d",
+                                  self.filament_ch[ch], wheel_cnt_a_1, wheel_cnt_b_1, motor_cnt_1)
+
+                    # feed
+                    self._set_channel_state(ch, FEED_STA_PRELOAD_FEEDING)
+                    systime_1 = self.reactor.monotonic()
+                    self.motor.run(motor_dir, self.motor_speed_slow_switching)
+                    has_put_into_drive = True
+                    arrive_runout_sensor = False
+                    logging.info("[feed] extruder[%d] putting into drive", self.filament_ch[ch])
+                    self.reactor.pause(self.reactor.monotonic() + 0.5)
+
+                    preload_duty = self.motor_speed_preload
+                    if arrive_runout_sensor == False:
+                        for i in range(3):
+                            self.motor.run(motor_dir, preload_duty)
+                            self.reactor.pause(self.reactor.monotonic() + 0.35)
+                            arrive_runout_sensor = self.runout_sensor[ch].get_status(0)['filament_detected']
+                            if arrive_runout_sensor == True or preload_duty >= 1.0:
+                                break
+                            preload_duty = min(1.0, preload_duty + 0.1)
+                        if arrive_runout_sensor == False and preload_duty < 1.0:
+                            self.motor.run(motor_dir, 1.0)
+                            self.reactor.pause(self.reactor.monotonic() + 0.2)
+                            arrive_runout_sensor = self.runout_sensor[ch].get_status(0)['filament_detected']
+                    logging.info("[feed_preload] extruder[%d], duty:%f, ", self.filament_ch[ch], preload_duty)
+
+                    motor_speed = 0
+                    wheel_speed_a = 0
+                    wheel_speed_b = 0
+                    wheel_speed_err_max = FEED_PRELOAD_WHEEL_ERR_CNT_MAX
+                    motor_speed_err_max = FEED_PRELOAD_MOTOR_ERR_CNT_MAX
+                    if arrive_runout_sensor == False:
+                        while 1:
+                            wheel_cnt_a_2 = self.wheel[ch].get_counts()
+                            wheel_cnt_b_2 = self.wheel_2[ch].get_counts()
+                            systime_2 = self.reactor.monotonic()
+                            motor_speed = self.motor_tachometer.get_rpm()
+                            wheel_speed_a = self.wheel[ch].get_rpm()
+                            wheel_speed_b = self.wheel_2[ch].get_rpm()
+                            port_detect = self._port[ch].get_filament_detected()
+                            runout_detect = self.runout_sensor[ch].get_status(0)['filament_detected']
+
+                            # Please do not adjust the order arbitrarily
+                            if runout_detect == True:
+                                self.channel_error[ch] = FEED_OK
+                                break
+                            if port_detect == False:
+                                self.channel_error[ch] = FEED_ERR_NO_FILAMENT
+                                self.exception_code[ch] = 13
+                                break
+                            if (wheel_cnt_a_2 - wheel_cnt_a_1) / self.wheel[ch].ppr > self._feed_preload_counts or \
+                                    (wheel_cnt_b_2 - wheel_cnt_b_1) / self.wheel_2[ch].ppr > self._feed_preload_counts:
+                                self.channel_error[ch] = FEED_OK
+                                break
+                            if motor_speed < FEED_PRELOAD_MOTOR_MIN_SPEED:
+                                logging.info("[feed_preload] extruder[%d], motor speed error, motor_speed:%d",
+                                             self.filament_ch[ch], motor_speed)
+                                if motor_speed_err_max > 0:
+                                    motor_speed_err_max -= 1
+                                else:
+                                    self.channel_error[ch] = FEED_ERR_MOTOR_SPEED
+                                    self.exception_code[ch] = 11
+                                    break
+                            else:
+                                motor_speed_err_max = FEED_PRELOAD_MOTOR_ERR_CNT_MAX
+                            if wheel_speed_a * FEED_MOTOR_REDUCTION_R < motor_speed * (1 - FEED_MOTOR_SLIP_RATE) and \
+                                wheel_speed_b * FEED_MOTOR_REDUCTION_R < motor_speed * (1 - FEED_MOTOR_SLIP_RATE):
+                                logging.info("[feed_preload] extruder[%d], wheel speed error, wheel_speed_a:%d, wheel_speed_b:%d, motor_speed:%d",
+                                             self.filament_ch[ch], wheel_speed_a, wheel_speed_b, motor_speed)
+                                if wheel_speed_err_max > 0:
+                                    wheel_speed_err_max -= 1
+                                else:
+                                    self.channel_error[ch] = FEED_ERR_WHEEL_SPEED
+                                    self.exception_code[ch] = 12
+                                    break
+                            else:
+                                wheel_speed_err_max = FEED_PRELOAD_WHEEL_ERR_CNT_MAX
+                            if systime_2 - systime_1 > FEED_PRELOAD_TIMEOUT_TIME:
+                                self.channel_error[ch] = FEED_ERR_TIMEOUT
+                                self.exception_code[ch] = 14
+                                break
+
+                            self.reactor.pause(self.reactor.monotonic() + 0.05)
+
+                    self.motor.run(FEED_MOTOR_DIR_IDLE, 0)
+                    wheel_cnt_a_2 = self.wheel[ch].get_counts()
+                    wheel_cnt_b_2 = self.wheel_2[ch].get_counts()
+                    motor_cnt_2 = self.motor_tachometer.get_counts()
+
+                    logging.info("[feed_preloading] extruder[%d], wheel, cnt_a_1:%d, cnt_b_1:%d, cnt_a_2:%d, cnt_b_2:%d, wheel_speed_a:%d, wheel_speed_b: %d, "
+                                 "motor, motor_cnt_1:%d, motor_cnt_2:%d, motor_speed:%d",
+                                 self.filament_ch[ch], wheel_cnt_a_1, wheel_cnt_b_1, wheel_cnt_a_2, wheel_cnt_b_2, wheel_speed_a, wheel_speed_b,
+                                 motor_cnt_1, motor_cnt_2, motor_speed)
+                    if self.channel_error[ch] != FEED_OK:
+                        raise
+
+                    self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH)
+
+                except:
+                    if self.channel_error[ch] == FEED_OK:
+                        self.channel_error[ch] = FEED_ERR
+                        self.exception_code[ch] = 10
+                    self._set_channel_state(ch, FEED_STA_PRELOAD_FAIL)
+                    self.channel_error_state[ch] = self.channel_state[ch]
+                    if self.exception_manager is not None:
+                        self.exception_manager.raise_exception_async(
+                            id = self.exception_manager.list.MODULE_ID_FEEDING,
+                            index = self.filament_ch[ch],
+                            code = self.exception_code[ch],
+                            message = "preload fail: %s" % (self.channel_error[ch]),
+                            oneshot = 1,
+                            level = 1)
+
+                finally:
+                    if has_put_into_drive:
+                        self._hang_neutral(ch)
+
+            # load
+            elif action == FEED_ACT_LOAD:
+                try:
+                    # prepare
+                    self.exception_code[ch] = 30
+                    self.manual_feeding[ch] = False
+                    self.channel_error_state[ch] = FEED_STA_NONE
+                    self._set_channel_state(ch, FEED_STA_LOAD_PREPARE, True)
+
+                    if self._port[ch].get_filament_detected() == False:
+                        self.channel_error[ch] = FEED_ERR_NO_FILAMENT
+                        self.exception_code[ch] = 33
+                        raise ValueError('logic error!')
+
+                    # home
+                    try:
+                        self._set_channel_state(ch, FEED_STA_LOAD_HOMING)
+                        if self._check_homing_xy() != True:
+                            self.gcode.run_script_from_command("G28 X Y\r\n")
+                            self.toolhead.wait_moves()
+                    except:
+                        self.channel_error[ch] = FEED_ERR_MOVE_HOME
+                        raise
+
+                    # switch extruder
+                    try:
+                        self._set_channel_state(ch, FEED_STA_LOAD_PICKING)
+                        self.gcode.run_script_from_command("T%d A0\r\n" % (self.filament_ch[ch]))
+                        self.toolhead.wait_moves()
+                    except:
+                        self.channel_error[ch] = FEED_ERR_MOVE_SWITCH
+                        raise
+
+                    # feed filament
+                    self._set_channel_state(ch, FEED_STA_LOAD_FEEDING)
+                    self._put_into_drive(ch)
+                    self.toolhead.wait_moves()
+
+                    # Please do not adjust the order arbitrarily
+                    if self.runout_sensor[ch].get_status(0)['filament_detected'] == False:
+                        # move to dest position
+                        try:
+                            self.toolhead.wait_moves()
+                            self.gcode.run_script_from_command( \
+                                f"G90\nG0 Y{self._feed_load_position_y} F18000\r\n")
+                            self.gcode.run_script_from_command( \
+                                f"G90\nG0 X{self._feed_load_position_x} F18000\r\n")
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE
+                            raise
+
+                        self.reactor.pause(self.reactor.monotonic() + 0.105)
+                        wheel_cnt_a_0 = self.wheel[ch].get_counts()
+                        wheel_cnt_b_0 = self.wheel_2[ch].get_counts()
+                        systime_0 = self.reactor.monotonic()
+                        duty = self.motor_speed_load
+                        period = 0.09
+                        motor_err_max_cnt = FEED_LOAD_MOTOR_ERR_CNT_MAX
+                        wheel_err_max_cnt = FEED_LOAD_WHEEL_ERR_CNT_MAX
+                        one_step_cnt = self.wheel[ch].ppr * 2.0 * 10.0 / FEED_WHEEL_CIRCUMFERENCE
+
+                        while 1:
+                            wheel_cnt_a_1 = self.wheel[ch].get_counts()
+                            wheel_cnt_b_1 = self.wheel_2[ch].get_counts()
+                            motor_cnt_1 = self.motor_tachometer.get_counts()
+                            self.motor.run_one_cycle(motor_dir, duty, period)
+                            self.reactor.pause(self.reactor.monotonic() + 0.105)
+                            systime_2 = self.reactor.monotonic()
+                            motor_cnt_2 = self.motor_tachometer.get_counts()
+                            wheel_cnt_a_2 = self.wheel[ch].get_counts()
+                            wheel_cnt_b_2 = self.wheel_2[ch].get_counts()
+                            port_detect = self._port[ch].get_filament_detected()
+                            runout_detect = self.runout_sensor[ch].get_status(0)['filament_detected']
+                            logging.info("[feed_loading] phase2: duty:%f, period:%f, "
+                                         "wheel, cnt_a_0:%d, cnt_a_1:%d, cnt_a_2:%d, cnt_b_0:%d, cnt_b_1:%d, cnt_b_2:%d, cnterr:%d, "
+                                         "motor, cnt_0:%d, cnt_1:%d, cnt_2:%d, cnterr:%d",
+                                         duty, period,
+                                         wheel_cnt_a_0, wheel_cnt_a_1, wheel_cnt_a_2, wheel_cnt_b_0, wheel_cnt_b_1, wheel_cnt_b_2, wheel_err_max_cnt,
+                                         motor_cnt_1, motor_cnt_2, motor_cnt_2 - motor_cnt_1, motor_err_max_cnt)
+                            if runout_detect == True:
+                                self.channel_error[ch] = FEED_OK
+                                break
+                            if port_detect == False:
+                                self.channel_error[ch] = FEED_ERR_NO_FILAMENT
+                                self.exception_code[ch] = 33
+                                break
+                            if systime_2 - systime_0 > FEED_LOAD_TIMEOUT_TIME:
+                                self.channel_error[ch] = FEED_ERR_TIMEOUT
+                                self.exception_code[ch] = 34
+                                break
+                            if (wheel_cnt_a_2 - wheel_cnt_a_0) / self.wheel[ch].ppr > self._feed_load_counts_max or \
+                                    (wheel_cnt_b_2 - wheel_cnt_b_0) / self.wheel_2[ch].ppr > self._feed_load_counts_max:
+                                self.channel_error[ch] = FEED_ERR_DISTANCE
+                                self.exception_code[ch] = 35
+                                break
+                            if wheel_cnt_a_2 - wheel_cnt_a_1 < 1 and wheel_cnt_b_2 - wheel_cnt_b_1 < 1:
+                                wheel_err_max_cnt -= 1
+                                if wheel_err_max_cnt <= 0:
+                                    self.channel_error[ch] = FEED_ERR_WHEEL_SPEED
+                                    self.exception_code[ch] = 32
+                                    break
+                            else:
+                                wheel_err_max_cnt = FEED_LOAD_WHEEL_ERR_CNT_MAX
+                            if motor_cnt_2 - motor_cnt_1 < 1:
+                                motor_err_max_cnt -= 1
+                                if motor_err_max_cnt <= 0:
+                                    self.channel_error[ch] = FEED_ERR_MOTOR_SPEED
+                                    self.exception_code[ch] = 31
+                                    break
+                            else:
+                                motor_err_max_cnt = FEED_LOAD_MOTOR_ERR_CNT_MAX
+
+                            if wheel_cnt_a_2 - wheel_cnt_a_1 > one_step_cnt or wheel_cnt_b_2 - wheel_cnt_b_1 > one_step_cnt:
+                                if duty > 0.7:
+                                    duty = max(0.7, duty - 0.1)
+                                period = max(0.09, period - 0.01)
+                            elif wheel_cnt_a_2 - wheel_cnt_a_1 < one_step_cnt and wheel_cnt_b_2 - wheel_cnt_b_1 < one_step_cnt:
+                                if duty < 1.0:
+                                    duty = min(1.0, duty + 0.1)
+                                else:
+                                    period = min(0.120, period + 0.01)
+
+                        if self.channel_error[ch] != FEED_OK:
+                            self._hang_neutral(ch)
+                            raise ValueError('logic error!')
+
+                    self.gcode.run_script_from_command("M104 S%d\r\n" % (filament_feed_temp))
+                    try:
+                        self.toolhead.wait_moves()
+                        self.gcode.run_script_from_command("MOVE_TO_DISCARD_FILAMENT_POSITION\r\n")
+                        self.toolhead.wait_moves()
+                    except:
+                        self.channel_error[ch] = FEED_ERR_MOVE
+                        raise
+
+                    # heating
+                    self._set_channel_state(ch, FEED_STA_LOAD_HEATING)
+                    try:
+                        self.gcode.run_script_from_command("M109 S%d\r\n" % (filament_feed_temp))
+                    except:
+                        self.channel_error[ch] = FEED_ERR_HEAT
+                        raise
+
+                    # extruding
+                    self.exception_code[ch] = 50
+                    self._set_channel_state(ch, FEED_STA_LOAD_EXTRUDING)
+                    inductance_coil = None
+                    try:
+                        inductance_coil = self.toolhead.get_extruder().binding_probe.sensor
+                    except:
+                        logging.info("[feed_loading] inductance_coil not found")
+                        inductance_coil = None
+
+                    extruded = False
+                    try:
+                        duty = 0.8
+                        period = 0.100
+                        self.gcode.run_script_from_command("M83\r\n")
+                        for retry in range(self._feed_load_extrude_max_times):
+                            self.toolhead.wait_moves()
+                            self.reactor.pause(self.reactor.monotonic() + 0.105)
+                            wheel_cnt_a_1 = self.wheel[ch].get_counts()
+                            wheel_cnt_b_1 = self.wheel_2[ch].get_counts()
+                            coil_freq_start = 0
+                            coil_freq_end_min = 0
+                            coil_freq_end_max = 0
+                            coil_freq_threshold = 1500
+                            coil_freq_sample_times = 5
+                            coil_freq_time_interval = 0.1
+                            extrude_length = 20
+                            extrude_speed = 400
+                            retry_extrude_times = 2
+                            if filament_soft == True:
+                                extrude_length = 30
+                                extrude_speed = 200
+                                coil_freq_time_interval = 1.0
+                                coil_freq_sample_times = 8
+                                coil_freq_threshold = self.coil_freq_threshold_soft
+                                retry_extrude_times = 3
+                            else:
+                                extrude_length = 20
+                                extrude_speed = 400
+                                coil_freq_time_interval = 0.5
+                                coil_freq_sample_times = 5
+                                coil_freq_threshold = self.coil_freq_threshold_hard
+                                retry_extrude_times = 2
+
+                            for retry_extrude in range(retry_extrude_times):
+                                if inductance_coil is not None:
+                                    coil_freq_start = inductance_coil.get_coil_freq()
+                                    coil_freq_end_min = coil_freq_end_max = coil_freq_start
+                                self.gcode.run_script_from_command(f"G1 E{extrude_length} F{extrude_speed}\r\n")
+                                self.reactor.pause(self.reactor.monotonic() + 0.5)
+                                if inductance_coil is not None:
+                                    for i in range(coil_freq_sample_times):
+                                        tmp_coil_frep = inductance_coil.get_coil_freq()
+                                        if tmp_coil_frep > coil_freq_end_max:
+                                            coil_freq_end_max = tmp_coil_frep
+                                        elif tmp_coil_frep < coil_freq_end_min:
+                                            coil_freq_end_min = tmp_coil_frep
+                                        self.reactor.pause(self.reactor.monotonic() + coil_freq_time_interval)
+                                self.toolhead.wait_moves()
+                                self.reactor.pause(self.reactor.monotonic() + 0.105)
+                                wheel_cnt_a_2 = self.wheel[ch].get_counts()
+                                wheel_cnt_b_2 = self.wheel_2[ch].get_counts()
+                                logging.info("[feed_loading] phase3: extrude[%d] retry:%d, retry_extrude:%d, "
+                                             "coil_freq_start:%d, coil_freq_end_min:%d, coil_freq_end_max:%d, coil_freq_delta:%d",
+                                                self.filament_ch[ch], retry, retry_extrude, coil_freq_start,
+                                                coil_freq_end_min, coil_freq_end_max, coil_freq_end_max - coil_freq_end_min)
+                                logging.info("[feed_loading] phase3: wheel, cnt_a_1:%d, cnt_a_2:%d, cnt_b_1:%d, cnt_b_2:%d",
+                                         wheel_cnt_a_1, wheel_cnt_a_2, wheel_cnt_b_1, wheel_cnt_b_2)
+                                if self.check_wheel_data != 0 and self.check_coil_freq == 0:
+                                    if wheel_cnt_a_2 - wheel_cnt_a_1 >= 2 or wheel_cnt_b_2 - wheel_cnt_b_1 >= 2:
+                                        extruded = True
+                                        break
+                                elif self.check_wheel_data == 0 and self.check_coil_freq != 0:
+                                    if retry > 0 and inductance_coil is not None:
+                                        if abs(coil_freq_end_min - coil_freq_start) >= coil_freq_threshold or \
+                                                abs(coil_freq_end_max - coil_freq_start) >= coil_freq_threshold:
+                                            extruded = True
+                                            break
+                                else:
+                                    if wheel_cnt_a_2 - wheel_cnt_a_1 >= 2 or wheel_cnt_b_2 - wheel_cnt_b_1 >= 2:
+                                        extruded = True
+                                        break
+                                    if retry > 0 and inductance_coil is not None:
+                                        if abs(coil_freq_end_min - coil_freq_start) >= coil_freq_threshold or \
+                                                abs(coil_freq_end_max - coil_freq_start) >= coil_freq_threshold:
+                                            extruded = True
+                                            break
+
+                            if extruded == True:
+                                break
+
+                            self.gcode.run_script_from_command("ROUGHLY_CLEAN_NOZZLE_WITH_DISCARD\r\n")
+                            self.toolhead.wait_moves()
+
+                            if filament_soft:
+                                self.gcode.run_script_from_command("G1 E50 F200\r\n")
+                            else:
+                                self.gcode.run_script_from_command("G1 E40 F480\r\n")
+                            self.toolhead.get_last_move_time()
+                            self.reactor.pause(self.reactor.monotonic() + 0.7)
+
+                            if retry < 5:
+                                duty = max(1.0, duty + 0.05)
+                            else:
+                                period = max(0.12, period + 0.01)
+                            self.motor.run_one_cycle(motor_dir, duty, period)
+                            self.toolhead.wait_moves()
+                            logging.info(f"[feed_loading] phase3: retry:{retry}, duty:{duty}, period:{period}")
+                    except Exception as e:
+                        self.channel_error[ch] = FEED_ERR_MOVE_EXTRUDE
+                        self.exception_code[ch] = 51
+                        logging.error("[feed_loading] phase3: except rawinfo: %s", str(e))
+                        raise ValueError('logic error!')
+                    finally:
+                        self._hang_neutral(ch)
+
+                    if extruded == False:
+                        self.channel_error[ch] = FEED_ERR_MOVE_EXTRUDE
+                        self.exception_code[ch] = 51
+                        raise ValueError('logic error!')
+
+                    # flush filaments
+                    self._set_channel_state(ch, FEED_STA_LOAD_FLUSHING)
+                    try:
+                        self.toolhead.wait_moves()
+                        self.gcode.run_script_from_command("INNER_FLUSH_FILAMENT TEMP=%d SOFT=%d\r\n" %
+                                            (filament_feed_temp, int(filament_soft)))
+                        self.toolhead.wait_moves()
+                    except:
+                        self.channel_error[ch] = FEED_ERR_CUSTOM_GCODE
+                        raise ValueError('custom gcode error!')
+
+                    # not need!
+                    # if self._port[ch].get_filament_detected() == False:
+                    #     self.channel_error[ch] = FEED_ERR_NO_FILAMENT
+                    #     raise
+
+                    self.channel_error[ch] = FEED_OK
+                    self._set_channel_state(ch, FEED_STA_LOAD_FINISH, True)
+
+                except:
+                    self.toolhead.wait_moves()
+                    self.channel_error_state[ch] = self.channel_state[ch]
+                    if self.channel_error[ch] == FEED_OK:
+                        self.channel_error[ch] = FEED_ERR
+                    self._set_channel_state(ch, FEED_STA_LOAD_FAIL)
+                    raise
+
+                finally:
+                    self.gcode.run_script_from_command("M107\r\n")
+                    self.gcode.run_script_from_command("M104 S0\r\n")
+
+            # unload
+            elif action == FEED_ACT_UNLOAD:
+                self.exception_code[ch] = 70
+                if stage not in [None, FEED_UNLOAD_STAGE_PREPARE, FEED_UNLOAD_STAGE_DOING,
+                                 FEED_UNLOAD_STAGE_CANCEL]:
+                    logging.error("[feed][unload] stage parameter error!\r\n")
+                    self.toolhead.wait_moves()
+                    self.channel_error[ch] = FEED_ERR_PARAMETER
+                    self._set_channel_state(ch, FEED_STA_UNLOAD_FAIL)
+                    raise ValueError('parameter error!')
+
+                self.manual_feeding[ch] = False
+                self.channel_error_state[ch] = FEED_STA_NONE
+                if stage == FEED_UNLOAD_STAGE_PREPARE:
+                    try:
+                        # prepare
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_PREPARE, True)
+
+                        # home
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_HOMING)
+                            if self._check_homing_xy() != True:
+                                self.gcode.run_script_from_command("G28 X Y\r\n")
+                                self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE_HOME
+                            raise
+
+                        # switch extruder
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_PICKING)
+                            self.gcode.run_script_from_command("T%d A0\r\n" % (self.filament_ch[ch]))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE_SWITCH
+                            raise
+
+                        # move to dest position
+                        try:
+                            self.gcode.run_script_from_command("MOVE_TO_DISCARD_FILAMENT_POSITION\r\n")
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE
+                            raise
+
+                        # heat
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_HEATING)
+                            self.gcode.run_script_from_command("M109 S%d\r\n" % (filament_feed_temp))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_HEAT
+                            raise
+
+                        self.channel_error[ch] = FEED_OK
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_HEAT_FINISH)
+
+                    except:
+                        self.toolhead.wait_moves()
+                        self.channel_error_state[ch] = self.channel_state[ch]
+                        if self.channel_error[ch] == FEED_OK:
+                            self.channel_error[ch] = FEED_ERR
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_FAIL)
+                        raise
+
+                elif stage == FEED_UNLOAD_STAGE_DOING:
+                    try:
+                        # prepare for unloading?
+                        if self.channel_state[ch] != FEED_STA_UNLOAD_HEAT_FINISH:
+                            self.channel_error[ch] = FEED_ERR_STATE_MISMATCH
+                            raise ValueError('state mismatch!')
+
+                        # unloading
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_DOING)
+                            self.toolhead.wait_moves()
+                            self.gcode.run_script_from_command("INNER_FILAMENT_UNLOAD TEMP=%d SOFT=%d\r\n"
+                                                            % (filament_feed_temp, int(filament_soft)))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_CUSTOM_GCODE
+                            raise ValueError('custom gcode error!')
+
+                        # finish
+                        self.toolhead.wait_moves()
+                        self.gcode.run_script_from_command("M104 S0\r\n")
+                        self.channel_error[ch] = FEED_OK
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_FINISH)
+
+                    except:
+                        self.toolhead.wait_moves()
+                        self.channel_error_state[ch] = self.channel_state[ch]
+                        self.gcode.run_script_from_command("M104 S0\r\n")
+                        if self.channel_error[ch] == FEED_OK:
+                            self.channel_error[ch] = FEED_ERR
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_FAIL)
+                        raise
+
+                elif stage == FEED_UNLOAD_STAGE_CANCEL:
+                    self.toolhead.wait_moves()
+                    self.channel_error[ch] = FEED_OK
+                    self._set_channel_state(ch, FEED_STA_UNLOAD_FAIL, True)
+                    self.gcode.run_script_from_command("M104 S0\r\n")
+                    if self.module_exist[ch] == True and self.config['auto_mode'][ch] == True:
+                        if self._port[ch].get_filament_detected() == False:
+                            self._set_channel_state(ch, FEED_STA_WAIT_INSERT)
+                        else:
+                            self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH)
+
+                else:
+                    try:
+                        # prepare
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_PREPARE, True)
+
+                        # home
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_HOMING)
+                            if self._check_homing_xy() != True:
+                                self.gcode.run_script_from_command("G28 X Y\r\n")
+                                self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE_HOME
+                            raise
+
+                        # switch extruder
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_PICKING)
+                            self.gcode.run_script_from_command("T%d A0\r\n" % (self.filament_ch[ch]))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE_SWITCH
+                            raise
+
+                        # move to dest position
+                        try:
+                            self.gcode.run_script_from_command("MOVE_TO_DISCARD_FILAMENT_POSITION\r\n")
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE
+                            raise
+
+                        # heat
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_HEATING)
+                            self.gcode.run_script_from_command("M109 S%d\r\n" % (filament_feed_temp))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_HEAT
+                            raise
+
+                        try:
+                            self._set_channel_state(ch, FEED_STA_UNLOAD_DOING)
+                            self.toolhead.wait_moves()
+                            self.gcode.run_script_from_command("INNER_FILAMENT_UNLOAD TEMP=%d SOFT=%d\r\n"
+                                                            % (filament_feed_temp, int(filament_soft)))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_CUSTOM_GCODE
+                            raise ValueError('custom gcode error!')
+
+                        self.toolhead.wait_moves()
+                        self.gcode.run_script_from_command("M104 S0\r\n")
+                        self.channel_error[ch] = FEED_OK
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_FINISH)
+
+                    except:
+                        self.toolhead.wait_moves()
+                        self.channel_error_state[ch] = self.channel_state[ch]
+                        self.gcode.run_script_from_command("M104 S0\r\n")
+                        if self.channel_error[ch] == FEED_OK:
+                            self.channel_error[ch] = FEED_ERR
+                        self._set_channel_state(ch, FEED_STA_UNLOAD_FAIL)
+                        raise
+
+            # manually feed
+            elif action == FEED_ACT_MANUAL_FEED:
+                self.exception_code[ch] = 90
+                if stage not in [FEED_MANUAL_STAGE_PREPARE, FEED_MANUAL_STAGE_EXTRUDE,
+                                 FEED_MANUAL_STAGE_FLUSH, FEED_MANUAL_STAGE_FINISH,
+                                 FEED_MANUAL_STAGE_CANCEL]:
+                    logging.error("[feed][manual] stage parameter error!\r\n")
+                    self.toolhead.wait_moves()
+                    self.channel_error[ch] = FEED_ERR_PARAMETER
+                    self._set_channel_state(ch, FEED_STA_MANUAL_FAIL)
+                    raise ValueError('parameter error!')
+
+                self.channel_error_state[ch] = FEED_STA_NONE
+                if stage == FEED_MANUAL_STAGE_PREPARE:
+                    try:
+                        self._set_channel_state(ch, FEED_STA_MANUAL_PREPARE, True)
+                        self.manual_feeding[ch] = True
+
+                        # home
+                        try:
+                            self._set_channel_state(ch, FEED_STA_MANUAL_HOMING)
+                            if self._check_homing_xy() != True:
+                                self.gcode.run_script_from_command("G28 X Y\r\n")
+                                self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE_HOME
+                            raise
+
+                        # switch extruder
+                        try:
+                            self._set_channel_state(ch, FEED_STA_MANUAL_PICKING)
+                            self.gcode.run_script_from_command("T%d A0\r\n" % (self.filament_ch[ch]))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_MOVE_SWITCH
+                            raise
+
+                        try:
+                            self.toolhead.wait_moves()
+                            self.gcode.run_script_from_command("INNER_MANUAL_FEED_STAGE_PREPARE\r\n")
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_CUSTOM_GCODE
+                            raise ValueError('custom gcode error!')
+
+                        self.channel_error[ch] = FEED_OK
+                        self._set_channel_state(ch, FEED_STA_MANUAL_PREPARE_FINISH)
+
+                    except:
+                        self.manual_feeding[ch] = False
+                        self.toolhead.wait_moves()
+                        self.channel_error_state[ch] = self.channel_state[ch]
+                        if self.channel_error[ch] == FEED_OK:
+                            self.channel_error[ch] = FEED_ERR
+                        self._set_channel_state(ch, FEED_STA_MANUAL_PREPARE_FAIL)
+                        raise
+
+                elif stage == FEED_MANUAL_STAGE_EXTRUDE:
+                    try:
+                        # heat
+                        try:
+                            self._set_channel_state(ch, FEED_STA_MANUAL_HEATING, True)
+                            self.gcode.run_script_from_command("M109 S%d\r\n" % (filament_feed_temp))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_HEAT
+                            raise
+
+                        # extrude
+                        try:
+                            self._set_channel_state(ch, FEED_STA_MANUAL_EXTRUDING)
+                            self.toolhead.wait_moves()
+                            self.gcode.run_script_from_command("INNER_MANUAL_FEED_STAGE_EXTRUDE TEMP=%d SOFT=%d\r\n" %
+                                                               (filament_feed_temp, int(filament_soft)))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_CUSTOM_GCODE
+                            raise ValueError('custom gcode error!')
+
+                        self.channel_error[ch] = FEED_OK
+                        self._set_channel_state(ch, FEED_STA_MANUAL_EXTRUDE_FINISH)
+
+                    except:
+                        self.toolhead.wait_moves()
+                        self.manual_feeding[ch] = False
+                        self.channel_error_state[ch] = self.channel_state[ch]
+                        if self.channel_error[ch] == FEED_OK:
+                            self.channel_error[ch] = FEED_ERR
+                        self._set_channel_state(ch, FEED_STA_MANUAL_EXTRUDE_FAIL)
+                        raise
+
+                elif stage == FEED_MANUAL_STAGE_FLUSH:
+                    try:
+                        # flush
+                        try:
+                            self.toolhead.wait_moves()
+                            self._set_channel_state(ch, FEED_STA_MANUAL_FLUSHING, True)
+                            self.gcode.run_script_from_command("INNER_MANUAL_FEED_STAGE_FLUSH TEMP=%d SOFT=%d\r\n" %
+                                                (filament_feed_temp, int(filament_soft)))
+                            self.toolhead.wait_moves()
+                        except:
+                            self.channel_error[ch] = FEED_ERR_CUSTOM_GCODE
+                            raise ValueError('custom gcode error!')
+
+                        self.channel_error[ch] = FEED_OK
+                        self._set_channel_state(ch, FEED_STA_MANUAL_FLUSH_FINISH)
+
+                    except:
+                        self.toolhead.wait_moves()
+                        self.manual_feeding[ch] = False
+                        self.channel_error_state[ch] = self.channel_state[ch]
+                        if self.channel_error[ch] == FEED_OK:
+                            self.channel_error[ch] = FEED_ERR
+                        self._set_channel_state(ch, FEED_STA_MANUAL_FLUSH_FAIL)
+                        raise
+
+                elif stage == FEED_MANUAL_STAGE_FINISH:
+                    self.manual_feeding[ch] = False
+                    try:
+                        self.toolhead.wait_moves()
+                        self.gcode.run_script_from_command("INNER_MANUAL_FEED_STAGE_FINISH\r\n")
+                        self.toolhead.wait_moves()
+                    except:
+                        logging.error("[feed][manual] stage: finish, gcode error\r\n")
+                        self._set_channel_state(ch, FEED_STA_MANUAL_FAIL)
+                        self.channel_error_state[ch] = self.channel_state[ch]
+                        raise
+                    self._set_channel_state(ch, FEED_STA_MANUAL_FINISH, True)
+                    # The delay here is for the convenience of updating the status to the client
+                    self.reactor.pause(self.reactor.monotonic() + 0.26)
+                    self._set_channel_state(ch, FEED_STA_LOAD_FINISH, True)
+
+                    if self.module_exist[ch] == True and self.config['auto_mode'][ch] == True:
+                        if self._port[ch].get_filament_detected() == False:
+                            self._set_channel_state(ch, FEED_STA_WAIT_INSERT)
+                        else:
+                            if self.runout_sensor[ch] is not None and \
+                                    self.runout_sensor[ch].get_status(0)['enabled'] == True and \
+                                    self.runout_sensor[ch].get_status(0)['filament_detected'] == True:
+                                self._set_channel_state(ch, FEED_STA_LOAD_FINISH, True)
+                            else:
+                                self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH)
+
+                elif stage == FEED_MANUAL_STAGE_CANCEL:
+                    self.manual_feeding[ch] = False
+                    try:
+                        self.toolhead.wait_moves()
+                        self.gcode.run_script_from_command("INNER_MANUAL_FEED_STAGE_CANCEL\r\n")
+                        self.toolhead.wait_moves()
+                    except:
+                        logging.error("[feed][manual] stage: cancel, gcode error!\r\n")
+                    self._set_channel_state(ch, FEED_STA_MANUAL_FAIL, True)
+                    self.channel_error_state[ch] = self.channel_state[ch]
+
+                    if self.module_exist[ch] == True and self.config['auto_mode'][ch] == True:
+                        if self._port[ch].get_filament_detected() == False:
+                            self._set_channel_state(ch, FEED_STA_WAIT_INSERT)
+                        else:
+                            self._set_channel_state(ch, FEED_STA_PRELOAD_FINISH)
+                else:
+                    logging.error("[feed][manual] stage parameter error!\r\n")
+
+        except:
+            raise
+
+        finally:
+            self.channel_active = None
+
+    def get_status(self, eventtime=None):
+        filament_detected = []
+        filament_detected.append(self._port[FEED_CHANNEL_1].get_filament_detected())
+        filament_detected.append(self._port[FEED_CHANNEL_2].get_filament_detected())
+
+        channel_1_dist = {
+            'module_exist': self.module_exist[FEED_CHANNEL_1],
+            'filament_detected': filament_detected[FEED_CHANNEL_1],
+            'disable_auto': not self.config['auto_mode'][FEED_CHANNEL_1],
+            'channel_state':self.channel_state[FEED_CHANNEL_1],
+            'channel_error':self.channel_error[FEED_CHANNEL_1],
+            'channel_error_state': self.channel_error_state[FEED_CHANNEL_1],
+            'channel_action_state': self.channel_action_state[FEED_CHANNEL_1]
+        }
+        channel_2_dist = {
+            'module_exist': self.module_exist[FEED_CHANNEL_2],
+            'filament_detected': filament_detected[FEED_CHANNEL_2],
+            'disable_auto': not self.config['auto_mode'][FEED_CHANNEL_2],
+            'channel_state':self.channel_state[FEED_CHANNEL_2],
+            'channel_error':self.channel_error[FEED_CHANNEL_2],
+            'channel_error_state': self.channel_error_state[FEED_CHANNEL_2],
+            'channel_action_state': self.channel_action_state[FEED_CHANNEL_2]
+        }
+
+        return {
+            f'extruder{self.filament_ch[FEED_CHANNEL_1]}': channel_1_dist,
+            f'extruder{self.filament_ch[FEED_CHANNEL_2]}': channel_2_dist}
+
+    def cmd_FEED_LIGHT(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+        index = gcmd.get('INDEX').upper()
+        value = gcmd.get_int('VALUE', minval=0, maxval=1)
+
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+
+        if not index in FEED_LIGHT_INDEXS:
+            raise gcmd.error("[feed] light index[%s] is error" % (index))
+
+        systime = self.reactor.monotonic()
+        systime += FEED_MIN_TIME
+        print_time = self.light[channel].get_mcu().estimated_print_time(systime)
+        self.light[channel].set_light_state(print_time, FEED_STA_TEST, index, value)
+        self._last_print_time = print_time
+
+    def cmd_FEED_PORT(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+
+        adc_value = self._port[channel].get_adc_value()
+        present = None
+        if (self._port[channel].get_filament_detected()):
+            present = "detected"
+        else:
+            present = "not detected"
+
+        msg = ("port[%d]: adc value = %f, filament: %s\n" % (
+                channel, adc_value, present))
+        gcmd.respond_info(msg, log=False)
+
+    def cmd_FEED_WHEEL_TACH(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+
+        msg = ( "rpm: %d\n"
+                "cnt: %d\n"
+                "rpm2: %d\n"
+                "cnt2: %d\n"
+                % ( self.wheel[channel].get_rpm(),
+                    self.wheel[channel].get_counts(),
+                    self.wheel_2[channel].get_rpm(),
+                    self.wheel_2[channel].get_counts()))
+        gcmd.respond_info(msg, log=False)
+
+    def cmd_FEED_MOTOR(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+        value = gcmd.get_float('VALUE')
+
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+
+        if channel == FEED_CHANNEL_1:
+            self.motor.run(FEED_MOTOR_DIR_A, value)
+        else:
+            self.motor.run(FEED_MOTOR_DIR_B, value)
+
+    def cmd_FEED_MOTOR_ONE_CYCLE(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+        value = gcmd.get_float('VALUE')
+        time = gcmd.get_float('TIME', self.motor_hang_neutral_time)
+
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+
+        if channel == FEED_CHANNEL_1:
+            self.motor.run_one_cycle(FEED_MOTOR_DIR_A, value, time)
+        else:
+            self.motor.run_one_cycle(FEED_MOTOR_DIR_B, value, time)
+
+    def cmd_FEED_MOTOR_TACH(self, gcmd):
+        msg = ( "rpm: %d\n"
+                "cnt: %d\n"
+                % ( self.motor_tachometer.get_rpm(),
+                    self.motor_tachometer.get_counts()))
+        gcmd.respond_info(msg, log=False)
+
+    def cmd_FEED_AUTO(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+        auto_mode = gcmd.get_int('AUTO', None)
+        if auto_mode is not None:
+            auto_mode = bool(auto_mode)
+        need_to_load = gcmd.get_int('LOAD', None)
+        if need_to_load is not None:
+            need_to_load = bool(need_to_load)
+        need_to_unload = gcmd.get_int('UNLOAD', None)
+        if need_to_unload is not None:
+            need_to_unload = bool(need_to_unload)
+        stage = gcmd.get('STAGE', None)
+        if stage is not None:
+            stage = stage.lower()
+        is_printing = gcmd.get_int('PRINTING', 0, minval=0, maxval=1)
+        need_save = gcmd.get_int('SAVE', 1, minval=0, maxval=1)
+
+        raw_msg = None
+        msg = None
+
+        logging.info("[feed] FEED_AUTO %s", gcmd.get_raw_command_parameters())
+        filament_entangle_detect = self.printer.lookup_object(
+                f'filament_entangle_detect e{self.filament_ch[channel]}_filament', None)
+        machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        if machine_state_manager is not None:
+            machine_sta = machine_state_manager.get_status()
+            if str(machine_sta["main_state"]) not in ["IDLE", "PRINTING", "AUTO_LOAD", "AUTO_UNLOAD" ]:
+                raise gcmd.error('[feed] channel[%d] machine main state error: %s\n'
+                                 % (channel, str(machine_sta["main_state"])))
+
+        if auto_mode is not None:
+            try:
+                self._do_feed(channel, FEED_ACT_UPDATE_AUTO_MODE, auto_mode=auto_mode)
+            except:
+                raise gcmd.error(
+                        message = '[feed] channel[%d]: set auto mode error \n' % (channel),
+                        action = 'none',
+                        id = 525,
+                        index = self.filament_ch[channel],
+                        code = 0,
+                        oneshot = 1,
+                        level = 2)
+
+            if need_save:
+                load_config = self.printer.load_snapmaker_config_file(self.config_path, FEED_DEFAULT_CONFIG)
+                load_config['auto_mode'] = self.config['auto_mode']
+                ret = self.printer.update_snapmaker_config_file(self.config_path, load_config, FEED_DEFAULT_CONFIG)
+                if not ret:
+                    logging.error("[feed] save auto_mode failed!")
+            return
+
+        if need_to_load == True:
+            if self.channel_state[channel] == FEED_STA_LOAD_FINISH and self.channel_error[channel] == FEED_OK:
+                return
+
+            if is_printing == 1 and self._port[channel].get_filament_detected() == False:
+                return
+
+            if self.module_exist[channel] == False or self.config['auto_mode'][channel] == False:
+                return
+
+            if self.runout_sensor[channel] is None or self.runout_sensor[channel].get_status(0)['enabled'] == False:
+                return
+
+            try:
+                if machine_state_manager is not None:
+                    machine_sta = machine_state_manager.get_status()
+                    if str(machine_sta["main_state"]) == "PRINTING":
+                        self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=PRINT_AUTO_FEEDING")
+                    else:
+                        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=AUTO_LOAD ACTION=AUTO_LOADING")
+                    self.toolhead.wait_moves()
+                if filament_entangle_detect is not None:
+                    filament_entangle_detect.skip_entangle_check(True)
+                self._do_feed(channel, FEED_ACT_LOAD)
+            except Exception as e:
+                raw_msg =  self.printer.extract_coded_message_field(str(e))
+                logging.error("[feed][load] channel[%d] auto load error: %s", channel, raw_msg)
+                if self._is_keep_raw_error_info(self.channel_error[channel]):
+                    raise
+            finally:
+                if filament_entangle_detect is not None:
+                    filament_entangle_detect.skip_entangle_check(False)
+                if machine_state_manager is not None:
+                    machine_sta = machine_state_manager.get_status()
+                    if str(machine_sta["main_state"]) == "PRINTING":
+                        self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+                    else:
+                        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE ACTION=IDLE")
+                    self.toolhead.wait_moves()
+
+            if self.channel_state[channel] != FEED_STA_LOAD_FINISH or self.channel_error[channel] != FEED_OK:
+                msg = 'extruder[%d]: state: %s, error: %s!' % (
+                        self.filament_ch[channel],
+                        self.channel_error_state[channel],
+                        self.channel_error[channel])
+                if raw_msg is not None:
+                    msg = msg + "raw msg:" + raw_msg
+
+                raise gcmd.error(
+                        message = msg,
+                        action = 'pause',
+                        id = 525,
+                        index = self.filament_ch[channel],
+                        code = self.exception_code[channel],
+                        oneshot = 1,
+                        level = 2)
+
+            return
+
+        if need_to_unload == True:
+            try:
+                if filament_entangle_detect is not None:
+                    filament_entangle_detect.skip_entangle_check(True)
+                if machine_state_manager is not None:
+                    machine_sta = machine_state_manager.get_status()
+                    if str(machine_sta["main_state"]) == "PRINTING":
+                        self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=PRINT_AUTO_UNLOADING")
+                    else:
+                        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=AUTO_UNLOAD ACTION=AUTO_UNLOADING")
+                self._do_feed(channel, FEED_ACT_UNLOAD, stage=stage)
+            except Exception as e:
+                if machine_state_manager is not None:
+                    machine_sta = machine_state_manager.get_status()
+                    if str(machine_sta["main_state"]) == "PRINTING":
+                        self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+                    else:
+                        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE ACTION=IDLE")
+                raw_msg =  self.printer.extract_coded_message_field(str(e))
+                logging.error("[feed][unload] channel[%d]: auto unload error: %s", channel, raw_msg)
+                if self._is_keep_raw_error_info(self.channel_error[channel]):
+                    raise
+            else:
+                # cancel or finish
+                if stage in [FEED_UNLOAD_STAGE_DOING, FEED_UNLOAD_STAGE_CANCEL]:
+                    if machine_state_manager is not None:
+                        machine_sta = machine_state_manager.get_status()
+                        if str(machine_sta["main_state"]) == "PRINTING":
+                            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+                        else:
+                            self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE ACTION=IDLE")
+            finally:
+                if filament_entangle_detect is not None:
+                    filament_entangle_detect.skip_entangle_check(False)
+
+            if self.channel_error[channel] != FEED_OK:
+                msg = 'extruder[%d]: state: %s, error: %s!' % (
+                        self.filament_ch[channel],
+                        self.channel_error_state[channel],
+                        self.channel_error[channel])
+                if raw_msg is not None:
+                    msg = msg + "raw msg:" + raw_msg
+
+                raise gcmd.error(
+                        message = msg,
+                        action = 'pause',
+                        id = 525,
+                        index = self.filament_ch[channel],
+                        code = self.exception_code[channel],
+                        oneshot = 1,
+                        level = 2)
+
+            return
+
+    def cmd_FEED_MANUAL(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed][manual_load] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+        stage = gcmd.get('STAGE').lower()
+        if stage not in [FEED_MANUAL_STAGE_PREPARE, FEED_MANUAL_STAGE_EXTRUDE,
+                         FEED_MANUAL_STAGE_FLUSH, FEED_MANUAL_STAGE_FINISH,
+                         FEED_MANUAL_STAGE_CANCEL]:
+            raise gcmd.error('[feed][manual_load] stage error: %s\n' % (stage))
+
+        raw_msg = None
+        msg = None
+
+        logging.info("[feed] FEED_MANUAL %s", gcmd.get_raw_command_parameters())
+
+        filament_entangle_detect = self.printer.lookup_object(
+                f'filament_entangle_detect e{self.filament_ch[channel]}_filament', None)
+        machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        if machine_state_manager is not None:
+            machine_sta = machine_state_manager.get_status()
+            if str(machine_sta["main_state"]) not in ["IDLE", "PRINTING", "MANUAL_LOAD"]:
+                raise gcmd.error('[feed][manual] channel[%d] machine main state error: %s\n'
+                                 % (channel, str(machine_sta["main_state"])))
+
+        try:
+            if filament_entangle_detect is not None:
+                filament_entangle_detect.skip_entangle_check(True)
+            if machine_state_manager is not None:
+                machine_sta = machine_state_manager.get_status()
+                if str(machine_sta["main_state"]) != "PRINTING":
+                    self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=MANUAL_LOAD ACTION=MANUAL_LOADING")
+            self._do_feed(channel, FEED_ACT_MANUAL_FEED, stage)
+        except Exception as e:
+            if machine_state_manager is not None:
+                machine_sta = machine_state_manager.get_status()
+                if str(machine_sta["main_state"]) != "PRINTING":
+                    self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE ACTION=IDLE")
+            raw_msg =  self.printer.extract_coded_message_field(str(e))
+            logging.error("[feed][manual] channel[%d]: manual load error: %s", channel, raw_msg)
+            if self._is_keep_raw_error_info(self.channel_error[channel]):
+                raise
+        else:
+            # cancel or finish
+            if stage in [FEED_MANUAL_STAGE_FINISH, FEED_MANUAL_STAGE_CANCEL]:
+                if machine_state_manager is not None:
+                    machine_sta = machine_state_manager.get_status()
+                    if str(machine_sta["main_state"]) != "PRINTING":
+                        self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE ACTION=IDLE")
+        finally:
+            if filament_entangle_detect is not None:
+                filament_entangle_detect.skip_entangle_check(False)
+
+        if self.channel_error[channel] != FEED_OK:
+            msg = 'extruder[%d]: state: %s, error: %s!' % (
+                    self.filament_ch[channel],
+                    self.channel_error_state[channel],
+                    self.channel_error[channel])
+            if raw_msg is not None:
+                msg = msg + "raw msg:" + raw_msg
+
+            raise gcmd.error(
+                    message = msg,
+                    action = 'pause',
+                    id = 525,
+                    index = self.filament_ch[channel],
+                    code = self.exception_code[channel],
+                    oneshot = 1,
+                    level = 2)
+    def cmd_FEED_RUNOUT_EVENT_HANDLE(self, gcmd):
+        channel = gcmd.get_int('CHANNEL')
+        if channel < 0 or channel >= FEED_CHANNEL_NUMS:
+            raise gcmd.error('[feed] channel[%d] is out of range[0,%d]\n' % (channel, FEED_CHANNEL_NUMS - 1))
+
+        self.toolhead.wait_moves()
+        try:
+            self._do_feed(channel, FEED_ACT_FILAMENT_RUNOUT)
+        except:
+            logging.error("[feed] channel[%d]: runout event handle error!", channel)
+
+def load_config_prefix(config):
+    return FilamentFeed(config)
+
--- /dev/null
+++ b/klippy/extras/filament_feed_fac_test.py
@@ -0,0 +1,302 @@
+import logging
+from . import pulse_counter
+
+TEST_STATE_IDLE                                 = 'idle'
+TEST_STATE_TESTING                              = 'testing'
+TEST_STATE_FAILED                               = 'failed'
+TEST_STATE_SUCCESSFUL                           = 'successful'
+
+FEED_MOTOR_DIR_IDLE                             = 0
+FEED_MOTOR_DIR_A                                = 1
+FEED_MOTOR_DIR_B                                = 2
+
+FEED_MOTOR_HARD_PROTECT_TIME                    = 2.5
+
+FEED_MIN_TIME                                   = 0.100
+
+class FeedTachometer:
+    def __init__(self, printer, pin, ppr, sample_time, poll_time):
+        self.frequence = pulse_counter.FrequencyCounter(printer, pin, sample_time, poll_time)
+        self.ppr = ppr
+
+    def get_rpm(self):
+        rpm = self.frequence.get_frequency()  * 30. / self.ppr
+        return rpm
+    
+    def get_counts(self):
+        return self.frequence.get_count() / 2
+    
+class FeedPwmCfg:
+    def __init__(self):
+        self.a_pin = None
+        self.b_pin = None
+        self.cycle_time = 0.010
+        self.max_value = 1.0
+
+class FeedMotor:
+    def __init__(self, printer, reactor, cfg:FeedPwmCfg):
+        self.reactor = reactor
+        ppins = printer.lookup_object('pins')
+        self.max_value = cfg.max_value
+        self._motor_a = ppins.setup_pin('pwm', cfg.a_pin)
+        self._motor_a.setup_max_duration(0.)
+        self._motor_a.setup_cycle_time(cfg.cycle_time, False)
+        self._motor_a.setup_start_value(0, 0)
+        self._motor_b = ppins.setup_pin('pwm', cfg.b_pin)
+        self._motor_b.setup_max_duration(0.)
+        self._motor_b.setup_cycle_time(cfg.cycle_time, False)
+        self._motor_b.setup_start_value(0, 0)
+        self._mutex_lock = False
+        self._dir = FEED_MOTOR_DIR_IDLE
+
+    def get_mcu(self):
+        return self._motor_a.get_mcu()
+    
+    def _run(self, dir, value):
+        systime = self.reactor.monotonic()
+        systime += FEED_MIN_TIME
+        print_time = self._motor_a.get_mcu().estimated_print_time(systime)
+        if FEED_MOTOR_DIR_A == dir:
+            self._motor_b.set_pwm(print_time, 0)
+            self._motor_a.set_pwm(print_time, value)
+        elif FEED_MOTOR_DIR_B == dir:
+            self._motor_a.set_pwm(print_time, 0)
+            self._motor_b.set_pwm(print_time, value)
+        else:
+            self._motor_b.set_pwm(print_time, 0)
+            self._motor_a.set_pwm(print_time, 0)
+
+    def _run_one_cycle(self, dir, value):
+        systime = self.reactor.monotonic()
+        systime += FEED_MIN_TIME
+        print_time = self._motor_a.get_mcu().estimated_print_time(systime)
+        if FEED_MOTOR_DIR_A == dir:
+            self._motor_b.set_pwm(print_time, 0)
+            self._motor_a.set_pwm(print_time, value)
+            self._motor_a.set_pwm(print_time + 0.01, 0)
+        elif FEED_MOTOR_DIR_B == dir:
+            self._motor_a.set_pwm(print_time, 0)
+            self._motor_b.set_pwm(print_time, value)
+            self._motor_b.set_pwm(print_time + 0.01, 0)
+    
+    def run(self, dir, value):
+        while self._mutex_lock:
+            self.reactor.pause(self.reactor.monotonic() + 0.1)
+        self._mutex_lock = True
+
+        val = max(0, min(self.max_value, value))
+        if val == 0:
+            dir = FEED_MOTOR_DIR_IDLE
+            
+        while 1:
+            if FEED_MOTOR_DIR_IDLE == self._dir:
+                if FEED_MOTOR_DIR_IDLE == dir:
+                    break
+                self._dir = dir
+                self._run(dir, val)
+                self.reactor.pause(self.reactor.monotonic() + 2 * FEED_MIN_TIME)
+            else:
+                if dir == self._dir:
+                    self._run(dir, val)
+                    self.reactor.pause(self.reactor.monotonic() + 2 * FEED_MIN_TIME)
+                else:
+                    self._run(FEED_MOTOR_DIR_IDLE, 0)
+                    self.reactor.pause(self.reactor.monotonic() + FEED_MOTOR_HARD_PROTECT_TIME)
+                    self._dir = FEED_MOTOR_DIR_IDLE
+                    if FEED_MOTOR_DIR_IDLE != dir:
+                        self._dir = dir
+                        self._run(dir, val)
+                        self.reactor.pause(self.reactor.monotonic() + 2 * FEED_MIN_TIME)
+            break
+        self._mutex_lock = False
+
+    def run_one_cycle(self, dir, value):
+        while self._mutex_lock:
+            self.reactor.pause(self.reactor.monotonic() + 0.1)
+        self._mutex_lock = True
+
+        val = max(0, min(self.max_value, value))
+        if val == 0:
+            dir = FEED_MOTOR_DIR_IDLE
+
+        while 1:
+            if FEED_MOTOR_DIR_IDLE == self._dir:
+                if FEED_MOTOR_DIR_IDLE == dir:
+                    break
+                self._dir = dir
+                self._run_one_cycle(dir, val)
+                self.reactor.pause(self.reactor.monotonic() + 2 * FEED_MIN_TIME)
+                self._dir = FEED_MOTOR_DIR_IDLE
+            else:
+                self._run(FEED_MOTOR_DIR_IDLE, 0)
+                self.reactor.pause(self.reactor.monotonic() + FEED_MOTOR_HARD_PROTECT_TIME)
+                self._dir = FEED_MOTOR_DIR_IDLE
+                if FEED_MOTOR_DIR_IDLE != dir:
+                    self._dir = dir
+                    self._run_one_cycle(dir, val)
+                    self.reactor.pause(self.reactor.monotonic() + 2 * FEED_MIN_TIME)
+                    self._dir = FEED_MOTOR_DIR_IDLE
+            break
+        self._mutex_lock = False
+
+
+class FeedFacTest:
+    def __init__(self, config) -> None:
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        gcode = self.printer.lookup_object('gcode')
+        self.module_name = config.get_name().split()[1]
+        ppins = self.printer.lookup_object('pins')
+        printer_buttons = self.printer.lookup_object('buttons')
+
+        self._test_state = TEST_STATE_IDLE
+
+        # Please confirm the order of input and output pins
+        # output pin
+        self._output_pin_list = []
+        self._output_pin_state = 0
+        tmp_pin = config.get('light_ch_1_white')
+        tmp_obj = ppins.setup_pin('digital_out', tmp_pin)
+        tmp_obj.setup_max_duration(0.)
+        self._output_pin_list.append(tmp_obj)
+        tmp_pin = config.get('light_ch_2_white')
+        tmp_obj = ppins.setup_pin('digital_out', tmp_pin)
+        tmp_obj.setup_max_duration(0.)
+        self._output_pin_list.append(tmp_obj)
+        tmp_pin = config.get('wheel_tach_ch_1_1_pin')
+        tmp_obj = ppins.setup_pin('digital_out', tmp_pin)
+        tmp_obj.setup_max_duration(0.)
+        self._output_pin_list.append(tmp_obj)
+        tmp_pin = config.get('wheel_tach_ch_2_1_pin')
+        tmp_obj = ppins.setup_pin('digital_out', tmp_pin)
+        tmp_obj.setup_max_duration(0.)
+        self._output_pin_list.append(tmp_obj)
+        tmp_pin = config.get('port_ch_1_pin')
+        tmp_obj = ppins.setup_pin('digital_out', tmp_pin)
+        tmp_obj.setup_max_duration(0.)
+        self._output_pin_list.append(tmp_obj)
+
+        # input pin
+        self._input_pin_state = 0
+        self._button_list = []
+        tmp_pin = config.get('light_ch_1_red')
+        self._button_list.append(tmp_pin)
+        tmp_pin = config.get('light_ch_2_red')
+        self._button_list.append(tmp_pin)
+        tmp_pin = config.get('wheel_tach_ch_1_2_pin')
+        self._button_list.append(tmp_pin)
+        tmp_pin = config.get('wheel_tach_ch_2_2_pin')
+        self._button_list.append(tmp_pin)
+        tmp_pin = config.get('port_ch_2_pin')
+        self._button_list.append(tmp_pin)
+        printer_buttons.register_buttons(self._button_list, self._button_handler)
+
+        # motor
+        self._rpm = 0
+        motor_cfg = FeedPwmCfg()
+        motor_cfg.a_pin = config.get('motor_ch_1_pin')
+        motor_cfg.b_pin = config.get('motor_ch_2_pin')
+        motor_cfg.cycle_time = config.getfloat('motor_cycle_time')
+        motor_cfg.max_value = config.getfloat('motor_max_value', maxval=1.0)
+        self.motor = FeedMotor(self.printer, self.reactor, motor_cfg)
+        # motor tachometer
+        tmp_pin = config.get('motor_tach_pin')
+        motor_tach_ppr = config.getint('motor_tach_ppr', 2, minval=1)
+        poll_time = config.getfloat('motor_tach_poll_interval', 0.0005, above=0.)
+        self.motor_tachometer = FeedTachometer(
+                                self.printer, 
+                                tmp_pin, 
+                                motor_tach_ppr,
+                                0.200, 
+                                poll_time)
+        self._motor_dest_rpm_min = config.getint('motor_dest_rpm_min')
+        self._motor_dest_rpm_max = config.getint('motor_dest_rpm_max')
+        
+        gcode.register_mux_command("FEED_FACTORY_TEST", "MODULE",
+                                self.module_name,
+                                self.cmd_FEED_FACTORY_TEST)
+    
+    def _button_handler(self, eventtime, state):
+        self._input_pin_state = state
+
+    def get_status(self, eventtime=None):
+        return {
+            'state': self._test_state,
+            'output_state': self._output_pin_state,
+            'input_state': self._input_pin_state,
+            'rpm': self._rpm}
+
+    def cmd_FEED_FACTORY_TEST(self, gcmd):
+        rpm_idle = 0
+        rpm_dir_a = 0
+        rpm_dir_b = 0
+
+        try:
+            self._test_state = TEST_STATE_TESTING
+
+            self._output_pin_state = 0
+            for i in range (len(self._output_pin_list)):
+                systime = self.reactor.monotonic()
+                systime += FEED_MIN_TIME
+                print_time = self._output_pin_list[i].get_mcu().estimated_print_time(systime)
+                if i % 2 == 0:
+                    self._output_pin_list[i].set_digital(print_time, 1)
+                    self._output_pin_state |= 1 << i
+                else:
+                    self._output_pin_list[i].set_digital(print_time, 0)
+
+            self.reactor.pause(self.reactor.monotonic() + 2 * FEED_MIN_TIME)
+            
+            if self._output_pin_state != self._input_pin_state:
+                raise
+
+            self._output_pin_state = 0
+            for i in range (len(self._output_pin_list)):
+                systime = self.reactor.monotonic()
+                systime += FEED_MIN_TIME
+                print_time = self._output_pin_list[i].get_mcu().estimated_print_time(systime)
+                if i % 2 == 0:
+                    self._output_pin_list[i].set_digital(print_time, 0)
+                else:
+                    self._output_pin_list[i].set_digital(print_time, 1)
+                    self._output_pin_state |= 1 << i
+
+            self.reactor.pause(self.reactor.monotonic() + 2 * FEED_MIN_TIME)
+            
+            if self._output_pin_state != self._input_pin_state:
+                raise
+
+            self.motor.run(FEED_MOTOR_DIR_A, 0.5)
+            self.reactor.pause(self.reactor.monotonic() + 0.5)
+            rpm_dir_a = self.motor_tachometer.get_rpm()
+            if self.motor_tachometer.get_rpm() < self._motor_dest_rpm_min or \
+                    self.motor_tachometer.get_rpm() > self._motor_dest_rpm_max:
+                raise
+
+            self.motor.run(FEED_MOTOR_DIR_B, 0.5)
+            self.reactor.pause(self.reactor.monotonic() + 0.5)
+            self._rpm = rpm_dir_b = self.motor_tachometer.get_rpm()
+            if self.motor_tachometer.get_rpm() < self._motor_dest_rpm_min or \
+                    self.motor_tachometer.get_rpm() > self._motor_dest_rpm_max:
+                raise
+
+            self.motor.run(FEED_MOTOR_DIR_IDLE, 0)
+            rpm_idle = self.motor_tachometer.get_rpm()
+            if self.motor_tachometer.get_rpm() > 0:
+                raise
+
+            self._test_state = TEST_STATE_SUCCESSFUL
+
+        except Exception as e:
+            self._test_state = TEST_STATE_FAILED
+            self.motor.run(FEED_MOTOR_DIR_IDLE, 0)
+
+        msg = ("filament_feed_fac_test: state = %s, output_state = 0x%X, input_state = 0x%X\r\n" 
+               "rpm_idle = %d, rpm_dir_a = %d, rpm_dir_b = %d\r\n" % (
+            self._test_state, self._output_pin_state, self._input_pin_state,
+            rpm_idle, rpm_dir_a, rpm_dir_b))
+        gcmd.respond_info(msg, log=False)
+
+def load_config_prefix(config):
+    return FeedFacTest(config)
+
--- a/klippy/extras/filament_motion_sensor.py
+++ b/klippy/extras/filament_motion_sensor.py
@@ -6,7 +6,7 @@
 import logging
 from . import filament_switch_sensor
 
-CHECK_RUNOUT_TIMEOUT = .250
+CHECK_RUNOUT_TIMEOUT = .100
 
 class EncoderSensor:
     def __init__(self, config):
@@ -18,7 +18,13 @@ class EncoderSensor:
                 'detection_length', 7., above=0.)
         # Configure pins
         buttons = self.printer.load_object(config, 'buttons')
-        buttons.register_buttons([switch_pin], self.encoder_event)
+        if config.get('analog_range', None) is None:
+            buttons.register_buttons([switch_pin], self.encoder_event)
+        else:
+            amin, amax = config.getfloatlist('analog_range', count=2)
+            pullup = config.getfloat('analog_pullup_resistor', 4700., above=0.)
+            buttons.register_adc_button(switch_pin, amin, amax, pullup, self.encoder_event)
+        # buttons.register_buttons([switch_pin], self.encoder_event)
         # Get printer objects
         self.reactor = self.printer.get_reactor()
         self.runout_helper = filament_switch_sensor.RunoutHelper(config)
@@ -27,21 +33,28 @@ class EncoderSensor:
         self.estimated_print_time = None
         # Initialise internal state
         self.filament_runout_pos = None
+        self.runout_buttun_state = False
+        self._extruder_pos_update_timer = None
         # Register commands and event handlers
         self.printer.register_event_handler('klippy:ready',
                 self._handle_ready)
-        self.printer.register_event_handler('idle_timeout:printing',
-                self._handle_printing)
+        # self.printer.register_event_handler('idle_timeout:printing',
+        #         self._handle_printing)
         self.printer.register_event_handler('idle_timeout:ready',
                 self._handle_not_printing)
         self.printer.register_event_handler('idle_timeout:idle',
                 self._handle_not_printing)
-    def _update_filament_runout_pos(self, eventtime=None):
+        self.printer.register_event_handler('print_stats:start',
+                self._handle_start_print_job)
+        self.printer.register_event_handler('print_stats:stop',
+                self._handle_stop_print_job)
+    def _update_filament_runout_pos(self, eventtime=None, fast_runout=False):
         if eventtime is None:
             eventtime = self.reactor.monotonic()
-        self.filament_runout_pos = (
-                self._get_extruder_pos(eventtime) +
-                self.detection_length)
+        if fast_runout:
+            self.filament_runout_pos = (self._get_extruder_pos(eventtime) + 0.2)
+        else:
+            self.filament_runout_pos = (self._get_extruder_pos(eventtime) + self.detection_length)
     def _handle_ready(self):
         self.extruder = self.printer.lookup_object(self.extruder_name)
         self.estimated_print_time = (
@@ -49,12 +62,18 @@ class EncoderSensor:
         self._update_filament_runout_pos()
         self._extruder_pos_update_timer = self.reactor.register_timer(
                 self._extruder_pos_update_event)
-    def _handle_printing(self, print_time):
-        self.reactor.update_timer(self._extruder_pos_update_timer,
-                self.reactor.NOW)
+    # def _handle_printing(self, print_time):
+    #     self.reactor.update_timer(self._extruder_pos_update_timer,
+    #             self.reactor.NOW)
     def _handle_not_printing(self, print_time):
         self.reactor.update_timer(self._extruder_pos_update_timer,
                 self.reactor.NEVER)
+    def _handle_start_print_job(self):
+        if self.runout_buttun_state == False:
+            self.reactor.update_timer(self._extruder_pos_update_timer, self.reactor.NOW)
+            self._update_filament_runout_pos(fast_runout=True)
+    def _handle_stop_print_job(self):
+        self.runout_helper.note_filament_present(self.runout_buttun_state, True)
     def _get_extruder_pos(self, eventtime=None):
         if eventtime is None:
             eventtime = self.reactor.monotonic()
@@ -63,15 +82,28 @@ class EncoderSensor:
     def _extruder_pos_update_event(self, eventtime):
         extruder_pos = self._get_extruder_pos(eventtime)
         # Check for filament runout
-        self.runout_helper.note_filament_present(
-                extruder_pos < self.filament_runout_pos)
+        is_runout = (extruder_pos >= self.filament_runout_pos)
+        if (is_runout):
+            self.runout_helper.note_filament_present(False, True)
+            return self.reactor.NEVER
         return eventtime + CHECK_RUNOUT_TIMEOUT
     def encoder_event(self, eventtime, state):
-        if self.extruder is not None:
-            self._update_filament_runout_pos(eventtime)
-            # Check for filament insertion
-            # Filament is always assumed to be present on an encoder event
-            self.runout_helper.note_filament_present(True)
+        self.runout_buttun_state = state
+        print_stats = self.printer.lookup_object('print_stats')
+        if print_stats.state == "printing":
+            if self.extruder is not None:
+                if state == True:
+                    self.reactor.update_timer(self._extruder_pos_update_timer,
+                            self.reactor.NEVER)
+                    self.runout_helper.note_filament_present(True)
+                else:
+                    self.reactor.update_timer(self._extruder_pos_update_timer,
+                            self.reactor.NOW)
+                    self._update_filament_runout_pos(eventtime)
+        else:
+            self.runout_helper.note_filament_present(state)
+            if self._extruder_pos_update_timer != None:
+                self.reactor.update_timer(self._extruder_pos_update_timer, self.reactor.NEVER)
 
 def load_config_prefix(config):
     return EncoderSensor(config)
--- /dev/null
+++ b/klippy/extras/filament_parameters.py
@@ -0,0 +1,495 @@
+import copy, os, logging
+
+FILAMENT_LOAD_TEMP_UNKNOWN                      = 250
+FILAMENT_UNLOAD_TEMP_UNKNOWN                    = 250
+FILAMENT_CLEAN_NOZZLE_TEMP_UNKNOWN              = 170
+FILAMENT_FLOW_TEMP_UNKNOWN                      = 220
+FILAMENT_FLOW_K_UNKNOWN                         = 0.02
+FILAMENT_FLOW_SLOW_V_UNKNOWN                    = 0.8
+FILAMENT_FLOW_FAST_V_UNKNOWN                    = 8.0
+FILAMENT_FLOW_K_MIN_UNKNOWN                     = 0.005
+FILAMENT_FLOW_K_MAX_UNKNOWN                     = 0.065
+FILAMENT_IS_SOFT_UNKNOWN                        = False
+FILAMENT_PARAMETER_VERSION                      = '0.0.5'
+
+FILAMENT_PARA_CFG_FILE                          = 'filament_parameters.json'
+FILAMENT_PARA_CFG_DEFAULT = {
+    'version': '0.0.4',
+    'PLA': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 170,
+                'is_soft': False,
+                'flow_temp': 220,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.012,
+                'flow_k_max': 0.028,
+            },
+        },
+        'vendor_Snapmaker': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 170,
+                'is_soft': False,
+                'flow_temp': 220,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.012,
+                'flow_k_max': 0.028,
+            },
+        },
+        'vendor_Polymaker': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 170,
+                'is_soft': False,
+                'flow_temp': 220,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.012,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'PLA-CF': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 170,
+                'is_soft': False,
+                'flow_temp': 220,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.012,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'TPU': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': True,
+                'flow_temp': 240,
+                'flow_k': 0.28,
+                'flow_slow_v': 0.4,
+                'flow_fast_v': 1.8,
+                'flow_k_min': 0.20,
+                'flow_k_max': 0.36,
+            },
+        },
+        'vendor_Snapmaker': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': True,
+                'flow_temp': 240,
+                'flow_k': 0.28,
+                'flow_slow_v': 0.4,
+                'flow_fast_v': 1.8,
+                'flow_k_min': 0.20,
+                'flow_k_max': 0.36,
+            },
+        },
+    },
+    'PETG': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': False,
+                'flow_temp': 255,
+                'flow_k': 0.04,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.02,
+                'flow_k_max': 0.06,
+            },
+            'sub_HF': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': False,
+                'flow_temp': 255,
+                'flow_k': 0.025,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.013,
+                'flow_k_max': 0.037,
+            },
+        },
+        'vendor_Snapmaker': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': False,
+                'flow_temp': 255,
+                'flow_k': 0.05,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.038,
+                'flow_k_max': 0.062,
+            },
+        },
+        'vendor_Polymaker': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': False,
+                'flow_temp': 255,
+                'flow_k': 0.05,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.038,
+                'flow_k_max': 0.062,
+            },
+        },
+    },
+    'PETG-CF': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': False,
+                'flow_temp': 255,
+                'flow_k': 0.025,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.013,
+                'flow_k_max': 0.037,
+            },
+        },
+    },
+    'PETG-HF': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': False,
+                'flow_temp': 255,
+                'flow_k': 0.025,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.013,
+                'flow_k_max': 0.037,
+            },
+        },
+    },
+    'PCTG': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 200,
+                'is_soft': False,
+                'flow_temp': 255,
+                'flow_k': 0.04,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.02,
+                'flow_k_max': 0.06,
+            },
+        },
+    },
+    'EVA': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 160,
+                'is_soft': True,
+                'flow_temp': 210,
+                'flow_k': 0.28,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 5.0,
+                'flow_k_min': 0.20,
+                'flow_k_max': 0.36,
+            },
+        },
+    },
+    'ABS': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 220,
+                'is_soft': False,
+                'flow_temp': 265,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.012,
+                'flow_k_max': 0.028,
+            },
+        },
+        'vendor_Snapmaker': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 220,
+                'is_soft': False,
+                'flow_temp': 265,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.005,
+                'flow_k_max': 0.065,
+            },
+        },
+        'vendor_Polymaker': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 220,
+                'is_soft': False,
+                'flow_temp': 265,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.012,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'ASA': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 250,
+                'unload_temp': 250,
+                'clean_nozzle_temp': 220,
+                'is_soft': False,
+                'flow_temp': 260,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.012,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'PA': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 300,
+                'unload_temp': 300,
+                'clean_nozzle_temp': 220,
+                'is_soft': False,
+                'flow_temp': 250,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.01,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'PA-CF': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 300,
+                'unload_temp': 300,
+                'clean_nozzle_temp': 240,
+                'is_soft': False,
+                'flow_temp': 250,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.01,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'PA6-CF': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 300,
+                'unload_temp': 300,
+                'clean_nozzle_temp': 240,
+                'is_soft': False,
+                'flow_temp': 250,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.01,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'PA-GF': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 300,
+                'unload_temp': 300,
+                'clean_nozzle_temp': 240,
+                'is_soft': False,
+                'flow_temp': 250,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.01,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'PA6-GF': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 300,
+                'unload_temp': 300,
+                'clean_nozzle_temp': 240,
+                'is_soft': False,
+                'flow_temp': 250,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.01,
+                'flow_k_max': 0.028,
+            },
+        },
+    },
+    'PC': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 300,
+                'unload_temp': 300,
+                'clean_nozzle_temp': 220,
+                'is_soft': False,
+                'flow_temp': 280,
+                'flow_k': 0.025,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.017,
+                'flow_k_max': 0.033,
+            },
+        },
+    },
+    'PC-ABS': {
+        'vendor_generic': {
+            'sub_generic': {
+                'load_temp': 300,
+                'unload_temp': 300,
+                'clean_nozzle_temp': 220,
+                'is_soft': False,
+                'flow_temp': 270,
+                'flow_k': 0.02,
+                'flow_slow_v': 0.8,
+                'flow_fast_v': 8.0,
+                'flow_k_min': 0.005,
+                'flow_k_max': 0.065,
+            },
+        },
+    },
+}
+
+FILAMENT_PARA_CFG_UNKNOWN = {
+    'load_temp': FILAMENT_LOAD_TEMP_UNKNOWN,
+    'unload_temp': FILAMENT_UNLOAD_TEMP_UNKNOWN,
+    'clean_nozzle_temp': FILAMENT_CLEAN_NOZZLE_TEMP_UNKNOWN,
+    'is_soft': FILAMENT_IS_SOFT_UNKNOWN,
+    'flow_temp': FILAMENT_FLOW_TEMP_UNKNOWN,
+    'flow_k': FILAMENT_FLOW_K_UNKNOWN,
+    'flow_slow_v': FILAMENT_FLOW_SLOW_V_UNKNOWN,
+    'flow_fast_v': FILAMENT_FLOW_FAST_V_UNKNOWN,
+    'flow_k_min': FILAMENT_FLOW_K_MIN_UNKNOWN,
+    'flow_k_max': FILAMENT_FLOW_K_MAX_UNKNOWN,
+}
+
+class FilamentParameters:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = FILAMENT_PARA_CFG_FILE
+        self._config_path = os.path.join(config_dir, config_name)
+        self._config = self.printer.load_snapmaker_config_file(
+                            self._config_path,
+                            FILAMENT_PARA_CFG_DEFAULT,
+                            create_if_not_exist=True)
+
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_command('FILAMENT_PARA_GET_ALL_INFO',
+                               self.cmd_FILAMENT_PARA_GET_ALL_INFO)
+        self.printer.register_event_handler("klippy:ready", self._ready)
+
+    def _ready(self):
+        version = self._config.get('version', None)
+        if version != FILAMENT_PARAMETER_VERSION:
+            self.reset_parameters()
+
+
+    def get_status(self, eventtime=None):
+        return copy.deepcopy(self._config)
+
+    def get_filament_parameters(self, filament_vendor, filament_main_type, filament_sub_type):
+        main_type = None
+        vendor = None
+        sub_type = None
+        try:
+            main_type = self._config.get(filament_main_type)
+            vendor = main_type.get('vendor_' + filament_vendor, None)
+            if vendor == None:
+                vendor = main_type.get('vendor_generic')
+            sub_type = vendor.get('sub_' + filament_sub_type, None)
+            if sub_type == None:
+                sub_type = vendor.get('sub_generic')
+        except:
+            pass
+
+        if main_type == None or vendor == None or sub_type == None:
+            return FILAMENT_PARA_CFG_UNKNOWN
+        else:
+            return sub_type
+    def get_load_temp(self, filament_vendor, filament_main_type, filament_sub_type):
+        parameter = self.get_filament_parameters(filament_vendor, filament_main_type, filament_sub_type)
+        return parameter.get('load_temp', FILAMENT_LOAD_TEMP_UNKNOWN)
+
+    def get_unload_temp(self, filament_vendor, filament_main_type, filament_sub_type):
+        parameter = self.get_filament_parameters(filament_vendor, filament_main_type, filament_sub_type)
+        return parameter.get('unload_temp', FILAMENT_UNLOAD_TEMP_UNKNOWN)
+
+    def get_clean_nozzle_temp(self, filament_vendor, filament_main_type, filament_sub_type):
+        parameter = self.get_filament_parameters(filament_vendor, filament_main_type, filament_sub_type)
+        return parameter.get('clean_nozzle_temp', FILAMENT_CLEAN_NOZZLE_TEMP_UNKNOWN)
+
+    def get_flow_temp(self, filament_vendor, filament_main_type, filament_sub_type):
+        parameter = self.get_filament_parameters(filament_vendor, filament_main_type, filament_sub_type)
+        return parameter.get('flow_temp', FILAMENT_FLOW_TEMP_UNKNOWN)
+
+    def get_flow_k(self, filament_vendor, filament_main_type, filament_sub_type):
+        parameter = self.get_filament_parameters(filament_vendor, filament_main_type, filament_sub_type)
+        return parameter.get('flow_k', FILAMENT_FLOW_K_UNKNOWN)
+
+    def get_is_soft(self, filament_vendor, filament_main_type, filament_sub_type):
+        parameter = self.get_filament_parameters(filament_vendor, filament_main_type, filament_sub_type)
+        return parameter.get('is_soft', FILAMENT_IS_SOFT_UNKNOWN)
+
+    def reset_parameters(self):
+        self._config = copy.deepcopy(FILAMENT_PARA_CFG_DEFAULT)
+        self._config['version'] = FILAMENT_PARAMETER_VERSION
+        self.printer.update_snapmaker_config_file(self._config_path, self._config, FILAMENT_PARA_CFG_DEFAULT)
+        logging.info("[filament_parameters] reset filament parameters")
+
+    def cmd_FILAMENT_PARA_GET_ALL_INFO(self, gcmd):
+        gcmd.respond_info(str(self._config))
+
+def load_config(config):
+    return FilamentParameters(config)
+
--- /dev/null
+++ b/klippy/extras/filament_protocol.py
@@ -0,0 +1,427 @@
+import copy
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import padding
+from cryptography.hazmat.backends import default_backend
+from cryptography.exceptions import InvalidSignature
+
+FILAMENT_INFO_STRUCT = {
+    'VERSION': 0,
+    'VENDOR': 'NONE', # Brand Owner
+    'MANUFACTURER': 'NONE',
+    'MAIN_TYPE': 'NONE',
+    'SUB_TYPE': 'NONE',
+    'TRAY': 0,
+    'ALPHA': 0xFF,
+    'COLOR_NUMS': 1,
+    'ARGB_COLOR': 0xFFFFFFFF, # Old version
+    'RGB_1': 0xFFFFFF,
+    'RGB_2': 0,
+    'RGB_3': 0,
+    'RGB_4': 0,
+    'RGB_5': 0,
+    'DIAMETER': 0,
+    'WEIGHT': 0,
+    'LENGTH': 0,
+    'DRYING_TEMP': 0,
+    'DRYING_TIME': 0,
+    'HOTEND_MAX_TEMP': 0,
+    'HOTEND_MIN_TEMP': 0,
+    'BED_TYPE': 0,
+    'BED_TEMP': 0,
+    'FIRST_LAYER_TEMP': 0,
+    'OTHER_LAYER_TEMP': 0,
+    'SKU': 0,
+    'MF_DATE': '19700101',
+    'RSA_KEY_VERSION': 0,
+    'OFFICIAL': False,
+    'CARD_UID': 0,
+}
+
+# Filament main type
+FILAMENT_PROTO_MAIN_TYPE_RESERVED               = 0
+FILAMENT_PROTO_MAIN_TYPE_PLA                    = 1
+FILAMENT_PROTO_MAIN_TYPE_PETG                   = 2
+FILAMENT_PROTO_MAIN_TYPE_ABS                    = 3
+FILAMENT_PROTO_MAIN_TYPE_TPU                    = 4
+FILAMENT_PROTO_MAIN_TYPE_PVA                    = 5
+
+FILAMENT_PROTO_MAIN_TYPE_MAPPING = {
+    "PLA":          FILAMENT_PROTO_MAIN_TYPE_PLA,
+    "PETG":         FILAMENT_PROTO_MAIN_TYPE_PETG,
+    "ABS":          FILAMENT_PROTO_MAIN_TYPE_ABS,
+    "TPU":          FILAMENT_PROTO_MAIN_TYPE_TPU,
+    "PVA":          FILAMENT_PROTO_MAIN_TYPE_PVA,
+    "Reserved":     FILAMENT_PROTO_MAIN_TYPE_RESERVED
+}
+
+#Filament sub type
+FILAMENT_PROTO_SUB_TYPE_RESERVED                = 0
+FILAMENT_PROTO_SUB_TYPE_BASIC                   = 1
+FILAMENT_PROTO_SUB_TYPE_MATTE                   = 2
+FILAMENT_PROTO_SUB_TYPE_SNAPSPEED               = 3
+
+FILAMENT_PROTO_SUB_TYPE_MAPPING = {
+    'Basic':        FILAMENT_PROTO_SUB_TYPE_BASIC,
+    'Matte':        FILAMENT_PROTO_SUB_TYPE_MATTE,
+    'SnapSpeed':    FILAMENT_PROTO_SUB_TYPE_SNAPSPEED,
+    'Reserved':     FILAMENT_PROTO_SUB_TYPE_RESERVED
+}
+
+# Filament color nums
+FILAMENT_PROTO_COLOR_NUMS_MAX                   = 5
+
+# Filament Tag type
+FILAMENT_PROTO_TAG_M1                           = 'M1_1K'
+
+# M1 card protocol
+M1_PROTO_TOTAL_SIZE                             = 1024
+## position : section_num * 64 + block_nom * 16 + byte_num
+# Section 0
+M1_PROTO_UID_POS                                = (0 * 64 + 0 * 16 + 0)
+M1_PROTO_UID_LEN                                = (4)
+M1_PROTO_VENDOR_POS                             = (0 * 64 + 1 * 16 + 0)
+M1_PROTO_VENDOR_LEN                             = (16)
+M1_PROTO_MANUFACTURER_POS                       = (0 * 64 + 2 * 16 + 0)
+M1_PROTO_MANUFACTURER_LEN                       = (16)
+# Section 1
+M1_PROTO_VERSION_POS                            = (1 * 64 + 0 * 16 + 0)
+M1_PROTO_VERSION_LEN                            = (2)
+M1_PROTO_MAIN_TYPE_POS                          = (1 * 64 + 0 * 16 + 2)
+M1_PROTO_MAIN_TYPE_LEN                          = (2)
+M1_PROTO_SUB_TYPE_POS                           = (1 * 64 + 0 * 16 + 4)
+M1_PROTO_SUB_TYPE_LEN                           = (2)
+M1_PROTO_TRAY_POS                               = (1 * 64 + 0 * 16 + 6)
+M1_PROTO_TRAY_LEN                               = (2)
+M1_PROTO_COLOR_NUMS_POS                         = (1 * 64 + 0 * 16 + 8)
+M1_PROTO_COLOR_NUMS_LEN                         = (1)
+M1_PROTO_ALPHA_POS                              = (1 * 64 + 0 * 16 + 9)
+M1_PROTO_ALPHA_LEN                              = (1)
+M1_PROTO_RGB_1_POS                              = (1 * 64 + 1 * 16 + 0)
+M1_PROTO_RGB_1_LEN                              = (3)
+M1_PROTO_RGB_2_POS                              = (1 * 64 + 1 * 16 + 3)
+M1_PROTO_RGB_2_LEN                              = (3)
+M1_PROTO_RGB_3_POS                              = (1 * 64 + 1 * 16 + 6)
+M1_PROTO_RGB_3_LEN                              = (3)
+M1_PROTO_RGB_4_POS                              = (1 * 64 + 1 * 16 + 9)
+M1_PROTO_RGB_4_LEN                              = (3)
+M1_PROTO_RGB_5_POS                              = (1 * 64 + 1 * 16 + 12)
+M1_PROTO_RGB_5_LEN                              = (3)
+M1_PROTO_SKU_POS                                = (1 * 64 + 2 * 16 + 0)
+M1_PROTO_SKU_LEN                                = (4)
+# Section 2
+M1_PROTO_DIAMETER_POS                           =( 2 * 64 + 0 * 16 + 0)
+M1_PROTO_DIAMETER_LEN                           = (2)
+M1_PROTO_WEIGHT_POS                             = (2 * 64 + 0 * 16 + 2)
+M1_PROTO_WEIGHT_LEN                             = (2)
+M1_PROTO_LENGTH_POS                             = (2 * 64 + 0 * 16 + 4)
+M1_PROTO_LENGTH_LEN                             = (2)
+M1_PROTO_DRY_TEMP_POS                           = (2 * 64 + 1 * 16 + 0)
+M1_PROTO_DRY_TEMP_LEN                           = (2)
+M1_PROTO_DRY_TIME_POS                           = (2 * 64 + 1 * 16 + 2)
+M1_PROTO_DRY_TIME_LEN                           = (2)
+M1_PROTO_HOTEND_MAX_TEMP_POS                    = (2 * 64 + 1 * 16 + 4)
+M1_PROTO_HOTEND_MAX_TEMP_LEN                    = (2)
+M1_PROTO_HOTEND_MIN_TEMP_POS                    = (2 * 64 + 1 * 16 + 6)
+M1_PROTO_HOTEND_MIN_TEMP_LEN                    = (2)
+M1_PROTO_BED_TYPE_POS                           = (2 * 64 + 1 * 16 + 8)
+M1_PROTO_BED_TYPE_LEN                           = (2)
+M1_PROTO_BED_TEMP_POS                           = (2 * 64 + 1 * 16 + 10)
+M1_PROTO_BED_TEMP_LEN                           = (2)
+M1_PROTO_FIRST_LAYER_TEMP_POS                   = (2 * 64 + 1 * 16 + 12)
+M1_PROTO_FIRST_LAYER_TEMP_LEN                   = (2)
+M1_PROTO_OTHER_LAYER_TEMP_POS                   = (2 * 64 + 1 * 16 + 14)
+M1_PROTO_OTHER_LAYER_TEMP_LEN                   = (2)
+M1_PROTO_MF_DATE_POS                            = (2 * 64 + 2 * 16 + 0)
+M1_PROTO_MF_DATE_LEN                            = (8)
+M1_PROTO_RSA_KEY_VER_POS                        = (2 * 64 + 2 * 16 + 8)
+M1_PROTO_RSA_KEY_VER_LEN                        = 2
+
+# ERROR CODE
+FILAMENT_PROTO_OK                               = 0
+FILAMENT_PROTO_ERR                              = -1
+FILAMENT_PROTO_PARAMETER_ERR                    = -2
+FILAMENT_PROTO_RSA_KEY_VER_ERR                  = -3
+FILAMENT_PROTO_SIGN_CHECK_ERR                   = -4
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_0 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8oEF7YuKO863TbUxnrvY
+H1JFrvCnMapm8Ho952KlfNWbf6IEDMlX6QJpBuvUkrkjWpLJJQurIWL3KFeLUhCh
+POrYdiGrdsUlp4YO037iLSlgmzo1dUdgbawAcGox1PvR/Naw5ADibubO2rN49WQR
++BkxxigvoWHSFetaoMCswQ5B/niq3byhzktgmWOcv71F4yFwcxivF8R+s0gSBL4i
+/1zNeSUZkbvP4/T0B08i3D+e6fl9xpCnINZ3P9OWcx+p3SB2o4TdmAeKV4hkT9n7
+o+/OWr92fx6qbiNKJr04oMhrRsFK6w7hitp2n8RGS64w9lhtplnBgxtbgxAYyUnp
+qwIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_1 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8nbtQNABbc5PkyzI0A5m
+VH/E8y23Wld0iykvTOoBYJOrPwJDmXsnSyyX84Nv6voSr8FYv3Fb2SqSdOgQLFqp
+BXvntXew8rPpq5Ll8gSzLRxE1VmEOVtZWCTJ4Wxwwi79rrFmpa/nAtUeYZIGiiud
+w2MzCHXW5G3c1FWhQ0C8vUUMfBQXmGnoHGsul6R8xld6CDCWY8ia/FvfR+KCtMRn
+VYyYguYsq4rODWJHiFCOef4FZconUR3RTh0ojvq78CsHk94goxidWzZoKcVnvWhh
+bOixTjU37W4JDECEOui3ObMMvJkzxkZo1irlAH7jTiPqhP94U/JbRDpBlHOOn67b
+GQIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_2 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxZQPYewwMFaPlcEHq+SH
+QS1C1NhVmAaY56qxLyHJ4aNc2iWdCx4/9ZKY4CL6xkeCD88Zndv/xzImplRdoAzo
+whD47Vm4iuq8+NqHUI8na6ISd+MZ/O6/eo/ggaEZBX8lR+Yf0qfWtntsI9flUOoJ
+mq1IXvNXqOxflUmPyffT40QSkAN4Rr3scB3ozlxuJZehWM/lUmZ1H5PQDwAqsM0T
+Rj6ChzVmUbSvwEvbDTwpXkpMA0C5//OW0T//IKDEBYxEl928vYbraLRDRIetgdaD
+o+77+ztfOv4AyP/ipikprHwIWi7yga5KUXq/XpNPy6cPISZD+/LBUJBxLELspREP
+rQIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_3 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvK8cJyeFeTkFgkSLCCAg
+EgR9KAvIHmvK8CRdtn+W6PiIbN04MFIg8jiYW/3fq+AcBFFMo+HtR2gym8JNVx2I
+RDI4WdfbR/0gaIHjOQ41OwlXmqqSkDsFmjxVI6bDRZYpHkOfkC+9Vi1Aii4l/Yq9
+O7s+2j4zP9GoUWWJPb3mW07Vu+EnHB/XIuaoDJVQAS+ov3xTotCeKdcdgySnNP5g
+kOvWUvWtwNQldCRcQ0eo3j5RO+4J4IRK2J8q7BrdV/gbJUE/BBPIOuURPLzNJJO3
+wgx4PEwlb5uYEUL35ARL7NzL8ZOxebzs5H4tXuWrBhALw6O33Tfg3TmTmwR2JUpv
+7QIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_4 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvafhk7Bdb3F+5B9w7YXv
+chrNzl09QkZc27NLxL0ViRitGQhX9KC/xVg+XkBGI8XfioAwYkJ3jYgwmci5gJOL
+ofPyNXcFtvtzq2NZNuDZY26krrXLORhS1o8ue92RB2gM92Rc2heWVrsvLycNl2Qz
+OUjUEGmWpSMo98xIsgkTZJ4aYxWVN86yqknOcHVpTmcr5SBRB90K9hTRtsaMD97O
+FYVc7AA/TGwqFJOnXXzWczWtg7kUY2vqCHwsvKs3G/EIFKOIe1n37V94OcxHTySC
+co9Kc6Y0bGFIwIruinH1WkFVt6TAzo+0ZdZy5Sq493AG9y1RZ5nYj5qUmc1PMmrD
+gwIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_5 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxWdxd7qeouSFbZ2Sldv3
+apDrgAupOYiDRkO85C+qkZaezOzqW0EsOV0x7nG/smw++TRfHyGIK4gXCdg1JfNR
+WYjqckRdnLYMzGdDk24VV5Bbrsgska0v0Oy1ucz3CYu+F22ais00OqK0MY0B96MI
+/B/0pRSTAIyxvC6LjhHy8DYyPdqNF9EMikKfAfcn7ytsH1PoSSGVtrZqyNe5OLrW
+yAw+FQsTg/VFJcYxPTQJ1ymwQmDCdKgApe3PVajyYswoIA7R0S8ujau0aAFEO3dU
+GDEwjOnaHfwFlg3OKMFJTxc2sl/WEB8xtWuKl0Guf0VnzWJ6noxqf/DiaN1fuHG0
+AwIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_6 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqF+YJNHLHC6c25oTDgNg
+liahUxWBPSkgght1/gJu5vBRDKWEn6i/RuKAFdTOsH+Hlvr5qWms7bBUHx78UMF+
+FF1Nq9tb4jhFuqq4HWsBBjNnU6O0JhFTjKJU2nudmphXlpdLQfcKSIYMQe795GHL
+izh8WsNTcTHNNBkjhi7y4c4RUqnJso0L6vrf0B3EB/9DDUJitrwfw+1/OrKOEVEP
+624sEa802cHfb+BG9zKBXjFwzYCYF9gWey9yeA3UA7EYmPpqA1lqNv8m0r7YjZ4n
+uGBDjs+AXaGtdqrW3IUtkUF2vWwNSRncbcXi3mNfzslrtPhsDVAFki4vDSw7yNht
+2wIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_7 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuKWRCTTgxPltfflWHdhu
+2ITxWC/LTEl7OtatNWFhMFQZF2J5SN/45bjH6xIPTcDglTSl2/UMC1D/ugiq+j0z
+dGSdE7xn3ZSzLTMCwgRkvXmd8aQgafBYbB7E6oAgus+6lRXZPwnMfZAe0yaJNHyt
+1Wd8ZUlRY7BHSPPtmG1liVEzxoTb6urB6mK49r24+oC7xa65q5NSdlZWSTeaK4Xt
+DVVDiwe+uubNTm59KnVAKgBMNd3qN942pH6fo/dBz++BzJVEG/qJewHUTGZAeIl+
+CgqhSEbmEIgolsDgaKY99ZWa2FWJdo+ohYhmjc92TyB9kWw6yIwez+tlRUkssLGt
+SwIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_8 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt7XOTs6P2xB8v8/xWVdR
+wVefphRDXSuv74RObtr0pwLTc7BytkcDw8r60BNPv9hGDpW2S1szxqS8x4EaOHP7
+81qNpIUULlUdXxty1RvpSdfRb044kpwl7A/s4OEakkyJZF1ed+Qte1FqOFDDIZ+l
+g+Co8FjOwWixoSyIlR22mEP7r6Y98GL5tnSohkVoGAgEipswWb6549mssjZmES+J
+hB0axY6Dl/LlDYxN6jjUZwSIo7bw0GXGm9ScW2qTVaT1m2A9etpD6OIG+iQVLQqP
+whVBs5q0o/EM4nBN88RBsF2OmfkcZPJ2NdX6o3qx+pCZ9NDgkHjGDZdnGEnM5Lu2
+dwIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+FILAMENT_PROTO_RSA_PUBLIC_KEY_9 = b"""
+-----BEGIN RSA PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz/d5C5FpqlcF7NbUEvBN
+fiDJWH0BF63PEwHPiX+cS6l+q4NqqYI167u1pGkZGJV1njgGYFTM08x2KO7/bk6o
+CWcGuKWNM8Tp1+tv3XioNGVCnIpHmdUx5F9qcXlPtDx74wQk/+JZLQ/sLnLvHcV3
+YTaz55fpyzVUHkgXusdVynSyAt3ywWWQRcjp3sspGa/udC0j6LCvrzqLACv3gMGA
+Id0b6REzjSn03UzkwBIwSb8DszieeNhaCOK4M/TxPFNyrhQRYcAvhiZJu+tylqJs
+VP+gaWFvElFeFkxcHvYXHdJPlJLjYeT51hm/pdll26yYLhpeBa0inHwSqv4D3jFZ
+PQIDAQAB
+-----END RSA PUBLIC KEY-----"""
+
+
+def get_key_by_value(dict_obj, value):
+    for key, val in dict_obj.items():
+        if val == value:
+            return key
+    return None
+
+def verify_signature_pkcs1(public_key, data, signature):
+    try:
+        public_key = serialization.load_pem_public_key(public_key, backend=default_backend())
+        public_key.verify(
+            signature,
+            data,
+            padding.PKCS1v15(),
+            hashes.SHA256()
+        )
+        return True
+    except InvalidSignature:
+        return False
+
+def m1_proto_data_parse(data_buf):
+    if (None == data_buf or isinstance(data_buf, list) == False) or\
+            len(data_buf) != M1_PROTO_TOTAL_SIZE:
+        return FILAMENT_PROTO_PARAMETER_ERR, None
+
+    rsa_ver = data_buf[M1_PROTO_RSA_KEY_VER_POS : M1_PROTO_RSA_KEY_VER_POS + M1_PROTO_RSA_KEY_VER_LEN]
+    rsa_ver = (rsa_ver[1] << 8) | (rsa_ver[0])
+    rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_0
+    if rsa_ver == 0:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_0
+    elif rsa_ver == 1:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_1
+    elif rsa_ver == 2:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_2
+    elif rsa_ver == 3:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_3
+    elif rsa_ver == 4:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_4
+    elif rsa_ver == 5:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_5
+    elif rsa_ver == 6:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_6
+    elif rsa_ver == 7:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_7
+    elif rsa_ver == 8:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_8
+    elif rsa_ver == 9:
+        rsa_key_select = FILAMENT_PROTO_RSA_PUBLIC_KEY_9
+    else:
+        return FILAMENT_PROTO_RSA_KEY_VER_ERR, None
+
+    # check digital signature
+    signature_read = []
+    for i in range(6):
+        signature_read += copy.copy(data_buf[(10 + i) * 64 : (10 + i) * 64 + 48])
+    signature_read = bytes(signature_read)
+    if (verify_signature_pkcs1(rsa_key_select,
+                         bytes(data_buf[0:640]), signature_read[0:256]) == False):
+        return FILAMENT_PROTO_SIGN_CHECK_ERR, None
+
+    info = copy.copy(FILAMENT_INFO_STRUCT)
+    info['RSA_KEY_VERSION'] = rsa_ver
+
+    tmp = data_buf[M1_PROTO_VERSION_POS : M1_PROTO_VERSION_POS + M1_PROTO_VERSION_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['VERSION'] = tmp
+
+    tmp = data_buf[M1_PROTO_VENDOR_POS : M1_PROTO_VENDOR_POS + M1_PROTO_VENDOR_LEN]
+    tmp = bytes(tmp).decode('ascii').rstrip('\x00')
+    info['VENDOR'] = tmp
+
+    tmp = data_buf[M1_PROTO_MANUFACTURER_POS : M1_PROTO_MANUFACTURER_POS + M1_PROTO_MANUFACTURER_LEN]
+    tmp = bytes(tmp).decode('ascii').rstrip('\x00')
+    info['MANUFACTURER'] = tmp
+
+    tmp = data_buf[M1_PROTO_MAIN_TYPE_POS : M1_PROTO_MAIN_TYPE_POS + M1_PROTO_MAIN_TYPE_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    ret = get_key_by_value(FILAMENT_PROTO_MAIN_TYPE_MAPPING, tmp)
+    if (ret == None):
+        return FILAMENT_PROTO_ERR, None
+    else:
+        info['MAIN_TYPE'] = ret
+
+    tmp = data_buf[M1_PROTO_SUB_TYPE_POS : M1_PROTO_SUB_TYPE_POS + M1_PROTO_SUB_TYPE_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    ret = get_key_by_value(FILAMENT_PROTO_SUB_TYPE_MAPPING, tmp)
+    if (ret == None):
+        return FILAMENT_PROTO_ERR, None
+    else:
+        info['SUB_TYPE'] = ret
+
+    tmp = data_buf[M1_PROTO_TRAY_POS : M1_PROTO_TRAY_POS + M1_PROTO_TRAY_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['TRAY'] = tmp
+
+    info['ALPHA'] = 0xFF - data_buf[M1_PROTO_ALPHA_POS]
+
+    tmp = data_buf[M1_PROTO_COLOR_NUMS_POS]
+    if tmp > FILAMENT_PROTO_COLOR_NUMS_MAX :
+        return FILAMENT_PROTO_ERR, None
+    info['COLOR_NUMS'] = tmp
+
+    tmp = data_buf[M1_PROTO_RGB_1_POS : M1_PROTO_RGB_1_POS + M1_PROTO_RGB_1_LEN]
+    tmp = (tmp[0] << 16) | (tmp[1] << 8) | (tmp[2])
+    info['RGB_1'] = tmp
+    tmp = data_buf[M1_PROTO_RGB_2_POS : M1_PROTO_RGB_2_POS + M1_PROTO_RGB_2_LEN]
+    tmp = (tmp[0] << 16) | (tmp[1] << 8) | (tmp[2])
+    info['RGB_2'] = tmp
+    tmp = data_buf[M1_PROTO_RGB_3_POS : M1_PROTO_RGB_3_POS + M1_PROTO_RGB_3_LEN]
+    tmp = (tmp[0] << 16) | (tmp[1] << 8) | (tmp[2])
+    info['RGB_3'] = tmp
+    tmp = data_buf[M1_PROTO_RGB_4_POS : M1_PROTO_RGB_4_POS + M1_PROTO_RGB_4_LEN]
+    tmp = (tmp[0] << 16) | (tmp[1] << 8) | (tmp[2])
+    info['RGB_4'] = tmp
+    tmp = data_buf[M1_PROTO_RGB_5_POS : M1_PROTO_RGB_5_POS + M1_PROTO_RGB_5_LEN]
+    tmp = (tmp[0] << 16) | (tmp[1] << 8) | (tmp[2])
+    info['RGB_5'] = tmp
+    info['ARGB_COLOR'] = info['ALPHA'] << 24 | info['RGB_1']
+
+    tmp = data_buf[M1_PROTO_DIAMETER_POS : M1_PROTO_DIAMETER_POS + M1_PROTO_DIAMETER_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['DIAMETER'] = tmp
+
+    tmp = data_buf[M1_PROTO_WEIGHT_POS : M1_PROTO_WEIGHT_POS + M1_PROTO_WEIGHT_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['WEIGHT'] = tmp
+
+    tmp = data_buf[M1_PROTO_LENGTH_POS : M1_PROTO_LENGTH_POS + M1_PROTO_LENGTH_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['LENGTH'] = tmp
+
+    tmp = data_buf[M1_PROTO_DRY_TEMP_POS : M1_PROTO_DRY_TEMP_POS + M1_PROTO_DRY_TEMP_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['DRYING_TEMP'] = tmp
+
+    tmp = data_buf[M1_PROTO_DRY_TIME_POS : M1_PROTO_DRY_TIME_POS + M1_PROTO_DRY_TIME_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['DRYING_TIME'] = tmp
+
+    tmp = data_buf[M1_PROTO_HOTEND_MAX_TEMP_POS : M1_PROTO_HOTEND_MAX_TEMP_POS + M1_PROTO_HOTEND_MAX_TEMP_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['HOTEND_MAX_TEMP'] = tmp
+
+    tmp = data_buf[M1_PROTO_HOTEND_MIN_TEMP_POS : M1_PROTO_HOTEND_MIN_TEMP_POS + M1_PROTO_HOTEND_MIN_TEMP_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['HOTEND_MIN_TEMP'] = tmp
+
+    tmp = data_buf[M1_PROTO_BED_TYPE_POS : M1_PROTO_BED_TYPE_POS + M1_PROTO_BED_TYPE_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['BED_TYPE'] = tmp
+
+    tmp = data_buf[M1_PROTO_BED_TEMP_POS : M1_PROTO_BED_TEMP_POS + M1_PROTO_BED_TEMP_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['BED_TEMP'] = tmp
+
+    tmp = data_buf[M1_PROTO_FIRST_LAYER_TEMP_POS : M1_PROTO_FIRST_LAYER_TEMP_POS + M1_PROTO_FIRST_LAYER_TEMP_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['FIRST_LAYER_TEMP'] = tmp
+
+    tmp = data_buf[M1_PROTO_OTHER_LAYER_TEMP_POS : M1_PROTO_OTHER_LAYER_TEMP_POS + M1_PROTO_OTHER_LAYER_TEMP_LEN]
+    tmp = (tmp[1] << 8) | (tmp[0])
+    info['OTHER_LAYER_TEMP'] = tmp
+
+    tmp = data_buf[M1_PROTO_SKU_POS : M1_PROTO_SKU_POS + M1_PROTO_SKU_LEN]
+    info['SKU'] = (tmp[3] << 24) | (tmp[2] << 16) | (tmp[1] << 8) | (tmp[0] << 0)
+
+    info['CARD_UID'] = data_buf[M1_PROTO_UID_POS : M1_PROTO_UID_POS + M1_PROTO_UID_LEN]
+
+    info['OFFICIAL'] = True
+
+    return FILAMENT_PROTO_OK, info
+
--- a/klippy/extras/filament_switch_sensor.py
+++ b/klippy/extras/filament_switch_sensor.py
@@ -3,7 +3,12 @@
 # Copyright (C) 2019  Eric Callahan <arksine.code@gmail.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
+import logging, os
+
+POSTFIX_CONFIG_FILE ='_runout_sensor.json'
+DEFAULT_CONFIG = {
+    'enable': True
+}
 
 class RunoutHelper:
     def __init__(self, config):
@@ -29,6 +34,16 @@ class RunoutHelper:
         self.min_event_systime = self.reactor.NEVER
         self.filament_present = False
         self.sensor_enabled = True
+
+        self.extruder_index = self._get_extruder_index(config.get('extruder'))
+        self.exception_manager = self.printer.lookup_object('exception_manager', None)
+
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = self.name + POSTFIX_CONFIG_FILE
+        self.config_path = os.path.join(config_dir, config_name)
+        self.config = self.printer.load_snapmaker_config_file(self.config_path, DEFAULT_CONFIG)
+        self.sensor_enabled = self.config['enable']
+
         # Register commands and event handlers
         self.printer.register_event_handler("klippy:ready", self._handle_ready)
         self.gcode.register_mux_command(
@@ -39,8 +54,20 @@ class RunoutHelper:
             "SET_FILAMENT_SENSOR", "SENSOR", self.name,
             self.cmd_SET_FILAMENT_SENSOR,
             desc=self.cmd_SET_FILAMENT_SENSOR_help)
+        self.gcode.register_mux_command(
+            "CHECK_FILAMENT_RUNOUT", "SENSOR", self.name,
+            self.cmd_CHECK_FILAMENT_RUNOUT,
+            desc=self.cmd_CHECK_FILAMENT_RUNOUT_help)
     def _handle_ready(self):
         self.min_event_systime = self.reactor.monotonic() + 2.
+        self.print_task_config = self.printer.lookup_object('print_task_config', None)
+
+    def _get_extruder_index(self, extruder_name):
+        if extruder_name is not None and extruder_name.startswith('extruder'):
+            num_str = extruder_name[8:]
+            return int(num_str) if num_str.isdigit() else 0
+        return 0
+
     def _runout_event_handler(self, eventtime):
         # Pausing from inside an event requires that the pause portion
         # of pause_resume execute immediately.
@@ -48,19 +75,35 @@ class RunoutHelper:
         if self.runout_pause:
             pause_resume = self.printer.lookup_object('pause_resume')
             pause_resume.send_pause_command()
-            pause_prefix = "PAUSE\n"
+            pause_prefix = "PAUSE IS_RUNOUT=1\n"
             self.printer.get_reactor().pause(eventtime + self.pause_delay)
         self._exec_gcode(pause_prefix, self.runout_gcode)
+        if self.runout_pause:
+            try:
+                self.gcode.run_script('\nM400\nINNER_AUTO_REPLENISH_FILAMENT\n')
+            except Exception:
+                logging.exception("Script running error")
+            if self.print_task_config.perform_auto_replenish == False:
+                if self.exception_manager is not None:
+                    self.exception_manager.raise_exception_async(
+                        id = self.exception_manager.list.MODULE_ID_TOOLHEAD,
+                        index = self.extruder_index,
+                        code = self.exception_manager.list.CODE_TOOLHEAD_FILAMENT_RUNOUT,
+                        message = '%s runout' % (self.name),
+                        oneshot = 0,
+                        level = 2)
+
     def _insert_event_handler(self, eventtime):
         self._exec_gcode("", self.insert_gcode)
+
     def _exec_gcode(self, prefix, template):
         try:
             self.gcode.run_script(prefix + template.render() + "\nM400")
         except Exception:
             logging.exception("Script running error")
         self.min_event_systime = self.reactor.monotonic() + self.event_delay
-    def note_filament_present(self, is_filament_present):
-        if is_filament_present == self.filament_present:
+    def note_filament_present(self, is_filament_present, force=False):
+        if is_filament_present == self.filament_present and force == False:
             return
         self.filament_present = is_filament_present
         eventtime = self.reactor.monotonic()
@@ -69,18 +112,35 @@ class RunoutHelper:
             # during the event delay time, while an event is running, or
             # when the sensor is disabled
             return
+
+        if self.filament_present:
+            logging.info("Filament Sensor %s: insert event detected, Time %.2f" %
+                         (self.name, eventtime))
+        else:
+            logging.info("Filament Sensor %s: remove event detected, Time %.2f" %
+                         (self.name, eventtime))
+
+        if self.print_task_config is not None:
+            self.print_task_config.backup_print_task_config()
+        self.printer.send_event("filament_switch_sensor:runout",
+                                self.extruder_index, is_filament_present)
+
         # Determine "printing" status
-        idle_timeout = self.printer.lookup_object("idle_timeout")
-        is_printing = idle_timeout.get_status(eventtime)["state"] == "Printing"
+        # idle_timeout = self.printer.lookup_object("idle_timeout")
+        # is_printing = idle_timeout.get_status(eventtime)["state"] == "Printing"
+        print_stats = self.printer.lookup_object('print_stats')
+        is_printing = print_stats.state == "printing"
         # Perform filament action associated with status change (if any)
         if is_filament_present:
             if not is_printing and self.insert_gcode is not None:
                 # insert detected
                 self.min_event_systime = self.reactor.NEVER
-                logging.info(
-                    "Filament Sensor %s: insert event detected, Time %.2f" %
-                    (self.name, eventtime))
                 self.reactor.register_callback(self._insert_event_handler)
+            if self.exception_manager is not None:
+                self.exception_manager.clear_exception(
+                    id = self.exception_manager.list.MODULE_ID_TOOLHEAD,
+                    index = self.extruder_index,
+                    code = self.exception_manager.list.CODE_TOOLHEAD_FILAMENT_RUNOUT)
         elif is_printing and self.runout_gcode is not None:
             # runout detected
             self.min_event_systime = self.reactor.NEVER
@@ -88,6 +148,7 @@ class RunoutHelper:
                 "Filament Sensor %s: runout event detected, Time %.2f" %
                 (self.name, eventtime))
             self.reactor.register_callback(self._runout_event_handler)
+
     def get_status(self, eventtime):
         return {
             "filament_detected": bool(self.filament_present),
@@ -102,13 +163,42 @@ class RunoutHelper:
     cmd_SET_FILAMENT_SENSOR_help = "Sets the filament sensor on/off"
     def cmd_SET_FILAMENT_SENSOR(self, gcmd):
         self.sensor_enabled = gcmd.get_int("ENABLE", 1)
+        self.config['enable'] = bool(self.sensor_enabled)
+        logging.info("Filament Sensor: set enable/disable -- %d", self.sensor_enabled)
+
+        need_save = gcmd.get_int('SAVE', 1, minval=0, maxval=1)
+        if (need_save):
+            load_config = self.printer.load_snapmaker_config_file(self.config_path, DEFAULT_CONFIG)
+            load_config['enable'] = self.config['enable']
+            ret = self.printer.update_snapmaker_config_file(self.config_path, load_config, DEFAULT_CONFIG)
+            if not ret:
+                raise gcmd.error("save startup stay failed!")
+    cmd_CHECK_FILAMENT_RUNOUT_help = "Check for filament runout during printing process."
+    def cmd_CHECK_FILAMENT_RUNOUT(self, gcmd):
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats is not None and print_stats.state in ["printing", "paused"]:
+            if bool(self.sensor_enabled) and not bool(self.filament_present):
+                raise gcmd.error(
+                        message = f'{self.name} runout',
+                        action = 'pause',
+                        id = 523,
+                        index = self.extruder_index,
+                        code = 0,
+                        oneshot = 0,
+                        level = 2)
 
 class SwitchSensor:
     def __init__(self, config):
         printer = config.get_printer()
         buttons = printer.load_object(config, 'buttons')
         switch_pin = config.get('switch_pin')
-        buttons.register_buttons([switch_pin], self._button_handler)
+        # buttons.register_buttons([switch_pin], self._button_handler)
+        if config.get('analog_range', None) is None:
+            buttons.register_buttons([switch_pin], self._button_handler)
+        else:
+            amin, amax = config.getfloatlist('analog_range', count=2)
+            pullup = config.getfloat('analog_pullup_resistor', 4700., above=0.)
+            buttons.register_adc_button(switch_pin, amin, amax, pullup, self._button_handler)
         self.runout_helper = RunoutHelper(config)
         self.get_status = self.runout_helper.get_status
     def _button_handler(self, eventtime, state):
--- /dev/null
+++ b/klippy/extras/flow_calibrator.py
@@ -0,0 +1,850 @@
+import logging, multiprocessing, os, time, pathlib, queuefile
+from . import motion_report
+from . import flow_calculator
+import numpy as np
+import json
+
+# algorithm type
+ALGORITHM_TYPE_DICHOTOMY                = 'DICHOTOMY'
+ALGORITHM_TYPE_LINEAR_FITTING           = 'LINEAR_FITTING'
+
+# abort reason
+ABORT_REASON_CANCEL_BY_USER             = 'cancel_by_user'
+ABORT_REASON_FILAMENT_RUNOUT            = 'filament_runout'
+ABORT_REASON_OUT_OF_RANGE               = 'out_of_range'
+ABORT_REASON_FILAMENT_TANGLED           = 'filament_tangled'
+
+DEFAULT_ENV = {
+    'k_min': 0.005,
+    'k_max': 0.065,
+    'k_step': 0.005,
+    'start_vel': 4,
+    'start_dist': 20,
+    'slow_vel': 0.8,
+    'slow_dist': 0.8,
+    'fast_dist': 2,
+    'fast_vel': 8,
+    'accel': 200,
+    'loop': 14
+}
+
+DEFAULT_K = {'extruder': 0.02, 'extruder1': 0.02, 'extruder2': 0.02, 'extruder3': 0.02}
+DEFAULT_CALI_STATE = {'extruder': False, 'extruder1': False, 'extruder2': False, 'extruder3': False}
+
+class AbortCalibration(Exception):
+    def __init__(self, msg=''):
+        self.message = msg
+        Exception.__init__(self, msg)
+
+class AccelTimeQueryHelper:
+    def __init__(self, printer):
+        self._printer = printer
+        self.is_finished = False
+        print_time = printer.lookup_object('toolhead').get_last_move_time()
+        self.request_start_time = self.request_end_time = print_time
+        self.msgs = []
+        self.samples = []
+    def finish_measurements(self):
+        toolhead = self._printer.lookup_object('toolhead')
+        self.request_end_time = toolhead.get_last_move_time()
+        toolhead.wait_moves()
+        self.is_finished = True
+    def handle_batch(self, msg):
+        # "trapq:extruder","params":{"data":[[17713.215392520833,0.036,8.0,-200.0,[8538.241600000292,1.8415999999999997,0.0],[1.0,1.0,0.0]]]
+        if self.is_finished:
+            return False
+        if len(self.msgs) >= 10000:
+            # Avoid filling up memory with too many samples
+            return False
+        # logging.info(f'got mesg: {msg}')
+        self.msgs.append(msg)
+        return True
+    def get_samples(self):
+        if not self.msgs:
+            logging.warning("no mesg")
+            return self.samples
+        total = sum([len(m['data']) for m in self.msgs])
+        count = 0
+        self.samples = samples = [None] * total
+
+        # 'time', 'duration', 'start_velocity',
+        # 'acceleration', 'start_position', 'direction'
+        for msg in self.msgs:
+            for t, d, sv, a, sp, dir in msg['data']:
+                # logging.info("t:%.4f, d:%.4f, sv: %.4f, a:%.4f\n" % (t, d, sv, a))
+                samples[count] = (t, d, sv, a)
+                count += 1
+        del samples[count:]
+        del self.msgs[:]
+        logging.info('got accel time sameple len: {}'.format(len(self.samples)))
+        return self.samples
+    def write_to_file(self, filename, slowv=None, fastv=None):
+        """
+        need to detect acceleration time:
+        8 mm/s        _____       ___     ___
+        0.8mm/s ___|/|     |\|___/   \___/   \___
+                   1 2     3 4
+        1 -> acceleration start
+        2 -> cruise start of fast speed, 8mm/s
+        3 -> decceleration start
+        4 -> cruise start of slow speed, 0.8mm/s
+        """
+        def write_impl():
+            try:
+                # Try to re-nice writing process
+                os.nice(20)
+            except:
+                pass
+            f = open(filename, 'w+')
+            f.write("time, duration, start speed, accel\n")
+            samples = self.samples or self.get_samples()
+            for t, d, sv, a in samples:
+                if slowv is None and fastv is None:
+                    f.write("%.4f,%.4f,%.4f,%.4f\n" % (t,d,sv,a))
+                    continue
+
+                if slowv != None and fastv != None:
+                    if sv != slowv and sv != fastv:
+                        continue
+                f.write("%.4f,%.4f,%.4f,%.4f\n" % (t,d,sv,a))
+            f.close()
+        write_proc = multiprocessing.Process(target=write_impl)
+        write_proc.daemon = True
+        write_proc.start()
+
+class FlowCalibrator(object):
+    def __init__(self, config) -> None:
+        self._printer = config.get_printer()
+        config_dir = self._printer.get_snapmaker_config_dir()
+        config_name = config.get('config_name', 'flow_calibrator.json')
+        self._config_path = os.path.join(config_dir, config_name)
+        self._current_k = dict()
+        self._env = dict()
+        self._load_json_config(self._config_path)
+        self._calibrated_in_printing = DEFAULT_CALI_STATE
+
+        debug = config.getint('debug', 0)
+        start_args = self._printer.get_start_args()
+        factory_mode = start_args.get('factory_mode', False)
+        if debug or factory_mode:
+            self._debug_mode = True
+        else:
+            self._debug_mode = False
+        self._abort_calibration = False
+        self._abort_reason = None
+
+        # register gcode commands
+        self._gcode = self._printer.lookup_object('gcode')
+        self._gcode.register_command('ACCEL_TIME_MEASURE',
+                               self.cmd_ACCEL_TIME_MEASURE,
+                               desc=self.cmd_ACCEL_TIME_MEASURE_help)
+        self._gcode.register_command('FLOW_CALIBRATE',
+                               self.cmd_FLOW_CALIBRATE,
+                               desc=self.cmd_FLOW_CALIBRATE_help)
+        self._gcode.register_command('FLOW_MEASURE_K',
+                               self.cmd_FLOW_MEASURE_K,
+                               desc=self.cmd_ACCEL_TIME_MEASURE_help)
+        self._gcode.register_command('FLOW_RESET_K',
+                               self.cmd_FLOW_RESET_K)
+        self._bg_client = None
+        self._motion_report: motion_report.PrinterMotionReport = None
+        self._printer.register_event_handler("klippy:ready", self._handle_ready)
+        self._printer.register_event_handler("virtual_sdcard:reset_file", self._handle_reset_file)
+        self._printer.register_event_handler("pause_resume:cancel", self._handle_cancel_print)
+        self._printer.register_event_handler("filament_switch_sensor:runout", self._handle_filament_runout)
+        self._printer.register_event_handler("filament_entangle_detect:tangled", self._handle_filament_tangled)
+
+    def _apply_k(self):
+        extruder_list = self._printer.lookup_object('extruder_list', None)
+        for extruder in extruder_list:
+            if extruder:
+                logging.info('update k{} for {}'.format(self._current_k[extruder.get_name()], extruder.get_name()))
+                self._set_pressure_advance(extruder, self._current_k[extruder.get_name()])
+
+    def _load_json_config(self, json_file):
+        try:
+            params = json.load(open(json_file, 'r'))
+            if not params.get('factor') or not params.get('env'):
+                raise "invalid parameters in json config"
+            k = params.get('factor')
+            env = params.get('env')
+
+            if not k.get('extruder') or not k.get('extruder1') or not k.get('extruder2') or not k.get('extruder3'):
+                raise
+            if not env.get('k_min') or not env.get('k_max') or not env.get('start_vel') or not env.get('start_dist') or \
+                not env.get('slow_vel') or not env.get('slow_dist') or not env.get('fast_dist') or not env.get('fast_vel') \
+                or not env.get('accel') or not env.get('loop') or not env.get('k_step') :
+                raise
+            self._current_k = k
+            self._env = env
+        except Exception as e:
+            logging.info(f'reset flowcalibration config: {e}')
+            if os.path.exists(json_file):
+                os.remove(json_file)
+            settings = {'factor': DEFAULT_K, 'env': DEFAULT_ENV}
+            with open(json_file, 'w+') as f:
+                f.write(json.dumps(settings))
+            self._current_k = DEFAULT_K
+            self._env = DEFAULT_ENV
+
+    def _save_config(self):
+        try:
+            config = {'factor': self._current_k, 'env': self._env}
+            json_content = json.dumps(config)
+            queuefile.async_write_file(self._config_path, json_content, safe_write=True)
+        except Exception as e:
+            logging.exception(f"Failed to save flow calibrator config to {self._config_path}: {e}")
+    def _handle_ready(self):
+        self._apply_k()
+        self._motion_report = self._printer.lookup_object('motion_report')
+        self._toolhead = self._printer.lookup_object('toolhead')
+        self._task_config = self._printer.lookup_object('print_task_config', None)
+        self._filament_parameters = self._printer.lookup_object('filament_parameters', None)
+
+    def _handle_reset_file(self):
+        extruder_list = self._printer.lookup_object('extruder_list', None)
+        for extruder in extruder_list:
+            self._calibrated_in_printing[extruder.get_name()] = False
+
+    def _handle_cancel_print(self):
+        self._abort_calibration = True
+        self._abort_reason = ABORT_REASON_CANCEL_BY_USER
+
+    def _handle_filament_runout(self, extruder, present):
+        if not present and extruder == self._toolhead.get_extruder().extruder_index:
+            self._abort_calibration = True
+            self._abort_reason = ABORT_REASON_FILAMENT_RUNOUT
+
+
+    def _handle_filament_tangled(self, extruder):
+        if extruder == self._toolhead.get_extruder().extruder_index:
+            self._abort_calibration = True
+            self._abort_reason = ABORT_REASON_FILAMENT_TANGLED
+
+    def start_measure_acceleration_time(self, axis='toolhead'):
+        atqh = AccelTimeQueryHelper(self._printer)
+        self._motion_report.start_trapq_client(axis, atqh.handle_batch)
+        return atqh
+
+    def _end_of_measure(self):
+        self._gcode.run_script_from_command("INNER_FLOW_MEASURE_END_BASE_DISCARD")
+
+    def _end_of_calibration(self, extruder):
+        self._gcode.run_script_from_command("INNER_FLOW_CALIB_END_BASE_DISCARD")
+
+    def _set_pressure_advance(self, extruder, k, st=None):
+        estepper = extruder.extruder_stepper
+        if st == None:
+            st = estepper.config_smooth_time
+        estepper._set_pressure_advance(k, st)
+
+    def _prepare_phase(self, extruder, k, accel, velocity, distance):
+        self._toolhead.wait_moves()
+        extruder.set_max_accel(accel)
+        self._set_pressure_advance(extruder, k, 0.001)
+        curpos = self._toolhead.get_position()
+        curpos[3] += distance
+        self._toolhead.manual_move(curpos, velocity)
+
+    def _extrude_loop(self, extruder, slow_v, slow_d, fast_v, fast_d, loop):
+        for i in range(loop):
+            if not self._abort_calibration:
+                curpos = self._toolhead.get_position()
+                curpos[3] += slow_d
+                self._toolhead.manual_move(curpos, slow_v)
+            if not self._abort_calibration:
+                curpos[3] += fast_d
+                self._toolhead.manual_move(curpos, fast_v)
+            if self._abort_calibration:
+                if self._abort_reason != None:
+                    raise AbortCalibration(f'{self._abort_reason}')
+                else:
+                    raise AbortCalibration(f'generic')
+        curpos = self._toolhead.get_position()
+        curpos[3] += slow_d * 5
+        self._toolhead.manual_move(curpos, slow_v)
+
+    def _measure_k(self, extruder, inductance_coil, k, params, extruder_dir=None):
+        accel_client = None
+        freq_client = None
+        try:
+            self._gcode.run_script_from_command("MOVE_TO_DISCARD_FILAMENT_POSITION")
+            pheaters = self._printer.lookup_object('heaters')
+            pheaters.set_temperature(extruder.get_heater(), params['temp'], True)
+
+            self._toolhead.wait_moves()
+            accel_client = self.start_measure_acceleration_time(extruder.get_name())
+            freq_client = inductance_coil.start_internal_client()
+
+            self._prepare_phase(extruder, k, params['accel'], params['start_vel'], params['start_dist'])
+
+            self._extrude_loop(extruder, params['slow_vel'], params['slow_dist'], params['fast_vel'],
+                                params['fast_dist'], params['loop'])
+
+            self._toolhead.dwell(0.5)
+            self._toolhead.wait_moves()
+        except AbortCalibration as e:
+            raise
+        except Exception as e:
+            raise e
+        finally:
+            # Ensure measurements are always finished, even if aborted
+            if freq_client:
+                freq_client.finish_measurements()
+            if accel_client:
+                accel_client.finish_measurements()
+        self._toolhead.dwell(0.1)
+        freq_pt, freq = freq_client.get_samples()
+        accel_ts = accel_client.get_samples()
+
+        self._end_of_measure()
+
+        area = flow_calculator.calc_flow_factor(freq_pt, freq, accel_ts, params['loop'], params['slow_vel'], params['fast_vel'], 1, 1)
+        if extruder_dir is None:
+            return area
+
+        # Write data to file
+        if not extruder_dir.exists():
+            os.makedirs(str(extruder_dir))
+        accel_filename = extruder_dir.joinpath("accelts-k%.5f.csv"  % (k,))
+        freq_filename = extruder_dir.joinpath("freq-k%.5f.csv"  % (k, ))
+        accel_client.write_to_file(str(accel_filename), params['slow_vel'], params['fast_vel'])
+        freq_client.write_to_file(str(freq_filename))
+        # waiting write process ending
+        logging.info("Writing raw accel ts to %s, and freq to %s file"
+                            % (accel_filename, freq_filename))
+        return area
+
+    def _get_next_k(self, k_left, k_right, area_left, area_right):
+        area_sum = area_left + area_right
+        # actual k is to the right of k_right
+        if area_sum > area_left and area_sum > area_right:
+            return round(k_right + (k_right - k_left), 6)
+        # actual k is to the left of k_left
+        if area_sum < area_left and area_sum < area_right:
+            if (k_right - k_left) > k_left:
+                return 0
+            else:
+                return round(k_left - (k_right - k_left), 6)
+        if area_sum < area_left or area_sum < area_right:
+            return round(k_left + (k_right - k_left) / 2, 6)
+
+    def _calculate_zero_crossing(self, point1, point2):
+        x1, y1 = point1
+        x2, y2 = point2
+
+        if abs(y2 - y1) < 0.0001:
+            self._abort_reason = ABORT_REASON_OUT_OF_RANGE
+            self._abort_calibration = True
+            raise AbortCalibration(f'{self._abort_reason}')
+
+        return x1 - y1 * (x2 - x1) / (y2 - y1)
+
+    def _reset_pressure_advance(self, extruder_index):
+        filament_parameters = self._printer.lookup_object('filament_parameters', None)
+        print_task_config = self._printer.lookup_object('print_task_config', None)
+        extruder = None
+        if extruder_index == 0:
+            extruder = self._printer.lookup_object('extruder', None)
+        else:
+            extruder = self._printer.lookup_object(f'extruder{extruder_index}', None)
+
+        default_k = 0.02
+        if filament_parameters is None or print_task_config is None or extruder is None:
+            logging.error("[flow_calibrate] cannot get necessary objects")
+        else:
+            status = print_task_config.get_status()
+            default_k = filament_parameters.get_flow_k(
+                status['filament_vendor'][extruder_index],
+                status['filament_type'][extruder_index],
+                status['filament_sub_type'][extruder_index])
+
+        self._set_pressure_advance(extruder, default_k)
+        self._current_k[extruder.get_name()] = default_k
+        self._save_config()
+
+    def cmd_FLOW_RESET_K(self, gcmd):
+        extruder_index = gcmd.get_int("EXTRUDER")
+        self._reset_pressure_advance(extruder_index)
+
+    cmd_FLOW_CALIBRATE_help = """start calibrate the factor for pressure advance\n
+    TARGET  -> target extruder name, must specify it
+    TEMP    -> temperature for test, default 250
+    MIN     -> min K, default 0.008
+    MAX     -> max K, default 0.052
+    STARTV  -> extrude velocity in prepare phase, default 4mm/s
+    STARTD  -> extrude distance in prepare phase, default 20mm
+    SLOWV   -> slow velocity in normal phase, default 0.8mm/s
+    SLOWD   -> extrude distance in slow velocity, default 0.8mm
+    FASTV   -> fast velocity in normal phase, default 8mm/s
+    FASTD   -> extrude distance in fast velocity, default 8mm/s
+    ACCEL   -> acceleration for extruding, default 200mm/s^2
+    LOOP    -> extrude count for one loop, default 14 round
+    """
+    def cmd_FLOW_CALIBRATE(self, gcmd):
+        self._abort_calibration = False
+        self._abort_reason = None
+        machine_state_manager = None
+
+        if self._task_config is None or self._filament_parameters is None:
+            raise gcmd.error("[flow_calibrate] cannot get necessary objects")
+
+        print_stats = self._printer.lookup_object('print_stats', None)
+        if print_stats and print_stats.state in ['printing', 'paused']:
+            if not self._task_config.print_task_config['flow_calibrate']:
+                gcmd.respond_info("[flow_calibrate] flow calibration is disabled")
+                return
+
+        extruder = self._toolhead.get_extruder()
+        extruder_index = self._toolhead.get_extruder().extruder_index
+        task_config_status = self._task_config.get_status()
+
+        if print_stats and print_stats.state in ['printing', 'paused']:
+            if self._calibrated_in_printing[extruder.get_name()]:
+                gcmd.respond_info(f'[flow_calibrate]flow calibration of {extruder.get_name()} has been finished')
+                return
+
+        if task_config_status['filament_type'][extruder_index] == 'NONE':
+            raise gcmd.error(
+                    message = "[flow_calibrate] not edit filament info!",
+                    action = 'pause',
+                    id = 523,
+                    index = extruder_index,
+                    code = 39,
+                    oneshot = 0,
+                    level = 2)
+
+        runout_sensor = self._printer.lookup_object(f'filament_motion_sensor e{extruder_index}_filament', None)
+        if runout_sensor is not None and runout_sensor.get_status(0)['enabled'] == True and \
+                runout_sensor.get_status(0)['filament_detected'] == False:
+            raise gcmd.error(
+                    message = f'e{extruder_index}_filament runout',
+                    action = 'pause',
+                    id = 523,
+                    index = extruder_index,
+                    code = 0,
+                    oneshot = 0,
+                    level = 2)
+
+        filament_parameter = self._filament_parameters.get_filament_parameters(
+                task_config_status['filament_vendor'][extruder_index],
+                task_config_status['filament_type'][extruder_index],
+                task_config_status['filament_sub_type'][extruder_index])
+
+        temperature = gcmd.get_int('TEMP', filament_parameter.get('flow_temp', 250))
+        k_min = gcmd.get_float('MIN', filament_parameter.get('flow_k_min', self._env['k_min']))
+        k_max = gcmd.get_float('MAX', filament_parameter.get('flow_k_max', self._env['k_max']))
+        start_vel = gcmd.get_float('STARTV', self._env['start_vel'])
+        start_dist = gcmd.get_float('STARTD', self._env['start_dist'])
+        slow_v = gcmd.get_float('SLOWV', filament_parameter.get('flow_slow_v', self._env['slow_vel']))
+        slow_dist = gcmd.get_float('SLOWD', self._env['slow_dist'])
+        fast_v = gcmd.get_float('FASTV', filament_parameter.get('flow_fast_v', self._env['fast_vel']))
+        fast_dist = gcmd.get_float('FASTD', self._env['fast_dist'])
+        accel = gcmd.get_int('ACCEL', self._env['accel'])
+        loop = gcmd.get_int('LOOP', self._env['loop'])
+        algorithm = gcmd.get('ALGORITHM', ALGORITHM_TYPE_LINEAR_FITTING)
+
+        if task_config_status['filament_type'][extruder_index] == 'TPU':
+            start_vel = fast_v
+
+        filament_default_k = filament_parameter.get('flow_k', DEFAULT_K[extruder.get_name()])
+        if filament_default_k <= k_min or filament_default_k >= k_max:
+            raise gcmd.error("[flow_calibrate] K range setting error, should be: MIN < default[%f] < MAX\r\n" % (
+                filament_default_k))
+
+        cali_params = {
+            'k_min': k_min,
+            'k_max': k_max,
+            'start_vel': start_vel,
+            'start_dist': start_dist,
+            'slow_vel': slow_v,
+            'slow_dist': slow_dist,
+            'fast_dist': fast_dist,
+            'fast_vel': fast_v,
+            'accel': accel,
+            'loop': loop,
+            'temp': temperature
+        }
+
+        gcmd.respond_info("[flow_calibrate] filament: %s %s %s , calib_param: %s \r\n" % (
+                        task_config_status['filament_vendor'][extruder_index],
+                        task_config_status['filament_type'][extruder_index],
+                        task_config_status['filament_sub_type'][extruder_index],
+                        str(cali_params)))
+
+        try:
+            self._toolhead.wait_moves()
+            machine_state_manager = self._printer.lookup_object('machine_state_manager', None)
+            if machine_state_manager is not None:
+                cur_sta = machine_state_manager.get_status()
+                if str(cur_sta["main_state"]) == "PRINTING":
+                    self._gcode.run_script_from_command("SET_ACTION_CODE ACTION={}_FLOW_CALIBRATING".format(extruder.get_name().upper()))
+                else:
+                    self._gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=FLOW_CALIBRATION ACTION={}_FLOW_CALIBRATING".format(extruder.get_name().upper()))
+
+            if not extruder.check_xy_homing():
+                self._gcode.run_script_from_command("G28 X Y")
+                self._toolhead.wait_moves()
+
+            estepper = extruder.extruder_stepper
+            backup_st = estepper.config_smooth_time
+            inductance_coil_name = f'inductance_coil {extruder.get_name()}'
+            self._toolhead.get_last_move_time()
+            try:
+                pheaters = self._printer.lookup_object('heaters')
+                inductance_coil_wrapper = self._printer.lookup_object(inductance_coil_name)
+                status = extruder.get_extruder_activate_status()
+                info = status[0]
+                if info[1] != 0:
+                    gcmd.respond_info(f'{status}')
+                    raise gcmd.error(f'[{extruder.get_name()}] is not available for flow calibration!')
+            except self._printer.config_error as e:
+                raise gcmd.error(str(e))
+
+            # move to extrusion position before heating nozzle, avoid dripping on the bed
+            self._gcode.run_script_from_command("MOVE_TO_DISCARD_FILAMENT_POSITION")
+
+            gcmd.respond_info(f'start flow calibration for {extruder.get_name()}')
+            gcmd.respond_info(f'start heating heater to {temperature} degre')
+            pheaters.set_temperature(extruder.get_heater(), temperature, True)
+
+            # start measuring inductance coil frequency
+            gcmd.respond_info(f'start measuring frequency')
+            inductance_coil = inductance_coil_wrapper.sensor
+
+            gcmd.respond_info(f'start extruding')
+
+            measure_success_k = None
+
+            # prepaire direcotry for data
+            extruder_dir = None
+            if self._debug_mode:
+                vsd = self._printer.lookup_object('virtual_sdcard', None)
+                if vsd is None:
+                    gcmd.respond_info("No virtual_sdcard dir to save frequency_data data")
+                    data_path = pathlib.Path('/userdata/gcodes/frequency_data/flow_test')
+                else:
+                    data_path = pathlib.Path(f'{vsd.sdcard_dirname}/frequency_data/flow_test')
+
+                if not os.path.exists(data_path):
+                    os.makedirs(data_path)
+                extruder_dir = data_path.joinpath(f'{time.strftime("%m%d-%H%M")}_{extruder.get_name()}')
+                if not os.path.exists(extruder_dir):
+                    os.makedirs(extruder_dir)
+
+            # notify other objects to start flow calibration
+            self._printer.send_event('flow_calibration:begin')
+            try:
+                if algorithm == ALGORITHM_TYPE_DICHOTOMY:
+                    # gcmd.respond_info("Starting flow calibration, algorithm: dichotomy")
+                    k_left = cali_params['k_min']
+                    k_right = cali_params['k_max']
+                    gcmd.respond_info(f'measure k: {k_left:.5f}')
+                    area_left = self._measure_k(extruder, inductance_coil, k_left, cali_params, extruder_dir)
+                    gcmd.respond_info(f'measure k: {k_right:.5f}')
+                    area_right = self._measure_k(extruder, inductance_coil, k_right, cali_params, extruder_dir)
+                    next_k = self._get_next_k(k_left, k_right, area_left, area_right)
+                    gcmd.respond_info(f'calculate next_k: {next_k:.5f}')
+                    if next_k < cali_params['k_min'] or next_k > cali_params['k_max']:
+                        self._abort_reason = ABORT_REASON_OUT_OF_RANGE
+                        self._abort_calibration = True
+                        raise AbortCalibration(f'{self._abort_reason}')
+
+                    # if next_k > k_right:
+                    #     # next_k is to the right of k_right, adjust k_left and k_right
+                    #     gcmd.respond_info(f'next_k is to the right of k_right')
+                    #     k_left = k_right
+                    #     area_left = area_right
+                    #     k_right = next_k
+                    #     gcmd.respond_info(f'get new area_right')
+                    #     area_right = self._measure_k(extruder, inductance_coil, k_right, cali_params, extruder_dir)
+                    #     # update next_k
+                    #     next_k = round((k_right - k_left) / 2, 6)
+                    # elif next_k < k_left:
+                    #     # next_k is to the left of k_left, adjust k_left and k_right
+                    #     gcmd.respond_info(f'next_k is to the left of k_left')
+                    #     k_right = k_left
+                    #     area_right = area_left
+                    #     k_left = next_k
+                    #     # get new area_left
+                    #     gcmd.respond_info(f'get new area_left')
+                    #     area_left = self._measure_k(extruder, inductance_coil, k_left, cali_params, extruder_dir)
+                    #     # update next_k
+                    #     next_k = round((k_right - k_left) / 2, 6)
+
+                    gcmd.respond_info(f'area_left[k{k_left:.5f}]: {area_left}, next k: {next_k:.5f}, area_right[k{k_right:.5f}]: {area_right}')
+
+                    for i in range(4):
+                        gcmd.respond_info(f'measure k: {next_k:.5f}')
+                        measure_area = self._measure_k(extruder, inductance_coil, next_k, cali_params, extruder_dir)
+                        gcmd.respond_info(f'area_left[k{k_left:.5f}]: {area_left}, measure_area[k{next_k:.5f}]: {measure_area}, area_right[k{k_right:.5f}]: {area_right}')
+                        if measure_area > 0:
+                            k_left = next_k
+                            area_left = measure_area
+                        elif measure_area < 0:
+                            k_right = next_k
+                            area_right = measure_area
+                        else:
+                            break
+                        next_k = self._get_next_k(k_left, k_right, area_left, area_right)
+
+                    measure_success_k = next_k
+
+                elif algorithm == ALGORITHM_TYPE_LINEAR_FITTING:
+                    # gcmd.respond_info("Starting flow calibration, algorithm: linear fitting")
+                    measure_point_1_k = cali_params['k_min']
+                    measure_point_2_k = cali_params['k_max']
+                    gcmd.respond_info(f'measure k: {measure_point_1_k:.5f}')
+                    measure_point_1_area = self._measure_k(extruder, inductance_coil, measure_point_1_k, cali_params, extruder_dir)
+                    gcmd.respond_info(f'measure area: {measure_point_1_area:.5f}')
+                    gcmd.respond_info(f'measure k: {measure_point_2_k:.5f}')
+                    measure_point_2_area = self._measure_k(extruder, inductance_coil, measure_point_2_k, cali_params, extruder_dir)
+                    gcmd.respond_info(f'measure area: {measure_point_2_area:.5f}')
+                    measure_point_3_k = measure_point_1_k
+                    measure_point_4_k = measure_point_2_k
+                    measure_point_3_area = measure_point_1_area
+                    measure_point_4_area = measure_point_2_area
+                    measure_point_1 = measure_point_1_k, measure_point_1_area
+                    measure_point_2 = measure_point_2_k, measure_point_2_area
+                    calculate_next_k = self._get_next_k(measure_point_1_k, measure_point_2_k, measure_point_1_area, measure_point_2_area)
+                    calculate_k_zero_12 = self._calculate_zero_crossing(measure_point_1, measure_point_2)
+                    if calculate_next_k < measure_point_1_k or calculate_next_k > measure_point_2_k or \
+                            calculate_k_zero_12 < measure_point_1_k or calculate_k_zero_12 > measure_point_2_k:
+                        self._abort_reason = ABORT_REASON_OUT_OF_RANGE
+                        self._abort_calibration = True
+                        raise AbortCalibration(f'{self._abort_reason}')
+
+                    tmp_k = calculate_k_zero_12
+                    for i in range(2):
+                        tmp_k = measure_point_1_k + (tmp_k - measure_point_1_k) / 2
+                        gcmd.respond_info(f'measure k: {tmp_k:.5f}')
+                        tmp_area = self._measure_k(extruder, inductance_coil, tmp_k, cali_params, extruder_dir)
+                        gcmd.respond_info(f'measure area: {tmp_area:.5f}')
+                        if tmp_area >= 0 and tmp_area <= measure_point_1_area:
+                            measure_point_3_k = tmp_k
+                            measure_point_3_area = tmp_area
+                            break
+
+                    tmp_k = measure_point_2_k
+                    for i in range(2):
+                        tmp_k = measure_point_2_k - (tmp_k - calculate_k_zero_12) / 2
+                        gcmd.respond_info(f'measure k: {tmp_k:.5f}')
+                        tmp_area = self._measure_k(extruder, inductance_coil, tmp_k, cali_params, extruder_dir)
+                        gcmd.respond_info(f'measure area: {tmp_area:.5f}')
+                        if tmp_area <= 0 and tmp_area >= measure_point_2_area:
+                            measure_point_4_k = tmp_k
+                            measure_point_4_area = tmp_area
+                            break
+
+                    measure_point_3 = measure_point_3_k, measure_point_3_area
+                    measure_point_4 = measure_point_4_k, measure_point_4_area
+
+                    calculate_k_zero_list = [calculate_k_zero_12]
+                    calculate_k_zero_list.append( self._calculate_zero_crossing(measure_point_1, measure_point_3))
+                    calculate_k_zero_list.append( self._calculate_zero_crossing(measure_point_1, measure_point_4))
+                    calculate_k_zero_list.append( self._calculate_zero_crossing(measure_point_2, measure_point_3))
+                    calculate_k_zero_list.append( self._calculate_zero_crossing(measure_point_2, measure_point_4))
+                    calculate_k_zero_list.append( self._calculate_zero_crossing(measure_point_3, measure_point_4))
+                    calculate_k_zero_list.remove(max(calculate_k_zero_list))
+                    calculate_k_zero_list.remove(min(calculate_k_zero_list))
+                    measure_success_k = sum(calculate_k_zero_list) / len(calculate_k_zero_list)
+                    gcmd.respond_info("k_zero: %s" % (str(calculate_k_zero_list)))
+
+            except AbortCalibration as e:
+                if self._abort_reason == ABORT_REASON_FILAMENT_RUNOUT:
+                    raise gcmd.error(
+                            message = f'e{extruder_index}_filament runout',
+                            action = 'pause',
+                            id = 523,
+                            index = extruder_index,
+                            code = 0,
+                            oneshot = 0,
+                            level = 2,
+                            proactive_report = 0)
+                elif self._abort_reason == ABORT_REASON_FILAMENT_TANGLED:
+                    raise gcmd.error(
+                            message = 'detect filament tangled!',
+                            action = 'pause',
+                            id = 523,
+                            index = extruder_index,
+                            code = 38,
+                            oneshot = 1,
+                            level = 2,
+                            proactive_report = 0)
+                else:
+                    gcmd.respond_info(f'abort calibration: {e}')
+
+            except Exception as e:
+                raise gcmd.error(
+                        message = f'error: {e}',
+                        action = 'pause',
+                        id = 523,
+                        index = extruder_index,
+                        code = 9000,
+                        oneshot = 1,
+                        level = 2)
+
+            finally:
+                # notify other objects to end flow calibration
+                self._printer.send_event('flow_calibration:end')
+                virtual_sdcard = self._printer.lookup_object('virtual_sdcard', None)
+                # measure success
+                if not self._abort_calibration and measure_success_k != None:
+                    measure_success_k = round(measure_success_k, 6)
+                    gcmd.respond_info(f'Got pressure advance: {measure_success_k}')
+                    if measure_success_k < cali_params['k_min'] or measure_success_k > cali_params['k_max']:
+                        measure_success_k = filament_default_k
+                        gcmd.respond_info(f'flow k is out of range, use default value:{filament_default_k}')
+                    self._set_pressure_advance(extruder, measure_success_k, backup_st)
+                    if virtual_sdcard is not None:
+                        estepper = extruder.extruder_stepper
+                        virtual_sdcard.record_pl_print_pressure_advance({estepper.name: [estepper.pressure_advance, estepper.pressure_advance_smooth_time]})
+                    self._current_k[extruder.get_name()] = measure_success_k
+                    self._save_config()
+
+                    if print_stats and print_stats.state == 'printing':
+                        self._calibrated_in_printing[extruder.get_name()] = True
+                    self._end_of_calibration(extruder)
+
+                # measure failure
+                else:
+                    # out of range
+                    if self._abort_reason == ABORT_REASON_OUT_OF_RANGE:
+                        measure_success_k = filament_default_k
+                        gcmd.respond_info(f'flow k is out of range, use default value:{filament_default_k}')
+                        self._set_pressure_advance(extruder, measure_success_k, backup_st)
+                        if virtual_sdcard is not None:
+                            estepper = extruder.extruder_stepper
+                            virtual_sdcard.record_pl_print_pressure_advance({estepper.name: [estepper.pressure_advance, estepper.pressure_advance_smooth_time]})
+                        self._current_k[extruder.get_name()] = measure_success_k
+                        self._save_config()
+                        if print_stats and print_stats.state == 'printing':
+                            self._calibrated_in_printing[extruder.get_name()] = True
+                        self._end_of_calibration(extruder)
+
+                self._abort_calibration = False
+                self._abort_reason = None
+                self._gcode.run_script_from_command("MOVE_TO_XY_IDLE_POSITION_EXTRUDER")
+                self._toolhead.wait_moves()
+                pheaters.set_temperature(extruder.get_heater(), 0)
+
+        finally:
+            if machine_state_manager is not None:
+                cur_sta = machine_state_manager.get_status()
+                if str(cur_sta["main_state"]) == "PRINTING":
+                    self._gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+                elif str(cur_sta["main_state"]) == "FLOW_CALIBRATION":
+                    self._gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE")
+
+    cmd_ACCEL_TIME_MEASURE_help = 'measure acceleration time of specified axis'
+    def cmd_ACCEL_TIME_MEASURE(self, gcmd):
+        axis = gcmd.get('AXIS')
+        if self._bg_client is None:
+            self._bg_client = self.start_measure_acceleration_time(axis)
+            gcmd.respond_info("acceleration measurements started")
+            return
+        # End measurements
+        name = gcmd.get("NAME", time.strftime("%m%d_%H%M"))
+        if not name.replace('-', '').replace('_', '').isalnum():
+            raise gcmd.error("Invalid NAME parameter")
+        bg_client = self._bg_client
+        self._bg_client = None
+        bg_client.finish_measurements()
+        # Write data to file
+        vsd = self._printer.lookup_object('virtual_sdcard', None)
+        if vsd is None:
+            gcmd.respond_info("No virtual_sdcard dir to save frequency_data data")
+            data_path = pathlib.Path('/userdata/gcodes/frequency_data')
+        else:
+            data_path = pathlib.Path(f'{vsd.sdcard_dirname}/frequency_data')
+        if not os.path.exists(data_path):
+            os.makedirs(data_path)
+        filename = data_path.joinpath("accelts-%s-%s.csv" % (str(axis), name))
+        bg_client.write_to_file(filename)
+
+        gcmd.respond_info("Writing raw accel time data to %s file"
+                          % (filename,))
+
+    def cmd_FLOW_MEASURE_K(self, gcmd):
+        temperature = gcmd.get_int('TEMP', 250)
+        self._abort_calibration = False
+        self._abort_reason = None
+        cali_params = {
+            'k_min': gcmd.get_float('MIN', self._env['k_min']),
+            'k_max': gcmd.get_float('MAX', self._env['k_max']),
+            'k_step': gcmd.get_float('STEP', self._env['k_step']),
+            'start_vel': gcmd.get_float('STARTV', self._env['start_vel']),
+            'start_dist': gcmd.get_float('STARTD', self._env['start_dist']),
+            'slow_vel': gcmd.get_float('SLOWV', self._env['slow_vel']),
+            'slow_dist': gcmd.get_float('SLOWD', self._env['slow_dist']),
+            'fast_dist': gcmd.get_float('FASTD', self._env['fast_dist']),
+            'fast_vel': gcmd.get_float('FASTV', self._env['fast_vel']),
+            'accel': gcmd.get_int('ACCEL', self._env['accel']),
+            'loop': gcmd.get_int('LOOP', self._env['loop'])
+        }
+        # check if target extruder is current extruder?
+        extruder = self._toolhead.get_extruder()
+        estepper = extruder.extruder_stepper
+        backup_st = estepper.config_smooth_time
+        inductance_coil_name = f'inductance_coil {extruder.get_name()}'
+        self._toolhead.get_last_move_time()
+        try:
+            pheaters = self._printer.lookup_object('heaters')
+            inductance_coil_wrapper = self._printer.lookup_object(inductance_coil_name)
+            status = extruder.get_extruder_activate_status()
+            info = status[0]
+            if info[1] != 0:
+                raise gcmd.error(f'extruder {extruder.get_name()} is not activated!')
+        except self._printer.config_error as e:
+            raise gcmd.error(str(e))
+
+        try:
+            # move to extrusion position before heating nozzle, avoid dripping on the bed
+            self._gcode.run_script_from_command("MOVE_TO_DISCARD_FILAMENT_POSITION")
+
+            gcmd.respond_info(f'start flow calibration for {extruder.get_name()}')
+            gcmd.respond_info(f'start heating heater to {temperature} degre')
+            pheaters.set_temperature(extruder.get_heater(), temperature, True)
+
+            # start measuring inductance coil frequency
+            gcmd.respond_info(f'start measuring frequency')
+            inductance_coil = inductance_coil_wrapper.sensor
+
+            gcmd.respond_info(f'start extruding')
+
+            k_min = int(cali_params['k_min'] * 1000)
+            k_max = int(cali_params['k_max'] * 1000)
+            k_step = int(cali_params['k_step'] * 1000)
+
+            # prepaire direcotry for data
+            vsd = self._printer.lookup_object('virtual_sdcard', None)
+            if vsd is None:
+                gcmd.respond_info("No virtual_sdcard dir to save frequency_data data")
+                data_path = pathlib.Path('/userdata/gcodes/frequency_data/flow_test')
+            else:
+                data_path = pathlib.Path(f'{vsd.sdcard_dirname}/frequency_data/flow_test')
+            if not os.path.exists(data_path):
+                os.makedirs(data_path)
+            extruder_dir = data_path.joinpath(f'{time.strftime("%m%d-%H%M")}_{extruder.get_name()}')
+            if not os.path.exists(extruder_dir):
+                os.makedirs(extruder_dir)
+            # notify other objects to start flow calibration
+            self._printer.send_event('flow_calibration:begin')
+            gcmd.respond_info(f'k min: {k_min/1000:.3f}, max: {k_max/1000:.3f}, step: {k_step/1000:.3f}')
+            for k in range(k_min, k_max, k_step):
+                float_k = round(k / 1000, 3)
+                area = self._measure_k(extruder, inductance_coil, float_k, cali_params, extruder_dir)
+                gcmd.respond_info(f'k{float_k:.3f}: area: {area}')
+        except AbortCalibration as e:
+            gcmd.respond_info(f'abort calibration')
+        self._set_pressure_advance(extruder, DEFAULT_K[extruder.get_name()], backup_st)
+        if not self._abort_calibration:
+            self._end_of_calibration(extruder)
+        self._abort_calibration = False
+        self._abort_reason = None
+        # notify other objects to end flow calibration
+        self._printer.send_event('flow_calibration:end')
+        pheaters.set_temperature(extruder.get_heater(), 0)
+
+def load_config(config):
+    return FlowCalibrator(config)
--- /dev/null
+++ b/klippy/extras/fm175xx_reader.py
@@ -0,0 +1,1079 @@
+import logging, time, threading, copy
+import spidev
+import hmac, hashlib
+
+# channels
+FM175XX_CHANNEL_NUMS                    = 4
+FM175XX_CHANNEL_1                       = 0
+FM175XX_CHANNEL_2                       = 1
+FM175XX_CHANNEL_3                       = 2
+FM175XX_CHANNEL_4                       = 3
+
+# Error code
+FM175XX_OK                              = 0
+FM175XX_ERR                             = -1
+FM175XX_PARAM_ERR                       = -2
+FM175XX_CHIP_TYPE_ERR                   = -10
+FM175XX_CHIP_COMM_ERR                   = -11
+FM175XX_CARD_TIMER_ERR                  = -20
+FM175XX_CARD_LENGTH_ERR                 = -21
+FM175XX_CARD_COMM_ERR                   = -22
+FM175XX_CARD_AUTH_ERR                   = -23
+FM175XX_CARD_WAKEUP_ERR                 = -24
+FM175XX_CARD_COLL_ERR                   = -25
+FM175XX_CARD_SELECT_ERR                 = -26
+FM175XX_CARD_ACTIVATE_ERR               = -27
+FM175XX_CARD_HALT_ERR                   = -28
+FM175XX_CARD_READ_ERR                   = -29
+FM175XX_CARD_WRITE_ERR                  = -30
+
+# Mask
+FM175XX_RESET                           = 0
+FM175XX_SET                             = 1
+
+# FM175xx register address
+FM175XX_COMMAND_REG                     = 0x01
+FM175XX_COM_I_EN_REG                    = 0x02
+FM175XX_DIV_I_EN_REG                    = 0x03
+FM175XX_COM_IRQ_REG                     = 0x04
+FM175XX_DIV_IRQ_REG                     = 0x05
+FM175XX_ERROR_REG                       = 0x06
+FM175XX_STATUS_1_REG                    = 0x07
+FM175XX_STATUS_2_REG                    = 0x08
+FM175XX_FIFO_DATA_REG                   = 0x09
+FM175XX_FIFO_LEVEL_REG                  = 0x0A
+FM175XX_WATER_LEVEL_REG                 = 0x0B
+FM175XX_CONTROL_REG                     = 0x0C
+FM175XX_BIT_FRAMING_REG                 = 0x0D
+FM175XX_COLL_REG                        = 0x0E
+FM175XX_MODE_REG                        = 0x11
+FM175XX_TX_MODE_REG                     = 0x12
+FM175XX_RX_MODE_REG                     = 0x13
+FM175XX_TX_CONTROL_REG                  = 0x14
+FM175XX_TX_AUTO_REG                     = 0x15
+FM175XX_TX_SEL_REG                      = 0x16
+FM175XX_RX_SEL_REG                      = 0x17
+FM175XX_RX_THRESHOLD_REG                = 0x18
+FM175XX_DEMOD_REG                       = 0x19
+FM175XX_MF_TX_REG                       = 0x1C
+FM175XX_MF_RX_REG                       = 0x1D
+FM175XX_TPYE_B_REG                      = 0x1E
+FM175XX_SERIAL_SPEED_REG                = 0x1F
+FM175XX_CRC_MSB_REG                     = 0x21
+FM175XX_CRC_LSB_REG                     = 0x22
+FM175XX_GSN_OFF_REG                     = 0x23
+FM175XX_MODE_WIDTH_REG                  = 0x24
+FM175XX_RF_CFG_REG                      = 0x26
+FM175XX_GSN_ON_REG                      = 0x27
+FM175XX_CW_GSP_REG                      = 0x28
+FM175XX_MOD_GSP_REG                     = 0x29
+FM175XX_T_MODE_REG                      = 0x2A
+FM175XX_T_PRESCALER_REG                 = 0x2B
+FM175XX_T_RELOAD_MSB_REG                = 0x2C
+FM175XX_T_RELOAD_LSB_REG                = 0x2D
+FM175XX_T_COUNTER_VAL_MSB_REG           = 0x2E
+FM175XX_T_COUNTER_VAL_LSB_REG           = 0x2f
+FM175XX_TEST_SEL_1_REG                  = 0x31
+FM175XX_TEST_SEL_2_REG                  = 0x32
+FM175XX_TEST_PIN_EN_REG                 = 0x33
+FM175XX_TEST_PIN_VALUE_REG              = 0x34
+FM175XX_TEST_BUS_REG                    = 0x35
+FM175XX_TEST_CTRL_REG                   = 0x36
+FM175XX_VERSION_REG                     = 0x37
+FM175XX_TEST_DAC_1_REG                  = 0x39
+FM175XX_TEST_DAC_2_REG                  = 0x3A
+FM175XX_TEST_ADC_REG                    = 0x3B
+
+# FM175xx command code
+FM175XX_CMD_IDLE                        = 0x00
+FM175XX_CMD_GEN_RANDOM_ID               = 0x02
+FM175XX_CMD_CALC_CRC                    = 0x03
+FM175XX_CMD_TRANSMIT                    = 0x04
+FM175XX_CMD_NO_CMD_CHANGE               = 0x07
+FM175XX_CMD_RECEIVE                     = 0x08
+FM175XX_CMD_TRANSCEIVE                  = 0x0C
+FM175XX_CMD_MF_AUTHENT                  = 0x0E
+FM175XX_CMD_SOFT_RESET                  = 0x0F
+
+# FM175XX RF command code
+FM175XX_RF_CMD_REQA                     = 0x26
+FM175XX_RF_CMD_WUPA                     = 0x52
+FM175XX_RF_CMD_ANTICOL                  = [0x93, 0x95, 0x97]
+FM175XX_RF_CMD_SELECT                   = [0x93, 0x95, 0x97]
+FM175XX_RF_CMD_HALT                     = [0x50, 0x00]
+
+# Chip Type
+FM175XX_CHIP_TYPE_UNKNOWN               = 0x00
+FM175XX_CHIP_TYPE_FM17580               = 0x01
+
+# Chip version
+FM175XX_CHIP_VER_FM17580                = 0xA1
+
+# Carrier wave setting
+FM175XX_CW_DISABLE                      = 0
+FM175XX_CW1_ENABLE                      = 1
+FM175XX_CW2_ENABLE                      = 2
+FM175XX_CW_ENABLE                       = 3
+
+FM175XX_CARD_INFO_READ                  = 0
+FM175XX_CARD_INFO_CLEAR                 = 1
+
+# RFID card type
+FM175XX_MIFARE_CARD_TYPE_UNKNOWN        = 0xFF  # unknown type
+FM175XX_MIFARE_CARD_TYPE_M1             = 0x08  # M1
+
+# About M1 Card
+# EEPROM
+FM175XX_M1_CARD_EEPROM_SIZE             = 1024
+FM175XX_M1_CARD_SECTORS                 = 16
+FM175XX_M1_CARD_BLOCKS_PER_SEC          = 4
+FM175XX_M1_CARD_BYTES_PER_BLK           = 16
+FM175XX_M1_CARD_BYTES_PER_SEC           = 64
+# Authentication mode
+FM175XX_M1_CARD_AUTH_MODE_A             = 0
+FM175XX_M1_CARD_AUTH_MODE_B             = 1
+# Access Control Block
+FM175XX_M1_CARD_ACCESS_CODE             = [0x87, 0x87, 0x87, 0x69]
+FM175XX_M1_CARD_HKDF_SALT_KEY_A         = b"Snapmaker_qwertyuiop[,.;]"
+FM175XX_M1_CARD_HKDF_SALT_KEY_B         = b"Snapmaker_qwertyuiop[,.;]_1q2w3e"
+
+# Self test
+FM175XX_SELF_TEST_STAGE_READY           = 0
+FM175XX_SELF_TEST_STAGE_DOING           = 1
+FM175XX_SELF_TEST_STAGE_STOP            = 2
+
+FM175XX_MIN_TIME                        = 0.200
+
+# Picc meta data
+class Fm175xxPiccMetaData:
+    def __init__(self) -> None:
+        self.CASCADE_LEVEL = 0
+        self.ATQA = [0] * 2
+        self.UID = [0] * 12
+        self.BCC = [0] * 3
+        self.SAK = [0] * 3
+    def reset(self):
+        self.CASCADE_LEVEL = 0
+        self.ATQA = [0] * 2
+        self.UID = [0] * 12
+        self.BCC = [0] * 3
+        self.SAK = [0] * 3
+
+# Reader command
+class Fm175xxCmdMetaData:
+    def __init__(self) -> None:
+        self.cmd : int
+        self.send_crc_en : int
+        self.recv_crc_en : int
+        self.bits_to_send : int
+        self.bytes_to_send : int
+        self.bits_to_recv : int
+        self.bytes_to_recv : int
+        self.bits_recved : int
+        self.bytes_recved : int
+        self.send_buff : list
+        self.recv_buff : list
+        self.coll_pos : int
+        self.error : int
+        self.timeout : int
+
+# Return value
+class Fm175xxReturnVal:
+    def __init__(self) -> None:
+        self.err_code = None
+        self.out_param = None
+
+# Fm175xx Reader
+class FM175XXReader:
+    def __init__(self, config) -> None:
+        self.__printer = config.get_printer()
+        self.__reactor = self.__printer.get_reactor()
+        ppins = self.__printer.lookup_object('pins')
+
+        # read config
+        self.soc_spi_bus = config.getint('soc_spi_bus')
+        self.soc_spi_dev_num = config.getint('soc_spi_dev_num')
+        self.soc_spi_mode = config.getint('soc_spi_mode')
+        self.soc_spi_speed_max = config.getint('soc_spi_speed_max')
+        soc_rst_pin = config.get('soc_rst_pin')
+        self.extra_spi_bus = config.getint('extra_spi_bus')
+        self.extra_spi_dev_num = config.getint('extra_spi_dev_num')
+        self.extra_spi_mode = config.getint('extra_spi_mode')
+        self.extra_spi_speed_max = config.getint('extra_spi_speed_max')
+        extra_rst_pin = config.get('extra_rst_pin')
+
+        self.soc_ch_1 = config.getint('soc_ch_1')
+        self.soc_ch_2 = config.getint('soc_ch_2')
+        self.extra_ch_1 = config.getint('extra_ch_1')
+        self.extra_ch_2 = config.getint('extra_ch_2')
+
+        rf_1_pin = config.get('rf_1_pin')
+        rf_2_pin = config.get('rf_2_pin')
+
+        self._hkdf_key_a = None
+        self._hkdf_key_b = None
+
+        # SPI Commu
+        self.__spi = spidev.SpiDev()
+
+        # RST Pin
+        self.__soc_rst_pin = ppins.setup_pin('digital_out', soc_rst_pin)
+        self.__soc_rst_pin.setup_max_duration(0.)
+        self.__extra_rst_pin = ppins.setup_pin('digital_out', extra_rst_pin)
+        self.__extra_rst_pin.setup_max_duration(0.)
+
+        self.__rst_pin = None
+        self.__rst_ctrl_finish = False
+
+        # rfid sw pin
+        self.__rf_1_pin = ppins.setup_pin('digital_out', rf_1_pin)
+        self.__rf_1_pin.setup_max_duration(0.)
+        self.__rf_2_pin = ppins.setup_pin('digital_out', rf_2_pin)
+        self.__rf_2_pin.setup_max_duration(0.)
+        self.__select_channel_finish = False
+
+        self.__card_info_read_flag = 0
+        self.__card_info_clear_flag = 0
+        self.__need_to_shutdown = False
+        self.__card_info_deal_cb = None
+        self.__picc_a = Fm175xxPiccMetaData()
+
+        # self test
+        self.__self_test_stage = FM175XX_SELF_TEST_STAGE_STOP
+        self.__self_test_channel = 0
+        self.__self_test_times = 100
+        self.__self_test_success_cnt = 0
+
+        self.__printer.register_event_handler("klippy:ready", self.__ready)
+        self.__printer.register_event_handler("klippy:shutdown", self.__shutdown)
+
+    def __ready(self):
+        self.__select_fm175xx_obj(FM175XX_CHANNEL_1)
+        self.__do_hard_reset()
+        self.__select_fm175xx_obj(FM175XX_CHANNEL_3)
+        self.__do_hard_reset()
+
+        # Threading
+        background_thread = threading.Thread(target=self.__bg_thread)
+        background_thread.start()
+
+    def __shutdown(self):
+        self.__need_to_shutdown = True
+
+    def __select_fm175xx_obj(self, channel):
+        self.__spi.close()
+        if (channel == FM175XX_CHANNEL_3 or channel == FM175XX_CHANNEL_4):
+            self.__spi.open(self.soc_spi_bus, self.soc_spi_dev_num)
+            self.__spi.mode = self.soc_spi_mode
+            self.__spi.max_speed_hz = self.soc_spi_speed_max
+            self.__rst_pin = self.__soc_rst_pin
+        else:
+            self.__spi.open(self.extra_spi_bus, self.extra_spi_dev_num)
+            self.__spi.mode = self.extra_spi_mode
+            self.__spi.max_speed_hz = self.extra_spi_speed_max
+            self.__rst_pin = self.__extra_rst_pin
+
+    # hardware reset
+    def __do_hard_reset(self):
+        delta_time = 0
+        systime = self.__reactor.monotonic()
+        systime += FM175XX_MIN_TIME + delta_time
+        print_time = self.__rst_pin.get_mcu().estimated_print_time(systime)
+        self.__rst_pin.set_digital(print_time, 0)
+        delta_time += FM175XX_MIN_TIME
+
+        systime = self.__reactor.monotonic()
+        systime += FM175XX_MIN_TIME + delta_time
+        print_time = self.__rst_pin.get_mcu().estimated_print_time(systime)
+        self.__rst_pin.set_digital(print_time, 1)
+
+        self.__rst_ctrl_finish = True
+
+    def __hard_reset(self):
+        self.__rst_ctrl_finish = False
+        self.__reactor.register_async_callback(
+            (lambda et, c=self.__do_hard_reset: c()))
+        while 1:
+            if self.__rst_ctrl_finish:
+                break
+            else:
+                time.sleep(0.020)
+        time.sleep(0.5)
+
+    def __do_select_channel(self, channel):
+        delta_time = 0
+        if (channel == self.extra_ch_1 or channel == self.soc_ch_2):
+            systime = self.__reactor.monotonic()
+            systime += FM175XX_MIN_TIME + delta_time
+            print_time = self.__rf_1_pin.get_mcu().estimated_print_time(systime)
+            self.__rf_1_pin.set_digital(print_time, 1)
+            delta_time += 0.100
+
+            systime = self.__reactor.monotonic()
+            systime += FM175XX_MIN_TIME + delta_time
+            print_time = self.__rf_2_pin.get_mcu().estimated_print_time(systime)
+            self.__rf_2_pin.set_digital(print_time, 0)
+
+        else:
+            systime = self.__reactor.monotonic()
+            systime += FM175XX_MIN_TIME + delta_time
+            print_time = self.__rf_1_pin.get_mcu().estimated_print_time(systime)
+            self.__rf_1_pin.set_digital(print_time, 0)
+            delta_time += 0.100
+
+            systime = self.__reactor.monotonic()
+            systime += FM175XX_MIN_TIME + delta_time
+            print_time = self.__rf_2_pin.get_mcu().estimated_print_time(systime)
+            self.__rf_2_pin.set_digital(print_time, 1)
+
+        self.__select_channel_finish = True
+
+    def __select_channel(self, channel):
+        self.__select_channel_finish = False
+        self.__reactor.register_async_callback(
+            (lambda et, c=self.__do_select_channel, ch=channel: c(ch)))
+        while 1:
+            if self.__select_channel_finish:
+                break
+            else:
+                time.sleep(0.020)
+
+        time.sleep(0.2)
+
+    # read register
+    def __register_read(self, addr:int) -> int:
+        addr = (addr << 1) | 0x80
+        to_send = [addr, 0x00]
+        reg_data = self.__spi.xfer(to_send)
+        return reg_data[1]
+
+    # write register
+    def __register_write(self, addr:int, reg_data:int) -> None:
+        addr = (addr << 1) & 0x7E
+        to_send = [addr, reg_data]
+        self.__spi.xfer(to_send)
+
+    # modify register
+    def __register_modify(self, addr:int, mask:int, is_set:int) -> None:
+        reg_data = self.__register_read(addr)
+        if (is_set):
+            reg_data |= mask
+        else:
+            reg_data &= ~mask
+        self.__register_write(addr, reg_data)
+
+    # read FIFO
+    def __fifo_read(self, len:int) -> list:
+        addr = [0x92] * len + [0x00]
+        buff = self.__spi.xfer(addr)
+        return buff[1 : len + 1]
+
+    # write FIFO
+    def __fifo_write(self, len:int, buff:list) -> None:
+        to_write = [0x12]
+        to_write += buff[0:len]
+        self.__spi.xfer(to_write)
+
+    # Enable/Disable CRC check generation during data transmission.
+    def __set_send_crc(self, mode:int) -> None:
+        if (mode):
+            self.__register_modify(FM175XX_TX_MODE_REG, 0x80, FM175XX_SET)
+        else:
+            self.__register_modify(FM175XX_TX_MODE_REG, 0x80, FM175XX_RESET)
+
+    # Enable/Disable CRC check generation during data reception.
+    def __set_recv_crc(self, mode:int) -> None:
+        if (mode):
+            self.__register_modify(FM175XX_RX_MODE_REG, 0x80, FM175XX_SET)
+        else:
+            self.__register_modify(FM175XX_RX_MODE_REG, 0x80, FM175XX_RESET)
+
+    # Set the timeout period for communication
+    def __set_timeout(self, microseconds:int) -> None:
+        prescaler = 0
+        time_reload = 0
+
+        if microseconds < 1 :
+            microseconds = 1
+
+        while( prescaler < 0xFFF ):
+            time_reload = int((( microseconds * 13560 ) -1 ) / ( prescaler * 2 + 1))
+            if (time_reload < 0xFFFF):
+                break
+            prescaler += 1
+
+        time_reload &=  0xFFFF
+        self.__register_write(FM175XX_T_MODE_REG, 0x80 | ((prescaler >> 8) & 0x0F) )
+        self.__register_write(FM175XX_T_PRESCALER_REG, prescaler & 0xFF)
+        self.__register_write(FM175XX_T_RELOAD_MSB_REG, time_reload >> 8 )
+        self.__register_write(FM175XX_T_RELOAD_LSB_REG, time_reload & 0xFF )
+
+    # set carrier wave
+    def __set_carrier_wave(self, mode:int) -> None:
+        if (FM175XX_CW1_ENABLE == mode):
+            self.__register_modify(FM175XX_TX_CONTROL_REG, 0x01, FM175XX_SET)
+            self.__register_modify(FM175XX_TX_CONTROL_REG, 0x02, FM175XX_RESET)
+        elif (FM175XX_CW2_ENABLE == mode):
+            self.__register_modify(FM175XX_TX_CONTROL_REG, 0x01, FM175XX_RESET)
+            self.__register_modify(FM175XX_TX_CONTROL_REG, 0x02, FM175XX_SET)
+        elif (FM175XX_CW_ENABLE == mode):
+            self.__register_modify(FM175XX_TX_CONTROL_REG, 0x03, FM175XX_SET)
+        else: # FM175XX_CW_DISABLE == mode
+            self.__register_modify(FM175XX_TX_CONTROL_REG, 0x03, FM175XX_RESET)
+
+    # Execute Command
+    def __command_exe(self, cmd:Fm175xxCmdMetaData) -> Fm175xxReturnVal:
+        reg_data = 0
+        irq = 0
+        result = FM175XX_ERR
+        send_length = cmd.bytes_to_send
+        receive_length = 0
+        send_finish = 0
+        cmd.bits_recved = 0
+        cmd.bytes_recved = 0
+        cmd.coll_pos = 0
+        cmd.error = 0
+        fifo_water_level  = 32
+        last_time = time.time()
+
+        self.__register_write(FM175XX_COMMAND_REG, FM175XX_CMD_IDLE)
+        self.__register_write(FM175XX_FIFO_LEVEL_REG, 0x80)
+        self.__register_write(FM175XX_COM_IRQ_REG, 0x7F)
+        self.__register_write(FM175XX_DIV_IRQ_REG, 0x7F)
+        self.__register_write(FM175XX_COM_I_EN_REG, 0x80)
+        self.__register_write(FM175XX_DIV_I_EN_REG, 0x00)
+        self.__register_write(FM175XX_WATER_LEVEL_REG, fifo_water_level)
+
+        self.__set_send_crc(cmd.send_crc_en)
+        self.__set_recv_crc(cmd.recv_crc_en)
+        self.__set_timeout(cmd.timeout)
+
+        # authentication
+        if (cmd.cmd == FM175XX_CMD_MF_AUTHENT) :
+            self.__fifo_write(send_length, cmd.send_buff)
+            send_length = 0
+            self.__register_write(FM175XX_COMMAND_REG, cmd.cmd)
+            self.__register_write(FM175XX_BIT_FRAMING_REG, 0x80 | cmd.bits_to_send)
+
+        if (cmd.cmd == FM175XX_CMD_TRANSCEIVE):
+            self.__register_write(FM175XX_COMMAND_REG, cmd.cmd)
+            self.__register_write(FM175XX_BIT_FRAMING_REG, (cmd.bits_to_recv << 4) | cmd.bits_to_send)
+
+        last_time = time.time() * 1000
+        while 1:
+            # timeout
+            new_time = time.time() * 1000
+            if (new_time - last_time > 50 + cmd.timeout):
+                result = FM175XX_CARD_TIMER_ERR
+                break
+            irq = self.__register_read(FM175XX_COM_IRQ_REG)
+
+            # timeout
+            if (irq & 0x01):
+                self.__register_write(FM175XX_COM_IRQ_REG, 0x01)
+                result = FM175XX_CARD_TIMER_ERR
+                break
+
+            # errors occurred
+            if (irq & 0x02):
+                reg_data = self.__register_read(FM175XX_ERROR_REG)
+                cmd.error = reg_data
+
+                if (cmd.error & 0x08):
+                    reg_data = self.__register_read(FM175XX_COLL_REG)
+                    cmd.coll_pos = reg_data & 0x1F
+                    result = FM175XX_CARD_COLL_ERR
+                    break
+
+                result = FM175XX_CARD_COMM_ERR
+                self.__register_write(FM175XX_COM_IRQ_REG, 0x02)
+                break
+
+            # low level alert
+            if (irq & 0x04):
+                # send data
+                if (send_length > 0):
+                    if (send_length > fifo_water_level):
+                        self.__fifo_write(fifo_water_level, cmd.send_buff)
+                        del cmd.send_buff[0:fifo_water_level]
+                        send_length = send_length - fifo_water_level
+                    else:
+                        self.__fifo_write(send_length, cmd.send_buff)
+                        send_length = 0
+                    self.__register_modify(FM175XX_BIT_FRAMING_REG, 0x80, FM175XX_SET)
+                self.__register_write(FM175XX_COM_IRQ_REG, 0x04)
+
+            # high level alert
+            if (irq & 0x08):
+                # Waiting for data transmission to complete
+                if (send_finish == 1):
+                    cmd.recv_buff[cmd.bytes_recved:cmd.bytes_recved + fifo_water_level] = self.__fifo_read(fifo_water_level)
+                    cmd.bytes_recved += fifo_water_level
+                self.__register_write(FM175XX_COM_IRQ_REG, 0x08)
+
+            # idle status
+            if ((irq & 0x10) and (cmd.cmd == FM175XX_CMD_MF_AUTHENT)):
+                self.__register_write(FM175XX_COM_IRQ_REG, 0x10)
+                result = FM175XX_OK
+                break
+
+            # receice data
+            if ((irq & 0x20) and (cmd.cmd == FM175XX_CMD_TRANSCEIVE)):
+                reg_data = self.__register_read(FM175XX_CONTROL_REG)
+                cmd.bits_recved = reg_data & 0x07
+                reg_data = self.__register_read(FM175XX_FIFO_LEVEL_REG)
+                receive_length = reg_data & 0x7F
+                cmd.recv_buff[cmd.bytes_recved:cmd.bytes_recved+receive_length] = self.__fifo_read(receive_length)
+                cmd.bytes_recved += receive_length
+                if ((cmd.bytes_to_recv != cmd.bytes_recved) and (cmd.bytes_to_recv != 0)):
+                    result = FM175XX_CARD_LENGTH_ERR
+                    break
+                self.__register_write(FM175XX_COM_IRQ_REG, 0x20)
+                result = FM175XX_OK
+                break
+
+            # Completed data transmission
+            if (irq & 0x40):
+                self.__register_write(FM175XX_COM_IRQ_REG, 0x40)
+                if (cmd.cmd == FM175XX_CMD_TRANSCEIVE):
+                    send_finish = 1
+
+        self.__register_modify(FM175XX_BIT_FRAMING_REG, 0x80, FM175XX_RESET)
+        self.__register_write(FM175XX_COMMAND_REG, FM175XX_CMD_IDLE)
+
+        ret = Fm175xxReturnVal()
+        ret.err_code = result
+        ret.out_param = cmd
+        return ret
+
+    # Reader-A: init
+    def __reader_a_init(self) -> None:
+        self.__register_write(FM175XX_TX_MODE_REG, 0x00)
+        self.__register_write(FM175XX_RX_MODE_REG, 0x08)
+        self.__register_modify(FM175XX_TX_AUTO_REG, 0x40, FM175XX_SET)
+        self.__register_write(FM175XX_MODE_WIDTH_REG, 0x26)
+        self.__register_write(FM175XX_CONTROL_REG, 0x10)
+        self.__register_write(FM175XX_GSN_ON_REG, 0xF0)
+        self.__register_write(FM175XX_CW_GSP_REG, 0x3F)
+        self.__register_write(FM175XX_RF_CFG_REG, 0x60)
+        self.__register_write(FM175XX_RX_THRESHOLD_REG, 0x84)
+        self.__register_modify(FM175XX_STATUS_2_REG, 0x08, FM175XX_RESET)
+
+    # Reader-A: wake up picc(s)
+    def __reader_a_wakeup(self) -> int:
+        ret = FM175XX_ERR
+        outbuf = [0]
+        inbuf = [0] * 2
+        cmd = Fm175xxCmdMetaData()
+
+        cmd.send_crc_en = FM175XX_RESET
+        cmd.recv_crc_en = FM175XX_RESET
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        cmd.send_buff[0] = FM175XX_RF_CMD_WUPA
+        cmd.bytes_to_send = 1
+        cmd.bits_to_send = 7
+        cmd.bits_to_recv = 0
+        cmd.bytes_to_recv = 2
+        cmd.timeout = 10
+        cmd.cmd = FM175XX_CMD_TRANSCEIVE
+        result = self.__command_exe(cmd)
+        ret = result.err_code
+
+        if (result.err_code == FM175XX_OK):
+            if (result.out_param.bytes_recved == 2):
+                self.__picc_a.ATQA[0] = result.out_param.recv_buff[0]
+                self.__picc_a.ATQA[1] = result.out_param.recv_buff[1]
+            else:
+                ret = FM175XX_CARD_COMM_ERR
+
+        return ret
+
+    # Reader-A: anti-collision
+    def __reader_a_anticoll(self, cascade_level:int) -> int:
+        ret = FM175XX_ERR
+        outbuf = [0] * 2
+        inbuf = [0] * 5
+        cmd = Fm175xxCmdMetaData()
+
+        if(cascade_level > 2):
+            return FM175XX_PARAM_ERR
+
+        cmd.send_crc_en = FM175XX_RESET
+        cmd.recv_crc_en = FM175XX_RESET
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        cmd.send_buff[0] = FM175XX_RF_CMD_ANTICOL[cascade_level]
+        cmd.send_buff[1] = 0x20
+        cmd.bytes_to_send = 2
+        cmd.bits_to_send = 0
+        cmd.bits_to_recv = 0
+        cmd.bytes_to_recv = 5
+        cmd.timeout = 10
+        cmd.cmd = FM175XX_CMD_TRANSCEIVE
+        result = self.__command_exe(cmd)
+        ret = result.err_code
+        self.__register_modify(FM175XX_COLL_REG, 0x80, FM175XX_SET)
+
+        if (result.err_code == FM175XX_OK):
+            if (result.out_param.bytes_recved == 5):
+                if((result.out_param.recv_buff[0] ^ \
+                    result.out_param.recv_buff[1] ^ \
+                    result.out_param.recv_buff[2] ^ \
+                    result.out_param.recv_buff[3] ^ \
+                    result.out_param.recv_buff[4]) != 0):
+                    ret = FM175XX_CARD_COMM_ERR
+                else:
+                    self.__picc_a.UID[cascade_level * 4:cascade_level*4 + 4] = result.out_param.recv_buff[0:4]
+                    self.__picc_a.BCC[cascade_level] = result.out_param.recv_buff[4]
+            else:
+                ret = FM175XX_CARD_COMM_ERR
+
+        return ret
+
+    # Reader-A: select a picc
+    def __reader_a_select(self, cascade_level:int) -> int:
+        ret = FM175XX_ERR
+        outbuf = [0] * 7
+        inbuf = [0]
+        cmd = Fm175xxCmdMetaData()
+
+        if(cascade_level > 2):
+            return FM175XX_PARAM_ERR
+
+        cmd.send_crc_en = FM175XX_SET
+        cmd.recv_crc_en = FM175XX_SET
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        cmd.send_buff[0] = FM175XX_RF_CMD_SELECT[cascade_level]
+        cmd.send_buff[1] = 0x70
+        cmd.send_buff[2] = self.__picc_a.UID[4 * cascade_level + 0]
+        cmd.send_buff[3] = self.__picc_a.UID[4 * cascade_level + 1]
+        cmd.send_buff[4] = self.__picc_a.UID[4 * cascade_level + 2]
+        cmd.send_buff[5] = self.__picc_a.UID[4 * cascade_level + 3]
+        cmd.send_buff[6] = self.__picc_a.BCC[cascade_level]
+        cmd.bytes_to_send = 7
+        cmd.bits_to_send = 0
+        cmd.bits_to_recv = 0
+        cmd.bytes_to_recv = 1
+        cmd.timeout = 10
+        cmd.cmd = FM175XX_CMD_TRANSCEIVE
+        result = self.__command_exe(cmd)
+        ret = result.err_code
+
+        if (result.err_code == FM175XX_OK):
+            if (result.out_param.bytes_recved == 1):
+                self.__picc_a.SAK[cascade_level] = result.out_param.recv_buff[0]
+            else:
+                ret = FM175XX_CARD_COMM_ERR
+
+        return ret
+
+    # Reader-A: halt
+    def __reader_a_halt(self) -> int:
+        outbuf = [0] * 2
+        inbuf = [0] * 2
+        cmd = Fm175xxCmdMetaData()
+
+        cmd.send_crc_en = FM175XX_SET
+        cmd.recv_crc_en = FM175XX_SET
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        cmd.send_buff[0] = FM175XX_RF_CMD_HALT[0]
+        cmd.send_buff[1] = FM175XX_RF_CMD_HALT[1]
+        cmd.bytes_to_send = 2
+        cmd.bits_to_send = 0
+        cmd.bits_to_recv = 0
+        cmd.bytes_to_recv = 0
+        cmd.timeout = 10
+        cmd.cmd = FM175XX_CMD_TRANSCEIVE
+        result = self.__command_exe(cmd)
+
+        # If there is no response within 1ms, the 'halt' is successful
+        if (result.err_code == FM175XX_CARD_TIMER_ERR):
+            result.err_code = FM175XX_OK
+        else:
+            result.err_code = FM175XX_CARD_HALT_ERR
+
+        return result.err_code
+
+    # Reader-A: activate a picc
+    def __reader_a_activate(self) -> int:
+        ret = FM175XX_ERR
+        cascade_level = 0
+
+        ret = self.__reader_a_wakeup()
+        if (FM175XX_OK != ret):
+            logging.info("wakeup err: %d", ret)
+            return FM175XX_CARD_WAKEUP_ERR
+
+        if ((self.__picc_a.ATQA[0] & 0xC0) == 0x00):
+            cascade_level = 1
+        elif ((self.__picc_a.ATQA[0] & 0xC0) == 0x40):
+            cascade_level = 2
+        elif ((self.__picc_a.ATQA[0] & 0xC0) == 0x80):
+            cascade_level = 3
+        else:
+            pass  # RFU
+
+        for i in range(cascade_level):
+            self.__picc_a.CASCADE_LEVEL = i
+            ret = self.__reader_a_anticoll(self.__picc_a.CASCADE_LEVEL)
+            if (FM175XX_OK != ret):
+                ret = FM175XX_CARD_COLL_ERR
+                break
+            ret = self.__reader_a_select(self.__picc_a.CASCADE_LEVEL)
+            if (FM175XX_OK != ret):
+                ret = FM175XX_CARD_SELECT_ERR
+                break
+
+        return ret
+
+    # Reader-A: M1 authentication
+    def __reader_a_mifare_auth(self, mode:int, sector:int, mifare_key:list, card_uid:list) -> int:
+        ret = FM175XX_ERR
+        reg_data = 0
+        outbuf = [0] * 12
+        inbuf = [0] * 1
+        cmd = Fm175xxCmdMetaData()
+
+        cmd.send_crc_en = FM175XX_SET
+        cmd.recv_crc_en = FM175XX_SET
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        if (FM175XX_M1_CARD_AUTH_MODE_A == mode):
+            cmd.send_buff[0] = 0x60
+        else:
+            cmd.send_buff[0] = 0x61
+        cmd.send_buff[1] = sector * 4
+        cmd.send_buff[2] = mifare_key[0]
+        cmd.send_buff[3] = mifare_key[1]
+        cmd.send_buff[4] = mifare_key[2]
+        cmd.send_buff[5] = mifare_key[3]
+        cmd.send_buff[6] = mifare_key[4]
+        cmd.send_buff[7] = mifare_key[5]
+        cmd.send_buff[8] = card_uid[0]
+        cmd.send_buff[9] = card_uid[1]
+        cmd.send_buff[10] = card_uid[2]
+        cmd.send_buff[11] = card_uid[3]
+        cmd.bytes_to_send = 12
+        cmd.bits_to_send = 0
+        cmd.bits_to_recv = 0
+        cmd.bytes_to_recv = 0
+        cmd.timeout = 10
+        cmd.cmd = FM175XX_CMD_MF_AUTHENT
+        result = self.__command_exe(cmd)
+        ret = result.err_code
+        if (FM175XX_OK == result.err_code):
+            reg_data = self.__register_read(FM175XX_STATUS_2_REG)
+            if (reg_data & 0x08):
+                ret =  FM175XX_OK
+            else:
+                ret =  FM175XX_CARD_COMM_ERR
+
+        return ret
+
+    # Reader-A: M1, read a block
+    def __reader_a_m1_block_read(self, block:int) -> Fm175xxReturnVal:
+        outbuf = [0] * 2
+        inbuf = [0] * 16
+        cmd = Fm175xxCmdMetaData()
+        ret = Fm175xxReturnVal()
+
+        cmd.send_crc_en = FM175XX_SET
+        cmd.recv_crc_en = FM175XX_SET
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        cmd.send_buff[0] = 0x30
+        cmd.send_buff[1] = block
+        cmd.bytes_to_send = 2
+        cmd.bits_to_send = 0
+        cmd.bits_to_recv = 0
+        cmd.bytes_to_recv = 16
+        cmd.timeout = 10
+        cmd.cmd = FM175XX_CMD_TRANSCEIVE
+        result = self.__command_exe(cmd)
+        ret.err_code = result.err_code
+
+        if (FM175XX_OK == result.err_code):
+            if (result.out_param.bytes_recved == 16):
+                ret.out_param = result.out_param.recv_buff[0:16]
+            else:
+                ret.err_code = FM175XX_CARD_COMM_ERR
+
+        return ret
+
+    # Reader-A: M1, write a block
+    def __reader_a_m1_block_write(self, block:int, buff:list) -> int:
+        ret = 0
+        outbuf = [0] * 16
+        inbuf = [0] * 1
+        cmd = Fm175xxCmdMetaData()
+
+        cmd.send_crc_en = FM175XX_SET
+        cmd.recv_crc_en = FM175XX_RESET
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        cmd.send_buff = outbuf
+        cmd.recv_buff = inbuf
+        cmd.send_buff[0] = 0xA0
+        cmd.send_buff[1] = block
+        cmd.bytes_to_send = 2
+        cmd.bits_to_send = 0
+        cmd.bits_to_recv = 0
+        cmd.bytes_to_recv = 1
+        cmd.timeout = 10
+        cmd.cmd = FM175XX_CMD_TRANSCEIVE
+        result = self.__command_exe(cmd)
+        ret = result.err_code
+
+        if ((result.err_code != FM175XX_OK) or (result.out_param.bits_recved != 4) or (result.out_param.recv_buff[0] & 0x0F != 0x0A)):
+            if (result.err_code == FM175XX_OK):
+                ret = FM175XX_CARD_COMM_ERR
+        else:
+            self.__set_timeout(10)
+            cmd.send_buff[0:16] = buff[0:16]
+            cmd.bytes_to_send = 16
+            cmd.bytes_to_recv = 1
+            cmd.cmd = FM175XX_CMD_TRANSCEIVE
+            result = self.__command_exe(cmd)
+            ret = result.err_code
+
+            if ((result.out_param.bits_recved != 4) or (result.out_param.recv_buff[0] & 0x0F != 0x0A)):
+                ret = FM175XX_CARD_COMM_ERR
+
+        return ret
+
+    # Reader-A: M1, read all data
+    def __reader_a_m1_read_all_data(self, uid:list, auth_mode:int, auth_key:list, retry_times = 3) -> Fm175xxReturnVal:
+        ret = Fm175xxReturnVal()
+        card_data_tmp = [0] * FM175XX_M1_CARD_EEPROM_SIZE
+        area = 0
+
+        # Traverse all sectors
+        for sector_no in range(FM175XX_M1_CARD_SECTORS):
+            # Authentication
+            result = FM175XX_ERR
+            for retry in range(retry_times):
+                result = self.__reader_a_mifare_auth(auth_mode, sector_no, auth_key[sector_no], uid)
+                if (result == FM175XX_OK):
+                    break
+            if (FM175XX_OK != result):
+                ret.err_code = FM175XX_CARD_AUTH_ERR
+                logging.info( "------ M1 AUTH ERROR------\r\n" )
+                return ret
+
+            # Traverse all blocks
+            for block_no in range(FM175XX_M1_CARD_BLOCKS_PER_SEC - 1):
+                result = Fm175xxReturnVal()
+                for retry in range(retry_times):
+                    result = self.__reader_a_m1_block_read(sector_no * FM175XX_M1_CARD_BLOCKS_PER_SEC + block_no)
+                    if (result.err_code == FM175XX_OK):
+                        break
+                if (result.err_code != FM175XX_OK):
+                    ret.err_code = FM175XX_CARD_READ_ERR
+                    return ret
+
+                area = FM175XX_M1_CARD_BYTES_PER_BLK * (sector_no * FM175XX_M1_CARD_BLOCKS_PER_SEC + block_no)
+                card_data_tmp[area : area + FM175XX_M1_CARD_BYTES_PER_BLK] = result.out_param[0 : FM175XX_M1_CARD_BYTES_PER_BLK]
+
+            area = sector_no * FM175XX_M1_CARD_BYTES_PER_SEC + 3 * FM175XX_M1_CARD_BYTES_PER_BLK
+            card_data_tmp[area : area + FM175XX_M1_CARD_BYTES_PER_BLK] = \
+                    self._hkdf_key_a[sector_no] + FM175XX_M1_CARD_ACCESS_CODE + self._hkdf_key_b[sector_no]
+
+        ret.err_code = FM175XX_OK
+        ret.out_param = card_data_tmp
+        return ret
+
+    def __bg_thread(self):
+        time.sleep(0.1)
+        self.__select_fm175xx_obj(FM175XX_CHANNEL_1)
+        time.sleep(0.05)
+        ver = self.__register_read(FM175XX_VERSION_REG)
+        logging.info("fm175xx[extra] version = 0x%X", ver)
+        self.__select_fm175xx_obj(FM175XX_CHANNEL_3)
+        time.sleep(0.05)
+        ver = self.__register_read(FM175XX_VERSION_REG)
+        logging.info("fm175xx[soc] version = 0x%X", ver)
+
+        while 1:
+            if self.__need_to_shutdown :
+                self.__need_to_shutdown = False
+                break
+
+            retry_times_1 = 3
+            retry_times_2 = 5
+            retry_times_3 = 3
+            if (self.__self_test_stage == FM175XX_SELF_TEST_STAGE_READY):
+                self.__card_info_read_flag = (1 << self.__self_test_channel)
+                self.__card_info_clear_flag = 0
+                retry_times_1 = self.__self_test_times
+                retry_times_2 = 1
+                retry_times_3 = 1
+                self.__self_test_stage = FM175XX_SELF_TEST_STAGE_DOING
+
+            # Traverse all channels
+            for ch in range(FM175XX_CHANNEL_NUMS):
+                if (self.__card_info_read_flag & (1 << ch)) == 0:
+                    if (self.__card_info_clear_flag & (1 << ch)) != 0:
+                        if (self.__card_info_deal_cb != None):
+                            self.__card_info_deal_cb(ch, FM175XX_CARD_INFO_CLEAR, FM175XX_OK, None, None)
+                            self.__card_info_clear_flag &= ~(1 << ch) & 0xFFFFFFFF
+                    continue
+
+                card_op = FM175XX_CARD_INFO_READ
+                card_op_result = FM175XX_ERR
+                card_type = FM175XX_MIFARE_CARD_TYPE_UNKNOWN
+                card_data = None
+
+                self.__select_fm175xx_obj(ch)
+                self.__select_channel(ch)
+
+                for retry_1 in range(retry_times_1):
+                    # init reader-A
+                    self.__picc_a.reset()
+                    self.__reader_a_init()
+
+                    # enable carrier wave
+                    self.__set_carrier_wave(FM175XX_CW_ENABLE)
+
+                    while 1:
+                        # activate a card
+                        ret = FM175XX_ERR
+
+                        for retry_2 in range(retry_times_2):
+                            ret = self.__reader_a_activate()
+                            if (FM175XX_OK == ret):
+                                break
+                        if (FM175XX_OK != ret):
+                            logging.error("Activate M1 card err, ret = %d", ret)
+                            card_op_result = FM175XX_CARD_ACTIVATE_ERR
+                            break
+
+                        try:
+                            ikm = copy.copy(self.__picc_a.UID[0:4])
+                            ikm = bytearray(ikm)
+                            self._hkdf_key_a = self._hkdf_create_key(ikm,
+                                                    FM175XX_M1_CARD_HKDF_SALT_KEY_A,
+                                                    'a')
+                            self._hkdf_key_b = self._hkdf_create_key(ikm,
+                                                    FM175XX_M1_CARD_HKDF_SALT_KEY_B,
+                                                    'b')
+                        except:
+                            logging.error("nfc hkdf error!")
+                            break
+
+                        # read all info
+                        # M1 card
+                        if (FM175XX_MIFARE_CARD_TYPE_M1 == self.__picc_a.SAK[0]):
+                            card_type = FM175XX_MIFARE_CARD_TYPE_M1
+                            ret = self.__reader_a_m1_read_all_data(self.__picc_a.UID,
+                                                                   FM175XX_M1_CARD_AUTH_MODE_A,
+                                                                   self._hkdf_key_a,
+                                                                   retry_times_3)
+                            if (FM175XX_OK != ret.err_code):
+                                card_op_result = FM175XX_CARD_READ_ERR
+                            else:
+                                card_data = ret.out_param[0:FM175XX_M1_CARD_EEPROM_SIZE]
+                                card_op_result = FM175XX_OK
+
+                                if (self.__self_test_stage != FM175XX_SELF_TEST_STAGE_DOING):
+                                    self.__card_info_read_flag &= ~(1 << ch) & 0xFFFFFFFF
+                                else:
+                                    self.__self_test_success_cnt += 1
+                                    if (self.__card_info_deal_cb != None):
+                                        self.__card_info_deal_cb(ch, card_op, card_op_result, card_type, card_data)
+                        break
+
+                    # halt a card
+                    self.__reader_a_halt()
+
+                    # disable carrier wave
+                    self.__set_carrier_wave(FM175XX_CW_DISABLE)
+
+                    if (self.__card_info_read_flag & (1 << ch)) == 0:
+                        break
+                    else:
+                        time.sleep(0.02)
+
+                if (self.__self_test_stage == FM175XX_SELF_TEST_STAGE_DOING):
+                    self.__self_test_stage = FM175XX_SELF_TEST_STAGE_STOP
+                else:
+                    if (self.__card_info_deal_cb != None):
+                        self.__card_info_deal_cb(ch, card_op, card_op_result, card_type, card_data)
+
+                self.__card_info_read_flag &= ~(1 << ch) & 0xFFFFFFFF
+
+            time.sleep(0.2)
+
+    def _hkdf_create_key(self, ikm, salt, key_type='a'):
+        sector_count = 16
+        key_len = 6
+        hash_algo = hashlib.sha256
+
+        if not isinstance(ikm, bytes):
+            ikm = bytes(ikm)
+        if not isinstance(salt, bytes):
+            salt = salt.encode() if isinstance(salt, str) else bytes(salt)
+        if salt.endswith(b'\0'):
+            salt = salt[:-1]
+
+        keys = []
+        prk = hmac.new(salt, ikm, hash_algo).digest()
+        for i in range(sector_count):
+            info = f"key_{key_type}_{i}".encode()
+            okm = bytearray()
+            counter = 1
+            while len(okm) < key_len:
+                data = hmac.new(prk, info + bytes([counter]), hash_algo).digest()
+                okm.extend(data)
+                counter += 1
+            okm_list = [int(byte) for byte in okm[:key_len]]
+            keys.append(okm_list)
+
+        return keys
+
+    # Register a callback function for protocol parsing
+    def register_cb_2_card_info_deal(self, cb) -> None:
+        try:
+            if callable(cb):
+                self.__card_info_deal_cb = cb
+            else:
+                raise TypeError()
+        except Exception as e:
+            logging.error("Param[cb] is not a callable function")
+
+    def request_read_card_info(self, channel):
+        self.__card_info_clear_flag &= ~(1 << channel) & 0xFFFFFFFF
+        self.__card_info_read_flag |= (1 << channel)
+
+    def request_clear_card_info(self, channel):
+        self.__card_info_read_flag &= ~(1 << channel) & 0xFFFFFFFF
+        self.__card_info_clear_flag |= (1 << channel)
+
+    def self_test(self, channel, times):
+        if (channel < 0 or channel > FM175XX_CHANNEL_NUMS):
+            logging.info("invalid channel[%d]", channel)
+            return
+
+        if (self.__self_test_stage != FM175XX_SELF_TEST_STAGE_STOP):
+            logging.info("self testing....")
+            return
+
+        if times < 1 :
+            times = 1
+
+        self.__self_test_channel = channel
+        self.__self_test_times = times
+        self.__self_test_success_cnt = 0
+        self.__self_test_stage = FM175XX_SELF_TEST_STAGE_READY
+
+    def self_test_result(self):
+        finish_flag = False
+        if (self.__self_test_stage == FM175XX_SELF_TEST_STAGE_STOP):
+            finish_flag = True
+        return finish_flag, self.__self_test_times, self.__self_test_success_cnt
+
+def load_config(config):
+      return FM175XXReader(config)
+
--- a/klippy/extras/gcode_move.py
+++ b/klippy/extras/gcode_move.py
@@ -3,7 +3,7 @@
 # Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
+import logging, copy
 
 class GCodeMove:
     def __init__(self, config):
@@ -43,12 +43,14 @@ class GCodeMove:
         self.last_position = [0.0, 0.0, 0.0, 0.0]
         self.homing_position = [0.0, 0.0, 0.0, 0.0]
         self.speed = 25.
-        self.speed_factor = 1. / 60.
+        self.speed_factor = self.speed_factor_bak = 1. / 60.
         self.extrude_factor = 1.
         # G-Code state
         self.saved_states = {}
         self.move_transform = self.move_with_transform = None
         self.position_with_transform = (lambda: [0., 0., 0., 0.])
+        wh = self.printer.lookup_object('webhooks')
+        wh.register_endpoint("control/print_speed", self.handle_control_print_speed)
     def _handle_ready(self):
         self.is_printer_ready = True
         if self.move_transform is None:
@@ -112,6 +114,7 @@ class GCodeMove:
     # G-Code movement commands
     def cmd_G1(self, gcmd):
         # Move
+        delta_e = 0
         params = gcmd.get_command_parameters()
         try:
             for pos, axis in enumerate('XYZ'):
@@ -127,24 +130,39 @@ class GCodeMove:
                 v = float(params['E']) * self.extrude_factor
                 if not self.absolute_coord or not self.absolute_extrude:
                     # value relative to position of last move
+                    delta_e = v
                     self.last_position[3] += v
                 else:
                     # value relative to base coordinate position
+                    delta_e = v - self.last_position[3]
                     self.last_position[3] = v + self.base_position[3]
             if 'F' in params:
                 gcode_speed = float(params['F'])
                 if gcode_speed <= 0.:
-                    raise gcmd.error("Invalid speed in '%s'"
-                                     % (gcmd.get_commandline(),))
+                    error = '{"coded": "0003-0529-0000-0013", "msg":"%s"}' % ("Invalid speed in '{}'".format(gcmd.get_commandline()))
+                    raise gcmd.error(error)
+                    # raise gcmd.error("Invalid speed in '%s'"
+                    #                  % (gcmd.get_commandline(),))
                 self.speed = gcode_speed * self.speed_factor
         except ValueError as e:
-            raise gcmd.error("Unable to parse move '%s'"
-                             % (gcmd.get_commandline(),))
+            error = '{"coded": "0003-0529-0000-0014", "msg":"%s"}' % ("Unable to parse move '%s'" % (gcmd.get_commandline(),))
+            raise gcmd.error(error)
+            # raise gcmd.error("Unable to parse move '%s'"
+            #                  % (gcmd.get_commandline(),))
+        toolhead = self.printer.lookup_object('toolhead')
+        extruder = toolhead.get_extruder()
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats is not None and print_stats.state == 'printing':
+            extruder.printing_e_pos += delta_e
+            if extruder.printing_e_pos > 0:
+                extruder.printing_e_pos = 0
         self.move_with_transform(self.last_position, self.speed)
     # G-Code coordinate manipulation
     def cmd_G20(self, gcmd):
         # Set units to inches
-        raise gcmd.error('Machine does not support G20 (inches) command')
+        error = '{"coded": "0003-0529-0000-0015", "msg":"%s"}' % ("Machine does not support G20 (inches) command")
+        raise gcmd.error(error)
+        # raise gcmd.error('Machine does not support G20 (inches) command')
     def cmd_G21(self, gcmd):
         # Set units to millimeters
         pass
@@ -170,15 +188,57 @@ class GCodeMove:
                 self.base_position[i] = self.last_position[i] - offset
         if offsets == [None, None, None, None]:
             self.base_position = list(self.last_position)
+        toolhead = self.printer.lookup_object('toolhead')
+        toolhead.get_extruder().printing_e_pos = 0
     def cmd_M114(self, gcmd):
         # Get Current Position
         p = self._get_gcode_position()
         gcmd.respond_raw("X:%.3f Y:%.3f Z:%.3f E:%.3f" % tuple(p))
+    def handle_control_print_speed(self, web_request):
+        try:
+            old_speed_factor = self.speed_factor
+            old_speed_factor_bak = self.speed_factor_bak
+            value = web_request.get_float('S', 100) / (60. * 100.)
+            self.speed = self._get_gcode_speed() * value
+            self.speed_factor = self.speed_factor_bak = value
+            web_request.send({'state': 'success'})
+            virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+            if virtual_sdcard is not None and (self.speed_factor != old_speed_factor or
+                                              self.speed_factor_bak != old_speed_factor_bak):
+                virtual_sdcard.record_pl_print_flow_and_speed_factor({
+                    'speed_factor': self.speed_factor,
+                    'speed_factor_bak': self.speed_factor_bak
+                })
+        except Exception as e:
+            logging.error(f'failed to set print speed: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
     def cmd_M220(self, gcmd):
         # Set speed factor override percentage
-        value = gcmd.get_float('S', 100., above=0.) / (60. * 100.)
-        self.speed = self._get_gcode_speed() * value
-        self.speed_factor = value
+        params = gcmd.get_command_parameters()
+        old_speed_factor = self.speed_factor
+        old_speed_factor_bak = self.speed_factor_bak
+
+        if 'R' in params:
+            value = self.speed_factor_bak
+            self.speed = self._get_gcode_speed() * value
+            self.speed_factor = self.speed_factor_bak
+
+        if 'B' in params:
+            self.speed_factor_bak = old_speed_factor
+
+        if 'S' in params:
+            value = gcmd.get_float('S', 100., above=0.) / (60. * 100.)
+            self.speed = self._get_gcode_speed() * value
+            self.speed_factor = value
+
+        virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+        if virtual_sdcard is not None and ('S' in params or 'R' in params or 'B' in params):
+            if (self.speed_factor != old_speed_factor or
+                self.speed_factor_bak != old_speed_factor_bak):
+                virtual_sdcard.record_pl_print_flow_and_speed_factor({
+                    'speed_factor': self.speed_factor,
+                    'speed_factor_bak': self.speed_factor_bak
+                })
     def cmd_M221(self, gcmd):
         # Set extrude factor override percentage
         new_extrude_factor = gcmd.get_float('S', 100., above=0.) / 100.
@@ -186,6 +246,9 @@ class GCodeMove:
         e_value = (last_e_pos - self.base_position[3]) / self.extrude_factor
         self.base_position[3] = last_e_pos - e_value * new_extrude_factor
         self.extrude_factor = new_extrude_factor
+        virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+        if virtual_sdcard is not None:
+            virtual_sdcard.record_pl_print_flow_and_speed_factor({'flow_factor': self.extrude_factor})
     cmd_SET_GCODE_OFFSET_help = "Set a virtual offset to g-code positions"
     def cmd_SET_GCODE_OFFSET(self, gcmd):
         move_delta = [0., 0., 0., 0.]
@@ -208,7 +271,12 @@ class GCodeMove:
             self.move_with_transform(self.last_position, speed)
     cmd_SAVE_GCODE_STATE_help = "Save G-Code coordinate state"
     def cmd_SAVE_GCODE_STATE(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead')
         state_name = gcmd.get('NAME', 'default')
+        gcode_id = None
+        extruder = toolhead.get_extruder()
+        if hasattr(extruder, 'gcode_id'):
+            gcode_id = extruder.gcode_id
         self.saved_states[state_name] = {
             'absolute_coord': self.absolute_coord,
             'absolute_extrude': self.absolute_extrude,
@@ -217,7 +285,13 @@ class GCodeMove:
             'homing_position': list(self.homing_position),
             'speed': self.speed, 'speed_factor': self.speed_factor,
             'extrude_factor': self.extrude_factor,
+            'accel': toolhead.max_accel,
+            'gcode_id': gcode_id
         }
+        fan_set = self.printer.lookup_object('fan', None)
+        if fan_set is not None:
+            self.saved_states[state_name]['fan_speed_dict'] = fan_set.get_all_fan_speed()
+
     cmd_RESTORE_GCODE_STATE_help = "Restore a previously saved G-Code state"
     def cmd_RESTORE_GCODE_STATE(self, gcmd):
         state_name = gcmd.get('NAME', 'default')
@@ -225,21 +299,40 @@ class GCodeMove:
         if state is None:
             raise gcmd.error("Unknown g-code state: %s" % (state_name,))
         # Restore state
+        fan_set = self.printer.lookup_object('fan', None)
+        if fan_set is not None:
+            try:
+                fan_set.resume_all_fan_speed(copy.deepcopy(state['fan_speed_dict']))
+            except Exception as e:
+                logging.error(f'failed to restore fan speed: {str(e)}')
         self.absolute_coord = state['absolute_coord']
         self.absolute_extrude = state['absolute_extrude']
-        self.base_position = list(state['base_position'])
-        self.homing_position = list(state['homing_position'])
+        # self.base_position = list(state['base_position'])
+        # self.homing_position = list(state['homing_position'])
         self.speed = state['speed']
         self.speed_factor = state['speed_factor']
         self.extrude_factor = state['extrude_factor']
+        toolhead = self.printer.lookup_object('toolhead')
         # Restore the relative E position
         e_diff = self.last_position[3] - state['last_position'][3]
         self.base_position[3] += e_diff
         # Move the toolhead back if requested
         if gcmd.get_int('MOVE', 0):
             speed = gcmd.get_float('MOVE_SPEED', self.speed, above=0.)
-            self.last_position[:3] = state['last_position'][:3]
+            accel = gcmd.get_float('MOVE_ACCEL', state['accel'], above=0.)
+            extrude = gcmd.get_float('EXTRUDE', 0., minval=0., maxval=20.)
+            toolhead.max_accel = accel
+            toolhead._calc_junction_deviation()
+            self.last_position[0] = state['last_position'][0] - state['base_position'][0] + self.base_position[0]
+            self.last_position[1] = state['last_position'][1] - state['base_position'][1] + self.base_position[1]
+            self.last_position[2] = state['last_position'][2] - state['base_position'][2] + self.base_position[2]
+            self.move_with_transform(self.last_position, speed)
+            self.last_position[3] += extrude
             self.move_with_transform(self.last_position, speed)
+            toolhead.max_accel = state['accel']
+            toolhead._calc_junction_deviation()
+        else:
+            toolhead.set_accel(state['accel'])
     cmd_GET_POSITION_help = (
         "Return information on the current location of the toolhead")
     def cmd_GET_POSITION(self, gcmd):
--- a/klippy/extras/heater_bed.py
+++ b/klippy/extras/heater_bed.py
@@ -3,6 +3,7 @@
 # Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
+import logging
 
 class PrinterHeaterBed:
     def __init__(self, config):
@@ -15,11 +16,27 @@ class PrinterHeaterBed:
         gcode = self.printer.lookup_object('gcode')
         gcode.register_command("M140", self.cmd_M140)
         gcode.register_command("M190", self.cmd_M190)
+        wh = self.printer.lookup_object('webhooks')
+        wh.register_endpoint("control/bed_temp", self._handle_control_bed_temp)
+    def _set_bed_temp(self, temp, wait=False):
+        pheaters = self.printer.lookup_object('heaters')
+        pheaters.set_temperature(self.heater, temp, wait)
+    # webhook interface
+    def _handle_control_bed_temp(self, web_request):
+        """Handle bed temperature setting request"""
+        try:
+            temp = web_request.get_float('S', 0.)
+            if temp < 0:
+                temp = 0
+            self._set_bed_temp(temp)
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to set bed temp: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
     def cmd_M140(self, gcmd, wait=False):
         # Set Bed Temperature
         temp = gcmd.get_float('S', 0.)
-        pheaters = self.printer.lookup_object('heaters')
-        pheaters.set_temperature(self.heater, temp, wait)
+        self._set_bed_temp(temp, wait)
     def cmd_M190(self, gcmd):
         # Set Bed Temperature and Wait
         self.cmd_M140(gcmd, wait=True)
--- a/klippy/extras/heater_fan.py
+++ b/klippy/extras/heater_fan.py
@@ -10,6 +10,7 @@ PIN_MIN_TIME = 0.100
 class PrinterHeaterFan:
     def __init__(self, config):
         self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
         self.printer.load_object(config, 'heaters')
         self.printer.register_event_handler("klippy:ready", self.handle_ready)
         self.heater_names = config.getlist("heater", ("extruder",))
@@ -17,26 +18,109 @@ class PrinterHeaterFan:
         self.heaters = []
         self.fan = fan.Fan(config, default_shutdown_speed=1.)
         self.fan_speed = config.getfloat("fan_speed", 1., minval=0., maxval=1.)
+        self.min_speed = config.getfloat("min_speed", 0., minval=0., maxval=1.)
+        self.probe_speed = config.getfloat("probe_speed", self.fan_speed, minval=0., maxval=1.)
+        self.temp_speed_table = config.getlists('temp_speed_table', None, seps=(',', '\n'), count=5, parser=float)
+        self.original_fan_speed = None
         self.last_speed = 0.
+        self.fan_timer = None
+
+        # Register SET_HEATER_FAN command
+        gcode = self.printer.lookup_object('gcode')
+        self.fan_name = config.get_name().split()[1]
+        gcode.register_mux_command("SET_HEATER_FAN", "FAN", self.fan_name,
+                                 self.cmd_SET_HEATER_FAN,
+                                 desc=self.cmd_SET_HEATER_FAN_help)
+        gcode.register_mux_command("SET_PROBE_FAN", "FAN", self.fan_name,
+                                 self.cmd_SET_PROBE_FAN,
+                                 desc=self.cmd_SET_PROBE_FAN_help)
+        gcode.register_mux_command("RESTORE_FAN", "FAN", self.fan_name,
+                                 self.cmd_RESTORE_FAN,
+                                 desc=self.cmd_RESTORE_FAN_help)
+        self.printer.register_event_handler("inductance_coil:probe_start", self._handle_probe_start)
+        self.printer.register_event_handler("inductance_coil:probe_end", self._handle_probe_end)
     def handle_ready(self):
         pheaters = self.printer.lookup_object('heaters')
         self.heaters = [pheaters.lookup_heater(n) for n in self.heater_names]
         reactor = self.printer.get_reactor()
-        reactor.register_timer(self.callback, reactor.monotonic()+PIN_MIN_TIME)
+        self.fan_timer = reactor.register_timer(self.callback, reactor.monotonic()+PIN_MIN_TIME)
     def get_status(self, eventtime):
         return self.fan.get_status(eventtime)
+    def set_probe_speed(self):
+        if self.original_fan_speed is None:
+            self.original_fan_speed = self.fan_speed
+        self.fan_speed = self.probe_speed
+        self.last_speed = -1  # Force update in next callback
+        if self.fan_timer is not None:
+            self.reactor.update_timer(self.fan_timer, self.reactor.NOW)
+    def restore_fan_speed(self):
+        if self.original_fan_speed is not None:
+            self.fan_speed = self.original_fan_speed
+            self.original_fan_speed = None
+            self.last_speed = -1  # Force update in next callback
+            if self.fan_timer is not None:
+                self.reactor.update_timer(self.fan_timer, self.reactor.NOW)
     def callback(self, eventtime):
         speed = 0.
-        for heater in self.heaters:
-            current_temp, target_temp = heater.get_temp(eventtime)
-            if target_temp or current_temp > self.heater_temp:
-                speed = self.fan_speed
+        if self.temp_speed_table is not None:
+            for rule in self.temp_speed_table:
+                temp_threshold, target_temp_threshold, satisfied_heater_threshold, heater_count_threshold, rule_speed = rule
+                satisfied_heaters = 0
+                heater_count = 0
+                for heater in self.heaters:
+                    current_temp, target_temp = heater.get_temp(eventtime)
+                    if target_temp > 0:
+                        heater_count += 1
+                    if current_temp > temp_threshold or target_temp > target_temp_threshold:
+                        satisfied_heaters += 1
+
+                if satisfied_heaters >= satisfied_heater_threshold and heater_count >= heater_count_threshold:
+                    speed = max(self.min_speed, min(rule_speed, 1.0))
+                    break
+        else:
+            for heater in self.heaters:
+                current_temp, target_temp = heater.get_temp(eventtime)
+                if target_temp > self.heater_temp or current_temp > self.heater_temp:
+                    speed = max(self.min_speed, min(self.fan_speed, 1.0))
         if speed != self.last_speed:
             self.last_speed = speed
             curtime = self.printer.get_reactor().monotonic()
             print_time = self.fan.get_mcu().estimated_print_time(curtime)
             self.fan.set_speed(print_time + PIN_MIN_TIME, speed)
         return eventtime + 1.
+    def _handle_probe_start(self):
+        # Get current extruder name
+        cur_extruder_name = self.printer.lookup_object('toolhead').get_extruder().get_name()
+        if cur_extruder_name in self.heater_names:
+            self.set_probe_speed()
+    def _handle_probe_end(self):
+        cur_extruder_name = self.printer.lookup_object('toolhead').get_extruder().get_name()
+        if cur_extruder_name in self.heater_names:
+            self.restore_fan_speed()
+    cmd_SET_HEATER_FAN_help = "Set the speed of a heater fan (0.0 to 1.0)"
+    def cmd_SET_HEATER_FAN(self, gcmd):
+        speed = gcmd.get_float('SPEED', minval=0., maxval=1.)
+        if speed > 0 and speed < self.min_speed:
+            gcmd.respond_info("Error: Speed cannot be below minimum speed of %.0f%%"
+                           % (self.min_speed * 100,))
+            return
+        self.fan_speed = speed
+        self.last_speed = -1  # Force update in next callback
+        if self.fan_timer is not None:
+            self.reactor.update_timer(self.fan_timer, self.reactor.NOW)
+        gcmd.respond_info("%s speed set to %.0f%%" % (self.fan_name, speed * 100,))
+    cmd_SET_PROBE_FAN_help = "Set fan speed for probing"
+    def cmd_SET_PROBE_FAN(self, gcmd):
+        """Set fan speed for probing"""
+        self.set_probe_speed()
+        gcmd.respond_info("%s probe speed set to %.0f%%" % (
+            self.fan_name, self.probe_speed * 100))
+    cmd_RESTORE_FAN_help = "Restore original fan speed"
+    def cmd_RESTORE_FAN(self, gcmd):
+        """Restore original fan speed"""
+        self.restore_fan_speed()
+        gcmd.respond_info("%s speed restored to %.0f%%" % (
+            self.fan_name, self.fan_speed * 100))
 
 def load_config_prefix(config):
     return PrinterHeaterFan(config)
--- a/klippy/extras/heaters.py
+++ b/klippy/extras/heaters.py
@@ -3,7 +3,7 @@
 # Copyright (C) 2016-2020  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import os, logging, threading
+import os, logging, threading, queuefile
 import json
 
 
@@ -12,9 +12,11 @@ import json
 ######################################################################
 
 KELVIN_TO_CELSIUS = -273.15
-MAX_HEAT_TIME = 5.0
+MAX_HEAT_TIME = 7.0
 AMBIENT_TEMP = 25.
 PID_PARAM_BASE = 255.
+READ_TIME_TOL = 0.45
+MIN_UPDATE_RATIO = 0.15
 
 class Heater:
     def __init__(self, config, sensor):
@@ -25,8 +27,11 @@ class Heater:
         self.sensor = sensor
         self.min_temp = config.getfloat('min_temp', minval=KELVIN_TO_CELSIUS)
         self.max_temp = config.getfloat('max_temp', above=self.min_temp)
-        self.sensor.setup_minmax(self.min_temp, self.max_temp)
+        min_temp_overshoot = config.getfloat('min_temp_overshoot', 0, minval=0)
+        max_temp_overshoot = config.getfloat('max_temp_overshoot', 0, minval=0)
+        self.sensor.setup_minmax(self.min_temp - min_temp_overshoot, self.max_temp + max_temp_overshoot)
         self.sensor.setup_callback(self.temperature_callback)
+        self.sensor.set_read_tolerance(READ_TIME_TOL, MIN_UPDATE_RATIO)
         self.pwm_delay = self.sensor.get_report_time_delta()
         # Setup temperature checks
         self.min_extrude_temp = config.getfloat(
@@ -37,6 +42,7 @@ class Heater:
         self.can_extrude = self.min_extrude_temp <= 0. or is_fileoutput
         self.max_power = config.getfloat('max_power', 1., above=0., maxval=1.)
         self.smooth_time = config.getfloat('smooth_time', 1., above=0.)
+        self.pwm_min_set_diff = config.getfloat('pwm_min_set_diff', 0.05, above=0.)
         self.inv_smooth_time = 1. / self.smooth_time
         self.is_shutdown = False
         self.lock = threading.Lock()
@@ -49,6 +55,7 @@ class Heater:
         algos = {'watermark': ControlBangBang, 'pid': ControlPID}
         algo = config.getchoice('control', algos)
         self.control = algo(self, config)
+        self.allow_pid_calibrate = config.getboolean('allow_pid_calibrate', True)
         # Setup output heater pin
         heater_pin = config.get('heater_pin')
         ppins = self.printer.lookup_object('pins')
@@ -64,17 +71,20 @@ class Heater:
         gcode.register_mux_command("SET_HEATER_TEMPERATURE", "HEATER",
                                    short_name, self.cmd_SET_HEATER_TEMPERATURE,
                                    desc=self.cmd_SET_HEATER_TEMPERATURE_help)
+        gcode.register_mux_command("SET_PID_PROFILE", "HEATER",
+                                   short_name, self.cmd_SET_PID_PROFILE,
+                                   desc=self.cmd_SET_PID_PROFILE_help)
         self.printer.register_event_handler("klippy:shutdown",
                                             self._handle_shutdown)
     def set_pwm(self, read_time, value):
         if self.target_temp <= 0. or self.is_shutdown:
             value = 0.
         if ((read_time < self.next_pwm_time or not self.last_pwm_value)
-            and abs(value - self.last_pwm_value) < 0.05):
+            and abs(value - self.last_pwm_value) < self.pwm_min_set_diff):
             # No significant change in value - can suppress update
             return
         pwm_time = read_time + self.pwm_delay
-        self.next_pwm_time = pwm_time + 0.75 * MAX_HEAT_TIME
+        self.next_pwm_time = pwm_time + 0.5 * MAX_HEAT_TIME
         self.last_pwm_value = value
         self.mcu_pwm.set_pwm(pwm_time, value)
         #logging.debug("%s: pwm=%.3f@%.3f (from %.3f@%.3f [%.3f])",
@@ -152,9 +162,16 @@ class Heater:
             target_temp = self.target_temp
             smoothed_temp = self.smoothed_temp
             last_pwm_value = self.last_pwm_value
-        return {'temperature': round(smoothed_temp, 2), 'target': target_temp,
+        return {'temperature': round(smoothed_temp, 0), 'target': target_temp,
                 'power': last_pwm_value}
     cmd_SET_HEATER_TEMPERATURE_help = "Sets a heater temperature"
+    cmd_SET_PID_PROFILE_help = "Sets active PID profile"
+    def cmd_SET_PID_PROFILE(self, gcmd):
+        profile = gcmd.get('PROFILE', 'default')
+        if not isinstance(self.control, ControlPID):
+            raise gcmd.error("Heater is not using PID control")
+        self.control.set_pid_profile(profile)
+
     def cmd_SET_HEATER_TEMPERATURE(self, gcmd):
         temp = gcmd.get_float('TARGET', 0.)
         pheaters = self.printer.lookup_object('heaters')
@@ -188,16 +205,98 @@ class ControlBangBang:
 # Proportional Integral Derivative (PID) control algo
 ######################################################################
 
-PID_SETTLE_DELTA = 1.
-PID_SETTLE_SLOPE = .1
+PID_SETTLE_DELTA = 2.
+PID_SETTLE_SLOPE = .5
 
 class ControlPID:
     def __init__(self, heater, config):
         self.heater = heater
         self.heater_max_power = heater.get_max_power()
-        self.Kp = config.getfloat('pid_Kp') / PID_PARAM_BASE
-        self.Ki = config.getfloat('pid_Ki') / PID_PARAM_BASE
-        self.Kd = config.getfloat('pid_Kd') / PID_PARAM_BASE
+
+        # Initialize PID profiles from config
+        self.pid_profiles = {}
+        self.ignore_pid_json = config.getboolean('ignore_pid_json', False)
+        config_name = self.heater.get_name()
+        config_dir = self.heater.printer.get_snapmaker_config_dir()
+        self.json_filename = os.path.join(config_dir, config_name.replace(" ", "_") + "_pid_parameters.json")
+        heater_json_profiles = None
+        need_save_to_json = False
+        if not self.ignore_pid_json:
+            heater_json_profiles = self._load_heater_pid_profiles_from_json(self.json_filename)
+
+        for prefix in ['', 'pid2_', 'pid3_']:
+            profile = prefix[:-1] if prefix != '' else 'default'
+            has_config_profile = config.getfloat(prefix + 'pid_Kp', None) is not None
+
+            # If profile exists in JSON and JSON is enabled, try to use it
+            profile_loaded_from_json = False
+            if not self.ignore_pid_json and heater_json_profiles and profile in heater_json_profiles:
+                validated_profile = self._validate_pid_profile(heater_json_profiles[profile])
+                if validated_profile:
+                    validated_profile['Kp'] = validated_profile['Kp'] / PID_PARAM_BASE
+                    validated_profile['Ki'] = validated_profile['Ki'] / PID_PARAM_BASE
+                    validated_profile['Kd'] = validated_profile['Kd'] / PID_PARAM_BASE
+                    self.pid_profiles[profile] = validated_profile
+                    profile_loaded_from_json = True
+                else:
+                    if not self.ignore_pid_json:
+                        logging.warning("Invalid PID profile '%s' for heater '%s' in JSON file, using config values",
+                                      profile, config_name)
+                        need_save_to_json = True
+
+            if has_config_profile:
+                config_Kp = config.getfloat(prefix + 'pid_Kp')
+                config_Ki = config.getfloat(prefix + 'pid_Ki')
+                config_Kd = config.getfloat(prefix + 'pid_Kd')
+                config_full_power_threshold = config.getfloat(prefix + 'full_power_threshold', None, above=0.)
+                config_zero_power_threshold = config.getfloat(prefix + 'zero_power_threshold', None, above=0.)
+                config_settle_delta = config.getfloat(prefix + 'settle_delta', PID_SETTLE_DELTA)
+                config_settle_slope = config.getfloat(prefix + 'settle_slope', PID_SETTLE_SLOPE)
+
+                profile_data = {
+                    'Kp': config_Kp / PID_PARAM_BASE,
+                    'Ki': config_Ki / PID_PARAM_BASE,
+                    'Kd': config_Kd / PID_PARAM_BASE,
+                    'full_power_threshold': config_full_power_threshold,
+                    'zero_power_threshold': config_zero_power_threshold,
+                    'settle_delta': config_settle_delta,
+                    'settle_slope': config_settle_slope,
+                }
+
+                json_profile_data = {
+                    'Kp': config_Kp,
+                    'Ki': config_Ki,
+                    'Kd': config_Kd,
+                    'full_power_threshold': config_full_power_threshold,
+                    'zero_power_threshold': config_zero_power_threshold,
+                    'settle_delta': config_settle_delta,
+                    'settle_slope': config_settle_slope,
+                }
+
+                if not profile_loaded_from_json:
+                    self.pid_profiles[profile] = profile_data
+                    if not self.ignore_pid_json:
+                        need_save_to_json = True
+
+                if not self.ignore_pid_json:
+                    if heater_json_profiles is None:
+                        heater_json_profiles = {}
+                    heater_json_profiles[profile] = json_profile_data
+
+        if not self.pid_profiles:
+            raise config.error("No PID profiles configured")
+
+        if not self.ignore_pid_json and need_save_to_json and heater_json_profiles:
+            self._save_heater_pid_profiles_to_json(self.json_filename, heater_json_profiles)
+
+        self.current_profile = 'default'
+        self.Kp = self.pid_profiles[self.current_profile]['Kp']
+        self.Ki = self.pid_profiles[self.current_profile]['Ki']
+        self.Kd = self.pid_profiles[self.current_profile]['Kd']
+        self.full_power_threshold = self.pid_profiles[self.current_profile]['full_power_threshold']
+        self.zero_power_threshold = self.pid_profiles[self.current_profile]['zero_power_threshold']
+        self.settle_delta = self.pid_profiles[self.current_profile]['settle_delta']
+        self.settle_slope = self.pid_profiles[self.current_profile]['settle_slope']
         self.min_deriv_time = heater.get_smooth_time()
         self.temp_integ_max = 0.
         if self.Ki:
@@ -206,7 +305,106 @@ class ControlPID:
         self.prev_temp_time = 0.
         self.prev_temp_deriv = 0.
         self.prev_temp_integ = 0.
+        # logging.info("PID profile {} loaded for heater {}".format(self.current_profile, config_name))
+        # logging.info("PID parameters: Kp: %0.2f Ki: %0.2f Kd: %0.2f" % (self.Kp*PID_PARAM_BASE,
+        #                                                 self.Ki*PID_PARAM_BASE, self.Kd*PID_PARAM_BASE))
+    def _validate_pid_profile(self, profile_data):
+        if not isinstance(profile_data, dict):
+            return None
+
+        required_fields = ['Kp', 'Ki', 'Kd']
+        validated_profile = {}
+
+        for field in required_fields:
+            if field not in profile_data:
+                return None
+            try:
+                validated_profile[field] = float(profile_data[field])
+            except (ValueError, TypeError):
+                return None
+
+        optional_fields = ['full_power_threshold', 'zero_power_threshold', 'settle_delta', 'settle_slope']
+        for field in optional_fields:
+            if field in profile_data and profile_data[field] is not None:
+                try:
+                    validated_profile[field] = float(profile_data[field])
+                except (ValueError, TypeError):
+                    pass
+            else:
+                if field == 'settle_delta':
+                    validated_profile[field] = PID_SETTLE_DELTA
+                elif field == 'settle_slope':
+                    validated_profile[field] = PID_SETTLE_SLOPE
+                else:
+                    validated_profile[field] = None
+
+        return validated_profile
+
+    def _load_heater_pid_profiles_from_json(self, json_filename):
+        try:
+            if os.path.exists(json_filename):
+                with open(json_filename, 'r') as f:
+                    profiles = json.load(f)
+                    validated_profiles = {}
+                    for profile_name, profile_data in profiles.items():
+                        validated_profile = self._validate_pid_profile(profile_data)
+                        if validated_profile:
+                            validated_profiles[profile_name] = validated_profile
+                        else:
+                            config_name = self.heater.get_name()
+                            logging.warning("Invalid PID profile '%s' in JSON file '%s', skipping",
+                                           profile_name, json_filename)
+                    return validated_profiles
+        except Exception as e:
+            logging.warning("Failed to load PID profiles from JSON (%s): %s. Using config values and will recreate JSON.", json_filename, e)
+        return None
+
+    def _save_heater_pid_profiles_to_json(self, json_filename, profiles):
+        try:
+            os.makedirs(os.path.dirname(json_filename), exist_ok=True)
+            json_content = json.dumps(profiles, indent=2)
+            queuefile.async_write_file(json_filename, json_content, flush=True, safe_write=True)
+        except Exception as e:
+            logging.warning("Failed to save PID profiles to JSON (%s): %s", json_filename, e)
     def temperature_update(self, read_time, temp, target_temp):
+        # Helper method to reset PID state
+        def reset_pid_state():
+            self.prev_temp = temp
+            self.prev_temp_time = read_time
+            self.prev_temp_deriv = 0.
+            self.prev_temp_integ = 0.
+
+        # Check temperature thresholds
+        if target_temp > 0:
+            # Check if temperature is too high
+            if (self.zero_power_threshold is not None and (temp - target_temp > self.zero_power_threshold)):
+                self.heater.set_pwm(read_time, 0.)
+                # Continue updating PID state variables
+                time_diff = read_time - self.prev_temp_time
+                temp_diff = temp - self.prev_temp
+                if time_diff >= self.min_deriv_time:
+                    temp_deriv = temp_diff / time_diff
+                else:
+                    temp_deriv = (self.prev_temp_deriv * (self.min_deriv_time-time_diff)
+                                + temp_diff) / self.min_deriv_time
+                temp_err = target_temp - temp
+                temp_integ = self.prev_temp_integ + temp_err * time_diff
+                temp_integ = max(0., min(self.temp_integ_max, temp_integ))
+
+                # Store state for next measurement
+                self.prev_temp = temp
+                self.prev_temp_time = read_time
+                self.prev_temp_deriv = temp_deriv
+                self.prev_temp_integ = temp_integ
+                return
+
+            # Check if temperature is too low
+            if (self.full_power_threshold is not None and (target_temp - temp > self.full_power_threshold)):
+                self.heater.set_pwm(read_time, self.heater_max_power)
+                reset_pid_state()
+                return
+
+        # Normal PID control
         time_diff = read_time - self.prev_temp_time
         # Calculate change of temperature
         temp_diff = temp - self.prev_temp
@@ -233,14 +431,39 @@ class ControlPID:
             self.prev_temp_integ = temp_integ
     def check_busy(self, eventtime, smoothed_temp, target_temp):
         temp_diff = target_temp - smoothed_temp
-        return (abs(temp_diff) > PID_SETTLE_DELTA
-                or abs(self.prev_temp_deriv) > PID_SETTLE_SLOPE)
+        return (abs(temp_diff) > self.settle_delta
+                or abs(self.prev_temp_deriv) > self.settle_slope)
+
+    def set_pid_profile(self, profile):
+        if profile not in self.pid_profiles:
+            raise self.heater.printer.command_error(
+                "Unknown PID profile: %s" % (profile,))
+        self.current_profile = profile
+        gcode = self.heater.printer.lookup_object('gcode', None)
+        if gcode is not None:
+            gcode.respond_info("set pid profile: {}\n{}".format(profile, self.pid_profiles[profile]))
+        self.Kp = self.pid_profiles[profile]['Kp']
+        self.Ki = self.pid_profiles[profile]['Ki']
+        self.Kd = self.pid_profiles[profile]['Kd']
+        self.full_power_threshold = self.pid_profiles[self.current_profile]['full_power_threshold']
+        self.zero_power_threshold = self.pid_profiles[self.current_profile]['zero_power_threshold']
+        self.settle_delta = self.pid_profiles[self.current_profile]['settle_delta']
+        self.settle_slope = self.pid_profiles[self.current_profile]['settle_slope']
+        # Reset PID state when switching profiles
+        self.prev_temp = AMBIENT_TEMP
+        self.prev_temp_time = 0.
+        self.prev_temp_deriv = 0.
+        self.prev_temp_integ = 0.
+        self.temp_integ_max = 0.
+        if self.Ki:
+            self.temp_integ_max = self.heater_max_power / self.Ki
 
 
 ######################################################################
 # Sensor and heater lookup
 ######################################################################
-
+MAX_HEATING_EXTRUDERS = 3
+INACTIVE_EXTRUDER_TEMP_DELTA = 5.0
 class PrinterHeaters:
     def __init__(self, config):
         self.printer = config.get_printer()
@@ -251,6 +474,13 @@ class PrinterHeaters:
         self.available_sensors = []
         self.available_monitors = []
         self.has_started = self.have_load_sensors = False
+        self.active_heating_extruders = []
+        self.pending_extruders = []
+        self.max_heating_extruders = 3
+        self.reactor = self.printer.get_reactor()
+        self.heater_check_timer = None
+        self.active_heating_extruders = []
+        self.max_heating_extruders = MAX_HEATING_EXTRUDERS
         self.printer.register_event_handler("klippy:ready", self._handle_ready)
         self.printer.register_event_handler("gcode:request_restart",
                                             self.turn_off_all_heaters)
@@ -318,6 +548,10 @@ class PrinterHeaters:
                 'available_sensors': self.available_sensors,
                 'available_monitors': self.available_monitors}
     def turn_off_all_heaters(self, print_time=0.):
+        # Clear all extruder heating state
+        self.active_heating_extruders = []
+        self.pending_extruders = []
+        # Turn off all heaters
         for heater in self.heaters.values():
             heater.set_temp(0.)
     cmd_TURN_OFF_HEATERS_help = "Turn off all heaters"
@@ -326,6 +560,9 @@ class PrinterHeaters:
     # G-Code M105 temperature reporting
     def _handle_ready(self):
         self.has_started = True
+        if self.heater_check_timer is None:
+            self.heater_check_timer = self.reactor.register_timer(
+                self._check_heater_queue, self.reactor.NOW)
     def _get_temp(self, eventtime):
         # Tn:XXX /YYY B:XXX /YYY
         out = []
@@ -355,12 +592,80 @@ class PrinterHeaters:
             print_time = toolhead.get_last_move_time()
             gcode.respond_raw(self._get_temp(eventtime))
             eventtime = reactor.pause(eventtime + 1.)
+    def _check_heater_queue(self, eventtime):
+        # Check active heaters
+        self.active_heating_extruders = [
+            h for h in self.active_heating_extruders
+            if self.heaters[h].last_temp < \
+                (self.heaters[h].target_temp - INACTIVE_EXTRUDER_TEMP_DELTA)
+        ]
+
+        # Start pending heaters if slots available
+        while (self.pending_extruders and
+               len(self.active_heating_extruders) < self.max_heating_extruders):
+            heater_name, temp = self.pending_extruders.pop(0)
+            self.active_heating_extruders.append(heater_name)
+            self.heaters[heater_name].set_temp(temp)
+
+        return eventtime + 1.0
+
     def set_temperature(self, heater, temp, wait=False):
         toolhead = self.printer.lookup_object('toolhead')
         toolhead.register_lookahead_callback((lambda pt: None))
-        heater.set_temp(temp)
-        if wait and temp:
-            self._wait_for_temperature(heater)
+        heater_name = heater.get_name()
+        virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+        if virtual_sdcard is not None:
+            virtual_sdcard.record_pl_print_temperature_env({heater.short_name: temp})
+        # Only apply limit to extruder heaters
+        if not heater_name.startswith('extruder'):
+            heater.set_temp(temp)
+            if wait and temp:
+                self._wait_for_temperature(heater)
+            return
+        # Handle extruder heating
+        if temp > 0:
+            if heater_name in self.active_heating_extruders:
+                # Already heating - just update target temp
+                heater.set_temp(temp)
+                if wait:
+                    self._wait_for_temperature(heater)
+                return
+
+            if len(self.active_heating_extruders) < self.max_heating_extruders:
+                # Start heating immediately
+                self.active_heating_extruders.append(heater_name)
+                heater.set_temp(temp)
+                if wait:
+                    self._wait_for_temperature(heater)
+            else:
+                logging.info("concurrently heating %d extruders, "
+                            "waiting for %s to finish",
+                            len(self.active_heating_extruders),
+                            self.active_heating_extruders[0])
+                # Add to pending queue
+                if wait:
+                    # If waiting, block until heater is active
+                    self.pending_extruders.append((heater_name, temp))
+                    while (heater_name, temp) in self.pending_extruders:
+                        self.reactor.pause(self.reactor.monotonic() + 0.2)
+
+                    while heater_name in self.active_heating_extruders:
+                        self._wait_for_temperature(self.heaters[heater_name])
+                        self.reactor.pause(self.reactor.monotonic() + 0.2)
+                else:
+                    # Non-blocking - just add to queue
+                    self.pending_extruders.append((heater_name, temp))
+        else:
+            # Cooling down
+            if heater_name in self.active_heating_extruders:
+                logging.info("cancel active heater %s", heater_name)
+                self.active_heating_extruders.remove(heater_name)
+            for i in range(len(self.pending_extruders)):
+                if self.pending_extruders[i][0] == heater_name:
+                    logging.info("cancel pending heater %s", heater_name)
+                    del self.pending_extruders[i]
+                    break
+            heater.set_temp(temp)
     cmd_TEMPERATURE_WAIT_help = "Wait for a temperature on a sensor"
     def cmd_TEMPERATURE_WAIT(self, gcmd):
         sensor_name = gcmd.get('SENSOR')
--- a/klippy/extras/homing.py
+++ b/klippy/extras/homing.py
@@ -152,6 +152,16 @@ class HomingMove:
             if sp.start_pos == sp.trig_pos:
                 return sp.endstop_name
         return None
+    def check_all_stepper_no_movement(self):
+        if self.printer.get_start_args().get('debuginput') is not None:
+            return None
+        endstop_name = None
+        for sp in self.stepper_positions:
+            if sp.start_pos != sp.trig_pos:
+                endstop_name = None
+                break
+            endstop_name = sp.endstop_name
+        return endstop_name
 
 # State tracking of homing requests
 class Homing:
@@ -161,6 +171,7 @@ class Homing:
         self.changed_axes = []
         self.trigger_mcu_pos = {}
         self.adjust_pos = {}
+        self.gcode = self.printer.lookup_object('gcode')
     def set_axes(self, axes):
         self.changed_axes = axes
     def get_axes(self):
@@ -189,33 +200,74 @@ class Homing:
         # Perform first home
         endstops = [es for rail in rails for es in rail.get_endstops()]
         hi = rails[0].get_homing_info()
+        # Stop waiting before homing
+        if hi.homing_before_delay:
+            self.toolhead.dwell(hi.homing_before_delay)
+            self.toolhead.wait_moves()
         hmove = HomingMove(self.printer, endstops)
         hmove.homing_move(homepos, hi.speed)
         # Perform second home
         if hi.retract_dist:
-            # Retract
-            startpos = self._fill_coord(forcepos)
-            homepos = self._fill_coord(movepos)
-            axes_d = [hp - sp for hp, sp in zip(homepos, startpos)]
-            move_d = math.sqrt(sum([d*d for d in axes_d[:3]]))
-            retract_r = min(1., hi.retract_dist / move_d)
-            retractpos = [hp - ad * retract_r
-                          for hp, ad in zip(homepos, axes_d)]
-            self.toolhead.move(retractpos, hi.retract_speed)
-            # Home again
-            startpos = [rp - ad * retract_r
-                        for rp, ad in zip(retractpos, axes_d)]
-            self.toolhead.set_position(startpos)
-            hmove = HomingMove(self.printer, endstops)
-            hmove.homing_move(homepos, hi.second_homing_speed)
-            if hmove.check_no_movement() is not None:
-                raise self.printer.command_error(
-                    "Endstop %s still triggered after retract"
-                    % (hmove.check_no_movement(),))
+            trigger_mcu_stpes = []
+            cal_stepper = rails[0].get_steppers()[0]
+            rotation_dist, steps_per_rotation = cal_stepper.get_rotation_distance()
+            step_dit = rotation_dist / steps_per_rotation
+            self.toolhead.flush_step_generation()
+            trigger_mcu_pos = {sp.stepper_name: sp.trig_pos
+                        for sp in hmove.stepper_positions}
+            trigger_mcu_stpes.append(trigger_mcu_pos[cal_stepper.get_name()])
+            homing_cnt, second_homing_first, homing_success = 0, True, True
+            while ((homing_cnt < hi.homing_tolerance_retries and hi.homing_tolerance is not None) or second_homing_first):
+                second_homing_first = False
+                # Retract
+                startpos = self._fill_coord(forcepos)
+                homepos = self._fill_coord(movepos)
+                axes_d = [hp - sp for hp, sp in zip(homepos, startpos)]
+                move_d = math.sqrt(sum([d*d for d in axes_d[:3]]))
+                retract_r = min(1., hi.retract_dist / move_d)
+                retractpos = [hp - ad * retract_r
+                            for hp, ad in zip(homepos, axes_d)]
+                self.toolhead.move(retractpos, hi.retract_speed)
+                if hi.second_homing_before_delay:
+                    self.toolhead.dwell(hi.second_homing_before_delay)
+                    self.toolhead.wait_moves()
+                # Home again
+                startpos = [rp - ad * retract_r
+                            for rp, ad in zip(retractpos, axes_d)]
+                self.toolhead.set_position(startpos)
+                hmove = HomingMove(self.printer, endstops)
+                hmove.homing_move(homepos, hi.second_homing_speed)
+                if hmove.check_no_movement() is not None:
+                    error = '{"coded": "0003-0528-0000-0005", "msg":"%s"}' % ("Endstop %s still triggered after retract" % (hmove.check_no_movement(),))
+                    raise self.printer.command_error(error)
+                if hi.homing_tolerance is not None:
+                    self.toolhead.flush_step_generation()
+                    trigger_mcu_pos = {sp.stepper_name: sp.trig_pos
+                                for sp in hmove.stepper_positions}
+                    trigger_mcu_stpes.append(trigger_mcu_pos[cal_stepper.get_name()])
+                    if len(trigger_mcu_stpes) >= 2:
+                        # Compare homing trigger tolerances
+                        distance_diff = abs(max(trigger_mcu_stpes) - min(trigger_mcu_stpes))*step_dit
+                        # self.gcode.respond_info(
+                        #         "rounds: {}, trig_pos max: {}, trig_pos min: {}, distance_diff: {} homing_tolerance: {}, \ntrigger_mcu_stpes: {}".format(
+                        #         homing_cnt, max(trigger_mcu_stpes), min(trigger_mcu_stpes), distance_diff, hi.homing_tolerance, trigger_mcu_stpes))
+                        if distance_diff > hi.homing_tolerance:
+                            homing_cnt += 1
+                            if homing_cnt >= hi.homing_tolerance_retries:
+                                homing_success = False
+                            trigger_mcu_stpes = []
+                        else:
+                            if len(trigger_mcu_stpes) >= hi.homing_samples:
+                                break
+            if homing_success == False:
+                error = '{"coded": "0003-0528-0000-0006", "msg":"%s"}' % ("Homing trigger distance over tolerance")
+                raise self.printer.command_error(error)
+
         # Signal home operation complete
         self.toolhead.flush_step_generation()
         self.trigger_mcu_pos = {sp.stepper_name: sp.trig_pos
                                 for sp in hmove.stepper_positions}
+        self.gcode.respond_info("self.trigger_mcu_pos: {}".format(self.trigger_mcu_pos))
         self.adjust_pos = {}
         self.printer.send_event("homing:home_rails_end", self, rails)
         if any(self.adjust_pos.values()):
@@ -230,6 +282,13 @@ class Homing:
                 homepos[axis] = newpos[axis]
             self.toolhead.set_position(homepos)
 
+        if hi.homing_backoff_dist:
+            self.toolhead.wait_moves()
+            axis = homing_axes[0]
+            pos = self.toolhead.get_position()
+            pos[axis] = pos[axis] + hi.homing_backoff_dist
+            self.toolhead.manual_move(pos, hi.retract_speed)
+
 class PrinterHoming:
     def __init__(self, config):
         self.printer = config.get_printer()
@@ -289,6 +348,22 @@ class PrinterHoming:
             if self.printer.is_shutdown():
                 error = '{"coded": "0003-0528-0000-0007", "msg":"%s"}' % ("Homing failed due to printer shutdown")
                 raise self.printer.command_error(error)
+            can_motor_off = True
+            if 2 not in axes:
+                if ("z" in kin.get_status(0)['homed_axes']):
+                    machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+                    if machine_state_manager is not None:
+                        cur_sta = machine_state_manager.get_status()
+                        if str(cur_sta["main_state"]) == "PRINTING":
+                            can_motor_off = False
+
+            if can_motor_off:
+                self.printer.lookup_object('stepper_enable').motor_off()
+            else:
+                if hasattr(kin, "note_x_not_homed"):
+                    kin.note_x_not_homed()
+                if hasattr(kin, "note_y_not_homed"):
+                    kin.note_y_not_homed()
             raise
 
 def load_config(config):
--- /dev/null
+++ b/klippy/extras/homing_precise_corexy.py
@@ -0,0 +1,208 @@
+import math, logging
+import stepper
+from . import homing
+
+TRINAMIC_DRIVERS = ["tmc2130", "tmc2208", "tmc2209", "tmc2240", "tmc2660",
+    "tmc5160"]
+
+class HomingPreciseCorexy:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.gcode = self.printer.lookup_object('gcode')
+        if config.getsection('printer').get('kinematics') != 'corexy':
+            raise config.error("homing_precise_corexy: kinematics must be corexy!!!")
+        self.xy_back_offset = config.getfloat('xy_back_offset', 5., above=0.)
+        self.probe_before_delay = config.getfloat('diagonal_probe_before_delay', 0., minval=0)
+        self.probe_samples = config.getint('diagonal_probe_samples', 2, minval=2)
+        self.probe_tolerance = config.getfloat('diagonal_probe_tolerance', minval=0)
+        self.probe_accel = config.getfloat('diagonal_probe_accel', None, above=0.)
+        self.probe_speed = config.getfloat('diagonal_probe_speed', above=0.)
+        self.probe_retract_speed = config.getfloat('diagonal_probe_retract_speed', above=0.)
+        self.probe_tolerance_retries = config.getint('diagonal_probe_tolerance_retries', minval=0)
+        self.move_rail = config.getint('diagonal_move_rail', 1, minval=0, maxval=1)
+        sconfig = config.getsection('stepper_x')
+        rotation_dist, steps_per_rotation = stepper.parse_step_distance(sconfig)
+        self.x_step_dist = rotation_dist / steps_per_rotation
+        self.x_phases = sconfig.getint("microsteps", note_valid=False) * 4
+        sconfig = config.getsection('stepper_y')
+        rotation_dist, steps_per_rotation = stepper.parse_step_distance(sconfig)
+        self.y_step_dist = rotation_dist / steps_per_rotation
+        self.y_phases = sconfig.getint("microsteps", note_valid=False) * 4
+        self.x_tmc_module = None
+        self.y_tmc_module = None
+        self.printer.register_event_handler("klippy:connect", self.lookup_tmc)
+        self.gcode.register_command('HOMING_PRECISE_COREXY', self.cmd_HOMING_PRECISE_COREXY)
+
+    def lookup_tmc(self):
+        for driver in TRINAMIC_DRIVERS:
+            x_driver_name = "%s stepper_x" % (driver)
+            y_driver_name = "%s stepper_y" % (driver)
+            module_x = self.printer.lookup_object(x_driver_name, None)
+            module_y = self.printer.lookup_object(y_driver_name, None)
+            if module_x is not None:
+                self.x_tmc_module = module_x
+            if module_y is not None:
+                self.y_tmc_module = module_y
+
+    def check_xy_is_homing(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        homed_axes = toolhead.get_kinematics().get_status(0)['homed_axes']
+        if 'x' not in homed_axes or 'y' not in homed_axes:
+            error = '{"coded": "0002-0528-0000-0010", "msg":"%s", "action": "pause"}' % ("Corexy precise homing aborted: Must home x and y axis first")
+            raise self.printer.command_error(error)
+
+    def cal_backoff_position(self, move_offset_x, move_offset_y):
+        toolhead = self.printer.lookup_object('toolhead')
+        corexy_rails = toolhead.get_kinematics().rails
+        x_homing_info = corexy_rails[0].get_homing_info()
+        y_homing_info = corexy_rails[1].get_homing_info()
+        start_park_position_x = x_homing_info.position_endstop + [1, -1][x_homing_info.positive_dir == True]*move_offset_x
+        start_park_position_y = y_homing_info.position_endstop + [1, -1][y_homing_info.positive_dir == True]*move_offset_y
+        return start_park_position_x, start_park_position_y
+
+    def calc_position(self, a_dist, b_dist):
+        return (a_dist+b_dist)*0.5, (a_dist-b_dist)*0.5
+
+    def phase_backoff_steps(self, corexy_rails):
+        if self.x_tmc_module is None or self.y_tmc_module is None:
+            raise self.printer.command_error("stepper_x, stepper_y must use the specified tmc devices")
+        # Getting an effective direction of travel
+        x_away_from_endstop_dir = not corexy_rails[0].get_homing_info().positive_dir
+        y_away_from_endstop_dir = not corexy_rails[1].get_homing_info().positive_dir
+        x_stepper_dir_inverted = corexy_rails[0].get_steppers()[0].get_dir_inverted()[0]
+        y_stepper_dir_inverted = corexy_rails[1].get_steppers()[0].get_dir_inverted()[0]
+        x_backoff_dir = [1, -1][x_away_from_endstop_dir == False] * [-1, 1][x_stepper_dir_inverted]
+        y_backoff_dir = [1, -1][y_away_from_endstop_dir == False] * [-1, 1][y_stepper_dir_inverted]
+        # self.gcode.respond_info("###########x_phase {}, y_phase {}###########".format(self.x_tmc_module.query_phase(), self.y_tmc_module.query_phase()))
+        # Calculate the step to be moved for tmc phase alignment
+        x_backoff_step = (([1, -1][x_backoff_dir == 1]*self.x_tmc_module.query_phase()) % 1024) / (1024 / self.x_tmc_module.get_phase_offset()[1])
+        y_backoff_step = (([1, -1][y_backoff_dir == 1]*self.y_tmc_module.query_phase()) % 1024) / (1024 / self.y_tmc_module.get_phase_offset()[1])
+        return x_backoff_step, y_backoff_step
+
+    def diagonal_probe(self, rail, movepos):
+        toolhead = self.printer.lookup_object('toolhead')
+        if self.probe_before_delay:
+            toolhead.dwell(self.probe_before_delay)
+            toolhead.wait_moves()
+        endstops = rail.get_endstops()
+        hmove = homing.HomingMove(self.printer, endstops)
+        # start diagonal probe
+        epos = hmove.homing_move(movepos, self.probe_speed, True)
+        toolhead.flush_step_generation()
+        trigger_mcu_pos = {sp.stepper_name: sp.trig_pos
+                                for sp in hmove.stepper_positions}
+        return epos, trigger_mcu_pos
+
+    def cal_diagonal_dist(self, m_steps):
+        d = (abs(m_steps[0][0]) + abs(m_steps[0][1]) + abs(m_steps[1][0]) + abs(m_steps[1][1])) // 2
+        c_dist_a = (d + self.x_phases) // (2 * self.x_phases)
+        d_y = d - (abs(m_steps[0][0]) + abs(m_steps[0][1]))
+        d_y2 = abs(d_y) + self.y_phases
+        if d_y < 0:
+            d_y2 = -d_y2
+        c_dist_b = d_y2 // (2 * self.y_phases)
+        return c_dist_a, c_dist_b
+
+    def precise_corexy_coord(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        kin = toolhead.get_kinematics()
+        cur_max_accel = None
+        try:
+            # Ensure that x and y have go home before diagonally moving the probe.
+            self.check_xy_is_homing()
+            corexy_rails = toolhead.get_kinematics().rails
+            # Move to the specified position, manual_move detects if the target position is out of range
+            x_position, y_position = self.cal_backoff_position(self.xy_back_offset, self.xy_back_offset)
+            toolhead.manual_move([x_position, y_position, None], self.probe_retract_speed)
+            toolhead.wait_moves()
+            # full phase alignment
+            x_step, y_step = self.phase_backoff_steps(corexy_rails)
+            x_dist, y_dist = self.calc_position(x_step*self.x_step_dist, y_step*self.y_step_dist)
+            pos = toolhead.get_position()
+            probe_start_x, probe_start_y = pos[0]+x_dist, pos[1]+y_dist
+            toolhead.manual_move([probe_start_x, probe_start_y, None], self.probe_retract_speed)
+            toolhead.wait_moves()
+            # Calculate probe target location
+            # self.gcode.respond_info("###pos: {}, {}####".format(self.calc_position(0, 20), self.calc_position(0, -20)))
+            # If diagonal_probe_accel is valid, set the acceleration during probing
+            # TODO
+            kin.set_ignore_check_move_limit(True)
+            if self.probe_accel is not None:
+                cur_max_accel = toolhead.max_accel
+                toolhead.set_accel(self.probe_accel)
+            park_step = corexy_rails[1].get_steppers()[0].get_mcu_position()
+            probe_cnt, sample, recv_steps = 0, 0, [[], []]
+            probe_success = True
+            while probe_cnt <= self.probe_tolerance_retries:
+                x_move_position, y_move_position = self.calc_position(0, [-1, 1][sample % 2 == 0]*self.xy_back_offset*4)
+                toolhead.wait_moves()
+                # self.gcode.respond_info("###a_phase :{} b_phase:{}".format(self.x_tmc_module.query_phase(), self.y_tmc_module.query_phase()))
+                # self.gcode.respond_info("###a_stp :{} b_stp:{}".format(corexy_rails[0].get_steppers()[0].get_mcu_position(), corexy_rails[1].get_steppers()[0].get_mcu_position()))
+                pos = toolhead.get_position()
+                pos[0] = pos[0] + x_move_position
+                pos[1] = pos[1] + y_move_position
+                epos, trigger_mcu_pos = self.diagonal_probe(corexy_rails[1], pos)
+                recv_steps[[0, 1][sample % 2 == 1]].append(park_step - trigger_mcu_pos['stepper_y'])
+                # Retract
+                toolhead.manual_move([probe_start_x, probe_start_y, None], self.probe_retract_speed)
+                toolhead.wait_moves()
+                sample += 1
+
+                if len(recv_steps[1]) >= 2:
+                    if (((abs(recv_steps[0][0] - recv_steps[0][1])*self.y_step_dist) >= self.probe_tolerance) or
+                        (abs((recv_steps[1][0] - recv_steps[1][1])*self.y_step_dist) >= self.probe_tolerance)):
+                        sample = 0
+                        probe_cnt += 1
+                        self.gcode.respond_info("###{}, {}, {}####".format(abs((abs(recv_steps[0][0]) - abs(recv_steps[0][1]))*self.y_step_dist), abs((abs(recv_steps[1][0]) - abs(recv_steps[1][1]))*self.y_step_dist), recv_steps))
+                        recv_steps = [[], []]
+                        probe_success = False
+                    else:
+                        probe_success = True
+                        break
+            if probe_success == True:
+                c_dist_a, c_dist_b = self.cal_diagonal_dist(recv_steps)
+                x, y = self.calc_position(c_dist_a*self.x_phases*self.x_step_dist, c_dist_b*self.y_phases*self.y_step_dist)
+                cal_x_position, cal_y_position = self.cal_backoff_position(x, y)
+                # Check the reasonableness of the calculated data
+                if abs(cal_x_position - probe_start_x) > self.x_step_dist*self.x_phases or abs(cal_y_position - probe_start_y) > self.y_step_dist*self.y_phases:
+                    error = '{"coded": "0002-0528-0000-0011", "msg":"%s", "action": "pause"}' % ("Corexy precise homing computed coordinate anomaly")
+                    logging.info(f"Corexy precise homing: cal_x: {cal_x_position}, cal_y: {cal_y_position}, probe_x: {probe_start_x}, probe_y: {probe_start_y}")
+                    raise self.printer.command_error(error)
+                    # raise self.printer.command_error("Calculated data anomaly!!!\ncal_x: {}, cal_y: {}\nprobe_x: {}, probe_y: {}".format(
+                    #                                 cal_x_position, cal_y_position, probe_start_x, probe_start_y))
+                toolhead.wait_moves()
+                pos = toolhead.get_position()
+                pos[0], pos[1] = cal_x_position, cal_y_position
+                toolhead.set_position(pos)
+            else:
+                error = '{"coded": "0002-0528-0000-0012", "msg":"%s", "action": "pause"}' % ("Corexy precise homing failed")
+                raise self.printer.command_error(error)
+
+        except Exception as e:
+            can_motor_off = True
+            if ("z" in kin.get_status(0)['homed_axes']):
+                machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+                if machine_state_manager is not None:
+                    cur_sta = machine_state_manager.get_status()
+                    if str(cur_sta["main_state"]) == "PRINTING":
+                        can_motor_off = False
+
+            if can_motor_off:
+                self.printer.lookup_object('stepper_enable').motor_off()
+            else:
+                if hasattr(kin, "note_x_not_homed"):
+                    kin.note_x_not_homed()
+                if hasattr(kin, "note_y_not_homed"):
+                    kin.note_y_not_homed()
+            raise
+        finally:
+            kin.set_ignore_check_move_limit(False)
+            if cur_max_accel is not None:
+                toolhead.set_accel(cur_max_accel)
+
+    def cmd_HOMING_PRECISE_COREXY(self, gcmd):
+        self.precise_corexy_coord()
+
+def load_config(config):
+    return HomingPreciseCorexy(config)
\ No newline at end of file
--- /dev/null
+++ b/klippy/extras/homing_xyz_override.py
@@ -0,0 +1,477 @@
+# Run user defined actions in place of a normal G28 homing command
+# This module forces an override of the XYZ homing
+import math, logging, copy
+import stepper
+from . import homing
+
+class HomingXYZOverride:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.gcode_move = self.printer.load_object(config, 'gcode_move')
+        x_pos, y_pos = config.getfloatlist("home_xy_position", count=2)
+        self.home_x_pos, self.home_y_pos = x_pos, y_pos
+        self.z_hop = config.getfloat("z_hop", default=0.0)
+        self.z_hop_speed = config.getfloat('z_hop_speed', 10., above=0.)
+        self.z_hop_homing_accel = config.getfloat('z_hop_homing_accel', None, above=0.)
+        self.z_safe = config.getfloat("z_safe", default=self.z_hop)
+        self.z_safe_speed = config.getfloat("z_safe_speed", default=self.z_hop_speed)
+        self.speed = config.getfloat('speed', 50.0, above=0.)
+        self.start_z_pos = config.getfloat('set_position_z', 0)
+        self.safe_move_y_pos = config.getfloat("safe_move_y_pos", default=250)
+
+        # Conveniently supports using different probing speeds during homing.
+        self.z_first_probe_speed = config.getfloat('z_first_probe_speed', 5, above=0.)
+        self.z_first_probe_tolerance = config.getfloat('z_first_probe_tolerance', 0.04, minval=0.)
+        self.z_first_probe_sample_count = config.getint('z_first_probe_sample_count', 2, minval=0)
+        self.z_first_probe_retract_dist = config.getfloat('z_first_probe_retract_dist', 1, above=0.)
+
+        self.z_offset = config.getfloat('z_offset', None)
+        self.z_probe_speed = config.getfloat('z_probe_speed', None, above=0.)
+        self.z_probe_fast_speed = config.getfloat('z_probe_fast_speed', None, above=0.)
+        self.z_probe_accel = config.getfloat('z_probe_accel', None, above=0.)
+        self.z_probe_z_accel = config.getfloat('z_probe_z_accel', 100, above=0.)
+        self.z_probe_tolerance = config.getfloat('z_probe_tolerance', None, minval=0.)
+        self.probe_lift_speed = config.getfloat('z_probe_lift_speed', None, above=0.)
+        self.sample_count = config.getint('z_probe_samples', None, minval=1)
+        self.relative_trigger_freq = config.getint('z_probe_trigger_freq', None, minval=10)
+        self.sample_retract_dist = config.getfloat('z_probe_retract_dist', None, above=0.)
+        self.in_script = False
+        self.z_need_home = False
+        self.z_raised = False
+        self.is_homing = False
+        self.homing_stepper_z_info = None
+
+        # gcode override template
+        gcode_macro = self.printer.load_object(config, 'gcode_macro')
+        self.template = gcode_macro.load_template(config, 'gcode')
+        self.z_hop_homing_begin_gcode = gcode_macro.load_template(config, 'z_hop_homing_begin_gcode', '')
+        self.z_hop_homing_end_gcode = gcode_macro.load_template(config, 'z_hop_homing_end_gcode', '')
+        self.printer.load_object(config, 'homing')
+        self.gcode = self.printer.lookup_object('gcode')
+        self.prev_G28 = self.gcode.register_command("G28", None)
+        self.gcode.register_command("G28", self.cmd_G28)
+        self.printer.register_event_handler("stepper_enable:motor_off", self._motor_off)
+
+        if config.has_section("homing_override") or config.has_section("safe_z_home"):
+            raise config.error("(homing_override or safe_z_home) and homing_xyz_override cannot"
+                               +" be used simultaneously")
+
+    def _motor_off(self, print_time):
+        self.z_raised = False
+        self.homing_stepper_z_info = None
+
+    def _z_hop_move(self, z_hop, pl_save_z_hop=False):
+        toolhead = self.printer.lookup_object('toolhead')
+        curtime = self.printer.get_reactor().monotonic()
+        kin_status = toolhead.get_kinematics().get_status(curtime)
+        rail = toolhead.get_kinematics().rails[2]
+        pos = toolhead.get_position()
+        cur_max_accel = None
+        cur_z_max_accel = None
+        if 'z' not in kin_status['homed_axes'] and self.z_raised == False:
+            try:
+                # Determine movement
+                hi = rail.get_homing_info()
+                if hi.positive_dir:
+                    homepos = list(toolhead.get_position())
+                    homepos[2] = hi.position_endstop
+                    startpos = list(homepos)
+                    startpos[2] = (hi.position_endstop - z_hop)
+
+                    # Stop waiting before homing
+                    if hi.homing_before_delay:
+                        self.toolhead.dwell(hi.homing_before_delay)
+                        self.toolhead.wait_moves()
+
+                    endstops = rail.get_endstops()
+                    hmove = homing.HomingMove(self.printer, endstops)
+                    toolhead.set_position(startpos, homing_axes=[2])
+
+                    if self.z_hop_homing_accel is not None:
+                        cur_max_accel = toolhead.max_accel
+                        toolhead.set_accel(self.z_hop_homing_accel)
+
+                    if toolhead.kin is not None and toolhead.kin.max_z_accel != self.z_probe_z_accel:
+                        cur_z_max_accel = toolhead.kin.max_z_accel
+                        toolhead.kin.max_z_accel = self.z_probe_z_accel
+
+                    # start z hop move
+                    self.z_hop_homing_begin_gcode.run_gcode_from_command()
+                    hmove.homing_move(homepos, hi.speed, True, check_triggered=False)
+                    self.z_hop_homing_end_gcode.run_gcode_from_command()
+                    toolhead.flush_step_generation()
+                else:
+                    # Always perform the z_hop if the Z axis is not homed
+                    pos[2] = 0
+                    toolhead.set_position(pos, homing_axes=[2])
+                    toolhead.manual_move([None, None, z_hop], self.z_hop_speed)
+                self.z_raised = True
+                if pl_save_z_hop:
+                    virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+                    if virtual_sdcard is not None:
+                        virtual_sdcard.record_pl_print_z_adjust_position(z_hop)
+            finally:
+                if cur_max_accel is not None:
+                    toolhead.set_accel(cur_max_accel)
+                if cur_z_max_accel is not None:
+                    toolhead.kin.max_z_accel = cur_z_max_accel
+                if hasattr(toolhead.get_kinematics(), "note_z_not_homed"):
+                    toolhead.get_kinematics().note_z_not_homed()
+        elif 'z' in kin_status['homed_axes'] and pos[2] < self.z_safe:
+            # If the Z axis is homed, and below z_safe, lift it to z_safe
+            toolhead.manual_move([None, None, self.z_safe], self.z_safe_speed)
+
+    def _z_probe_pre_process(self, gcmd):
+        probe_x_pos = probe_y_pos = None
+        toolhead = self.printer.lookup_object('toolhead')
+        # Check if the current extruder has a probe sensor
+        cur_extruder = toolhead.get_extruder()
+        if (not hasattr(cur_extruder, 'binding_probe') or cur_extruder.binding_probe is None):
+            raise gcmd.error("The current extruder does not have a bound probe")
+        curtime = self.printer.get_reactor().monotonic()
+        kin_status = toolhead.get_kinematics().get_status(curtime)
+        # Do not allow Z-axis homing if X and Y axes have not been homed
+        if ('x' not in kin_status['homed_axes'] or
+            'y' not in kin_status['homed_axes']):
+            message = '{"coded": "0002-0528-0000-0000", "msg":"%s", "action": "pause"}' % ("Z homing abort: Must home X and Y axes first")
+            raise gcmd.error(message)
+        # Get the current extruder status
+        retry_extruder_id = None
+        for i in range(10):
+            activate_status = cur_extruder.get_extruder_activate_status()
+            retry_extruder_id = cur_extruder.check_allow_retry_switch_extruder()
+            if activate_status[0][1] != 2 or retry_extruder_id is not None:
+                break
+            else:
+                if i >= 9:
+                    break
+                gcmd.respond_info("Retrying to get normal extruder activation status (attempt {})".format(i))
+                toolhead.dwell(0.2)
+                toolhead.wait_moves()
+
+        if activate_status[0][1] == 0 and activate_status[0][0] == cur_extruder.name:
+            pass
+        elif activate_status[0][1] == 0 or activate_status[0][1] == 1 or retry_extruder_id is not None:
+            # The extruder status does not match the actual state, need to retrieve the extruder status once
+            gcmd = self.gcode.create_gcode_command("", "", {})
+            extruder = self.printer.lookup_object(activate_status[0][0], None)
+            if extruder is not None:
+                cur_extruder = extruder
+            cur_extruder.cmd_SWITCH_EXTRUDER_ADVANCED(gcmd)
+        else:
+            cur_extruder = toolhead.get_extruder()
+            result = cur_extruder.analyze_switch_extruder_error(activate_status)
+            if result:
+                error_msg, activated, unknown, grip_states, activated_code, unknown_code = result
+                if hasattr(cur_extruder, 'grab_hall_sensor_type') and cur_extruder.grab_hall_sensor_type:
+                    if "multi-act" not in error_msg:
+                        first_unknown_index = None
+                        for i, idx in enumerate(unknown):
+                            if grip_states[idx] != 'FFT':
+                                first_unknown_index = idx
+                                break
+
+                        if first_unknown_index is not None:
+                            grip_state = grip_states[first_unknown_index]
+                            message = None
+                            if grip_state == 'FFF' or grip_state == 'FFT':
+                                info = "Z homing abort: detected that extruder%d is detached. %s" % (first_unknown_index, error_msg)
+                                message = '{"coded": "0002-0528-%4d-0013", "oneshot": %d, "msg":"%s", "action": "pause"}' % (first_unknown_index, 1, info)
+                            elif (grip_state == 'TTF' or grip_state == 'TTT'):
+                                info = "Z homing abort: detected conflicting status for extruder%d: both parked and picked states detected. %s" % (first_unknown_index, error_msg)
+                                message = '{"coded": "0002-0528-%4d-0014", "oneshot": %d, "msg":"%s", "action": "pause"}' % (first_unknown_index, 1, info)
+                            if message is not None:
+                                raise gcmd.error(message)
+            else:
+                error_msg = activate_status
+            error_msg = f"Z homing abort: Extruder parking status error, {error_msg}"
+            message = '{"coded": "0002-0528-0000-0001", "msg":"%s", "action": "pause"}' % (error_msg)
+            raise gcmd.error(message)
+            # raise gcmd.error("z homing error: Unknown extruder park status\n {}".format(activate_status))
+
+        # Extruder sensor detection
+        probe = self.printer.lookup_object('probe', None)
+        if probe is None:
+            raise gcmd.error("Z homing abort: The probe module must be configured")
+
+        # Move to XY homing position
+        home_x_pos, home_y_pos = self.home_x_pos, self.home_y_pos
+        speed = self.speed
+        bed_mesh = self.printer.lookup_object('bed_mesh', None)
+        if bed_mesh is not None and bed_mesh.get_mesh() is not None:
+            # bed_mesh.bmc.probe_mgr.probe_helper._move_next(0)
+            z_mesh = bed_mesh.get_mesh()
+            params = z_mesh.get_mesh_params()
+            x_count = params['x_count']
+            y_count = params['y_count']
+            min_x, max_x = params['min_x'], params['max_x']
+            min_y, max_y = params['min_y'], params['max_y']
+            x_step = (max_x - min_x) / (x_count - 1)
+            y_step = (max_y - min_y) / (y_count - 1)
+            x_mid_index = (x_count - 1) // 2
+            y_mid_index = (y_count - 1) // 2
+            home_x_pos = min_x + x_mid_index * x_step
+            home_y_pos = min_y + y_mid_index * y_step
+            # bed_mesh.bmc.probe_mgr.probe_helper._move_next(0)
+        # else:
+        #     toolhead.manual_move([home_x_pos, home_y_pos], speed)
+        # gcmd.respond_info("home_x_pos: {}, home_y_pos: {}".format(home_x_pos, home_y_pos))
+        probe_x_pos = gcmd.get_float("I", None)
+        probe_y_pos = gcmd.get_float("J", None)
+        # gcmd.respond_info("probe_x_pos: {}, probe_y_pos: {}".format(probe_x_pos, probe_y_pos))
+        if probe_x_pos is not None and probe_y_pos is not None:
+            home_x_pos = probe_x_pos
+            home_y_pos = probe_y_pos
+        toolhead.wait_moves()
+        pos = toolhead.get_position()
+        if pos[1] > self.safe_move_y_pos:
+            toolhead.manual_move([None, self.safe_move_y_pos, None], speed)
+
+        if home_y_pos > self.safe_move_y_pos:
+            toolhead.manual_move([home_x_pos, None], speed)
+        toolhead.manual_move([home_x_pos, home_y_pos], speed)
+
+    def _z_probe_homing_move(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead')
+        curtime = self.printer.get_reactor().monotonic()
+        kin_status = toolhead.get_kinematics().get_status(curtime)
+        rail = toolhead.get_kinematics().rails[2]
+        position_min, position_max = rail.get_range()
+        probe_x_pos = gcmd.get_float("I", None)
+        probe_y_pos = gcmd.get_float("J", None)
+        try:
+            # Set the starting coordinates
+            thcoord = list(toolhead.get_position())
+            thcoord[2] = 1.1 * (position_max - position_min)
+            toolhead.set_position(thcoord, homing_axes=[2])
+            toolhead.get_kinematics().set_ignore_check_move_limit(True)
+            # Build probe command
+            probe = self.printer.lookup_object('probe')
+            params = gcmd.get_command_parameters()
+            if 'SAMPLES_TOLERANCE' not in params and self.z_probe_tolerance is not None:
+                params['SAMPLES_TOLERANCE'] = self.z_probe_tolerance
+            if 'PROBE_SPEED' not in params and self.z_probe_speed is not None:
+                params['PROBE_SPEED'] = self.z_probe_speed
+            if 'PROBE_FAST_SPEED' not in params and self.z_probe_fast_speed is not None:
+                params['PROBE_FAST_SPEED'] = self.z_probe_fast_speed
+            if 'PROBE_ACCEL' not in params and self.z_probe_accel is not None:
+                params['PROBE_ACCEL'] = self.z_probe_accel
+            if 'LIFT_SPEED' not in params and self.probe_lift_speed is not None:
+                params['LIFT_SPEED'] = self.probe_lift_speed
+            if 'SAMPLES' not in params and self.sample_count is not None:
+                params['SAMPLES'] = self.sample_count
+            if 'SAMPLE_TRIG_FREQ' not in params and self.relative_trigger_freq is not None:
+                params['SAMPLE_TRIG_FREQ'] = self.relative_trigger_freq
+            if 'SAMPLE_RETRACT_DIST' not in params and self.sample_retract_dist is not None:
+                params['SAMPLE_RETRACT_DIST'] = self.sample_retract_dist
+            if 'Z_OFFSET' not in params and self.z_offset is not None:
+                z_probe_offset = self.z_offset
+            else:
+                z_probe_offset = probe.get_offsets()[2]
+            self.printer.send_event("inductance_coil:probe_start")
+            if self.z_first_probe_sample_count > 0:
+                fast_probe_params = copy.deepcopy(gcmd.get_command_parameters())
+                fast_probe_params['PROBE_FAST_SPEED'] = self.z_first_probe_speed
+                fast_probe_params['PROBE_SPEED'] = self.z_first_probe_speed
+                fast_probe_params['SAMPLES'] = self.z_first_probe_sample_count
+                fast_probe_params['SAMPLES_TOLERANCE'] = self.z_first_probe_tolerance
+                probe_gcmd = self.gcode.create_gcode_command("PROBE", "PROBE", fast_probe_params)
+                probe.cmd_helper.cmd_PROBE(probe_gcmd)
+                toolhead.wait_moves()
+                thcoord = list(toolhead.get_position())
+                toolhead.manual_move([None, None, thcoord[2]+self.z_first_probe_retract_dist], self.z_hop_speed)
+            probe_gcmd = self.gcode.create_gcode_command("PROBE", "PROBE", params)
+            probe.cmd_helper.cmd_PROBE(probe_gcmd)
+            toolhead.wait_moves()
+            thcoord = list(toolhead.get_position())
+            thcoord[2] = self.start_z_pos + z_probe_offset
+            bed_mesh = self.printer.lookup_object('bed_mesh', None)
+            if bed_mesh is not None and bed_mesh.get_mesh() is not None:
+                toolhead.set_position(thcoord, homing_axes=[2])
+                z_mesh = bed_mesh.get_mesh()
+                if z_mesh is not None and z_mesh.probed_matrix is not None:
+                    z_mesh_params = z_mesh.get_mesh_params()
+                    x_count = z_mesh_params['x_count']
+                    y_count = z_mesh_params['y_count']
+                    x_mid_index = (x_count - 1) // 2
+                    y_mid_index = (y_count - 1) // 2
+                    if probe_x_pos is not None and probe_y_pos is not None:
+                        z_mesh_complete = self.start_z_pos - z_mesh.calc_z(probe_x_pos, probe_y_pos)
+                        # gcmd.respond_info("probe_z_pos: {}, z_mesh: {}".format(z_mesh.calc_z(y_mid_index, probe_y_pos), z_mesh.probed_matrix[y_mid_index][x_mid_index]))
+                    else:
+                        z_mesh_complete = self.start_z_pos - z_mesh.probed_matrix[y_mid_index][x_mid_index]
+                    gcmd.respond_info("z_mesh_complete: {}".format(z_mesh_complete))
+                    cur_extruder = toolhead.get_extruder()
+                    if hasattr(cur_extruder, "gcode_offset") and cur_extruder.gcode_offset is not None:
+                        z_mesh_complete -= cur_extruder.gcode_offset[2]
+                    adjusted_matrix = [[value + z_mesh_complete for value in row] for row in z_mesh.probed_matrix]
+                    try:
+                        z_mesh.build_mesh(adjusted_matrix)
+                        bed_mesh.set_mesh(z_mesh)
+                        bed_mesh.save_profile('default')
+                    except Exception as e:
+                        raise
+                    finally:
+                        pass
+            else:
+                gcode_offset_complete = 0
+                cur_extruder = toolhead.get_extruder()
+                if hasattr(cur_extruder, "gcode_offset") and cur_extruder.gcode_offset is not None:
+                    gcode_offset_complete += cur_extruder.gcode_offset[2]
+                thcoord[2] += gcode_offset_complete
+                toolhead.set_position(thcoord, homing_axes=[2])
+            if self.z_hop:
+                pos = toolhead.get_position()
+                if pos[2] < self.z_safe:
+                    toolhead.manual_move([None, None, self.z_safe], self.z_safe_speed)
+            self.gcode_move.reset_last_position()
+            self.gcode_move.base_position[2] = self.gcode_move.homing_position[2]
+            self.update_homing_stepper_z()
+        except Exception as e:
+            self.printer.lookup_object('stepper_enable').motor_off()
+            raise
+        finally:
+            self.printer.send_event("inductance_coil:probe_end")
+            toolhead.get_kinematics().set_ignore_check_move_limit(False)
+
+    def update_homing_stepper_z(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        toolhead.wait_moves()
+        # cur_extruder = toolhead.get_extruder()
+        # if hasattr(cur_extruder, "gcode_offset") and cur_extruder.gcode_offset is not None:
+        #     z_offset = cur_extruder.gcode_offset[2]
+        # else:
+        #     z_offset = 0
+        curtime = self.printer.get_reactor().monotonic()
+        homed_axes_list = str(toolhead.get_status(curtime)['homed_axes'])
+        if 'z' in homed_axes_list:
+            kin = toolhead.get_kinematics()
+            steppers = kin.get_steppers()
+            stepper_mcu_pos = [s.get_mcu_position() for s in steppers]
+            z_pos = toolhead.get_position()[2]
+            self.homing_stepper_z_info = {
+                    'stepper_z_pos': stepper_mcu_pos[2],
+                    'z_pos': z_pos,
+                    'dir_inverted': kin.rails[2].get_steppers()[0].get_dir_inverted()[0],
+                    'step_dist':  kin.rails[2].get_steppers()[0].get_step_dist(),
+                }
+        else:
+            self.homing_stepper_z_info = None
+
+    def _bed_mesh_clear(self):
+        try:
+            bed_mesh = self.printer.lookup_object('bed_mesh', None)
+            if bed_mesh is not None and bed_mesh.get_mesh() is not None:
+                self.gcode.run_script_from_command("BED_MESH_CLEAR")
+        except Exception:
+            pass
+
+    def _load_bed_mesh_profile(self):
+        try:
+            bed_mesh = self.printer.lookup_object('bed_mesh', None)
+            if bed_mesh is not None and bed_mesh.get_mesh() is None:
+                self.gcode.run_script_from_command("BED_MESH_PROFILE LOAD=default")
+        except Exception:
+            pass
+
+    def cmd_G28(self, gcmd):
+        action = gcmd.get("ACTION", None)
+        if action is not None:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION={}".format(action))
+        try:
+            self.is_homing = True
+            self.cmd_G28_BASE(gcmd)
+        finally:
+            self.is_homing = False
+            if action is not None:
+                self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+
+    def cmd_G28_BASE(self, gcmd):
+        if self.in_script:
+            # Was called recursively - invoke the real G28 command
+            self.prev_G28(gcmd)
+            return
+
+        # if no axis is given as parameter we assume the override
+        no_axis = True
+        for axis in 'XYZ':
+            if gcmd.get(axis, None) is not None:
+                no_axis = False
+                break
+
+        if no_axis:
+            override = True
+            self.z_need_home = True
+        else:
+            # check if we home an axis which needs the override
+            override = False
+            # This module forces an override of the X Y axis homing
+            for axis in 'XY':
+                if gcmd.get(axis, None) is not None:
+                    override = True
+            if gcmd.get('Z', None) is not None:
+                self.z_need_home = True
+            else:
+                self.z_need_home = False
+
+        toolhead = self.printer.lookup_object('toolhead')
+        curtime = self.printer.get_reactor().monotonic()
+        kin_status = toolhead.get_kinematics().get_status(curtime)
+
+        # Check if XY axes have homed correctly before moving Z axis alone
+        if not override:
+            if ('x' not in kin_status['homed_axes'] or
+                'y' not in kin_status['homed_axes']):
+                message = '{"coded": "0002-0528-0000-0000", "msg":"%s", "action": "pause"}' % ("Z homing abort: Must home X and Y axes first")
+                raise gcmd.error(message)
+
+        # Perform Z Hop if necessary
+        need_z_hop = gcmd.get_float('Z_HOP', None)
+        if need_z_hop is None and self.z_hop != 0.0:
+            need_z_hop = self.z_hop
+
+        if need_z_hop is not None:
+            pl_save_z_hop = gcmd.get_int('PL_SAVE_Z_HOP', 0)
+            self._z_hop_move(need_z_hop, pl_save_z_hop)
+
+        if not override:
+            # z-axis homing
+            if self.z_need_home == True:
+                try:
+                    self._load_bed_mesh_profile()
+                    self._z_probe_pre_process(gcmd)
+                    self._z_probe_homing_move(gcmd)
+                except Exception:
+                    self._bed_mesh_clear()
+                    raise
+            return
+
+        # Perform homing
+        context = self.template.create_template_context()
+        context['params'] = gcmd.get_command_parameters()
+        context['rawparams'] = gcmd.get_raw_command_parameters()
+        max_accel_bak = toolhead.max_accel
+        try:
+            self.in_script = True
+            self.template.run_gcode_from_command(context)
+            if self.z_need_home:
+                try:
+                    self._load_bed_mesh_profile()
+                    self._z_probe_pre_process(gcmd)
+                    self._z_probe_homing_move(gcmd)
+                except Exception:
+                    self._bed_mesh_clear()
+                    raise
+            else:
+                kin_status = toolhead.get_kinematics().get_status(curtime)
+                if ('z' not in kin_status['homed_axes']):
+                    self._bed_mesh_clear()
+        finally:
+            self.in_script = False
+            extruder_offset_object = self.printer.lookup_object('extruder_offset_calibration', None)
+            if extruder_offset_object is not None:
+                extruder_offset_object.reset_xyz_probe_positions()
+            toolhead.set_accel(max_accel_bak)
+
+def load_config(config):
+    return HomingXYZOverride(config)
--- a/klippy/extras/idle_timeout.py
+++ b/klippy/extras/idle_timeout.py
@@ -23,6 +23,7 @@ class IdleTimeout:
         self.toolhead = self.timeout_timer = None
         self.printer.register_event_handler("klippy:ready", self.handle_ready)
         self.idle_timeout = config.getfloat('timeout', 600., above=0.)
+        self.idle_timeout_on_pause = config.getfloat('timeout_on_pause', 9999999999., above=0.)
         gcode_macro = self.printer.load_object(config, 'gcode_macro')
         self.idle_gcode = gcode_macro.load_template(config, 'gcode',
                                                     DEFAULT_IDLE_GCODE)
--- /dev/null
+++ b/klippy/extras/inductance_coil.py
@@ -0,0 +1,433 @@
+import logging, multiprocessing, os, time
+import shutil, pathlib
+from . import probe, bulk_sensor
+from . import probe_inductance_coil
+
+FIXED_TIME_FREQ_CAL_MODE              = 0
+FIXED_PULSE_NUM_CAL_MODE              = 1
+DEFAULT_FREQ_CAL_CYCLE                = 0
+DEFAULT_FREQ_TRG_MODE                 = 0
+DEFAULT_INPUT_CAPTURE_OVER_CNT        = 1000
+DEFAULT_INPUT_CAPTURE_CAL_TIMEOUT     = 1.0
+DEFAULT_INPUT_CAPTURE_TRIGGER_FREQ    = 1200000
+DEFAULT_INPUT_CAPTURE_TRIGGER_INVERT  = False
+
+MIN_MSG_TIME  = 0.100
+BATCH_UPDATES = 0.100
+
+# max frequency 2MHz
+MAX_INDUCTANCE_COIL_FREQUENCY = 2000000
+MIN_INDUCTANCE_COIL_FREQUENCY = 1000000
+
+class FrequencyQueryHelper:
+    def __init__(self, printer):
+        self.printer = printer
+        self.is_finished = False
+        print_time = printer.lookup_object('toolhead').get_last_move_time()
+        self.request_start_time = self.request_end_time = print_time
+        self.frequency = []
+        self.print_time = []
+        self.msgs = []
+    def finish_measurements(self):
+        logging.info("FrequencyQueryHelper: finish frequency measurements")
+        toolhead = self.printer.lookup_object('toolhead')
+        self.request_end_time = toolhead.get_last_move_time()
+        toolhead.wait_moves()
+        self.is_finished = True
+    def handle_batch(self, msg):
+        if self.is_finished:
+            return False
+        if len(self.msgs) >= 10000:
+            # Avoid filling up memory with too many samples
+            return False
+        self.msgs.append(msg)
+        return True
+    def has_valid_samples(self):
+        for msg in self.msgs:
+            data = msg['data']
+            first_sample_time = data[0][0]
+            last_sample_time = data[-1][0]
+            if (first_sample_time > self.request_end_time
+                    or last_sample_time < self.request_start_time):
+                continue
+            # The time intervals [first_sample_time, last_sample_time]
+            # and [request_start_time, request_end_time] have non-zero
+            # intersection. It is still theoretically possible that none
+            # of the samples from msgs fall into the time interval
+            # [request_start_time, request_end_time] if it is too narrow
+            # or on very heavy data losses. In practice, that interval
+            # is at least 1 second, so this possibility is negligible.
+            return True
+        return False
+    def get_samples(self):
+        if not self.msgs:
+            return self.print_time, self.frequency
+        total = sum([len(m['data']) for m in self.msgs])
+        count = 0
+        self.print_time = print_time = [None] * total
+        self.frequency = frequency = [None] * total
+        for msg in self.msgs:
+            for samp_time, freq in msg['data']:
+                if samp_time < self.request_start_time:
+                    continue
+                if samp_time > self.request_end_time:
+                    break
+                print_time[count] = samp_time
+                frequency[count] = freq
+                count += 1
+        del print_time[count:]
+        del frequency[count:]
+        del self.msgs[:]
+        return self.print_time, self.frequency
+    def write_to_file(self, filename):
+        def write_impl():
+            try:
+                # Try to re-nice writing process
+                os.nice(20)
+            except:
+                pass
+            f = open(filename, 'w+')
+            f.write("time,frequency\n")
+            print_time, frequency = self.get_samples()
+            for t, freq in zip(print_time, frequency):
+                f.write("%.4f,%d\n" % (
+                    t, freq))
+            f.close()
+        write_proc = multiprocessing.Process(target=write_impl)
+        write_proc.daemon = True
+        write_proc.start()
+
+# Helper class for G-Code commands
+class FrequencyCommandHelper:
+    def __init__(self, config, probe):
+        self.printer = config.get_printer()
+        self.probe = probe
+        self.bg_client = None
+        name_parts = config.get_name().split()
+        self.base_name = name_parts[0]
+        self.name = name_parts[-1]
+        self.register_commands(self.name)
+    def register_commands(self, name):
+        # Register commands
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_mux_command("FREQUENCY_MEASURE", "PROBE", name,
+                                   self.cmd_FREQUENCY_MEASURE,
+                                   desc=self.cmd_FREQUENCY_MEASURE_help)
+        gcode.register_mux_command("FREQUENCY_QUERY", "PROBE", name,
+                                   self.cmd_FREQUENCY_QUERY,
+                                   desc=self.cmd_FREQUENCY_QUERY_help)
+    cmd_FREQUENCY_MEASURE_help = "Start/stop frequency messurement of inductance coil"
+    def cmd_FREQUENCY_MEASURE(self, gcmd):
+        if self.bg_client is None:
+            # Start measurements
+            self.bg_client = self.probe.start_internal_client()
+            gcmd.respond_info("frequency measurements started")
+            return
+        # End measurements
+        name = gcmd.get("NAME", time.strftime("%m%d_%H%M"))
+        if not name.replace('-', '').replace('_', '').isalnum():
+            raise gcmd.error("Invalid NAME parameter")
+        bg_client = self.bg_client
+        self.bg_client = None
+        bg_client.finish_measurements()
+        try:
+            vsd = self.printer.lookup_object('virtual_sdcard', None)
+            if vsd is None:
+                gcmd.respond_info("No virtual_sdcard dir to save frequency_data data")
+                data_path = pathlib.Path('/userdata/gcodes/frequency_data')
+            else:
+                data_path = pathlib.Path(f'{vsd.sdcard_dirname}/frequency_data')
+            if not os.path.exists(data_path):
+                os.makedirs(data_path)
+            filename = data_path.joinpath("frequency-%s-%s.csv" % (self.name, name))
+            bg_client.write_to_file(filename)
+            gcmd.respond_info("Writing raw frequency data to %s file"
+                            % (str(filename),))
+        except Exception as e:
+            gcmd.error(e)
+    cmd_FREQUENCY_QUERY_help = "Query current frequency of inductance coil"
+    def cmd_FREQUENCY_QUERY(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead')
+        aclient = self.probe.start_internal_client()
+        toolhead.dwell(0.2)
+        aclient.finish_measurements()
+        toolhead.dwell(0.1)
+        pt, values = aclient.get_samples()
+        if values is None or len(values) == 0:
+            raise gcmd.error("No frequency measurements found")
+        freq = values[-1]
+        t = pt[-1]
+        gcmd.respond_info("frequency data: %.4fs: %dHz"
+                          % (t, freq))
+    cmd_ACCELEROMETER_DEBUG_READ_help = "Query register (for debugging)"
+
+class InductanceCoil:
+    def __init__(self, config, mcu):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.gcode = config.get_printer().lookup_object('gcode')
+        self._mcu = mcu
+        self._name = config.get_name().split()[1]
+        self._freq_cal_mode = config.getint('freq_cal_mode', minval=0, maxval=1)
+        self._freq_cal_cycle = config.getfloat('freq_cal_cycle', 0.001, above=0.)
+        self._capture_over_cnt = config.getint('capture_over_cnt', DEFAULT_INPUT_CAPTURE_OVER_CNT)
+        self._cal_time_out = config.getfloat('cal_time_out', DEFAULT_INPUT_CAPTURE_CAL_TIMEOUT)
+        self._trg_freq_ht = config.getfloat('trg_freq_ht', DEFAULT_INPUT_CAPTURE_TRIGGER_FREQ)
+        self._trg_freq_lt = config.getfloat('trg_freq_lt', DEFAULT_INPUT_CAPTURE_TRIGGER_FREQ)
+        self._trigger_mode = config.getfloat('trigger_mode', DEFAULT_FREQ_TRG_MODE)
+        self._trigger_invert = config.getboolean('trigger_invert', DEFAULT_INPUT_CAPTURE_TRIGGER_INVERT)
+        self._max_freq = config.getint('max_freq', 1500000, minval=1)
+        self._min_freq = config.getint('min_freq', 1000000, minval=1, maxval=self._max_freq)
+        self._cal_window_size = config.getint('cal_window_size', 1, minval=1, maxval=50)
+        self._cmd_queue = self._mcu.alloc_command_queue()
+
+        # setup bulk sensor helper, Process messages in batches
+        FrequencyCommandHelper(config, self)
+        self._data_rate = config.getint('date_rate', 1000)
+        chip_smooth = self._data_rate * BATCH_UPDATES * 2
+        self.ffreader = bulk_sensor.FixedFreqReader(mcu, chip_smooth, "<I")
+        self.batch_bulk = bulk_sensor.BatchBulkHelper(
+            self.printer, self._process_batch,
+            self._start_measurements, self._finish_measurements, BATCH_UPDATES)
+        self.name = config.get_name().split()[-1]
+        hdr = ('time', 'frequency')
+        self.batch_bulk.add_mux_endpoint("inductance_coil/dump_inductance_coil", "sensor",
+                                         self.name, {'header': hdr})
+        self.gcode.register_mux_command("SET_TRIG_FREQ", "PROBE", self._name,
+                                        self.cmd_SET_TRIG_FREQ,
+                                        desc=self.cmd_SET_TRIG_FREQ_help)
+        self.gcode.register_mux_command("INDUCTANCE_COIL_QUERY", "PROBE", self._name,
+                                        self.cmd_INDUCTANCE_COIL_QUERY,
+                                        desc=self.cmd_INDUCTANCE_COIL_QUERY_help)
+
+        self._mcu.register_config_callback(self._build_config)
+
+    def _build_config(self):
+        self._oid = self._mcu.create_oid()
+
+        self._mcu.add_config_cmd(
+            "inductance_coil_config oid=%d cal_mode=%u capture_over_cnt=%u freq_cal_cycle=%u cal_time_out=%u"
+            " trigger_mode=%u trigger_invert=%u trg_freq_ht=%u trg_freq_lt=%u cal_window_size=%u"
+            % (self._oid, self._freq_cal_mode, self._capture_over_cnt, self._freq_cal_cycle*1000000, self._cal_time_out*1000000,
+               self._trigger_mode, self._trigger_invert, self._trg_freq_ht, self._trg_freq_lt, self._cal_window_size))
+
+        self._mcu.add_config_cmd(
+            "query_inductance_coil oid=%d rest_ticks=%u"
+            % (self._oid, 0))
+
+        self.set_trig_freq_cmd = self._mcu.lookup_command(
+            "virtual_gpio_trigger oid=%c absolute_mode=%u trigger_mode=%u trigger_invert=%u trg_freq_ht=%u trg_freq_lt=%u force_update=%u")
+
+        self.set_trig_freq_with_timer_cmd = self._mcu.lookup_command(
+            "virtual_gpio_trigger_with_timer oid=%c absolute_mode=%u trigger_mode=%u trigger_invert=%u trg_freq_ht=%u trg_freq_lt=%u force_update=%u clock=%u")
+
+        self.query_inductance_coil_cmd = self._mcu.lookup_command(
+            "query_inductance_coil oid=%c rest_ticks=%u", cq=None)
+        self.ffreader.setup_query_command("query_inductance_coil_status oid=%c",
+                                          oid=self._oid, cq=None)
+
+        self.query_inductance_coil_info_cmd = self._mcu.lookup_query_command(
+            "query_inductance_coil_config_info oid=%c",
+            "inductance_coil_info oid=%c cal_mode=%u capture_over_cnt=%u freq_cal_cycle=%u cal_time_out=%u"
+            " trigger_mode=%u trigger_invert=%u trg_freq_ht=%u trg_freq_lt=%u capture_freq=%u virtual_gpio=%u",
+            oid=self._oid, cq=self._cmd_queue)
+
+    def _cmd_set_trig_freq(self, freq_ht, freq_lt, absolute_mode=True, trigger_mode=0, trigger_invert=False, force_update=True):
+        self.set_trig_freq_cmd.send([self._oid, absolute_mode, trigger_mode, trigger_invert, freq_ht, freq_lt, force_update])
+
+    def _cmd_set_trig_freq_with_timer(self, freq_ht, freq_lt, clock, absolute_mode=True, trigger_mode=0, trigger_invert=False, force_update=True):
+        self.set_trig_freq_with_timer_cmd.send([self._oid, absolute_mode, trigger_mode, trigger_invert, freq_ht, freq_lt, force_update, clock])
+
+    def _cmd_query_trig_freq_info(self):
+        param = self.query_inductance_coil_info_cmd.send([self._oid])
+        return param
+
+    def _convert_samples(self, samples):
+        count = 0
+        for ptime, freq in samples:
+            if freq > MAX_INDUCTANCE_COIL_FREQUENCY or \
+                freq < MIN_INDUCTANCE_COIL_FREQUENCY:
+                self.last_error_count += 1
+            samples[count] = (round(ptime, 6), freq)
+            count += 1
+        del samples[count:]
+
+    def _process_batch(self, eventtime):
+        samples = self.ffreader.pull_samples()
+        self._convert_samples(samples)
+        if not samples:
+            return {}
+        # if self.calibration is not None:
+        #     self.calibration.apply_calibration(samples)
+        return {'data': samples, 'errors': self.last_error_count,
+                'overflows': self.ffreader.get_last_overflows()}
+
+    def _start_measurements(self):
+        # Start bulk reading
+        rest_ticks = self._mcu.seconds_to_clock(1 / self._data_rate)
+        self.query_inductance_coil_cmd.send([self._oid, rest_ticks])
+        logging.info("Inductance coil starting '%s' measurements", self.name)
+        # Initialize clock tracking
+        self.ffreader.note_start()
+        self.last_error_count = 0
+
+    def _finish_measurements(self):
+        # Halt bulk reading
+        self.query_inductance_coil_cmd.send_wait_ack([self._oid, 0])
+        self.ffreader.note_end()
+        logging.info("Inductance coil finished '%s' measurements", self.name)
+
+    def check_coil_freq(self):
+        param = self._cmd_query_trig_freq_info()
+        if param['capture_freq'] > self._max_freq or param['capture_freq'] < self._min_freq:
+            return False, param['capture_freq']
+        return True, param['capture_freq']
+
+    def get_coil_freq(self):
+        param = self._cmd_query_trig_freq_info()
+        return param['capture_freq']
+
+    cmd_SET_TRIG_FREQ_help = 'Setting the trigger frequency of the inductance coil'
+    def cmd_SET_TRIG_FREQ(self, gcmd):
+        absolute_trig = gcmd.get_int("ABSOLUTE", 0, minval=0, maxval=1)
+        trigger_invert = gcmd.get_int("TRIGGER_INVERT", 0, minval=0, maxval=1)
+        trigger_mode = gcmd.get_int("TRIGGER_MODE", 0, minval=0, maxval=1)
+        trigger_freq_ht = 0
+        trigger_freq_lt = 0
+        params = gcmd.get_command_parameters()
+
+        # Unidirectional Trigger
+        if trigger_mode == 0:
+            if not ('TRIGGER_FREQ_HT' in params):
+                self.gcode.respond_info("Error: parameter must contain TRIGGER_FREQ_HT")
+                return
+            else:
+                trigger_freq_ht = gcmd.get_int("TRIGGER_FREQ_HT", 0)
+        else:
+            # Bidirectional Trigger
+            if not ('TRIGGER_FREQ_HT' in params):
+                self.gcode.respond_info("Error: parameter must contain TRIGGER_FREQ_HT")
+                return
+            else:
+                trigger_freq_ht = gcmd.get_int("TRIGGER_FREQ_HT", 0)
+                if absolute_trig:
+                    if not ('TRIGGER_FREQ_LT' in params):
+                        self.gcode.respond_info("Error: TRIGGER_FREQ_LT is not configured")
+                        return
+                    trigger_freq_lt = gcmd.get_int("TRIGGER_FREQ_LT", 0)
+                else:
+                    if not ('TRIGGER_FREQ_LT' in params):
+                        trigger_freq_ht = abs(trigger_freq_ht)
+                        trigger_freq_lt = -trigger_freq_ht
+                    else:
+                        trigger_freq_lt = gcmd.get_int("TRIGGER_FREQ_LT", 0)
+
+        if absolute_trig:
+            trigger_freq_ht = max(0, trigger_freq_ht)
+            trigger_freq_lt = max(0, trigger_freq_lt)
+
+        if trigger_mode and trigger_freq_ht < trigger_freq_lt:
+            self.gcode.respond_info("Error: Bidirectional Trigger TRIGGER_FREQ_HT must be greater than TRIGGER_FREQ_LT")
+            return
+
+        self._cmd_set_trig_freq(trigger_freq_ht, trigger_freq_lt, absolute_trig, trigger_mode, trigger_invert)
+
+    cmd_INDUCTANCE_COIL_QUERY_help = 'QUERY inductance coil information'
+    def cmd_INDUCTANCE_COIL_QUERY(self, gcmd):
+        param = self._cmd_query_trig_freq_info()
+        show_all = gcmd.get_int("SHOW_ALL", 0)
+        if show_all:
+            self.gcode.respond_info("cal_mode: %d capture_over_cnt: %d freq_cal_cycle: %f cal_time_out: %f trigger_mode: %d"
+                                    " trigger_invert: %d trg_freq_ht: %d trg_freq_lt: %d capture_freq=%u virtual_gpio=%u"
+                                    % (param['cal_mode'], param['capture_over_cnt'], param['freq_cal_cycle']/1000000,
+                                    param['cal_time_out']/1000000, param['trigger_mode'], param['trigger_invert'],
+                                    param['trg_freq_ht'], param['trg_freq_lt'], param['capture_freq'], param['virtual_gpio']))
+        else:
+            self.gcode.respond_info("capture_freq: %u virtual_gpio: %s" % (param['capture_freq'], ["open", "TRIGGERED"][not not param['virtual_gpio']]))
+
+    def start_internal_client(self):
+        aqh = FrequencyQueryHelper(self.printer)
+        self.batch_bulk.add_client(aqh.handle_batch)
+        return aqh
+
+class InductanceCoilEndstopWrapper:
+# Endstop wrapper that enables probe specific features
+    def __init__(self, config):
+        self.name = config.get_name()
+        self.printer = config.get_printer()
+        self.position_endstop = config.getfloat('z_offset')
+        self.stow_on_each_sample = config.getboolean(
+            'deactivate_on_each_sample', True)
+        gcode_macro = self.printer.load_object(config, 'gcode_macro')
+        self.activate_gcode = gcode_macro.load_template(
+            config, 'activate_gcode', '')
+        self.deactivate_gcode = gcode_macro.load_template(
+            config, 'deactivate_gcode', '')
+        # Create an "endstop" object to handle the probe pin
+        ppins = self.printer.lookup_object('pins')
+        pin = config.get('pin')
+        pin_params = ppins.lookup_pin(pin, can_invert=True, can_pullup=True)
+        mcu = pin_params['chip']
+        # Currently only supports AT32415 PA0
+        self.sensor = InductanceCoil(config, mcu)
+        self.mcu_endstop = mcu.setup_pin('pulse_endstop', pin_params)
+        self.printer.register_event_handler('klippy:mcu_identify',
+                                            self._handle_mcu_identify)
+        # Wrappers
+        self.get_mcu = self.mcu_endstop.get_mcu
+        self.add_stepper = self.mcu_endstop.add_stepper
+        self.get_steppers = self.mcu_endstop.get_steppers
+        self.home_start = self.mcu_endstop.home_start
+        self.home_wait = self.mcu_endstop.home_wait
+        self.query_endstop = self.mcu_endstop.query_endstop
+        # multi probes state
+        self.multi = 'OFF'
+    def _handle_mcu_identify(self):
+        kin = self.printer.lookup_object('toolhead').get_kinematics()
+        for stepper in kin.get_steppers():
+            if stepper.is_active_axis('x') or stepper.is_active_axis('y') or stepper.is_active_axis('z'):
+                self.add_stepper(stepper)
+    def _raise_probe(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        start_pos = toolhead.get_position()
+        self.deactivate_gcode.run_gcode_from_command()
+        if toolhead.get_position()[:3] != start_pos[:3]:
+            raise self.printer.command_error(
+                "Toolhead moved during probe activate_gcode script")
+    def _lower_probe(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        start_pos = toolhead.get_position()
+        self.activate_gcode.run_gcode_from_command()
+        if toolhead.get_position()[:3] != start_pos[:3]:
+            raise self.printer.command_error(
+                "Toolhead moved during probe deactivate_gcode script")
+    def multi_probe_begin(self):
+        if self.stow_on_each_sample:
+            return
+        self.multi = 'FIRST'
+    def multi_probe_end(self):
+        if self.stow_on_each_sample:
+            return
+        self._raise_probe()
+        self.multi = 'OFF'
+    def probing_move(self, pos, speed, axis=2):
+        phoming = self.printer.lookup_object('homing')
+        return phoming.probing_coil_move(self, pos, speed, axis)
+    def probe_prepare(self, hmove):
+        if self.multi == 'OFF' or self.multi == 'FIRST':
+            self._lower_probe()
+            if self.multi == 'FIRST':
+                self.multi = 'ON'
+    def probe_finish(self, hmove):
+        if self.multi == 'OFF':
+            self._raise_probe()
+    def get_position_endstop(self):
+        return self.position_endstop
+
+def load_config_prefix(config):
+    if config.get_printer().lookup_object('probe', None) is None:
+        config.get_printer().add_object('probe', probe_inductance_coil.PrinterProbe(config))
+        return config.get_printer().lookup_object('probe', None).mcu_probe
+    else:
+        ind_probe = InductanceCoilEndstopWrapper(config)
+    return ind_probe
--- a/klippy/extras/input_shaper.py
+++ b/klippy/extras/input_shaper.py
@@ -4,10 +4,25 @@
 # Copyright (C) 2020  Dmitry Butyugin <dmbutyugin@google.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
+import logging, copy, os
 import collections
 import chelper
 from . import shaper_defs
 
+SHAPER_CONFIG_FILE                  =   "input_shaper.json"
+DEFAULT_SHAPER_CONFIG = {
+    'axis_x': {
+        'type': 'mzv',
+        'freq': 54,
+        'damping_ratio': 0.1
+    },
+    'axis_y': {
+        'type': 'mzv',
+        'freq': 47.5,
+        'damping_ratio': 0.1
+    }
+}
+
 class InputShaperParams:
     def __init__(self, axis, config):
         self.axis = axis
@@ -92,6 +107,28 @@ class InputShaper:
         self.toolhead = None
         self.shapers = [AxisInputShaper('x', config),
                         AxisInputShaper('y', config)]
+        self.shaper_freq_x_min = config.getfloat('shaper_freq_x_min', 5)
+        self.shaper_freq_x_max = config.getfloat('shaper_freq_x_max', 100)
+        self.shaper_freq_x_default = config.getfloat('shaper_freq_x', 54)
+        self.shaper_freq_y_min = config.getfloat('shaper_freq_y_min', 5)
+        self.shaper_freq_y_max = config.getfloat('shaper_freq_y_max', 100)
+        self.shaper_freq_y_default = config.getfloat('shaper_freq_y', 47.5)
+
+        # Use the values defined by the user in printer.cfg as default values.
+        DEFAULT_SHAPER_CONFIG['axis_x']['type'] = self.shapers[0].params.shaper_type
+        DEFAULT_SHAPER_CONFIG['axis_x']['freq'] = self.shapers[0].params.shaper_freq
+        DEFAULT_SHAPER_CONFIG['axis_x']['damping_ratio'] = self.shapers[0].params.damping_ratio
+        DEFAULT_SHAPER_CONFIG['axis_y']['type'] = self.shapers[1].params.shaper_type
+        DEFAULT_SHAPER_CONFIG['axis_y']['freq'] = self.shapers[1].params.shaper_freq
+        DEFAULT_SHAPER_CONFIG['axis_y']['damping_ratio'] = self.shapers[1].params.damping_ratio
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = SHAPER_CONFIG_FILE
+        self._config_path = os.path.join(config_dir, config_name)
+        self._config = self.printer.load_snapmaker_config_file(
+                            self._config_path,
+                            DEFAULT_SHAPER_CONFIG,
+                            create_if_not_exist=True)
+
         self.input_shaper_stepper_kinematics = []
         self.orig_stepper_kinematics = []
         # Register gcode commands
@@ -104,7 +141,26 @@ class InputShaper:
     def connect(self):
         self.toolhead = self.printer.lookup_object("toolhead")
         # Configure initial values
+        self.shapers[0].params.shaper_type = self._config['axis_x']['type']
+        self.shapers[0].params.shaper_freq = self._config['axis_x']['freq']
+        self.shapers[0].params.damping_ratio = self._config['axis_x']['damping_ratio']
+        self.shapers[1].params.shaper_type = self._config['axis_y']['type']
+        self.shapers[1].params.shaper_freq = self._config['axis_y']['freq']
+        self.shapers[1].params.damping_ratio = self._config['axis_y']['damping_ratio']
         self._update_input_shaping(error=self.printer.config_error)
+
+    def _save_input_shaper_params(self):
+        self._config['axis_x']['type'] = self.shapers[0].params.shaper_type
+        self._config['axis_x']['freq'] = self.shapers[0].params.shaper_freq
+        self._config['axis_x']['damping_ratio'] = self.shapers[0].params.damping_ratio
+        self._config['axis_y']['type'] = self.shapers[1].params.shaper_type
+        self._config['axis_y']['freq'] = self.shapers[1].params.shaper_freq
+        self._config['axis_y']['damping_ratio'] = self.shapers[1].params.damping_ratio
+        ret = self.printer.update_snapmaker_config_file(self._config_path, self._config, DEFAULT_SHAPER_CONFIG)
+        if not ret:
+            logging.error("save input_shaper config failed!")
+        return ret
+
     def _get_input_shaper_stepper_kinematics(self, stepper):
         # Lookup stepper kinematics
         sk = stepper.get_stepper_kinematics()
@@ -162,6 +218,7 @@ class InputShaper:
             for shaper in self.shapers:
                 shaper.update(gcmd)
             self._update_input_shaping()
+            self._save_input_shaper_params()
         for shaper in self.shapers:
             shaper.report(gcmd)
 
--- a/klippy/extras/led.py
+++ b/klippy/extras/led.py
@@ -27,6 +27,23 @@ class LEDHelper:
         gcode = self.printer.lookup_object('gcode')
         gcode.register_mux_command("SET_LED", "LED", name, self.cmd_SET_LED,
                                    desc=self.cmd_SET_LED_help)
+        wh = self.printer.lookup_object('webhooks')
+        wh.register_mux_endpoint("control/led", 'led', name, self._handle_control_led)
+    def _handle_control_led(self, web_request):
+        try:
+            red = web_request.get_float('red', 0.)
+            green = web_request.get_float('green', 0.)
+            blue = web_request.get_float('blue', 0.)
+            white = web_request.get_float('white', 0.)
+            index = web_request.get_int('index', None)
+            transmit = web_request.get_int('transmit', 1)
+            sync = web_request.get_int('SYNC', 0)
+            color = (red, green, blue, white)
+            self._set_led(color, index, transmit, sync)
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to control led: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
     def get_led_count(self):
         return self.led_count
     def set_color(self, index, color):
@@ -49,17 +66,7 @@ class LEDHelper:
             self.update_func(self.led_state, print_time)
         except self.printer.command_error as e:
             logging.exception("led update transmit error")
-    cmd_SET_LED_help = "Set the color of an LED"
-    def cmd_SET_LED(self, gcmd):
-        # Parse parameters
-        red = gcmd.get_float('RED', 0., minval=0., maxval=1.)
-        green = gcmd.get_float('GREEN', 0., minval=0., maxval=1.)
-        blue = gcmd.get_float('BLUE', 0., minval=0., maxval=1.)
-        white = gcmd.get_float('WHITE', 0., minval=0., maxval=1.)
-        index = gcmd.get_int('INDEX', None, minval=1, maxval=self.led_count)
-        transmit = gcmd.get_int('TRANSMIT', 1)
-        sync = gcmd.get_int('SYNC', 1)
-        color = (red, green, blue, white)
+    def _set_led(self, color, index, transmit, sync):
         # Update and transmit data
         def lookahead_bgfunc(print_time):
             self.set_color(index, color)
@@ -72,6 +79,18 @@ class LEDHelper:
         else:
             #Send update now (so as not to wake toolhead and reset idle_timeout)
             lookahead_bgfunc(None)
+    cmd_SET_LED_help = "Set the color of an LED"
+    def cmd_SET_LED(self, gcmd):
+        # Parse parameters
+        red = gcmd.get_float('RED', 0., minval=0., maxval=1.)
+        green = gcmd.get_float('GREEN', 0., minval=0., maxval=1.)
+        blue = gcmd.get_float('BLUE', 0., minval=0., maxval=1.)
+        white = gcmd.get_float('WHITE', 0., minval=0., maxval=1.)
+        index = gcmd.get_int('INDEX', None, minval=1, maxval=self.led_count)
+        transmit = gcmd.get_int('TRANSMIT', 1)
+        sync = gcmd.get_int('SYNC', 1)
+        color = (red, green, blue, white)
+        self._set_led(color, index, transmit, sync)
     def get_status(self, eventtime=None):
         return {'color_data': self.led_state}
 
@@ -179,7 +198,7 @@ class PrinterLED:
                 self._activate_template(led_helper, i+1, template, lparams)
         self._activate_timer()
 
-PIN_MIN_TIME = 0.100
+PIN_MIN_TIME = 0.200
 MAX_SCHEDULE_TIME = 5.0
 
 # Handler for PWM controlled LEDs
--- /dev/null
+++ b/klippy/extras/machine_state_manager.py
@@ -0,0 +1,432 @@
+import logging, time
+from enum import Enum, IntEnum, unique
+
+class MachineStateManagerErr(Exception):
+    """Machine state manager error base class"""
+    pass
+
+@unique
+class MachineMainState(IntEnum):
+    """Printer main state enumeration (starting from 0)"""
+    IDLE = 0            # Idle state
+    PRINTING = 1        # Printing
+    XYZ_OFFSET_CALIBRATE = 2  # XYZ offset calibration
+    BED_LEVELING = 3    # Bed leveling
+    FLOW_CALIBRATION = 4  # Flow calibration
+    SHAPER_CALIBRATE = 5  # Shaper calibration
+    UPGRADING = 6       # Firmware upgrading
+    ABNORMAL = 7
+    SCREWS_TILT_ADJUST = 8 # Screws tilt adjust
+    AUTO_LOAD = 9               # auto load filament
+    AUTO_UNLOAD = 10            # auto unload filament
+    MANUAL_LOAD = 11            # manual load filament
+
+    def __str__(self):
+        return self.name
+
+@unique
+class ActionCode(IntEnum):
+    """Action code enumeration (starting from 0)"""
+    IDLE = 0
+    HOMING = 1
+    DETECT_PLATE = 2
+    # Printing
+    PRINT_PL_RESTORE = 128
+    PRINT_PAUSED = 129 # not used
+    PRINT_RESUMING = 130
+    PRINT_REPLENISHING = 131
+    PRINT_SWITCH_CHECKING = 132
+    PRINT_AUTO_FEEDING  = 133
+    PRINT_PREEXTRUDING  = 134
+    PRINT_AUTO_UNLOADING = 135
+    # XYZ offset calibration
+    MANUAL_CLEAN_EXTRUDER  = 192
+    MANUAL_CLEAN_EXTRUDER1 = 193
+    MANUAL_CLEAN_EXTRUDER2 = 194
+    MANUAL_CLEAN_EXTRUDER3 = 195
+    EXTRUDER_XYZ_OFFSET_PROBE = 196
+    EXTRUDER1_XYZ_OFFSET_PROBE = 197
+    EXTRUDER2_XYZ_OFFSET_PROBE = 198
+    EXTRUDER3_XYZ_OFFSET_PROBE = 199
+    AUTO_CLEAN_NOZZLE = 200
+    WAIT_NOZZLE_COOLING = 201
+    # Bed leveling
+    BED_LEVELING = 256
+    # Flow calibration
+    EXTRUDER_FLOW_CALIBRATING = 320
+    EXTRUDER1_FLOW_CALIBRATING = 321
+    EXTRUDER2_FLOW_CALIBRATING = 322
+    EXTRUDER3_FLOW_CALIBRATING = 323
+    # Shaper calibration
+    SHAPER_CALIBRATING = 384
+    # Firmware upgrading
+    # 448
+    # Screws tilt adjust
+    RESET_TO_INITIAL = 512
+    PROBE_REFERENCE_POINTS = 513
+    MANUAL_TUNING = 514
+    PROBING_ADJUST_VERIFY = 515
+    # auto load
+    AUTO_LOADING = 576
+    # auto unload
+    AUTO_UNLOADING = 640
+    # manual load
+    MANUAL_LOADING = 704
+
+    def __str__(self):
+        return self.name
+
+# Default transition rules
+# Format: {target_state: [allowed_current_states]}
+DEFAULT_TRANSITION_RULES = {
+    # MachineMainState.IDLE: [
+    #     MachineMainState.IDLE,
+    #     MachineMainState.PRINTING,
+    #     MachineMainState.XYZ_OFFSET_CALIBRATE,
+    #     MachineMainState.BED_LEVELING,
+    #     MachineMainState.FLOW_CALIBRATION,
+    #     MachineMainState.SHAPER_CALIBRATE,
+    #     MachineMainState.UPGRADING
+    # ],
+    MachineMainState.PRINTING: [MachineMainState.IDLE],
+    MachineMainState.BED_LEVELING: [MachineMainState.IDLE],
+    MachineMainState.XYZ_OFFSET_CALIBRATE: [MachineMainState.IDLE],
+    MachineMainState.FLOW_CALIBRATION: [MachineMainState.IDLE],
+    MachineMainState.SHAPER_CALIBRATE: [MachineMainState.IDLE],
+    MachineMainState.UPGRADING: [MachineMainState.IDLE]
+}
+
+# Default exit rules for EXIT_TO_IDLE command
+# Format: {current_state: {allowed_current_states}}
+DEFAULT_EXIT_RULES = {
+    MachineMainState.IDLE: {MachineMainState.IDLE},
+    MachineMainState.PRINTING: {MachineMainState.PRINTING},
+    MachineMainState.BED_LEVELING: {MachineMainState.BED_LEVELING},
+    MachineMainState.XYZ_OFFSET_CALIBRATE: {MachineMainState.XYZ_OFFSET_CALIBRATE},
+    MachineMainState.FLOW_CALIBRATION: {MachineMainState.FLOW_CALIBRATION},
+    MachineMainState.SHAPER_CALIBRATE: {MachineMainState.SHAPER_CALIBRATE},
+    MachineMainState.UPGRADING: {MachineMainState.UPGRADING}
+}
+
+class MachineStateManager:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.pre_hooks = []
+        self.post_hooks = []
+        self.lock = self.printer.get_reactor().mutex()
+        self.state_history = []
+        self.max_history = 10
+        all_states = list(MachineMainState)
+        # Initialize default exit rules (each state can only exit to idle from itself)
+        default_exit_rules = {
+            **{state: {state} for state in all_states}
+        }
+
+        # Initialize exit rules with defaults
+        self.exit_rules = default_exit_rules.copy()
+
+        # Override with DEFAULT_EXIT_RULES
+        for state, allowed_states in DEFAULT_EXIT_RULES.items():
+            self.exit_rules[state] = set(allowed_states)
+
+        # Initialize default transition rules
+        default_rules = {
+            MachineMainState.IDLE: all_states,  # IDLE can transition from any state
+            MachineMainState.ABNORMAL: all_states,  # ABNORMAL can also transition from any state
+            **{state: [MachineMainState.IDLE] for state in all_states
+               if state not in (MachineMainState.IDLE, MachineMainState.ABNORMAL)}  # Others can only transition from IDLE
+        }
+
+        # Initialize transition rules
+        self.transition_rules = default_rules.copy()
+
+        # Override default rules if custom rules provided
+        for target_state, allowed_states in DEFAULT_TRANSITION_RULES.items():
+            self.transition_rules[target_state] = set(allowed_states)
+
+        # self.register_pre_hook(self.default_pre_hook)
+        # self.register_post_hook(self.default_post_hook)
+
+        self.main_state = MachineMainState.IDLE
+        self.action_code = ActionCode.IDLE
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_command('SET_ACTION_CODE', self.cmd_SET_ACTION_CODE)
+        gcode.register_command('SET_MAIN_STATE', self.cmd_SET_MAIN_STATE)
+        gcode.register_command('GET_MACHINE_STATE', self.cmd_GET_MACHINE_STATE)
+        gcode.register_command('GET_STATE_HISTORY', self.cmd_GET_STATE_HISTORY)
+        gcode.register_command('EXIT_TO_IDLE', self.cmd_EXIT_TO_IDLE)
+        gcode.register_command('SHOW_STATE_RULES', self.cmd_SHOW_STATE_RULES)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+
+    def _handle_shutdown(self):
+        try:
+            self.change_state(MachineMainState.ABNORMAL)
+        except Exception as e:
+            logging.exception("{}".format(str(e)))
+
+    def can_transition(self, target_state, current_state=None):
+        if current_state is None:
+            current_state = self.main_state
+        rules = self.transition_rules.get(target_state, set())
+        if isinstance(rules, list):
+            rules = set(rules)
+        return current_state in rules
+
+    def set_action_code(self, action_code, main_state=None):
+        """Set action code for current state
+        Args:
+            action_code: The action code to set
+            main_state: Optional state to verify against current state
+                       If None, skips state verification
+        Raises:
+            self.printer.command_error: If state verification fails
+        """
+        with self.lock:
+            if main_state is not None and self.main_state != main_state:
+                raise MachineStateManagerErr(
+                    f"Cannot set action code {action_code} "
+                    f"(current state: {self.main_state}, "
+                    f"requested state: {main_state})")
+            self.action_code = action_code
+
+    def register_hook(self, hook, hook_type='pre'):
+        """Register hook method
+        Args:
+            hook: callback function to register
+            hook_type: 'pre' or 'post', specifies hook type
+        """
+        with self.lock:
+            hook_list = self.pre_hooks if hook_type == 'pre' else self.post_hooks
+            if hook not in hook_list:
+                hook_list.append(hook)
+
+    def unregister_hook(self, hook, hook_type='pre'):
+        """Unregister hook method
+        Args:
+            hook: callback function to unregister
+            hook_type: 'pre' or 'post', specifies hook type
+        """
+        with self.lock:
+            hook_list = self.pre_hooks if hook_type == 'pre' else self.post_hooks
+            if hook in hook_list:
+                hook_list.remove(hook)
+
+    def register_pre_hook(self, hook):
+        self.register_hook(hook, 'pre')
+
+    def unregister_pre_hook(self, hook):
+        self.unregister_hook(hook, 'pre')
+
+    def register_post_hook(self, hook):
+        self.register_hook(hook, 'post')
+
+    def unregister_post_hook(self, hook):
+        self.unregister_hook(hook, 'post')
+
+    def _safe_update_state(self, old_state, new_state, action=None):
+        self.main_state = new_state
+        if action is None:
+            self.action_code = ActionCode.IDLE  # Reset action code
+        else:
+            self.action_code = action  # Keep specified action
+
+    def _add_state_history(self, from_state, to_state, success, error=None):
+        """Add state transition record to history"""
+        if len(self.state_history) >= self.max_history:
+            self.state_history.pop(0)
+        record = {
+            'timestamp': self.printer.get_reactor().monotonic(),
+            'from_state': from_state,
+            'to_state': to_state,
+            'success': success
+        }
+        if not success:
+            record['error'] = error
+        self.state_history.append(record)
+
+    def change_state(self, new_state, action=None):
+        with self.lock:
+            old_state = self.main_state
+            # Skip if both state and action are unchanged
+            if old_state == new_state and (action is None or action == self.action_code):
+                return
+
+            # Only validate state transition if state is actually changing
+            if old_state != new_state:
+                allowed_states = self.transition_rules.get(new_state, [])
+                try:
+                    if old_state not in allowed_states:
+                        raise MachineStateManagerErr(
+                            f"Invalid state transition from {old_state} to {new_state}")
+
+                    for hook in self.pre_hooks:
+                        if not hook(old_state, new_state):
+                            raise MachineStateManagerErr(f"Pre-hook {hook.__name__} returned False")
+                except Exception as e:
+                    error_msg = (
+                        f"State transition failed: from {old_state} to {new_state}\n"
+                        f"Current state: {self.main_state}\n"
+                        f"Action code: {self.action_code}"
+                    )
+                    self._add_state_history(old_state, new_state, False, error_msg)
+                    raise
+
+            self._safe_update_state(old_state, new_state, action)
+            self._add_state_history(old_state, new_state, True)
+
+            # Only run post hooks if state actually changed
+            if old_state != new_state:
+                try:
+                    for hook in self.post_hooks:
+                        hook(old_state, new_state)
+                except Exception as e:
+                    logging.exception("Post-hook execution failed")
+
+    def exit_to_idle(self, requested_from_state=None):
+        """Exit current state to IDLE if allowed by exit rules
+        Args:
+            requested_from_state: The state that is requesting the exit.
+                                 If None, uses current state.
+        """
+        current_state = self.main_state
+        allowed_states = self.exit_rules.get(current_state, set())
+        if requested_from_state is not None and requested_from_state not in allowed_states:
+            raise MachineStateManagerErr(
+                f"Cannot exit to idle from {current_state} "
+                f"(requested from state: {requested_from_state})")
+        self.change_state(MachineMainState.IDLE)
+
+    # Register default hooks
+    def default_pre_hook(self, old_state, new_state):
+        gcode = self.printer.lookup_object('gcode')
+        gcode.respond_info(f"pre_hook: {old_state} -> {new_state}")
+        return True
+
+    def default_post_hook(self, old_state, new_state):
+        gcode = self.printer.lookup_object('gcode')
+        gcode.respond_info(f"post_hook: {old_state} -> {new_state}")
+        return True
+
+    def get_status(self, eventtime=None):
+        return {
+            'main_state':  self.main_state,
+            'action_code': self.action_code
+        }
+
+    def cmd_SET_ACTION_CODE(self, gcmd):
+        action = gcmd.get('ACTION')
+        main_state = gcmd.get('MAIN_STATE', None)
+        try:
+            if action.isdigit():
+                action_code = ActionCode(int(action))
+            else:
+                action_code = ActionCode[action]
+        except (ValueError, KeyError):
+            raise gcmd.error("Invalid action code: %s" % (action,))
+
+        main_state_val = None
+        if main_state is not None:
+            try:
+                if main_state.isdigit():
+                    main_state_val = MachineMainState(int(main_state))
+                else:
+                    main_state_val = MachineMainState[main_state]
+            except (ValueError, KeyError):
+                raise gcmd.error("Invalid main state: %s" % (main_state,))
+
+        try:
+            self.set_action_code(action_code, main_state_val)
+            if main_state_val is not None:
+                gcmd.respond_info("Success: Set action code {} for state {}".format(action_code, main_state_val))
+            else:
+                gcmd.respond_info("Success: Set action code {}".format(action_code))
+        except Exception as e:
+            raise gcmd.error(str(e))
+
+    def cmd_SET_MAIN_STATE(self, gcmd):
+        state = gcmd.get('MAIN_STATE')
+        action = gcmd.get('ACTION', None)
+        try:
+            if state.isdigit():
+                new_state = MachineMainState(int(state))
+            else:
+                new_state = MachineMainState[state]
+
+            if action is not None:
+                if action.isdigit():
+                    action_code = ActionCode(int(action))
+                else:
+                    action_code = ActionCode[action]
+            else:
+                action_code = None
+        except (ValueError, KeyError) as e:
+            raise gcmd.error("Invalid parameter: %s" % (str(e),))
+
+        try:
+            self.change_state(new_state, action_code)
+            gcmd.respond_info("Success: Changed main state to {} with action {}".format(
+                new_state, action_code if action_code else "None"))
+        except Exception as e:
+            raise gcmd.error("Failed to change state: {}".format(str(e)))
+
+    def cmd_GET_MACHINE_STATE(self, gcmd):
+        """Handle GET_MACHINE_STATE gcode command"""
+        gcmd.respond_info("Machine State: %s, Action: %s" % (
+            self.main_state, self.action_code))
+
+    def cmd_GET_STATE_HISTORY(self, gcmd):
+        """Handle GET_STATE_HISTORY gcode command
+        Args:
+            SHOW_ERROR: Optional parameter (0/1) to control error display
+        """
+        if not self.state_history:
+            gcmd.respond_info("State history is empty")
+            return
+
+        show_error = gcmd.get_int('SHOW_ERROR', 0)
+        gcmd.respond_info("=== State History (latest %d entries) ===" % len(self.state_history))
+        for entry in reversed(self.state_history):
+            timestamp = str(entry['timestamp'])
+            if entry['success']:
+                msg = "%s: %s -> %s SUCCESS" % (
+                    timestamp, entry['from_state'], entry['to_state'])
+            else:
+                msg = "%s: %s -> %s FAILED" % (
+                    timestamp, entry['from_state'], entry['to_state'])
+                if show_error:
+                    msg += " (Error: %s)" % entry['error']
+            gcmd.respond_info(msg)
+
+    def cmd_SHOW_STATE_RULES(self, gcmd):
+        """Display current state transition and exit rules"""
+        gcmd.respond_info("=== Current State: %s ===" % self.main_state)
+
+        gcmd.respond_info("\n=== Transition Rules ===")
+        for target_state, from_states in sorted(self.transition_rules.items()):
+            gcmd.respond_info("%-15s <- %s" % (
+                target_state, ", ".join(str(s) for s in sorted(from_states))))
+
+        gcmd.respond_info("\n=== Exit Rules ===")
+        for state, exit_states in sorted(self.exit_rules.items()):
+            gcmd.respond_info("%-15s can exit to: %s" % (
+                state, ", ".join(str(s) for s in sorted(exit_states))))
+
+    def cmd_EXIT_TO_IDLE(self, gcmd):
+        """Handle EXIT_TO_IDLE gcode command
+        Args:
+            REQ_FROM_STATE: Optional parameter to specify the requesting state
+        """
+        requested_from_state = gcmd.get('REQ_FROM_STATE', None)
+        try:
+            if requested_from_state is not None:
+                if requested_from_state.isdigit():
+                    requested_from_state = MachineMainState(int(requested_from_state))
+                else:
+                    requested_from_state = MachineMainState[requested_from_state]
+            self.exit_to_idle(requested_from_state)
+            gcmd.respond_info("Success: Exited to idle state")
+        except Exception as e:
+            raise gcmd.error(f"Failed to exit to idle: {str(e)}")
+
+def load_config(config):
+    return MachineStateManager(config)
--- a/klippy/extras/motion_report.py
+++ b/klippy/extras/motion_report.py
@@ -228,6 +228,15 @@ class PrinterMotionReport:
         self.last_status['live_velocity'] = xyzvelocity
         self.last_status['live_extruder_velocity'] = evelocity
         return self.last_status
+    
+    def start_trapq_client(self, trapq_name, client):
+        if self.trapqs.get(trapq_name) is None:
+            raise f'no trapq {trapq_name} in motion report'
+        if self.trapqs.get(trapq_name) is None:
+            raise f'invalid trapq name: {trapq_name}'
+        logging.info(f"create a trapq client for axis[{trapq_name}]")
+        trapq =  self.trapqs[trapq_name]
+        trapq.batch_bulk.add_client(client)
 
 def load_config(config):
     return PrinterMotionReport(config)
--- /dev/null
+++ b/klippy/extras/park_detector.py
@@ -0,0 +1,96 @@
+# Support for extruder park detection
+import logging
+
+class ParkDetector:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.name = config.get_name().split(' ')[-1]
+        self.pin = config.get('pin')
+        self.active_state = 0
+        self.park_state = 0
+        self.grab_valid_state = 0
+        self.ignore_active_pin = config.getboolean('ignore_active_pin', False)
+        self.gcode = self.printer.lookup_object('gcode')
+        self.park_adc_button = None
+        self.active_adc_button = None
+        self.grab_valid_adc_button = None
+        buttons = self.printer.load_object(config, "buttons")
+        if config.get('analog_range', None) is None:
+            buttons.register_buttons([self.pin], self.park_detector_callback)
+        else:
+            amin, amax = config.getfloatlist('analog_range', count=2)
+            pullup = config.getfloat('analog_pullup_resistor', 4700., above=0.)
+            self.park_adc_button = buttons.register_adc_button(self.pin, amin, amax, pullup,
+                                        self.park_detector_callback)
+
+        self.active_pin = config.get('active_pin', None)
+        if self.active_pin is not None:
+            if config.get('active_analog_range', None) is None:
+                buttons.register_buttons([self.active_pin], self.active_detector_callback)
+            else:
+                amin, amax = config.getfloatlist('active_analog_range', count=2)
+                pullup = config.getfloat('active_analog_pullup_resistor', 4700., above=0.)
+                self.active_adc_button = buttons.register_adc_button(self.active_pin, amin, amax, pullup,
+                                            self.active_detector_callback)
+
+        self.grab_valid_pin = config.get('grab_valid_pin', None)
+        if self.grab_valid_pin is not None:
+            if config.get('grab_valid_analog_range', None) is None:
+                buttons.register_buttons([self.grab_valid_pin], self.grab_valid_detector_callback)
+            else:
+                amin, amax = config.getfloatlist('grab_valid_analog_range', count=2)
+                pullup = config.getfloat('grab_valid_analog_pullup_resistor', 4700., above=0.)
+                self.grab_valid_adc_button = buttons.register_adc_button(self.grab_valid_pin, amin, amax, pullup,
+                                            self.grab_valid_detector_callback)
+
+        self.gcode.register_mux_command("QUERY_PARK_STA", "NAME", self.name,
+                                        self.cmd_QUERY_PARK,
+                                        desc=self.cmd_QUERY_PARK_help)
+
+    cmd_QUERY_PARK_help = "Report on the state of a Park Detector"
+    def cmd_QUERY_PARK(self, gcmd):
+        state = self.get_park_detector_status()
+        msg_info = self.name + " state: " + state['state'] + '\n'
+        msg_info += "park_pin: {} active_pin: {} grab_valid_pin: {}".format(state['park_pin'], state['active_pin'], state['grab_valid_pin'])
+        self.get_park_detector_adc_value()
+        gcmd.respond_info(msg_info)
+
+    def park_detector_callback(self, eventtime, state):
+        self.park_state = bool(state)
+        # self.gcode.respond_info("{} park_state {}, tick {}".format(self.name, self.park_state, self.reactor.monotonic()))
+
+    def active_detector_callback(self, eventtime, state):
+        self.active_state = bool(state)
+        # self.gcode.respond_info("{} active_state {}, tick {}".format(self.name, self.active_state, self.reactor.monotonic()))
+
+    def grab_valid_detector_callback(self, eventtime, state):
+        self.grab_valid_state = bool(state)
+
+    def get_park_detector_status(self):
+        state = {}
+        if self.active_pin is not None and not self.ignore_active_pin:
+            if self.active_state and not self.park_state:
+                state['state'] = 'ACTIVATE'
+            elif not self.active_state and self.park_state:
+                state['state'] = 'PARKED'
+            else:
+                state['state'] = 'UNKNOWN'
+        else:
+            state['state'] =  'PARKED' if self.park_state else 'ACTIVATE'
+        state['park_pin'] = bool(self.park_state)
+        state['active_pin'] = bool(self.active_state) if self.active_pin is not None else bool(not self.park_state)
+        state['grab_valid_pin'] = bool(self.grab_valid_state)
+        # self.get_park_detector_adc_value()
+        return state
+
+    def get_park_detector_adc_value(self):
+        if self.park_adc_button is not None:
+            self.gcode.respond_info("{} park_adc {:.3f}v".format(self.name, self.park_adc_button.last_adc_value*3.3))
+        if self.active_adc_button is not None:
+            self.gcode.respond_info("{} active_adc {:.3f}v".format(self.name, self.active_adc_button.last_adc_value*3.3))
+        if self.grab_valid_adc_button is not None:
+            self.gcode.respond_info("{} grab_valid_adc {:.3f}v".format(self.name, self.grab_valid_adc_button.last_adc_value*3.3))
+
+def load_config_prefix(config):
+    return ParkDetector(config)
\ No newline at end of file
--- a/klippy/extras/pause_resume.py
+++ b/klippy/extras/pause_resume.py
@@ -4,9 +4,12 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 
+import logging
+
 class PauseResume:
     def __init__(self, config):
         self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
         self.gcode = self.printer.lookup_object('gcode')
         self.recover_velocity = config.getfloat('recover_velocity', 50.)
         self.v_sd = None
@@ -15,8 +18,12 @@ class PauseResume:
         self.pause_command_sent = False
         self.printer.register_event_handler("klippy:connect",
                                             self.handle_connect)
+        self.gcode.register_command("PAUSE_BASE", self.cmd_PAUSE_BASE,
+                                    desc=self.cmd_PAUSE_BASE_help)
         self.gcode.register_command("PAUSE", self.cmd_PAUSE,
                                     desc=self.cmd_PAUSE_help)
+        self.gcode.register_command("RESUME_BASE", self.cmd_RESUME_BASE,
+                                    desc=self.cmd_RESUME_BASE_help)
         self.gcode.register_command("RESUME", self.cmd_RESUME,
                                     desc=self.cmd_RESUME_help)
         self.gcode.register_command("CLEAR_PAUSE", self.cmd_CLEAR_PAUSE,
@@ -33,8 +40,11 @@ class PauseResume:
     def handle_connect(self):
         self.v_sd = self.printer.lookup_object('virtual_sdcard', None)
     def _handle_cancel_request(self, web_request):
+        self.printer.send_event("pause_resume:cancel")
         self.gcode.run_script("CANCEL_PRINT")
     def _handle_pause_request(self, web_request):
+        if self.v_sd is not None and self.v_sd.work_timer is not None:
+            self.v_sd.pl_allow_save_env = False
         self.gcode.run_script("PAUSE")
     def _handle_resume_request(self, web_request):
         self.gcode.run_script("RESUME")
@@ -57,14 +67,27 @@ class PauseResume:
                 self.sd_paused = False
                 self.gcode.respond_info("action:paused")
             self.pause_command_sent = True
-    cmd_PAUSE_help = ("Pauses the current print")
-    def cmd_PAUSE(self, gcmd):
+    cmd_PAUSE_BASE_help = ("Pauses the current print")
+    def cmd_PAUSE_BASE(self, gcmd):
         if self.is_paused:
             gcmd.respond_info("Print already paused")
             return
         self.send_pause_command()
         self.gcode.run_script_from_command("SAVE_GCODE_STATE NAME=PAUSE_STATE")
         self.is_paused = True
+    cmd_PAUSE_help = ("Pauses the current print")
+    def cmd_PAUSE(self, gcmd):
+        if self.is_paused:
+            gcmd.respond_info("Print already paused")
+            return
+        try:
+            gcmd.respond_info("Pausing...")
+            rawparams = gcmd.get_raw_command_parameters()
+            self.gcode.run_script_from_command("INNER_PAUSE %s\n" % (rawparams))
+        except Exception as e:
+            raise gcmd.error("Unable to pause print: %s" % (str(e)))
+        finally:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
     def send_resume_command(self):
         if self.sd_paused:
             # Printing from virtual sd, run pause command
@@ -73,17 +96,54 @@ class PauseResume:
         else:
             self.gcode.respond_info("action:resumed")
         self.pause_command_sent = False
-    cmd_RESUME_help = ("Resumes the print from a pause")
-    def cmd_RESUME(self, gcmd):
+    cmd_RESUME_BASE_help = ("Resumes the print from a pause")
+    def cmd_RESUME_BASE(self, gcmd):
         if not self.is_paused:
             gcmd.respond_info("Print is not paused, resume aborted")
             return
         velocity = gcmd.get_float('VELOCITY', self.recover_velocity)
+        move = gcmd.get_int('MOVE', 1 , minval=0, maxval=1)
+        accel = gcmd.get_float('MOVE_ACCEL', 5000.)
+        extrude = gcmd.get_float('EXTRUDE', 0., minval=0., maxval=20.)
         self.gcode.run_script_from_command(
-            "RESTORE_GCODE_STATE NAME=PAUSE_STATE MOVE=1 MOVE_SPEED=%.4f"
-            % (velocity))
+            "RESTORE_GCODE_STATE NAME=PAUSE_STATE MOVE=%d MOVE_SPEED=%.4f MOVE_ACCEL=%.4f EXTRUDE=%.4f"
+            % (move, velocity, accel, extrude))
         self.send_resume_command()
         self.is_paused = False
+    cmd_RESUME_help = ("Resumes the print from a pause")
+    def cmd_RESUME(self, gcmd):
+        if self.is_paused == False:
+            gcmd.respond_info("Not in paused state and cannot be resumed!\r\n")
+            return
+        try:
+            gcmd.respond_info("Resuming...")
+            rawparams = gcmd.get_raw_command_parameters()
+            self.gcode.run_script_from_command("INNER_RESUME %s\n" % (rawparams))
+        except:
+            gcmd.respond_info("!! Resumes error!")
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+            try:
+                toolhead = self.printer.lookup_object('toolhead')
+                macro = self.printer.lookup_object('gcode_macro PAUSE', None)
+                temp = 40
+                if macro is not None:
+                    temp = macro.variables.get('pause_temp', 40)
+
+                for i in range(toolhead.max_physical_extruder_num):
+                    obj = None
+                    if i == 0:
+                        obj = self.printer.lookup_object('extruder', None)
+                    else:
+                        obj = self.printer.lookup_object(f'extruder{i}', None)
+
+                    if obj is not None and obj.get_status(self.reactor.monotonic())['target'] > 0:
+                        self.gcode.run_script_from_command(f"M104 S{temp} T{i} A0\n")
+            except Exception as e:
+                logging.error(str(e))
+                gcmd.respond_info("!! Set pause_temp error!\r\n")
+
+            raise
+
     cmd_CLEAR_PAUSE_help = (
         "Clears the current paused state without resuming the print")
     def cmd_CLEAR_PAUSE(self, gcmd):
--- a/klippy/extras/pid_calibrate.py
+++ b/klippy/extras/pid_calibrate.py
@@ -17,11 +17,17 @@ class PIDCalibrate:
         heater_name = gcmd.get('HEATER')
         target = gcmd.get_float('TARGET')
         write_file = gcmd.get_int('WRITE_FILE', 0)
+        profile = gcmd.get('PROFILE', 'default')
         pheaters = self.printer.lookup_object('heaters')
         try:
             heater = pheaters.lookup_heater(heater_name)
         except self.printer.config_error as e:
             raise gcmd.error(str(e))
+
+        # Check if PID calibration is allowed for this heater
+        if hasattr(heater, 'allow_pid_calibrate') and not heater.allow_pid_calibrate:
+            raise gcmd.error("PID calibration is not allowed for heater '%s'" % (heater_name,))
+
         self.printer.lookup_object('toolhead').get_last_move_time()
         calibrate = ControlAutoTune(heater, target)
         old_control = heater.set_control(calibrate)
@@ -50,6 +56,36 @@ class PIDCalibrate:
         configfile.set(cfgname, 'pid_Ki', "%.3f" % (Ki,))
         configfile.set(cfgname, 'pid_Kd', "%.3f" % (Kd,))
 
+        # Check if heater has ignore_pid_json setting and save to JSON if needed
+        ignore_pid_json = getattr(heater.control, 'ignore_pid_json', True)
+        if not ignore_pid_json:
+            try:
+                profiles = heater.control._load_heater_pid_profiles_from_json(heater.control.json_filename)
+                if profiles is None:
+                    profiles = {}
+
+                # Update or create specified profile
+                if profile not in profiles:
+                    profiles[profile] = {}
+
+                profiles[profile].update({
+                    'Kp': Kp,
+                    'Ki': Ki,
+                    'Kd': Kd
+                })
+                heater.control._save_heater_pid_profiles_to_json(heater.control.json_filename, profiles)
+
+                if (hasattr(heater.control, 'current_profile') and
+                    heater.control.current_profile == profile and
+                    hasattr(heater.control, 'pid_profiles')):
+                    heater.control.pid_profiles[profile]['Kp'] = Kp / heaters.PID_PARAM_BASE
+                    heater.control.pid_profiles[profile]['Ki'] = Ki / heaters.PID_PARAM_BASE
+                    heater.control.pid_profiles[profile]['Kd'] = Kd / heaters.PID_PARAM_BASE
+                    heater.control.set_pid_profile(profile)
+
+            except Exception as e:
+                logging.warning("Failed to save PID parameters to JSON: %s", str(e))
+
 TUNE_PID_DELTA = 5.0
 
 class ControlAutoTune:
--- /dev/null
+++ b/klippy/extras/power_loss_check.py
@@ -0,0 +1,291 @@
+# Power loss detection handling
+
+import logging, copy, ctypes
+import pins
+import stepper
+
+class PowerLossCheck:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.gcode = config.get_printer().lookup_object('gcode')
+        self.enable_status_output = False
+        self.name = 'master' if config.get_name() == 'power_loss_check' else config.get_name().split()[-1]
+
+        # Configuration parameters
+        ppins = self.printer.lookup_object('pins')
+        pin = config.get('pin')
+        pin_params = ppins.lookup_pin(pin, can_invert=True, can_pullup=True)
+        self._mcu = pin_params['chip']
+        self.power_loss_trigger_time = config.getfloat('power_loss_trigger_time', 0.0109, above=0.)
+        self.report_interval_time = config.getint('report_interval', 0, minval=0)
+        self.duty_threshold = config.getfloat('duty_threshold', 0.54, minval=0)
+        self.debounce_threshold = config.getint('debounce_threshold', 20, minval=0)
+        self.type_confirm_threshold = config.getint('type_confirm_threshold', 3, minval=0)
+        self._cmd_queue = self._mcu.alloc_command_queue()
+        self._mcu.register_config_callback(self._build_config)
+
+        self.high_level_tick = 0xFFFFFFFF
+        self.low_level_tick = 0xFFFFFFFF
+        self.voltage_type = 0xFF
+        self.power_loss_flag = 0
+        self.initialized = 0
+        self.duty_percent = 0.0
+        self.pl_flash_valid = {}
+        self.pl_flash_save_data = {}
+        self.pl_tmp_flash_data = {}
+        self.pl_get_flash_date = False
+        self.pl_exception_is_report = False
+        # Register GCODE commands
+        if self.name == 'master':
+            self.last_type = None
+            self.timer = self.reactor.register_timer(self._auto_switch_bed_pid_control)
+            self.bed_pid_control_mode = config.get('bed_pid_control_mode', 'auto_switch')
+            self.gcode.register_command('UPDATE_POWER_LOSS_REPORT_INTERVAL',
+                                    self.cmd_UPDATE_POWER_LOSS_REPORT_INTERVAL,
+                                    desc=self.cmd_UPDATE_POWER_LOSS_REPORT_INTERVAL_help)
+            self.gcode.register_command('QUERY_POWER_LOSS_CHECK_INFO',
+                                    self.cmd_QUERY_POWER_LOSS_CHECK_INFO,
+                                    desc=self.cmd_QUERY_POWER_LOSS_CHECK_INFO_help)
+            self.gcode.register_command('ENABLE_POWER_LOSS_REPORT_LOG',
+                                    self.cmd_ENABLE_POWER_LOSS_REPORT_LOG,
+                                    desc=self.cmd_ENABLE_POWER_LOSS_REPORT_LOG_help)
+
+        self.gcode.register_mux_command("ENABLE_POWER_LOSS", "NAME", self.name,
+                                        self.cmd_ENABLE_POWER_LOSS)
+        self.gcode.register_mux_command("QUERY_POWER_LOSS_FLASH_VALID", "NAME", self.name,
+                                        self.cmd_QUERY_POWER_LOSS_FLASH_VALID,
+                                        desc=self.cmd_QUERY_POWER_LOSS_FLASH_VALID_help)
+        self.gcode.register_mux_command("QUERY_POWER_LOSS_STEPPER_INFO", "NAME", self.name,
+                                        self.cmd_QUERY_POWER_LOSS_STEPPER_INFO,
+                                        desc=self.cmd_QUERY_POWER_LOSS_STEPPER_INFO_help)
+        self.printer.register_event_handler("klippy:ready", self._handle_klipper_ready)
+
+    def _build_config(self):
+        self._oid = self._mcu.create_oid()
+        clock = self._mcu.get_query_slot(self._oid)
+        self._report_clock = self._mcu.seconds_to_clock(self.report_interval_time)
+        self._mcu.add_config_cmd(
+            "config_power_loss_check oid=%d clock=%u power_loss_trigger_time=%u report_interval=%u duty_threshold=%u"
+            " debounce_threshold=%u type_confirm_threshold=%u"
+            % (self._oid, clock, self.power_loss_trigger_time*1000000, self._report_clock, self.duty_threshold*1000000,
+               self.debounce_threshold, self.type_confirm_threshold))
+
+        self.update_report_interval_cmd = self._mcu.lookup_command(
+            "update_report_interval oid=%c report_interval=%u")
+
+        self.enable_power_loss_cmd = self._mcu.lookup_command(
+            "enable_power_loss oid=%c enable=%u print_flag=%u move_line=%u")
+
+        self.query_power_loss_stepper_info_cmd = self._mcu.lookup_query_command(
+            "query_power_loss_stepper_info oid=%c type=%u index=%u",
+            "power_loss_stepper_info_result oid=%c result=%u",
+            oid=self._oid, cq=self._cmd_queue)
+
+        self.query_power_loss_flash_valid_cmd = self._mcu.lookup_query_command(
+            "query_power_loss_flash_valid oid=%c",
+            "power_loss_flash_valid oid=%c last_seq=%u valid_sector_count=%u env_flag=%u save_stepper_num=%u",
+            oid=self._oid, cq=self._cmd_queue)
+
+        self.query_power_loss_check_info_cmd = self._mcu.lookup_query_command(
+            "query_power_loss_status oid=%c",
+            "power_loss_status oid=%c high_level=%u low_level=%u voltage_type=%u power_loss_flag=%u initialized=%u",
+            oid=self._oid, cq=self._cmd_queue)
+
+        self._mcu.register_response(self.handle_report_power_loss_status,
+                            "report_power_loss_status", self._oid)
+
+        self._mcu.register_response(self.handle_report_stepper_info,
+                            "power_loss_stepper_info", self._oid)
+
+    def _handle_klipper_ready(self):
+        if self.name == 'master':
+            heater_bed = self.printer.lookup_object('heater_bed', None)
+            if heater_bed is not None:
+                if self.bed_pid_control_mode == 'auto_switch':
+                    # need to start a timer to detect the input voltage type
+                    self.reactor.update_timer(self.timer, self.reactor.NOW+0.5)
+                elif self.bed_pid_control_mode == 'pid2' or self.bed_pid_control_mode == 'default':
+                    try:
+                        if heater_bed is not None and hasattr(heater_bed.heater.control, 'Kp'):
+                            self.gcode.run_script_from_command("SET_PID_PROFILE HEATER=heater_bed PROFILE={}".format(self.bed_pid_control_mode))
+                    except Exception as e:
+                        logging.error(f"Error while attempting to force {self.bed_pid_control_mode} for heater_bed: {e}")
+        # query power-loss valid information
+        params = self.query_power_loss_flash_valid_cmd.send([self._oid])
+        self.pl_flash_valid = {}
+        self.pl_flash_valid['last_seq'] = params['last_seq']
+        self.pl_flash_valid['valid_sector_count'] = params['valid_sector_count']
+        self.pl_flash_valid['env_flag'] = params['env_flag']
+        self.pl_flash_valid['save_stepper_num'] = params['save_stepper_num']
+
+        # query flash saved stepper information
+        self.pl_tmp_flash_data = {}
+        params = self.query_power_loss_stepper_info_cmd.send([self._oid, 255, 0])
+        self.pl_flash_save_data = copy.deepcopy(self.pl_tmp_flash_data)
+        self.pl_get_flash_date = True
+        power_loss_check_list = self.printer.lookup_object('power_loss_check_list', [])
+        if all(getattr(obj, 'pl_get_flash_date', False) for obj in power_loss_check_list):
+            self.printer.send_event("power_loss_check:mcu_update_complete")
+
+    def _auto_switch_bed_pid_control(self, eventtime):
+        voltage_type = 0xFF
+        if self.voltage_type != voltage_type:
+            voltage_type = self.voltage_type
+            if self.last_type != voltage_type:
+                self.last_type = voltage_type
+            else:
+                switch_success = True
+                try:
+                    if voltage_type == 0:
+                        heater_bed = self.printer.lookup_object('heater_bed', None)
+                        if heater_bed is not None and hasattr(heater_bed.heater.control, 'Kp'):
+                            self.gcode.run_script_from_command("SET_PID_PROFILE HEATER=heater_bed PROFILE=pid2")
+                except Exception as e:
+                    switch_success = False
+                    logging.error(f"auto_switch_bed_pid_control failed: {e}")
+                finally:
+                    voltage_str = "220v" if voltage_type == 1 else "110v"
+                    self.gcode.respond_info("auto switching bed PID control based on voltage type: {}, switch_success: {}".format(voltage_str, switch_success))
+                    return self.reactor.NEVER
+        return eventtime + self.report_interval_time + 0.3
+
+    def get_status(self, eventtime):
+        return {
+            'initialized': self.initialized,
+            'high_level_tick': self.high_level_tick,
+            'low_level_tick': self.low_level_tick,
+            'voltage_type': self.voltage_type,
+            'power_loss_flag': self.power_loss_flag,
+            'duty_percent': self.duty_percent
+        }
+
+    def _update_status_from_params(self, params):
+        self.initialized = params['initialized']
+        self.high_level_tick = params['high_level']
+        self.low_level_tick = params['low_level']
+        self.voltage_type = params['voltage_type']
+        self.power_loss_flag = params['power_loss_flag']
+        if self.initialized and self.high_level_tick != 0xFFFFFFFF and self.low_level_tick != 0xFFFFFFFF:
+            self.duty_percent =  self.high_level_tick / (self.high_level_tick + self.low_level_tick)
+
+    def handle_report_power_loss_status(self, params):
+        self._update_status_from_params(params)
+        if self.enable_status_output:
+            voltage_str = "110v" if self.voltage_type == 0 else \
+                         "220v" if self.voltage_type == 1 else "detecting"
+            self.gcode.respond_info("Assigned variables: initialized=%d, high_level_tick=%d, low_level_tick=%d, voltage_type=%s, power_loss_flag=%d, duty_percent=%.2f%%" % (
+                self.initialized, self.high_level_tick, self.low_level_tick,
+                voltage_str, self.power_loss_flag, self.duty_percent*100))
+
+        if self.name == 'master' and self.power_loss_flag and self.pl_exception_is_report == False:
+            self.pl_exception_is_report = True
+            # coded = "0003-0522-0000-0017"
+            # self.printer.raise_structured_code_exception(coded, "mcu: Power loss triggered", 0, 0)
+            error = '{"coded": "0003-0522-0000-0017", "msg":"%s", "oneshot": 0}' % ("mcu: Power loss triggered",)
+            self.printer.invoke_shutdown(error)
+
+    def handle_report_stepper_info(self, params):
+        stepper_type = params['type']
+        stepper_index = params['index']
+        stepper_line = params['line']
+        stepper_position = ctypes.c_int32(params['position']).value
+        if stepper_type < len(stepper.power_loss_need_save_steppers):
+            name = stepper.power_loss_need_save_steppers[stepper_type]
+            if stepper_index > 0:
+                name += str(stepper_index)
+            self.gcode.respond_info(
+                "Stepper %s: line=%u position=%d" % (
+                    name, stepper_line, stepper_position))
+            # Save stepper info to pl_tmp_flash_data with name as key
+            self.pl_tmp_flash_data[name] = {
+                'line': stepper_line,
+                'position': stepper_position
+            }
+        else:
+            self.gcode.respond_info(
+                "Unknown stepper type=%d index=%d: line=%u position=%d" % (
+                    stepper_type, stepper_index, stepper_line, stepper_position))
+    def query_power_loss_stepper_info(self, stepper_type=0, stepper_index=0):
+        try:
+            self.pl_tmp_flash_data = {}
+            params = self.query_power_loss_stepper_info_cmd.send([self._oid, stepper_type, stepper_index])
+            return copy.deepcopy(self.pl_tmp_flash_data)
+        except Exception as e:
+            logging.error(f"Failed to query power loss stepper info: {e}")
+            return None
+
+    cmd_UPDATE_POWER_LOSS_REPORT_INTERVAL_help = "Update power loss report interval"
+    def cmd_UPDATE_POWER_LOSS_REPORT_INTERVAL(self, gcmd):
+        interval = gcmd.get_float('INTERVAL', minval=0)
+        clock = self._mcu.seconds_to_clock(interval)
+        self.update_report_interval_cmd.send([self._oid, clock])
+        self.report_interval_time = interval
+        gcmd.respond_info("Power loss report interval updated to %.3f seconds" % interval)
+
+    cmd_QUERY_POWER_LOSS_CHECK_INFO_help = "Query power loss check status"
+    def cmd_QUERY_POWER_LOSS_CHECK_INFO(self, gcmd):
+        params = self.query_power_loss_check_info_cmd.send([self._oid])
+        self._update_status_from_params(params)
+        voltage_str = "110v" if self.voltage_type == 0 else \
+                     "220v" if self.voltage_type == 1 else "detecting"
+        self.gcode.respond_info("QUERY_POWER_LOSS_CHECK_INFO: initialized=%d, high_level_tick=%d, low_level_tick=%d, voltage_type=%s, power_loss_flag=%d, duty_percent=%.2f%%" % (
+            self.initialized, self.high_level_tick, self.low_level_tick,
+            voltage_str, self.power_loss_flag, self.duty_percent*100))
+
+    cmd_ENABLE_POWER_LOSS_REPORT_LOG_help = "Enable/disable power loss status report output"
+    def cmd_ENABLE_POWER_LOSS_REPORT_LOG(self, gcmd):
+        enable = gcmd.get_int('ENABLE', 0, minval=0, maxval=1)
+        self.enable_status_output = bool(enable)
+        gcmd.respond_info("Power loss status report output %s" %
+                         ("enabled" if self.enable_status_output else "disabled"))
+
+    cmd_QUERY_POWER_LOSS_FLASH_VALID_help = "Query power loss flash valid status"
+    def cmd_QUERY_POWER_LOSS_FLASH_VALID(self, gcmd):
+        params = self.query_power_loss_flash_valid_cmd.send([self._oid])
+        self.gcode.respond_info(
+            "query %s power_loss_flash_valid: last_seq=%u valid_sector_count=%u "
+            "env_flag=%u save_stepper_num=%u" % (
+                self.name, params['last_seq'], params['valid_sector_count'],
+                params['env_flag'], params['save_stepper_num']))
+
+    cmd_QUERY_POWER_LOSS_STEPPER_INFO_help = "Query power loss stepper info"
+    def cmd_QUERY_POWER_LOSS_STEPPER_INFO(self, gcmd):
+        stepper_type = gcmd.get_int('TYPE', 0, minval=0)
+        stepper_index = gcmd.get_int('INDEX', 0, minval=0)
+        if stepper_type == 255:
+            self.gcode.respond_info("save {} flash steppers info:".format(self.name))
+        else:
+            self.gcode.respond_info("cur_kin steppers info:")
+        params = self.query_power_loss_stepper_info_cmd.send([self._oid, stepper_type, stepper_index])
+        self.gcode.respond_info("query {} completed".format(self.name))
+
+    def cmd_ENABLE_POWER_LOSS(self, gcmd):
+        enable = gcmd.get_int('ENABLE', 0, minval=0, maxval=1)
+        print_flag = gcmd.get_int('PRINT_FLAG', 0xFFFFFFFF)
+        move_line = gcmd.get_int('MOVE_LINE', 0xFFFFFFFF)
+        self.enable_power_loss_cmd.send([self._oid, enable, print_flag, move_line])
+        gcmd.respond_info("%s power loss %s, print_flag %d, move_line %d" %
+                         (self.name, "enabled" if enable else "disabled", print_flag, move_line))
+
+def load_config(config):
+    power_loss_check_list = config.get_printer().lookup_object('power_loss_check_list', None)
+    pl_obj = PowerLossCheck(config)
+    if power_loss_check_list is None:
+        pl_list = []
+        pl_list.append(pl_obj)
+        config.get_printer().add_object('power_loss_check_list', pl_list)
+    else:
+        power_loss_check_list.append(pl_obj)
+    return pl_obj
+
+def load_config_prefix(config):
+    power_loss_check_list = config.get_printer().lookup_object('power_loss_check_list', None)
+    pl_obj = PowerLossCheck(config)
+    if power_loss_check_list is None:
+        pl_list = []
+        pl_list.append(pl_obj)
+        config.get_printer().add_object('power_loss_check_list', pl_list)
+    else:
+        power_loss_check_list.append(pl_obj)
+    return pl_obj
--- a/klippy/extras/print_stats.py
+++ b/klippy/extras/print_stats.py
@@ -4,30 +4,93 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 
+import logging, copy, os
+
+LOGICAL_EXTRUDER_NUM = 32
+PHYSICAL_EXTRUDER_NUM = 4
+PRINT_STATS_CONFIG_FILE                         = "print_stats.json"
+
+PRINT_STATS_DEFAULT_CONFIG                      = {
+    'print_job': {
+        'flow_calibrate': [False] * PHYSICAL_EXTRUDER_NUM,
+        'preextrude_filament': [False] * LOGICAL_EXTRUDER_NUM,
+    }
+}
+
 class PrintStats:
     def __init__(self, config):
         printer = config.get_printer()
+        self.printer = printer
         self.gcode_move = printer.load_object(config, 'gcode_move')
         self.reactor = printer.get_reactor()
-        self.reset()
+
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = PRINT_STATS_CONFIG_FILE
+        self._config_path = os.path.join(config_dir, config_name)
+        self._config = self.printer.load_snapmaker_config_file(
+            self._config_path,
+            PRINT_STATS_DEFAULT_CONFIG,
+            create_if_not_exist=True)
+
+        self.print_task_config = None
+        self.max_logical_extruder_num = LOGICAL_EXTRUDER_NUM
+        self.max_physical_extruder_num = PHYSICAL_EXTRUDER_NUM
+
+        self.reset(reprint=True)
         # Register commands
         self.gcode = printer.lookup_object('gcode')
         self.gcode.register_command(
             "SET_PRINT_STATS_INFO", self.cmd_SET_PRINT_STATS_INFO,
             desc=self.cmd_SET_PRINT_STATS_INFO_help)
+        self.gcode.register_command(
+            "SM_PRINT_PREEXTRUDE_FILAMENT", self.cmd_SM_PRINT_PREEXTRUDE_FILAMENT)
+        self.gcode.register_command(
+            "SM_PRINT_FLOW_CALIBRATE", self.cmd_SM_PRINT_FLOW_CALIBRATE)
+        # event handler
+        self.printer.register_event_handler("klippy:ready", self._ready)
+
+    def _ready(self):
+        self.toolhead = self.printer.lookup_object("toolhead")
+        self.max_logical_extruder_num = self.toolhead.max_logical_extruder_num
+        self.max_physical_extruder_num = self.toolhead.max_physical_extruder_num
+        self.print_task_config = self.printer.lookup_object("print_task_config", None)
+        if len(self._config['print_job']['flow_calibrate']) != self.max_physical_extruder_num or \
+                len(self._config['print_job']['preextrude_filament']) != self.max_logical_extruder_num:
+            PRINT_STATS_DEFAULT_CONFIG['print_job']['flow_calibrate'] = [False] * self.max_physical_extruder_num
+            PRINT_STATS_DEFAULT_CONFIG['print_job']['preextrude_filament'] = [False] * self.max_logical_extruder_num
+            self._config = copy.deepcopy(PRINT_STATS_DEFAULT_CONFIG)
+            if not self.printer.update_snapmaker_config_file(self._config_path,
+                    self._config, PRINT_STATS_DEFAULT_CONFIG):
+                logging.error("[print_stats] save config failed\r\n")
+
     def _update_filament_usage(self, eventtime):
         gc_status = self.gcode_move.get_status(eventtime)
         cur_epos = gc_status['position'].e
         self.filament_used += (cur_epos - self.last_epos) \
             / gc_status['extrude_factor']
         self.last_epos = cur_epos
-    def set_current_file(self, filename):
-        self.reset()
+    def set_current_file(self, filename, reprint=False):
+        self.reset(reprint)
         self.filename = filename
     def note_start(self):
         curtime = self.reactor.monotonic()
+        virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+        print_file_env = layer_info = None
+        if virtual_sdcard is not None:
+            print_file_env = virtual_sdcard.get_pl_print_file_env()
+            layer_info = virtual_sdcard.get_pl_print_layer_info()
+            if print_file_env is not None and print_file_env.get("filament_used"):
+                self.filament_used = print_file_env.get("filament_used")
+
         if self.print_start_time is None:
-            self.print_start_time = curtime
+            # self.print_start_time = curtime
+            if print_file_env is not None and print_file_env.get("total_duration"):
+                self.print_start_time = curtime - int(print_file_env.get("total_duration"))
+                if layer_info is not None and layer_info.get("current_layer") is not None and layer_info.get("total_layer") is not None:
+                    self.info_current_layer = int(layer_info.get("current_layer"))
+                    self.info_total_layer = int(layer_info.get("total_layer"))
+            else:
+                self.print_start_time = curtime
         elif self.last_pause_time is not None:
             # Update pause time duration
             pause_duration = curtime - self.last_pause_time
@@ -38,7 +101,8 @@ class PrintStats:
         self.last_epos = gc_status['position'].e
         self.state = "printing"
         self.error_message = ""
-    def note_pause(self):
+        self.printer.send_event("print_stats:start")
+    def note_pause(self, message=None):
         if self.last_pause_time is None:
             curtime = self.reactor.monotonic()
             self.last_pause_time = curtime
@@ -46,6 +110,9 @@ class PrintStats:
             self._update_filament_usage(curtime)
         if self.state != "error":
             self.state = "paused"
+        if message is not None:
+            self.error_message = message
+        self.printer.send_event("print_stats:paused")
     def note_complete(self):
         self._note_finish("complete")
     def note_error(self, message):
@@ -53,7 +120,11 @@ class PrintStats:
     def note_cancel(self):
         self._note_finish("cancelled")
     def _note_finish(self, state, error_message = ""):
+        print_config = self.printer.lookup_object('print_task_config', None)
+        if print_config is not None:
+            print_config.reset_print_info()
         if self.print_start_time is None:
+            self.printer.send_event("print_stats:stop")
             return
         self.state = state
         self.error_message = error_message
@@ -64,6 +135,7 @@ class PrintStats:
             self.init_duration = self.total_duration - \
                 self.prev_pause_duration
         self.print_start_time = None
+        self.printer.send_event("print_stats:stop")
     cmd_SET_PRINT_STATS_INFO_help = "Pass slicer info like layer act and " \
                                     "total to klipper"
     def cmd_SET_PRINT_STATS_INFO(self, gcmd):
@@ -82,7 +154,89 @@ class PrintStats:
                 current_layer is not None and \
                 current_layer != self.info_current_layer:
             self.info_current_layer = min(current_layer, self.info_total_layer)
-    def reset(self):
+        virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+        if virtual_sdcard is not None:
+            info_layer = {'current_layer': self.info_current_layer, 'total_layer': self.info_total_layer}
+            virtual_sdcard.record_pl_print_layer_info(info_layer)
+
+    def cmd_SM_PRINT_PREEXTRUDE_FILAMENT(self, gcmd):
+        index = gcmd.get_int("INDEX", None)
+        force = gcmd.get_int("FORCE", False)
+        extruder = None
+        print_task_config_status = None
+        is_soft = False
+
+        if index != None and (index < 0 or index >= self.max_logical_extruder_num):
+            raise gcmd.error("[print_stats] invalid extruder index")
+
+        if self.print_task_config == None:
+            raise gcmd.error("[print_stats] print_task_config not available")
+        else:
+            print_task_config_status = self.print_task_config.get_status()
+        extruder = print_task_config_status['extruder_map_table'][index]
+        is_soft = int(print_task_config_status['filament_soft'][extruder])
+
+        if force == False:
+            if self._config['print_job']['preextrude_filament'][index] == True:
+                return
+            if print_task_config_status['extruders_used'][extruder] == False:
+                return
+
+        toolhead = self.printer.lookup_object("toolhead")
+        toolhead.wait_moves()
+        rawparams = gcmd.get_raw_command_parameters()
+        self.gcode.run_script_from_command(f"T{index}\n")
+        self.gcode.run_script_from_command("INNER_PREEXTRUDE_FILAMENT SOFT=%d %s\n" % (is_soft, rawparams))
+        toolhead.wait_moves()
+        self._config['print_job']['preextrude_filament'][index] = True
+        if not self.printer.update_snapmaker_config_file(self._config_path,
+                self._config, PRINT_STATS_DEFAULT_CONFIG):
+            logging.error("[print_stats] save config failed\r\n")
+
+    def cmd_SM_PRINT_FLOW_CALIBRATE(self, gcmd):
+        index = gcmd.get_int("INDEX", None)
+        extruder = gcmd.get_int("EXTRUDER", None)
+
+        if self.print_task_config is None:
+            raise gcmd.error("[print_stats] print_task_config object not available")
+        print_task_config_status = self.print_task_config.get_status()
+
+        if index is not None and extruder is not None:
+            raise gcmd.error("[print_stats] extruder and index cannot be specified together!")
+
+        if index is not None:
+            if index < 0 or index >= self.max_logical_extruder_num:
+                raise gcmd.error("[print_stats] invalid extruder index!")
+            extruder = print_task_config_status['extruder_map_table'][index]
+        elif extruder is not None:
+            if extruder < 0 or extruder >= self.max_physical_extruder_num:
+                raise gcmd.error("[print_stats] invalid extruder!")
+        else:
+            extruder = self.toolhead.get_extruder().extruder_index
+
+        if print_task_config_status['auto_replenish_filament']:
+            extruder = print_task_config_status['extruders_replenished'][extruder]
+
+        if print_task_config_status['extruders_used'][extruder] == False:
+            return
+
+        if print_task_config_status['flow_calibrate'] == False:
+            return
+
+        if self._config['print_job']['flow_calibrate'][extruder] == True:
+            return
+
+        self.toolhead.wait_moves()
+        rawparams = gcmd.get_raw_command_parameters()
+        self.gcode.run_script_from_command(f"T{extruder} A0\n")
+        self.gcode.run_script_from_command(f"FLOW_CALIBRATE %s\n" % (rawparams))
+        self.toolhead.wait_moves()
+        self._config['print_job']['flow_calibrate'][extruder] = True
+        if not self.printer.update_snapmaker_config_file(self._config_path,
+                self._config, PRINT_STATS_DEFAULT_CONFIG):
+            logging.error("[print_stats] save config failed\r\n")
+
+    def reset(self, reprint=False):
         self.filename = self.error_message = ""
         self.state = "standby"
         self.prev_pause_duration = self.last_epos = 0.
@@ -91,6 +245,13 @@ class PrintStats:
         self.init_duration = 0.
         self.info_total_layer = None
         self.info_current_layer = None
+        if reprint == False:
+            self._config['print_job'] = copy.deepcopy(PRINT_STATS_DEFAULT_CONFIG['print_job'])
+            if not self.printer.update_snapmaker_config_file(
+                    self._config_path,
+                    self._config, PRINT_STATS_DEFAULT_CONFIG):
+                logging.error("[print_stats] save config failed\r\n")
+
     def get_status(self, eventtime):
         time_paused = self.prev_pause_duration
         if self.print_start_time is not None:
--- /dev/null
+++ b/klippy/extras/print_task_config.py
@@ -0,0 +1,576 @@
+# print task config info
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging, os, copy, string
+
+LOGICAL_EXTRUDER_NUM = 32
+PHYSICAL_EXTRUDER_NUM = 4
+
+PRINT_TASK_CONFIG_FILE = "print_task.json"
+
+DEFAULT_PRINT_TASK_CONFIG = {
+    'filament_vendor': ['NONE'] * PHYSICAL_EXTRUDER_NUM,
+    'filament_type': ['NONE'] * PHYSICAL_EXTRUDER_NUM,
+    'filament_sub_type': ['NONE'] * PHYSICAL_EXTRUDER_NUM,
+    'filament_color': [0xFFFFFFFF] * PHYSICAL_EXTRUDER_NUM,
+    'filament_color_rgba': ['FFFFFFFF'] * PHYSICAL_EXTRUDER_NUM,
+    'filament_official': [False] * PHYSICAL_EXTRUDER_NUM,
+    'filament_sku': [0] * PHYSICAL_EXTRUDER_NUM,
+    'filament_edit': [True] * PHYSICAL_EXTRUDER_NUM,
+    'filament_exist': [False] * PHYSICAL_EXTRUDER_NUM,
+    'filament_soft': [False] * PHYSICAL_EXTRUDER_NUM,
+    'extruder_map_table': [i for i in range(PHYSICAL_EXTRUDER_NUM)] + [0] * (LOGICAL_EXTRUDER_NUM - PHYSICAL_EXTRUDER_NUM),
+    'extruders_used' : [False] * PHYSICAL_EXTRUDER_NUM,
+    'extruders_replenished': [i for i in range(PHYSICAL_EXTRUDER_NUM)],
+    'time_lapse_camera': False,
+    'auto_bed_leveling': False,
+    'flow_calibrate': False,
+    'shaper_calibrate': False,
+    'auto_replenish_filament': False,
+    'filament_entangle_detect': False,
+    'reprint_info': {
+        'auto_bed_leveling': False,
+        'flow_calibrate': False,
+        'time_lapse_camera': False,
+        'extruder_map_table': [i for i in range(PHYSICAL_EXTRUDER_NUM)] + [0] * (LOGICAL_EXTRUDER_NUM - PHYSICAL_EXTRUDER_NUM),
+        'extruders_used' : [False] * PHYSICAL_EXTRUDER_NUM,
+    }
+}
+
+class PrintTaskConfig:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+
+        self.filament_dt_obj = None
+        self.filament_param_obj = None
+        self.filament_feed_objects = None
+        self.print_task_config_bak = None
+        self.perform_auto_replenish = False
+
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = PRINT_TASK_CONFIG_FILE
+        self.config_path = os.path.join(config_dir, config_name)
+        self.print_task_config = self.printer.load_snapmaker_config_file(self.config_path, DEFAULT_PRINT_TASK_CONFIG)
+        self.reset_print_info()
+
+        self.gcode = self.printer.lookup_object('gcode')
+        self.gcode.register_command(
+            "SET_PRINT_EXTRUDER_MAP", self.cmd_SET_PRINT_EXTRUDER_MAP)
+        self.gcode.register_command(
+            "GET_PRINT_EXTRUDER_MAP", self.cmd_GET_PRINT_EXTRUDER_MAP)
+        self.gcode.register_command(
+            "SET_PRINT_FILAMENT_CONFIG", self.cmd_SET_PRINT_FILAMENT_CONFIG)
+        self.gcode.register_command(
+            "GET_PRINT_TASK_CONFIG", self.cmd_GET_PRINT_TASK_CONFIG)
+        self.gcode.register_command(
+            "SAVE_CURRENT_PRINT_TASK_CONFIG", self.cmd_SAVE_CURRENT_PRINT_TASK_CONFIG)
+        self.gcode.register_command(
+            "RESET_PRINT_TASK_CONFIG", self.cmd_RESET_PRINT_TASK_CONFIG)
+        self.gcode.register_command(
+            "LOAD_PRINT_TASK_CONFIG", self.cmd_LOAD_PRINT_TASK_CONFIG)
+        self.gcode.register_command(
+            "SET_TIME_LAPSE_CAMERA", self.cmd_SET_TIME_LAPSE_CAMERA)
+        self.gcode.register_command(
+            "SET_PRINT_AUTO_BED_LEVELING", self.cmd_SET_PRINT_AUTO_BED_LEVELING)
+        self.gcode.register_command(
+            "SET_PRINT_PREFERENCES", self.cmd_SET_PRINT_PREFERENCES)
+        self.gcode.register_command(
+            "SET_PRINT_USED_EXTRUDERS", self.cmd_SET_PRINT_USED_EXTRUDERS)
+        self.gcode.register_command(
+            "SET_REPRINT_INFO", self.cmd_SET_REPRINT_INFO)
+        self.gcode.register_command(
+            "INNER_AUTO_REPLENISH_FILAMENT", self.cmd_INNER_AUTO_REPLENISH_FILAMENT)
+
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("print_task_config/set_print_preferences",
+                                   self._handle_set_print_preferences)
+        self.printer.register_event_handler("klippy:ready", self._ready)
+
+    def _handle_set_print_preferences(self, web_request):
+        try:
+            logging.info("[print_task_config] set_print_preferences")
+            auto_replenish_filament = web_request.get_int('auto_replenish_filament', None)
+            filament_entangle_detect = web_request.get_int('filament_entangle_detect', None)
+
+            if auto_replenish_filament is not None:
+                self.print_task_config['auto_replenish_filament'] = bool(auto_replenish_filament)
+
+            if filament_entangle_detect is not None:
+                self.print_task_config['filament_entangle_detect'] = bool(filament_entangle_detect)
+                self.printer.send_event("print_task_config:set_entangle_detect", bool(filament_entangle_detect))
+
+            if not self.printer.update_snapmaker_config_file(self.config_path,
+                        self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+                logging.error("[print_task_config] save print_task_config failed\r\n")
+
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error("[print_task_config] set_print_preferences: %s", str(e))
+            web_request.send({'state': 'error', 'message': str(e)})
+
+    def _ready(self):
+        self.filament_feed_objects = self.printer.lookup_objects('filament_feed')
+        self.filament_param_obj = self.printer.lookup_object('filament_parameters', None)
+        self.filament_dt_obj = self.printer.lookup_object("filament_detect", None)
+        if self.filament_dt_obj is not None:
+            self.filament_dt_obj.register_cb_2_update_filament_info(self._rfid_filament_info_update_cb)
+
+        # Compatible with old versions
+        need_save = False
+        for i in range(PHYSICAL_EXTRUDER_NUM):
+            if type(self.print_task_config['filament_color'][i]) is str:
+                self.print_task_config['filament_color'] = copy.deepcopy(DEFAULT_PRINT_TASK_CONFIG['filament_color'])
+                self.print_task_config['filament_color_rgba'] = copy.deepcopy(DEFAULT_PRINT_TASK_CONFIG['filament_color_rgba'])
+                need_save = True
+
+        if need_save:
+            if not self.printer.update_snapmaker_config_file(self.config_path,
+                    self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+                logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def _reset_print_task_config(self):
+        self.print_task_config = copy.deepcopy(DEFAULT_PRINT_TASK_CONFIG)
+        if not self.printer.update_snapmaker_config_file(self.config_path,
+                self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def get_print_task_config(self):
+        return copy.deepcopy(self.print_task_config)
+
+    def backup_print_task_config(self):
+        # Mainly used for automatic feeding function
+        self.print_task_config_bak = copy.deepcopy(self.print_task_config)
+
+    def _rfid_filament_info_update_cb(self, channel, info, is_clear=False):
+        if channel < 0 or channel >= PHYSICAL_EXTRUDER_NUM:
+            logging.error("[print_task_config] rfid channel[%d] is out of range[0, %d]",
+                          channel, PHYSICAL_EXTRUDER_NUM -1)
+            return
+
+        if is_clear == False and info['OFFICIAL'] == False and \
+                self.print_task_config['filament_vendor'][channel] != 'NONE':
+            return
+
+        if is_clear == False and self.print_task_config['filament_sku'][channel] == info['SKU'] and \
+                self.print_task_config['filament_official'][channel] == info['OFFICIAL'] and \
+                info['OFFICIAL'] == True:
+            return
+
+        filament_color_rgba = f"{info['RGB_1']:06X}" + f"{info['ALPHA']:02X}"
+
+        self.print_task_config['filament_vendor'][channel] = info['VENDOR']
+        self.print_task_config['filament_type'][channel] = info['MAIN_TYPE']
+        self.print_task_config['filament_sub_type'][channel] = info['SUB_TYPE']
+        self.print_task_config['filament_color'][channel] = info['ARGB_COLOR']
+        self.print_task_config['filament_color_rgba'][channel] = filament_color_rgba
+        self.print_task_config['filament_official'][channel] = info['OFFICIAL']
+        self.print_task_config['filament_sku'][channel] = info['SKU']
+        if self.filament_param_obj is not None:
+            self.print_task_config['filament_soft'][channel] = \
+                self.filament_param_obj.get_is_soft(info['VENDOR'], info['MAIN_TYPE'], info['SUB_TYPE'])
+        else:
+            self.print_task_config['filament_soft'][channel] = False
+
+        # do not use run_script_from_command api
+        self.gcode.run_script(f"FLOW_RESET_K EXTRUDER={channel}\r\n")
+
+        if not self.printer.update_snapmaker_config_file(self.config_path,
+                self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def get_extruder_map_table(self):
+        return self.print_task_config['extruder_map_table']
+
+    def get_extruder_map_index(self, index):
+        if index + 1 > len(self.print_task_config['extruder_map_table']):
+            raise ValueError("[print_task_config] index out of range[0,%d]" % (LOGICAL_EXTRUDER_NUM - 1))
+        else:
+            return self.print_task_config['extruder_map_table'][index]
+
+    def reset_print_info(self):
+        logging.info("[print_task_config] reset print info")
+        self.print_task_config['extruder_map_table'] = copy.deepcopy(DEFAULT_PRINT_TASK_CONFIG['extruder_map_table'])
+        self.print_task_config['extruders_used'] = copy.deepcopy(DEFAULT_PRINT_TASK_CONFIG['extruders_used'])
+        self.print_task_config['extruders_replenished'] = copy.deepcopy(DEFAULT_PRINT_TASK_CONFIG['extruders_replenished'])
+        self.print_task_config['flow_calibrate'] = False
+        self.print_task_config['auto_bed_leveling'] = False
+        self.print_task_config['time_lapse_camera'] = False
+        if len(self.print_task_config['reprint_info']['extruder_map_table']) < LOGICAL_EXTRUDER_NUM:
+            self.print_task_config['reprint_info'] = copy.deepcopy(DEFAULT_PRINT_TASK_CONFIG['reprint_info'])
+        if not self.printer.update_snapmaker_config_file(self.config_path,
+                self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def set_reprint_info(self):
+        logging.info("[print_task_config] set reprint info")
+        self.print_task_config['extruder_map_table'] = copy.deepcopy(self.print_task_config['reprint_info']['extruder_map_table'])
+        self.print_task_config['extruders_used'] = copy.deepcopy(self.print_task_config['reprint_info']['extruders_used'])
+        self.print_task_config['time_lapse_camera'] = copy.deepcopy(self.print_task_config['reprint_info']['time_lapse_camera'])
+        self.print_task_config['flow_calibrate'] = copy.deepcopy(self.print_task_config['reprint_info']['flow_calibrate'])
+        self.print_task_config['auto_bed_leveling'] = copy.deepcopy(self.print_task_config['reprint_info']['auto_bed_leveling'])
+        if not self.printer.update_snapmaker_config_file(self.config_path,
+                self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def update_filament_edit_flag(self):
+        for ch in range(PHYSICAL_EXTRUDER_NUM):
+            allowd_edit = False
+            if self.print_task_config['filament_exist'][ch]:
+                if self.print_task_config['filament_official'][ch] == True:
+                    allowd_edit = False
+                else:
+                    allowd_edit = True
+
+            self.print_task_config['filament_edit'][ch] = allowd_edit
+
+    def update_filament_exist_flag(self):
+        filament_feed_infos = {}
+        if self.filament_feed_objects is not None:
+            for obj_name, obj in self.filament_feed_objects:
+                status = obj.get_status(0)
+                filament_feed_infos.update(status)
+
+        for ch in range(PHYSICAL_EXTRUDER_NUM):
+            sensor_obj = self.printer.lookup_object(f'filament_motion_sensor e{ch}_filament', None)
+            e_obj = filament_feed_infos.get(f'extruder{ch}', None)
+            is_exist = True
+            if sensor_obj != None and sensor_obj.get_status(0)['enabled']:
+                if sensor_obj.get_status(0)['filament_detected']:
+                    is_exist = True
+                else:
+                    if e_obj != None and e_obj['module_exist'] and not e_obj['disable_auto']:
+                        if e_obj['filament_detected']:
+                            is_exist = True
+                        else:
+                            is_exist = False
+                    else:
+                        is_exist = False
+            else:
+                is_exist = True
+
+            self.print_task_config['filament_exist'][ch] = is_exist
+
+    def get_status(self, eventtime=None):
+        ##### It is not allowed to adjust the order of the following codes. ####
+        self.update_filament_exist_flag()
+        self.update_filament_edit_flag()
+        ########################################################################
+        print_task_config = copy.deepcopy(self.print_task_config)
+        return print_task_config
+
+    def cmd_SET_PRINT_EXTRUDER_MAP(self, gcmd):
+        config_extruder = gcmd.get_int("CONFIG_EXTRUDER", None)
+        map_extruder = gcmd.get_int("MAP_EXTRUDER", None)
+        logging.info("[print_task_config] SET_PRINT_EXTRUDER_MAP %s",
+                        gcmd.get_raw_command_parameters())
+
+        machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        if machine_state_manager is not None:
+            machine_sta = machine_state_manager.get_status()
+            if str(machine_sta["main_state"]) == "PRINTING":
+                raise gcmd.error("[print_task_config] not allowed to set extruder map during printing!")
+
+        if config_extruder is None or map_extruder is None:
+            raise gcmd.error("[print_task_config] extruder map, incomplete parameters")
+
+        if (config_extruder < 0 or config_extruder >= LOGICAL_EXTRUDER_NUM) or \
+                (map_extruder < 0 or map_extruder >= PHYSICAL_EXTRUDER_NUM):
+            raise gcmd.error("[print_task_config] extruder map, invalid extruder index!!!")
+
+        self.print_task_config['extruder_map_table'][config_extruder] = map_extruder
+        self.print_task_config['reprint_info']['extruder_map_table'][config_extruder] = map_extruder
+
+        ###### No need, because saving will be triggered in other necessary commands.
+        # if not self.printer.update_snapmaker_config_file(self.config_path,
+        #         self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+        #     logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def cmd_GET_PRINT_EXTRUDER_MAP(self, gcmd):
+        map_info = ""
+        for n in range(len(self.print_task_config['extruder_map_table'])):
+            map_info += "T{} -> T{}\n".format(n, self.print_task_config['extruder_map_table'][n])
+        self.gcode.respond_info(map_info)
+
+    def cmd_GET_PRINT_TASK_CONFIG(self, gcmd):
+        self.gcode.respond_info(str(self.print_task_config))
+
+    def cmd_SAVE_CURRENT_PRINT_TASK_CONFIG(self, gcmd):
+        if self.printer.update_snapmaker_config_file(self.config_path, self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            self.gcode.respond_info("print task config saved successfully!!!")
+        else:
+            raise gcmd.error("Error: print task config save failure!!!")
+
+    def cmd_SET_PRINT_FILAMENT_CONFIG(self, gcmd):
+        config_extruder = gcmd.get_int('CONFIG_EXTRUDER')
+        filament_vendor = gcmd.get('VENDOR', None)
+        filament_type = gcmd.get('FILAMENT_TYPE', None)
+        filament_sub_type = gcmd.get('FILAMENT_SUBTYPE', None)
+        filament_color = gcmd.get_int('FILAMENT_COLOR', None)
+        filament_color_rgba = gcmd.get('FILAMENT_COLOR_RGBA', None)
+        logging.info("[print_task_config] PRINT_FILAMENT_CONFIG %s",
+                        gcmd.get_raw_command_parameters())
+
+        if filament_color is None and filament_color_rgba is None and filament_type is None:
+            raise gcmd.error("[print_task_config] filament_config, incomplete parameters")
+
+        if filament_color is not None and filament_color_rgba is not None:
+            raise gcmd.error("[print_task_config] filament_config, cannot set both filament_color and filament_color_rgba")
+
+        if filament_type is not None:
+            if filament_vendor is None or filament_sub_type is None:
+                raise gcmd.error("[print_task_config] filament_config, incomplete parameters")
+
+        if config_extruder < 0 or config_extruder >= PHYSICAL_EXTRUDER_NUM:
+            raise gcmd.error("[print_task_config] extruder{} is out of range[0, {}]".format(config_extruder, PHYSICAL_EXTRUDER_NUM -1))
+
+        if self.print_task_config['filament_official'][config_extruder]:
+            raise gcmd.error("[print_task_config] filament_config, official filament, not configurable!")
+
+        if filament_type is not None:
+            self.print_task_config['filament_vendor'][config_extruder] = filament_vendor
+            self.print_task_config['filament_type'][config_extruder] = filament_type
+            self.print_task_config['filament_sub_type'][config_extruder] = filament_sub_type
+            if self.filament_param_obj is not None:
+                self.print_task_config['filament_soft'][config_extruder] = \
+                    self.filament_param_obj.get_is_soft(filament_vendor, filament_type, filament_sub_type)
+            else:
+                self.print_task_config['filament_soft'][config_extruder] = False
+
+        if filament_color_rgba is not None:
+            if len(filament_color_rgba) == 6:
+                filament_color_rgba = filament_color_rgba + 'FF'
+
+            if len(filament_color_rgba) != 8:
+                raise gcmd.error("[print_task_config] Invalid filament rgba color, e.i.#11223344")
+
+            for i in range(len(filament_color_rgba)):
+                if not filament_color_rgba[i] in string.hexdigits:
+                    raise gcmd.error("[print_task_config] Invalid filament rgba color, e.i.#11223344")
+
+            self.print_task_config['filament_color_rgba'][config_extruder] = filament_color_rgba
+            red =   int(filament_color_rgba[0:2], 16)
+            green = int(filament_color_rgba[2:4], 16)
+            blue =  int(filament_color_rgba[4:6], 16)
+            alpha = int(filament_color_rgba[6:8], 16)
+            self.print_task_config['filament_color'][config_extruder] = (alpha << 24) | (red << 16) | (green << 8) | blue
+
+        if filament_color is not None:
+            self.print_task_config['filament_color'][config_extruder] = filament_color & 0xFFFFFFFF
+            alpha = (filament_color & 0xFF000000) >> 24
+            red =   (filament_color & 0x00FF0000) >> 16
+            green = (filament_color & 0x0000FF00) >> 8
+            blue =  (filament_color & 0x000000FF) >> 0
+            self.print_task_config['filament_color_rgba'][config_extruder] = \
+                f'{red:02X}' + f'{green:02X}' + f'{blue:02X}' + f'{alpha:02X}'
+
+        self.gcode.run_script_from_command(f"FLOW_RESET_K EXTRUDER={config_extruder}\r\n")
+
+        self.print_task_config['filament_official'][config_extruder] = False
+        self.print_task_config['filament_sku'][config_extruder] = 0
+
+        if not self.printer.update_snapmaker_config_file(self.config_path,
+                self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def cmd_SET_TIME_LAPSE_CAMERA(self, gcmd):
+        enable = gcmd.get_int('ENABLE', minval=0, maxval=1)
+        need_save = gcmd.get_int('SAVE', 1, minval=0, maxval=1)
+        self.print_task_config['time_lapse_camera'] = bool(enable)
+        if need_save:
+            load_config = self.printer.load_snapmaker_config_file(self.config_path, DEFAULT_PRINT_TASK_CONFIG)
+            load_config['time_lapse_camera'] = bool(enable)
+            if not self.printer.update_snapmaker_config_file(self.config_path, load_config, DEFAULT_PRINT_TASK_CONFIG):
+                raise gcmd.error("time_lapse_camera config save failed")
+
+    def cmd_SET_PRINT_AUTO_BED_LEVELING(self, gcmd):
+        enable = gcmd.get_int('ENABLE', minval=0, maxval=1)
+        need_save = gcmd.get_int('SAVE', 1, minval=0, maxval=1)
+        self.print_task_config['auto_bed_leveling'] = bool(enable)
+        if need_save:
+            load_config = self.printer.load_snapmaker_config_file(self.config_path, DEFAULT_PRINT_TASK_CONFIG)
+            load_config['auto_bed_leveling'] = bool(enable)
+            if not self.printer.update_snapmaker_config_file(self.config_path, load_config, DEFAULT_PRINT_TASK_CONFIG):
+                raise gcmd.error("print auto_bed_leveling config save failed")
+
+    def cmd_SET_PRINT_PREFERENCES(self, gcmd):
+        bed_level = gcmd.get_int('BED_LEVEL', None, minval=0, maxval=1)
+        flow_calibrate = gcmd.get_int('FLOW_CALIBRATE', None, minval=0, maxval=1)
+        shaper_calibrate = gcmd.get_int('SHAPER_CALIBRATE', None, minval=0, maxval=1)
+        time_lapse_camera  = gcmd.get_int('TIME_LAPSE_CAMERA', None, minval=0, maxval=1)
+        auto_replenish_filament  = gcmd.get_int('AUTO_REPLENISH_FILAMENT', None, minval=0, maxval=1)
+        filament_entangle_detect = gcmd.get_int('FILAMENT_ENTANGLE_DETECT', None, minval=0, maxval=1)
+        logging.info("[print_task_config] SET_PRINT_PREFERENCES %s", gcmd.get_raw_command_parameters())
+
+        machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        is_printing = False
+        if machine_state_manager is not None:
+            machine_sta = machine_state_manager.get_status()
+            if str(machine_sta["main_state"]) == "PRINTING":
+                is_printing = True
+
+        if bed_level is not None:
+            if is_printing:
+                raise gcmd.error("[print_task_config] not allow to set bed_level during printing!")
+            self.print_task_config['auto_bed_leveling'] = bool(bed_level)
+            self.print_task_config['reprint_info']['auto_bed_leveling'] = bool(bed_level)
+
+        if flow_calibrate is not None:
+            if is_printing:
+                raise gcmd.error("[print_task_config] not allow to set flow_calibrate during printing!")
+            self.print_task_config['flow_calibrate'] = bool(flow_calibrate)
+            self.print_task_config['reprint_info']['flow_calibrate'] = bool(flow_calibrate)
+
+        if shaper_calibrate is not None:
+            self.print_task_config['shaper_calibrate'] = bool(shaper_calibrate)
+
+        if time_lapse_camera is not None:
+            if is_printing:
+                raise gcmd.error("[print_task_config] not allow to set time_lapse_camera during printing!")
+            self.print_task_config['time_lapse_camera'] = bool(time_lapse_camera)
+            self.print_task_config['reprint_info']['time_lapse_camera'] = bool(time_lapse_camera)
+
+        if auto_replenish_filament is not None:
+            self.print_task_config['auto_replenish_filament'] = bool(auto_replenish_filament)
+
+        if filament_entangle_detect is not None:
+            self.print_task_config['filament_entangle_detect'] = bool(filament_entangle_detect)
+            self.printer.send_event("print_task_config:set_entangle_detect", bool(filament_entangle_detect))
+
+        if not self.printer.update_snapmaker_config_file(self.config_path,
+                    self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def cmd_SET_PRINT_USED_EXTRUDERS(self, gcmd):
+        extruders_str = gcmd.get('EXTRUDERS', None)
+        self.print_task_config['extruders_used'] = [False] * PHYSICAL_EXTRUDER_NUM
+        self.print_task_config['reprint_info']['extruders_used'] = [False] * PHYSICAL_EXTRUDER_NUM
+        logging.info("[print_task_config] SET_PRINT_USED_EXTRUDERS %s", gcmd.get_raw_command_parameters())
+
+        machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        if machine_state_manager is not None:
+            machine_sta = machine_state_manager.get_status()
+            if str(machine_sta["main_state"]) == "PRINTING":
+                raise gcmd.error("[print_task_config] not allow to set used_extruders during printing!")
+
+        if extruders_str is not None:
+            used_extruders = [int(value) for value in extruders_str.split(',')]
+            if len(used_extruders) > 0:
+                for i in range(len(used_extruders)):
+                    if used_extruders[i] >= 0 and used_extruders[i] < PHYSICAL_EXTRUDER_NUM:
+                        self.print_task_config['extruders_used'][used_extruders[i]] = True
+                        self.print_task_config['reprint_info']['extruders_used'][used_extruders[i]] = True
+
+        if not self.printer.update_snapmaker_config_file(self.config_path,
+                self.print_task_config, DEFAULT_PRINT_TASK_CONFIG):
+            logging.error("[print_task_config] save print_task_config failed\r\n")
+
+    def cmd_RESET_PRINT_TASK_CONFIG(self, gcmd):
+        if not self._reset_print_task_config():
+            raise gcmd.error("[print_task_config] reset print_task_config failed!")
+
+    def cmd_LOAD_PRINT_TASK_CONFIG(self, gcmd):
+        self.print_task_config = self.printer.load_snapmaker_config_file(self.config_path, DEFAULT_PRINT_TASK_CONFIG)
+
+    def cmd_SET_REPRINT_INFO(self, gcmd):
+        self.set_reprint_info()
+
+    def cmd_INNER_AUTO_REPLENISH_FILAMENT(self, gcmd):
+        self.perform_auto_replenish = False
+        if self.print_task_config['auto_replenish_filament'] == False:
+            logging.info("[print_task_config] auto_replenish_filament is disabled.")
+            return
+
+        toolhead = self.printer.lookup_object("toolhead")
+        toolhead.wait_moves()
+
+        if self.print_task_config_bak is None:
+            logging.error("[print_task_config] print_task_config_bak is none.\r\n")
+            return
+
+        print_stats = self.printer.lookup_object("print_stats", None)
+        if print_stats is None or print_stats.get_status(self.reactor.monotonic())["state"] != 'paused':
+            return
+
+        macro = self.printer.lookup_object('gcode_macro INNER_RESUME', None)
+        if macro is None:
+            logging.error("[print_task_config] INNER_RESUME macro is none.\r\n")
+            return
+
+        replenish_extruder = None
+        replenish_extruder_name = None
+        toolhead = self.printer.lookup_object("toolhead")
+        current_extruder = toolhead.get_extruder().extruder_index
+        current_extruder_name = toolhead.get_extruder().name
+        current_extruder_temp = macro.variables.get('last_extruder_temp', 0)
+
+        filament_feed_infos = {}
+        for obj_name, obj in self.filament_feed_objects:
+            status = obj.get_status(0)
+            filament_feed_infos.update(status)
+
+        e_obj = filament_feed_infos.get(f'extruder{current_extruder}', None)
+        runout_sensor = self.printer.lookup_object(f"filament_motion_sensor e{current_extruder}_filament", None)
+        if e_obj is not None and runout_sensor is not None and \
+                e_obj['module_exist'] == True and \
+                e_obj['disable_auto'] == False and \
+                e_obj['filament_detected'] == True and \
+                runout_sensor.get_status(0)['enabled'] == True:
+            replenish_extruder = current_extruder
+        else:
+            for i in range(PHYSICAL_EXTRUDER_NUM):
+                if i == current_extruder:
+                    continue
+                e_obj = filament_feed_infos.get(f'extruder{i}', None)
+                runout_sensor = self.printer.lookup_object(f"filament_motion_sensor e{i}_filament", None)
+                if e_obj is not None and runout_sensor is not None and \
+                        e_obj['module_exist'] == True and \
+                        e_obj['disable_auto'] == False and \
+                        e_obj['filament_detected'] == True and \
+                        runout_sensor.get_status(0)['enabled'] == True and \
+                        self.print_task_config['filament_vendor'][i] != 'NONE' and \
+                        self.print_task_config['filament_vendor'][i] == self.print_task_config_bak['filament_vendor'][current_extruder] and \
+                        self.print_task_config['filament_type'][i] == self.print_task_config_bak['filament_type'][current_extruder] and \
+                        self.print_task_config['filament_sub_type'][i] == self.print_task_config_bak['filament_sub_type'][current_extruder] and \
+                        self.print_task_config['filament_color_rgba'][i][0:6] == self.print_task_config_bak['filament_color_rgba'][current_extruder][0:6]:
+
+                    replenish_extruder = i
+                    break
+
+        if replenish_extruder == None:
+            return
+        else:
+            logging.info(f"[print_task_config] auto replenish filament: T{current_extruder} -> T{replenish_extruder}")
+
+        if replenish_extruder == 0:
+            replenish_extruder_name = 'extruder'
+        else:
+            replenish_extruder_name = f'extruder{replenish_extruder}'
+
+        toolhead.wait_moves()
+        if current_extruder != replenish_extruder:
+            virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+            if virtual_sdcard is not None:
+                temp_dir = {
+                    replenish_extruder_name: current_extruder_temp,
+                    current_extruder_name: 0
+                }
+                virtual_sdcard.record_pl_print_temperature_env(temp_dir, ignore_pl_condition = True)
+                virtual_sdcard.force_refresh_move_env_extruder(replenish_extruder_name)
+            self.gcode.run_script_from_command(f"SET_GCODE_VARIABLE MACRO=INNER_RESUME VARIABLE=extruder{current_extruder}_temp VALUE=0\n")
+            self.gcode.run_script_from_command(f"M104 S0 T{current_extruder} A0\n")
+            for i in range(LOGICAL_EXTRUDER_NUM):
+                if self.print_task_config['extruder_map_table'][i] == current_extruder:
+                    self.print_task_config['extruder_map_table'][i] = replenish_extruder
+            self.print_task_config['extruders_used'][current_extruder] = False
+            self.print_task_config['extruders_used'][replenish_extruder] = True
+            self.print_task_config['extruders_replenished'][current_extruder] = replenish_extruder
+            self.print_task_config['reprint_info']['extruder_map_table'] = copy.deepcopy(self.print_task_config['extruder_map_table'])
+            self.print_task_config['reprint_info']['extruders_used'] = copy.deepcopy(self.print_task_config['extruders_used'])
+            self.printer.update_snapmaker_config_file(self.config_path, self.print_task_config, DEFAULT_PRINT_TASK_CONFIG)
+
+        self.perform_auto_replenish = True
+        self.gcode.run_script_from_command(f"RESUME REPLENISH=1 REPLENISH_EXTRUDER={replenish_extruder}\n")
+
+def load_config(config):
+    return PrintTaskConfig(config)
--- /dev/null
+++ b/klippy/extras/probe_inductance_coil.py
@@ -0,0 +1,1939 @@
+# Z-Probe support
+#
+# Copyright (C) 2017-2024  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging, copy, time, os
+import pins, queuefile
+from . import manual_probe
+from . import inductance_coil
+from decimal import Decimal, getcontext
+
+HINT_TIMEOUT = """
+If the probe did not move far enough to trigger, then
+consider reducing the Z axis minimum position so the probe
+can travel further (the Z minimum position can be negative).
+"""
+
+AXIS_X_INDEX  = 0
+AXIS_Y_INDEX  = 1
+AXIS_Z_INDEX  = 2
+AXIS_NAME_STR = ["x", "y", "z"]
+
+RECTANGLE_PROBE_MODE = 0
+CIRCLE_PROBE_MODE    = 1
+
+class ExtruderOffsetCalAbort(Exception):
+    pass
+
+# Calculate the average Z from a set of positions
+def calc_probe_z_average(positions, method='average', axis=AXIS_Z_INDEX):
+    if method != 'median':
+        # Use mean average
+        count = float(len(positions))
+        return [sum([pos[i] for pos in positions]) / count
+                for i in range(3)]
+    # Use median
+    z_sorted = sorted(positions, key=(lambda p: p[axis]))
+    middle = len(positions) // 2
+    if (len(positions) & 1) == 1:
+        # odd number of samples
+        return z_sorted[middle]
+    # even number of samples
+    return calc_probe_z_average(z_sorted[middle-1:middle+1], 'average', axis)
+
+def find_circle_center(A, B, C):
+    getcontext().prec = 50
+
+    x1, y1 = map(Decimal, A)
+    x2, y2 = map(Decimal, B)
+    x3, y3 = map(Decimal, C)
+
+    xm1 = (x1 + x2) / Decimal(2)
+    ym1 = (y1 + y2) / Decimal(2)
+    xm2 = (x2 + x3) / Decimal(2)
+    ym2 = (y2 + y3) / Decimal(2)
+
+
+    if x2 - x1 == Decimal(0):
+        m1 = Decimal('Infinity')
+    else:
+        m1 = (y2 - y1) / (x2 - x1)
+
+    if x3 - x2 == Decimal(0):
+        m2 = Decimal('Infinity')
+    else:
+        m2 = (y3 - y2) / (x3 - x2)
+
+    m_perp1 = -1 / m1 if m1 != Decimal(0) else Decimal(0)
+    m_perp2 = -1 / m2 if m2 != Decimal(0) else Decimal(0)
+
+    if m_perp1 == Decimal(0) or m_perp2 == Decimal(0):
+        if m_perp1 == Decimal(0):
+            h = xm1
+            k = ym2 - m_perp2 * (xm2 - xm1)
+        elif m_perp2 == Decimal(0):
+            h = xm2
+            k = ym1 - m_perp1 * (xm1 - xm2)
+    else:
+        h = (ym2 - ym1 + m_perp1*xm1 - m_perp2*xm2) / (m_perp1 - m_perp2)
+        k = m_perp1 * (h - xm1) + ym1
+
+    return (float(h), float(k))
+
+######################################################################
+# Probe device implementation helpers
+######################################################################
+
+# Helper to implement common probing commands
+class ProbeCommandHelper:
+    def __init__(self, config, probe, query_endstop=None):
+        self.printer = config.get_printer()
+        self.probe = probe
+        self.query_endstop = query_endstop
+        self.name = config.get_name()
+        self.xyz_offset_abort = False
+        self.xyz_offset_probe_status = 'idle'
+        self.lock = self.printer.get_reactor().mutex()
+        gcode = self.printer.lookup_object('gcode')
+        # QUERY_PROBE command
+        self.last_state = False
+        gcode.register_command('QUERY_PROBE', self.cmd_QUERY_PROBE,
+                               desc=self.cmd_QUERY_PROBE_help)
+        # PROBE command
+        self.last_z_result = 0.
+        gcode.register_command('PROBE', self.cmd_PROBE,
+                               desc=self.cmd_PROBE_help)
+        # PROBE_CALIBRATE command
+        self.probe_calibrate_z = 0.
+        gcode.register_command('PROBE_CALIBRATE', self.cmd_PROBE_CALIBRATE,
+                               desc=self.cmd_PROBE_CALIBRATE_help)
+        # Other commands
+        gcode.register_command('PROBE_BED_CONTACT', self.cmd_PROBE_BED_CONTACT,
+                               desc=self.cmd_PROBE_BED_CONTACT_help)
+        gcode.register_command('PROBE_ACCURACY', self.cmd_PROBE_ACCURACY,
+                               desc=self.cmd_PROBE_ACCURACY_help)
+        gcode.register_command('Z_OFFSET_APPLY_PROBE',
+                               self.cmd_Z_OFFSET_APPLY_PROBE,
+                               desc=self.cmd_Z_OFFSET_APPLY_PROBE_help)
+        gcode.register_command('SET_PROBE_TRIG_FREQ',
+                               self.cmd_SET_PROBE_TRIG_FREQ,
+                                desc=None)
+        gcode.register_command('INDUCTANCE_COIL_PROBE_QUERY',
+                               self.cmd_INDUCTANCE_COIL_PROBE_QUERY,
+                                desc=None)
+        gcode.register_command('PROBE_XYZ_OFFSET_CALIBRATE',
+                               self.cmd_PROBE_XYZ_OFFSET_CALIBRATE_ADVANCED,
+                               desc=self.cmd_PROBE_XYZ_OFFSET_CALIBRATE_help)
+        self.printer.register_event_handler("probe_xyz_offset:abort", self._probe_xyz_offset_abort)
+        self.status = 'idle'
+    def _move(self, coord, speed):
+        self.printer.lookup_object('toolhead').manual_move(coord, speed)
+    def _probe_xyz_offset_abort(self):
+        if self.xyz_offset_probe_status == 'probing':
+            with self.lock:
+                self.xyz_offset_abort = True
+    def get_status(self, eventtime):
+        return {'name': self.name,
+                'last_query': self.last_state,
+                'last_z_result': self.last_z_result,
+                'status': self.status}
+    cmd_QUERY_PROBE_help = "Return the status of the z-probe"
+    def cmd_QUERY_PROBE(self, gcmd):
+        if self.query_endstop is None:
+            raise gcmd.error("Probe does not support QUERY_PROBE")
+        toolhead = self.printer.lookup_object('toolhead')
+        print_time = toolhead.get_last_move_time()
+        res = self.query_endstop(print_time)
+        self.last_state = res
+        gcmd.respond_info("probe: %s" % (["open", "TRIGGERED"][not not res],))
+    cmd_PROBE_help = "Probe Z-height at current XY position"
+    def cmd_PROBE(self, gcmd):
+        try:
+            self.printer.send_event("inductance_coil:probe_start")
+            pos = run_single_probe(self.probe, gcmd)
+            params = self.probe.get_probe_params(gcmd)
+            axis = params['samples_axis']
+            gcmd.respond_info("Result is %s=%.6f" % (AXIS_NAME_STR[axis], pos[axis],))
+            if axis == AXIS_Z_INDEX:
+                self.last_z_result = pos[2]
+        finally:
+            self.printer.send_event("inductance_coil:probe_end")
+    def probe_calibrate_finalize(self, kin_pos):
+        if kin_pos is None:
+            return
+        z_offset = self.probe_calibrate_z - kin_pos[2]
+        gcode = self.printer.lookup_object('gcode')
+        gcode.respond_info(
+            "%s: z_offset: %.3f\n"
+            "The SAVE_CONFIG command will update the printer config file\n"
+            "with the above and restart the printer." % (self.name, z_offset))
+        configfile = self.printer.lookup_object('configfile')
+        configfile.set(self.name, 'z_offset', "%.3f" % (z_offset,))
+    cmd_PROBE_CALIBRATE_help = "Calibrate the probe's z_offset"
+    def cmd_PROBE_CALIBRATE(self, gcmd):
+        manual_probe.verify_no_manual_probe(self.printer)
+        params = self.probe.get_probe_params(gcmd)
+        # Only allowed to be set to Z-axis
+        if params['samples_axis'] != AXIS_Z_INDEX:
+            raise self.printer.command_error(
+                "The command samples axis cannot be specified as X/Y.")
+        # Perform initial probe
+        curpos = run_single_probe(self.probe, gcmd)
+        # Move away from the bed
+        self.probe_calibrate_z = curpos[2]
+        curpos[2] += 5.
+        self._move(curpos, params['lift_speed'])
+        # Move the nozzle over the probe point
+        x_offset, y_offset, z_offset = self.probe.get_offsets()
+        curpos[0] += x_offset
+        curpos[1] += y_offset
+        self._move(curpos, params['probe_speed'])
+        # Start manual probe
+        manual_probe.ManualProbeHelper(self.printer, gcmd,
+                                       self.probe_calibrate_finalize)
+    cmd_PROBE_BED_CONTACT_help = "Probe bed by moving nozzle down until it touches the bed"
+    def cmd_PROBE_BED_CONTACT(self, gcmd):
+        macro = self.printer.lookup_object('gcode_macro _PROBE_BED_CONTACT', None)
+        gcode = self.printer.lookup_object('gcode')
+        move_speed = 30
+        check_fail_lift_z = 150
+        has_error = False
+        try:
+            if macro is not None:
+                move_speed = macro.variables.get('move_speed', move_speed)
+                check_fail_lift_z = macro.variables.get('check_fail_lift_z', check_fail_lift_z)
+                gcode.run_script_from_command("_PROBE_BED_CONTACT")
+            else:
+                gcode.run_script_from_command("PROBE SAMPLE_TRIG_FREQ=450 SAMPLES=1 PROBE_SPEED=5")
+        except Exception as e:
+            has_error = True
+            coded_message = self.printer.extract_encoded_message(str(e))
+            if coded_message is not None:
+                message = coded_message.get("msg", None)
+                if message == "No trigger on probe after full movement":
+                    err_msg = '{"coded": "0003-0530-0000-0017", "msg":"PEI coated plate not positioned correctly"}'
+                    raise self.printer.command_error(err_msg)
+            raise
+        finally:
+            if has_error:
+                toolhead = self.printer.lookup_object('toolhead')
+                curtime = self.printer.get_reactor().monotonic()
+                status = toolhead.get_status(curtime)
+                if 'z' in status['homed_axes']:
+                    pos = toolhead.get_position()
+                    if pos[2] < check_fail_lift_z:
+                        toolhead.manual_move([None, None, check_fail_lift_z], move_speed)
+    cmd_PROBE_ACCURACY_help = "Probe Z-height accuracy at current XY position"
+    def cmd_PROBE_ACCURACY(self, gcmd):
+        params = self.probe.get_probe_params(gcmd)
+        sample_count = gcmd.get_int("SAMPLES", 10, minval=1)
+        toolhead = self.printer.lookup_object('toolhead')
+        pos = toolhead.get_position()
+        gcmd.respond_info("PROBE_ACCURACY at X:%.3f Y:%.3f Z:%.3f"
+                          " (samples=%d retract=%.3f"
+                          " speed=%.1f lift_speed=%.1f)\n"
+                          % (pos[0], pos[1], pos[2],
+                             sample_count, params['sample_retract_dist'],
+                             params['probe_speed'], params['lift_speed']))
+        # Create dummy gcmd with SAMPLES=1
+        fo_params = dict(gcmd.get_command_parameters())
+        fo_params['SAMPLES'] = '1'
+        gcode = self.printer.lookup_object('gcode')
+        fo_gcmd = gcode.create_gcode_command("", "", fo_params)
+        # Probe bed sample_count times
+        probe_session = self.probe.start_probe_session(fo_gcmd)
+        probe_num = 0
+        while probe_num < sample_count:
+            # Probe position
+            probe_session.run_probe(fo_gcmd)
+            probe_num += 1
+            # Retract
+            pos = toolhead.get_position()
+            if params['samples_axis'] == AXIS_Z_INDEX:
+                liftpos = [None, None, pos[2] + params['sample_retract_dist'] * params['samples_retract_dir']]
+            elif params['samples_axis'] == AXIS_X_INDEX:
+                liftpos = [pos[0] + params['sample_retract_dist'] * params['samples_retract_dir'], None, None]
+            elif params['samples_axis'] == AXIS_Y_INDEX:
+                liftpos = [None, pos[1] + params['sample_retract_dist'] * params['samples_retract_dir'], None]
+            self._move(liftpos, params['lift_speed'])
+        positions = probe_session.pull_probed_results()
+        probe_session.end_probe_session()
+        # Calculate maximum, minimum and average values
+        max_value = max([p[params['samples_axis']] for p in positions])
+        min_value = min([p[params['samples_axis']] for p in positions])
+        range_value = max_value - min_value
+        avg_value = calc_probe_z_average(positions, 'average', params['samples_axis'])[params['samples_axis']]
+        median = calc_probe_z_average(positions, 'median', params['samples_axis'])[params['samples_axis']]
+        # calculate the standard deviation
+        deviation_sum = 0
+        for i in range(len(positions)):
+            deviation_sum += pow(positions[i][params['samples_axis']] - avg_value, 2.)
+        sigma = (deviation_sum / len(positions)) ** 0.5
+        # Show information
+        gcmd.respond_info(
+            "probe accuracy results: maximum %.6f, minimum %.6f, range %.6f, "
+            "average %.6f, median %.6f, standard deviation %.6f" % (
+            max_value, min_value, range_value, avg_value, median, sigma))
+    cmd_Z_OFFSET_APPLY_PROBE_help = "Adjust the probe's z_offset"
+    def cmd_Z_OFFSET_APPLY_PROBE(self, gcmd):
+        gcode_move = self.printer.lookup_object("gcode_move")
+        offset = gcode_move.get_status()['homing_origin'].z
+        if offset == 0:
+            gcmd.respond_info("Nothing to do: Z Offset is 0")
+            return
+        z_offset = self.probe.get_offsets()[2]
+        new_calibrate = z_offset - offset
+        gcmd.respond_info(
+            "%s: z_offset: %.3f\n"
+            "The SAVE_CONFIG command will update the printer config file\n"
+            "with the above and restart the printer."
+            % (self.name, new_calibrate))
+        configfile = self.printer.lookup_object('configfile')
+        configfile.set(self.name, 'z_offset', "%.3f" % (new_calibrate,))
+    def cmd_SET_PROBE_TRIG_FREQ(self, gcmd):
+        self.probe.mcu_probe.sensor.cmd_SET_TRIG_FREQ(gcmd)
+    def cmd_INDUCTANCE_COIL_PROBE_QUERY(self, gcmd):
+        self.probe.mcu_probe.sensor.cmd_INDUCTANCE_COIL_QUERY(gcmd)
+    def cmd_PROBE_XYZ_OFFSET_CALIBRATE_ADVANCED(self, gcmd):
+        try:
+            with self.lock:
+                self.xyz_offset_abort = False
+                self.xyz_offset_probe_status = 'probing'
+            self.printer.send_event("inductance_coil:probe_start")
+            base_position = self.cmd_PROBE_XYZ_OFFSET_CALIBRATE(gcmd)
+        finally:
+            with self.lock:
+                self.xyz_offset_probe_status = 'idle'
+                self.xyz_offset_abort = False
+            self.printer.send_event("inductance_coil:probe_end")
+
+    cmd_PROBE_XYZ_OFFSET_CALIBRATE_help = "Probe the x y z position of a specified place"
+    def find_circle_center_least_squares(self, points):
+        import numpy as np
+        # Convert points to numpy array
+        points = np.array(points)
+        x = points[:, 0]
+        y = points[:, 1]
+
+        # Setup the linear system for least squares
+        A = np.vstack([2*x, 2*y, np.ones(len(x))]).T
+        b = x**2 + y**2
+
+        # Solve using least squares
+        c_x, c_y, _ = np.linalg.lstsq(A, b, rcond=None)[0]
+
+        return float(c_x), float(c_y)
+
+    def _probe_z(self, gcmd, z_samples):
+        if self.xyz_offset_abort:
+            raise ExtruderOffsetCalAbort("ExtruderOffsetCalAbort")
+        gcmd.get_command_parameters()['SAMPLES_AXIS'] = str(AXIS_Z_INDEX)
+        gcmd.get_command_parameters()['SAMPLE_DIR'] = str(-1)
+        gcmd.get_command_parameters()['SAMPLES'] = int(z_samples[0])
+        gcmd.get_command_parameters()['SAMPLES_DISCARD'] = int(z_samples[1])
+        pos = run_single_probe(self.probe, gcmd)
+        return pos[2]
+
+    def _probe_xy(self, gcmd, params, points, center):
+        if points < 3:
+            return []
+
+        if points == 3:
+            sample_dir = [
+                params['samples_retract_dir'],
+                params['samples_dir'],
+                params['samples_retract_dir']
+            ]
+            position_prepare = [
+                None,
+                None,
+                None
+            ]
+            position_start_probe = [
+                [center[0] - 4, center[1], None],
+                [center[0],     center[1], None],
+                [center[0] + 4, center[1], None]
+            ]
+        elif points == 6:
+            sample_dir = [
+                params['samples_retract_dir'],
+                params['samples_retract_dir'],
+                params['samples_retract_dir'],
+                params['samples_dir'],
+                params['samples_dir'],
+                params['samples_dir']
+            ]
+            position_prepare = [
+                [center[0] + params['p1x'] - 0.7, center[1]],
+                None,
+                None,
+                [center[0] + params['p1x'] - 0.7, center[1]],
+                None,
+                None
+            ]
+            position_start_probe = [
+                [center[0] + params['p1x'], center[1] + params['p1y'], None],
+                [center[0] + params['p2x'], center[1] + params['p2y'], None],
+                [center[0] + params['p3x'], center[1] + params['p3y'], None],
+                [center[0] + params['p1x'], center[1] - params['p1y'], None],
+                [center[0] + params['p2x'], center[1] - params['p2y'], None],
+                [center[0] + params['p3x'], center[1] - params['p3y'], None]
+            ]
+        elif points == 10:
+            sample_dir = [
+                params['samples_retract_dir'],
+                params['samples_retract_dir'],
+                params['samples_retract_dir'],
+                params['samples_retract_dir'],
+                params['samples_retract_dir'],
+                params['samples_dir'],
+                params['samples_dir'],
+                params['samples_dir'],
+                params['samples_dir'],
+                params['samples_dir']
+            ]
+            position_prepare = [
+                [center[0] + params['p1x'] - 0.7, center[1]],
+                None,
+                None,
+                None,
+                None,
+                [center[0] + params['p1x'] - 0.7, center[1]],
+                None,
+                None,
+                None,
+                None
+            ]
+            position_start_probe = [
+                [center[0] + params['p1x'], center[1] + params['p1y'], None],
+                [center[0] + params['p2x'], center[1] + params['p2y'], None],
+                [center[0] + params['p3x'], center[1] + params['p3y'], None],
+                [center[0] + params['p4x'], center[1] + params['p4y'], None],
+                [center[0] + params['p5x'], center[1] + params['p5y'], None],
+                [center[0] + params['p1x'], center[1] - params['p1y'], None],
+                [center[0] + params['p2x'], center[1] - params['p2y'], None],
+                [center[0] + params['p3x'], center[1] - params['p3y'], None],
+                [center[0] + params['p4x'], center[1] - params['p4y'], None],
+                [center[0] + params['p5x'], center[1] - params['p5y'], None]
+            ]
+        else:
+            return []
+
+        gcmd.get_command_parameters()['SAMPLES_AXIS'] = str(AXIS_Y_INDEX)
+        hit_position = []
+        for i in range(points):
+            if position_prepare[i] != None:
+                self._move(position_prepare[i], params['travel_speed'])
+            # move to position to start probing
+            self._move(position_start_probe[i], params['travel_speed'])
+            gcmd.get_command_parameters()['SAMPLE_DIR'] = str(sample_dir[i])
+            if self.xyz_offset_abort:
+                raise ExtruderOffsetCalAbort("ExtruderOffsetCalAbort")
+            pos = run_single_probe(self.probe, gcmd)
+            hit_position.append(pos)
+
+        return hit_position
+
+    def cmd_PROBE_XYZ_OFFSET_CALIBRATE(self, gcmd):
+        cur_accel = None
+        center = [None, None, None]
+        # Check the status of inductance_coil
+        result, capture_freq = self.probe.mcu_probe.sensor.check_coil_freq()
+        if result != True:
+            index = {"extruder": 0, "extruder1": 1, "extruder2": 2, "extruder3": 3}.get(self.probe.mcu_probe.sensor._name, 0)
+            code = 0 if capture_freq == 0 else 1
+            msg = "%s inductance coil status error [freq: %d]" % (self.probe.mcu_probe.sensor._name, capture_freq)
+            message = '{"coded": "0003-0530-%4d-%4d", "oneshot": %d, "msg":"%s"}' % (index, code, 1, msg)
+            raise gcmd.error(message)
+            # raise gcmd.error("%s inductance coil status error, cannot start current calibration" % (self.probe.mcu_probe.sensor._name))
+        # Must go home before probing
+        toolhead = self.printer.lookup_object('toolhead')
+        configfile = self.printer.lookup_object('configfile')
+        gcode = self.printer.lookup_object('gcode')
+        curtime = self.printer.get_reactor().monotonic()
+        if 'z' not in toolhead.get_status(curtime)['homed_axes']:
+            raise self.printer.command_error('{"coded": "0003-0530-0000-0002", "msg":"Must home before probe"}')
+
+        params = self.probe.get_probe_params(gcmd)
+        if params['points'] != 6 and params['points'] != 10:
+            msg = '{"coded": "0003-0530-0000-0003", "msg":"%s"}' % f"invalid points{params['points']} for XY probe"
+            raise self.printer.command_error(msg)
+
+        origin_params = dict(gcmd.get_command_parameters())
+        if params.get('log_file') != None:
+            log_file = '{}_{}.txt'.format(toolhead.get_extruder().get_name(),
+                                            params['log_file'])
+            origin_params['LOG_FILE'] = log_file
+        z_gcmd = gcode.create_gcode_command("", "", origin_params)
+        xy_gcmd = gcode.create_gcode_command("", "", origin_params)
+        center = [params['horizontal_move_x'], params['horizontal_move_y'], params['horizontal_move_z']]
+        try:
+            if params['move_accel'] != toolhead.max_accel:
+                cur_accel = toolhead.max_accel
+                toolhead.set_accel(params['move_accel'])
+            # Move to z probe horizontal position
+            horizontal_move_z = params['horizontal_move_z']
+            self._move([None, None, horizontal_move_z], params['travel_speed'])
+            # Move to x y probe horizontal position
+            self._move([params['horizontal_move_x']+params['z_probe_x_move_offset'],
+                        params['horizontal_move_y']+params['z_probe_y_move_offset'], None], params['travel_speed'])
+            # samples and discard samples
+            z_samlpes = [(3, 0), (3, 0), (6, 2)]
+            # points for xy
+            xyz_points = [3, params['points'], 0]
+            for zs, xyp in zip(z_samlpes, xyz_points):
+                center[2] = self._probe_z(z_gcmd, zs)
+                # lift z
+                probe_xy_z_hight = center[2] + params['retract_z_hight']
+                self._move([None, None, probe_xy_z_hight], params['travel_speed'])
+                # probe in xy plane
+                points_pos = self._probe_xy(xy_gcmd, params, xyp, center)
+                if len(points_pos) >= 3:
+                    center[0], center[1] = self.find_circle_center_least_squares(points_pos)
+                # move to center of circle
+                gcmd.respond_info(f'Got center: {center[0]:.4f}, {center[1]:.4f}, {center[2]:.4f}')
+                self._move([center[0]+params['z_probe_x_move_offset'], center[1]+params['z_probe_y_move_offset'], None], params['travel_speed'])
+
+            if params['update_config']:
+                extruder_offset_object = self.printer.lookup_object('extruder_offset_calibration', None)
+                if extruder_offset_object is not None:
+                    extruder_offset_object.last_xyz_result[toolhead.get_extruder().get_name()] = [center[0], center[1], center[2]]
+                else:
+                    configfile.set(toolhead.get_extruder().get_name(), 'base_position',
+                                    "\n%.6f, %.6f, %.6f\n" % (center[0], center[1], center[2]))
+                if params['save_info']:
+                    vsd = self.printer.lookup_object('virtual_sdcard', None)
+                    if vsd is None:
+                        gcmd.respond_info("No virtual_sdcard dir to save extruder offset data")
+                        logdir = '/tmp/calibration_data'
+                    else:
+                        logdir = f'{vsd.sdcard_dirname}/calibration_data'
+                    ename = toolhead.get_extruder().get_name()
+                    if not os.path.exists(logdir):
+                        os.makedirs(logdir)
+
+                    content1 = f'{center[0]:.6f}, {center[1]:.6f}, {center[2]:.6f}\n'
+                    try:
+                        queuefile.async_append_file(f'{logdir}/{ename}_xyz_offset_data.txt', content1)
+                    except Exception as e:
+                        logging.exception(f"Failed to append to file {ename}_xyz_offset_data.txt: {e}")
+
+                    date = time.strftime("%Y-%m-%d %H:%M:%S")
+                    content2 = f'{ename}({date}): {center[0]:.6f}, {center[1]:.6f}, {center[2]:.6f}\n'
+                    if ename == 'extruder3':
+                        content2 += '\n'
+                    try:
+                        queuefile.async_append_file(f'{logdir}/xyz_offset_data.txt', content2)
+                    except Exception as e:
+                        logging.exception(f"Failed to append to xyz_offset_data.txt: {e}")
+            return center
+        except ExtruderOffsetCalAbort as e:
+            gcmd.respond_info("ExtruderOffsetCal Abort Success")
+        finally:
+            self._move([None, None, params['horizontal_move_z']], params['travel_speed'])
+            self._move([center[0], center[1], params['horizontal_move_z']], params['travel_speed'])
+            if cur_accel is not None and cur_accel != toolhead.max_accel:
+                toolhead.set_accel(cur_accel)
+
+# Homing via probe:z_virtual_endstop
+class HomingViaProbeHelper:
+    def __init__(self, config, mcu_probe):
+        self.printer = config.get_printer()
+        self.mcu_probe = mcu_probe
+        self.multi_probe_pending = False
+        # Register z_virtual_endstop pin
+        self.printer.lookup_object('pins').register_chip('probe', self)
+        # Register event handlers
+        self.printer.register_event_handler('klippy:mcu_identify',
+                                            self._handle_mcu_identify)
+        self.printer.register_event_handler("homing:homing_move_begin",
+                                            self._handle_homing_move_begin)
+        self.printer.register_event_handler("homing:homing_move_end",
+                                            self._handle_homing_move_end)
+        self.printer.register_event_handler("homing:home_rails_begin",
+                                            self._handle_home_rails_begin)
+        self.printer.register_event_handler("homing:home_rails_end",
+                                            self._handle_home_rails_end)
+        self.printer.register_event_handler("gcode:command_error",
+                                            self._handle_command_error)
+    def _handle_mcu_identify(self):
+        kin = self.printer.lookup_object('toolhead').get_kinematics()
+        for stepper in kin.get_steppers():
+            if stepper.is_active_axis('x') or stepper.is_active_axis('y') or stepper.is_active_axis('z'):
+                self.mcu_probe.add_stepper(stepper)
+    def _handle_homing_move_begin(self, hmove):
+        if self.mcu_probe in hmove.get_mcu_endstops():
+            self.mcu_probe.probe_prepare(hmove)
+    def _handle_homing_move_end(self, hmove):
+        if self.mcu_probe in hmove.get_mcu_endstops():
+            self.mcu_probe.probe_finish(hmove)
+    def _handle_home_rails_begin(self, homing_state, rails):
+        endstops = [es for rail in rails for es, name in rail.get_endstops()]
+        if self.mcu_probe in endstops:
+            self.mcu_probe.multi_probe_begin()
+            self.multi_probe_pending = True
+    def _handle_home_rails_end(self, homing_state, rails):
+        endstops = [es for rail in rails for es, name in rail.get_endstops()]
+        if self.multi_probe_pending and self.mcu_probe in endstops:
+            self.multi_probe_pending = False
+            self.mcu_probe.multi_probe_end()
+    def _handle_command_error(self):
+        if self.multi_probe_pending:
+            self.multi_probe_pending = False
+            try:
+                self.mcu_probe.multi_probe_end()
+            except:
+                logging.exception("Homing multi-probe end")
+    def setup_pin(self, pin_type, pin_params):
+        if pin_type != 'endstop' or pin_params['pin'] != 'z_virtual_endstop':
+            raise pins.error("Probe virtual endstop only useful as endstop pin")
+        if pin_params['invert'] or pin_params['pullup']:
+            raise pins.error("Can not pullup/invert probe virtual endstop")
+        return self.mcu_probe
+
+# Helper to track multiple probe attempts in a single command
+class ProbeSessionHelper:
+    def __init__(self, config, mcu_probe):
+        self.printer = config.get_printer()
+        self.mcu_probe = mcu_probe
+        gcode = self.printer.lookup_object('gcode')
+        self.dummy_gcode_cmd = gcode.create_gcode_command("", "", {})
+        # Infer Z position to move to during a probe
+        if config.has_section('stepper_z'):
+            zconfig = config.getsection('stepper_z')
+            self.z_position = zconfig.getfloat('position_min', 0.,
+                                               note_valid=False)
+        else:
+            pconfig = config.getsection('printer')
+            self.z_position = pconfig.getfloat('minimum_z_position', 0.,
+                                               note_valid=False)
+        # Get the allowable detection range of the X-axis
+        if config.has_section('stepper_x'):
+            xconfig = config.getsection('stepper_x')
+            self.x_min_position = xconfig.getfloat('position_min', 0., note_valid=False)
+            self.x_max_position = xconfig.getfloat('position_max', 0., note_valid=False)
+        else:
+            self.x_min_position = 0
+            self.x_max_position = 0
+
+        if config.has_section('stepper_y'):
+            yconfig = config.getsection('stepper_y')
+            self.y_min_position = yconfig.getfloat('position_min', 0., note_valid=False)
+            self.y_max_position = yconfig.getfloat('position_max', 0., note_valid=False)
+        else:
+            self.y_min_position = 0
+            self.y_max_position = 0
+        self.horizontal_move_z = config.getfloat('horizontal_move_z', 20)
+        self.horizontal_move_x = config.getfloat('horizontal_move_x', 20, minval=self.x_min_position, maxval=self.x_max_position)
+        self.horizontal_move_y = config.getfloat('horizontal_move_y', 20, minval=self.y_min_position, maxval=self.y_max_position)
+        self.retract_z_hight = config.getfloat('retract_z_hight', 5, minval=0.)
+        self.homing_helper = HomingViaProbeHelper(config, mcu_probe)
+        # Configurable probing speeds
+        self.speed = config.getfloat('speed', 5.0, above=0.)
+        self.accel = config.getfloat('accel', 1000, above=0.)
+        self.z_accel = config.getfloat('z_accel', 100, above=0.)
+        self.first_fast_speed = config.getfloat('first_fast_speed', self.speed, above=0.)
+        self.lift_speed = config.getfloat('lift_speed', self.speed, above=0.)
+        self.travel_speed = config.getfloat('travel_speed', 50, above=0.)
+        self.relative_trigger_freq = config.getint('relative_trigger_freq', 200, minval=10)
+        # Multi-sample support (for improved accuracy)
+        self.sample_count = config.getint('samples', 1, minval=1)
+        self.sample_retract_dist = config.getfloat('sample_retract_dist', 2.,
+                                                   above=0.)
+        atypes = ['median', 'average']
+        self.samples_result = config.getchoice('samples_result', atypes,
+                                               'average')
+        self.samples_tolerance = config.getfloat('samples_tolerance', 0.100,
+                                                 minval=0.)
+        self.samples_retries = config.getint('samples_tolerance_retries', 0,
+                                             minval=0)
+        # Session state
+        self.multi_probe_pending = False
+        self.results = []
+        # Register event handlers
+        self.printer.register_event_handler("gcode:command_error",
+                                            self._handle_command_error)
+    def _handle_command_error(self):
+        if self.multi_probe_pending:
+            try:
+                self.end_probe_session()
+            except:
+                logging.exception("Multi-probe end")
+    def _probe_state_error(self):
+        raise self.printer.command_error(
+            "Internal probe error - start/end probe session mismatch")
+    def start_probe_session(self, gcmd):
+        if self.multi_probe_pending:
+            self._probe_state_error()
+        self.mcu_probe.multi_probe_begin()
+        self.multi_probe_pending = True
+        self.results = []
+        return self
+    def end_probe_session(self):
+        if not self.multi_probe_pending:
+            self._probe_state_error()
+        self.results = []
+        self.multi_probe_pending = False
+        self.mcu_probe.multi_probe_end()
+    def get_probe_params(self, gcmd=None):
+        if gcmd is None:
+            gcmd = self.dummy_gcode_cmd
+        probe_speed = gcmd.get_float("PROBE_SPEED", self.speed, above=0.)
+        probe_accel = gcmd.get_float("PROBE_ACCEL", self.accel, above=0.)
+        probe_z_accel = gcmd.get_float("PROBE_Z_ACCEL", self.z_accel, above=0.)
+        lift_speed = gcmd.get_float("LIFT_SPEED", self.lift_speed, above=0.)
+        samples = gcmd.get_int("SAMPLES", self.sample_count, minval=1)
+        samples_discard = gcmd.get_int("SAMPLES_DISCARD", 0, minval=0)
+        sample_retract_dist = gcmd.get_float("SAMPLE_RETRACT_DIST",
+                                             self.sample_retract_dist, above=0.)
+        samples_tolerance = gcmd.get_float("SAMPLES_TOLERANCE",
+                                           self.samples_tolerance, minval=0.)
+        samples_retries = gcmd.get_int("SAMPLES_TOLERANCE_RETRIES",
+                                       self.samples_retries, minval=0)
+        samples_result = gcmd.get("SAMPLES_RESULT", self.samples_result)
+        samples_axis = gcmd.get_int("SAMPLES_AXIS", AXIS_Z_INDEX, minval=AXIS_X_INDEX, maxval=AXIS_Z_INDEX)
+        samples_dir = [1, -1][gcmd.get_int("SAMPLE_DIR", 0) <= 0 or samples_axis == AXIS_Z_INDEX]
+        samples_retract_dir = -1*samples_dir
+        sample_dist = gcmd.get_float("SAMPLE_DIST", 1.5*sample_retract_dist, minval=1.0)
+
+        # inductance_coil param configuration parsing fetch
+        sample_trig_freq_config = gcmd.get_int("TRIG_FREQ_CONFIG", 1, minval=0, maxval=1)
+        sample_trig_mode = gcmd.get_int("SAMPLE_TRIG_MODE", 1, minval=0, maxval=1)
+        sample_trig_freq = gcmd.get_int("SAMPLE_TRIG_FREQ", self.relative_trigger_freq, minval=10)
+        sample_trig_freq_y = gcmd.get_int("SAMPLE_TRIG_FREQ_Y", sample_trig_freq, minval=10)
+        sample_absolute_trig = gcmd.get_int("SAMPLE_ABSOLUTE_TRIG", 0, minval=0, maxval=1)
+        sample_trig_invert = gcmd.get_int("SAMPLE_TRIG_INVERT", 0, minval=0, maxval=1)
+        sample_wait_before_setup = gcmd.get_float("WAIT_BEFORE_SETUP", 0.1, minval=0.)
+        sample_wait_after_setup = gcmd.get_float("WAIT_AFTER_SETUP", 0.05, minval=0.)
+
+        # xyz calibration parameters
+        travel_speed = gcmd.get_float("TRAVEL_SPEED", self.travel_speed, above=0.)
+        horizontal_move_x = gcmd.get_float("HORIZONTAL_MOVE_X", self.horizontal_move_x, minval=self.x_min_position, maxval=self.x_max_position)
+        horizontal_move_y = gcmd.get_float("HORIZONTAL_MOVE_Y", self.horizontal_move_y, minval=self.y_min_position, maxval=self.y_max_position)
+        horizontal_move_z = gcmd.get_float("HORIZONTAL_MOVE_Z", self.horizontal_move_z)
+        z_probe_x_move_offset = gcmd.get_float("Z_PROBE_X_MOVE_OFFSET", 0)
+        z_probe_y_move_offset = gcmd.get_float("Z_PROBE_Y_MOVE_OFFSET", -4)
+        horizontal_move_z = gcmd.get_float("HORIZONTAL_MOVE_Z", self.horizontal_move_z)
+        retract_z_hight = gcmd.get_float("RETRACT_Z_HIGHT", self.retract_z_hight)
+        probe_fast_speed = gcmd.get_float("PROBE_FAST_SPEED", self.first_fast_speed, above=0.)
+        move_accel = gcmd.get_float("MOVE_ACCEL", 1000, above=0.)
+        # horizontal_dist = gcmd.get_float("HORIZONTAL_DIST", 2.0, minval=1.0)
+        # probe_xyz_mode = gcmd.get_int("PROBE_XYZ_MODE", RECTANGLE_PROBE_MODE, minval=RECTANGLE_PROBE_MODE, maxval=CIRCLE_PROBE_MODE)
+        log_file = gcmd.get("LOG_FILE", None)
+        xy_start_pos = gcmd.get_float("XY_START_POS", -6)
+        save_info = gcmd.get_int("SAVE_INFO", 0)
+        points = gcmd.get_int("PROBE_POINTS", 6)
+        if points == 6:
+            point1_x = gcmd.get_float("P1X", -4.6)
+            point1_y = gcmd.get_float("P1Y", -3.86)
+            point2_x = gcmd.get_float("P2X", 0)
+            point2_y = gcmd.get_float("P2Y", -6)
+            point3_x = gcmd.get_float("P3X", 4.6)
+            point3_y = gcmd.get_float("P3Y", -3.86)
+            point4_x = gcmd.get_float("P4X", 0)
+            point4_y = gcmd.get_float("P4Y", 0)
+            point5_x = gcmd.get_float("P5X", 0)
+            point5_y = gcmd.get_float("P5Y", 0)
+        elif points == 10:
+            point1_x = gcmd.get_float("P1X", -4.8)
+            point1_y = gcmd.get_float("P1Y", -3.6)
+            point2_x = gcmd.get_float("P2X", -2.4)
+            point2_y = gcmd.get_float("P2Y", -5.5)
+            point3_x = gcmd.get_float("P3X", 0)
+            point3_y = gcmd.get_float("P3Y", -6)
+            point4_x = gcmd.get_float("P4X", 2.4)
+            point4_y = gcmd.get_float("P4Y", -5.5)
+            point5_x = gcmd.get_float("P5X", 4.8)
+            point5_y = gcmd.get_float("P5Y", -3.6)
+        else:
+            point1_x = gcmd.get_float("P1X", 0)
+            point1_y = gcmd.get_float("P1Y", 0)
+            point2_x = gcmd.get_float("P2X", 0)
+            point2_y = gcmd.get_float("P2Y", 0)
+            point3_x = gcmd.get_float("P3X", 0)
+            point3_y = gcmd.get_float("P3Y", 0)
+            point4_x = gcmd.get_float("P4X", 0)
+            point4_y = gcmd.get_float("P4Y", 0)
+            point5_x = gcmd.get_float("P5X", 0)
+            point5_y = gcmd.get_float("P5Y", 0)
+        update_config = gcmd.get_int("UPDATE_CONFIG", 1, minval=0, maxval=1)
+        return {'probe_speed': probe_speed,
+                'probe_accel': probe_accel,
+                'probe_z_accel': probe_z_accel,
+                'lift_speed': lift_speed,
+                'move_accel': move_accel,
+                'probe_fast_speed': probe_fast_speed,
+                'samples': samples,
+                'samples_discard': samples_discard,
+                'travel_speed': travel_speed,
+                'sample_dist': sample_dist,
+                'sample_retract_dist': sample_retract_dist,
+                'samples_tolerance': samples_tolerance,
+                'samples_tolerance_retries': samples_retries,
+                'samples_result': samples_result,
+                'samples_axis': samples_axis,
+                'samples_dir': samples_dir,
+                'samples_retract_dir': samples_retract_dir,
+                'sample_trig_freq_config': sample_trig_freq_config,
+                'sample_trig_mode': sample_trig_mode,
+                'sample_trig_freq': sample_trig_freq,
+                'sample_trig_freq_y': sample_trig_freq_y,
+                'sample_absolute_trig': sample_absolute_trig,
+                'sample_trig_invert': sample_trig_invert,
+                'sample_wait_before_setup': sample_wait_before_setup,
+                'sample_wait_after_setup': sample_wait_after_setup,
+                'horizontal_move_x': horizontal_move_x,
+                'horizontal_move_y': horizontal_move_y,
+                'horizontal_move_z': horizontal_move_z,
+                'z_probe_x_move_offset': z_probe_x_move_offset,
+                'z_probe_y_move_offset': z_probe_y_move_offset,
+                'retract_z_hight': retract_z_hight,
+                # 'horizontal_dist' : horizontal_dist,
+                # 'probe_xyz_mode' : probe_xyz_mode,
+                'xy_start_pos': xy_start_pos,
+                'p1x': point1_x,
+                'p1y': point1_y,
+                'p2x': point2_x,
+                'p2y': point2_y,
+                'p3x': point3_x,
+                'p3y': point3_y,
+                'p4x': point4_x,
+                'p4y': point4_y,
+                'p5x': point5_x,
+                'p5y': point5_y,
+                'log_file': log_file,
+                'save_info': save_info,
+                'points': points,
+                'update_config' : update_config}
+    def _probe(self, gcmd, speed=None):
+        params = self.get_probe_params(gcmd)
+        toolhead = self.printer.lookup_object('toolhead')
+        curtime = self.printer.get_reactor().monotonic()
+        if 'z' not in toolhead.get_status(curtime)['homed_axes']:
+            raise self.printer.command_error('{"coded": "0003-0530-0000-0002", "msg":"Must home before probe"}')
+        result, capture_freq = self.mcu_probe.sensor.check_coil_freq()
+        if result != True:
+            index = {"extruder": 0, "extruder1": 1, "extruder2": 2, "extruder3": 3}.get(self.mcu_probe.sensor._name, 0)
+            code = 0 if capture_freq == 0 else 1
+            msg = "%s inductance coil status error [freq: %d]" % (self.mcu_probe.sensor._name, capture_freq)
+            message = '{"coded": "0003-0530-%4d-%4d", "oneshot": %d, "msg":"%s"}' % (index, code, 1, msg)
+            raise gcmd.error(message)
+        extruder = toolhead.get_extruder()
+        activate_status = extruder.get_extruder_activate_status()
+        grab_hall_sensor_type = None
+        if hasattr(extruder, 'grab_hall_sensor_type') and extruder.grab_hall_sensor_type:
+            grab_hall_sensor_type = extruder.grab_hall_sensor_type
+        if activate_status[0][1] != 0:
+            if grab_hall_sensor_type and activate_status[0][1] == 1:
+                error_msg = f"Probing abort: No extruder is picked up, all extruders are parked."
+                message = '{"coded": "0003-0530-0000-0013", "msg":"%s"}' % (error_msg)
+                raise gcmd.error(message)
+
+            result = extruder.analyze_switch_extruder_error(activate_status)
+            if result:
+                error_msg, activated, unknown, grip_states, activated_code, unknown_code = result
+                if grab_hall_sensor_type and "multi-act" not in error_msg:
+                    grip_state = grip_states[unknown[0]]
+                    message = None
+                    if grip_state == 'FFF':
+                        info = "Probing abort: detected that extruder%d is detached. %s" % (unknown[0], error_msg)
+                        message = '{"coded": "0003-0530-%4d-0014", "oneshot": %d, "msg":"%s"}' % (unknown[0], 1, info)
+                    elif grip_state == 'FFT':
+                        info = "Probing abort: detected that extruder%d pogopin not connected. %s" % (unknown[0], error_msg)
+                        message = '{"coded": "0003-0530-%4d-0015", "oneshot": %d, "msg":"%s"}' % (unknown[0], 1, info)
+                    elif (grip_state == 'TTF' or grip_state == 'TTT'):
+                        info = "Probing abort: detected conflicting status for extruder%d: both parked and picked states detected. %s" % (unknown[0], error_msg)
+                        message = '{"coded": "0003-0530-%4d-0016", "oneshot": %d, "msg":"%s"}' % (unknown[0], 1, info)
+                    if message is not None:
+                        raise gcmd.error(message)
+            else:
+                error_msg = activate_status
+            error_msg = f"Probing abort: Extruder parking status error, {error_msg}"
+            message = '{"coded": "0003-0530-0000-0004", "msg":"%s"}' % (error_msg)
+            raise gcmd.error(message)
+        if extruder.name != activate_status[0][0]:
+            error_msg = f"The extruder activation status does not match, current: {extruder.name}, detected: {activate_status[0][0]}"
+            message = '{"coded": "0003-0530-0000-0005", "msg":"%s"}' % (error_msg)
+            raise gcmd.error(message)
+        if extruder.binding_probe is not None and extruder.binding_probe != self.mcu_probe:
+            message = '{"coded": "0003-0530-0000-0006", "msg":"%s"}' % ("The extruder binding mcu probe does not match")
+            raise gcmd.error(message)
+        pos = toolhead.get_position()
+        if params['samples_axis'] == AXIS_Z_INDEX:
+            # The z-axis can only probe in the direction of the hot bed.
+            pos[2] = self.z_position
+        elif params['samples_axis'] == AXIS_X_INDEX:
+            # The detection range of the x-axis is not initialized, and x-axis detection is not supported.
+            if self.x_min_position == 0 and self.x_max_position == 0:
+                raise self.printer.command_error("The detection range of the x-axis is not initialized, and x-axis detection is not supported")
+            pos[AXIS_X_INDEX] = max(self.x_min_position, min(self.x_max_position, pos[AXIS_X_INDEX] + params['samples_dir'] * params['sample_dist']))
+        elif params['samples_axis'] == AXIS_Y_INDEX:
+            # The detection range of the y-axis is not initialized, and y-axis detection is not supported.
+            if self.y_min_position == 0 and self.y_max_position == 0:
+                raise self.printer.command_error("The detection range of the y-axis is not initialized, and y-axis detection is not supported")
+            pos[AXIS_Y_INDEX] = max(self.y_min_position, min(self.y_max_position, pos[AXIS_Y_INDEX] + params['samples_dir'] * params['sample_dist']))
+        else:
+            message = '{"coded": "0003-0530-0000-0007", "msg":"%s"}' % ("Unsupported probe axis")
+            raise self.printer.command_error(message)
+            # raise self.printer.command_error("Unsupported probe axis")
+
+        if params['sample_trig_freq_config']:
+            if params['samples_axis'] == AXIS_Z_INDEX:
+                new_freq = params['sample_trig_freq']
+            else:
+                new_freq = params['sample_trig_freq_y']
+            if params['sample_wait_before_setup'] != 0 or params['sample_wait_after_setup'] != 0:
+                toolhead.wait_moves()
+                # toolhead = self.printer.lookup_object('toolhead')
+                if params['sample_wait_before_setup'] != 0:
+                    toolhead.dwell(params['sample_wait_before_setup'])
+                    toolhead.wait_moves()
+                self.mcu_probe.sensor._cmd_set_trig_freq(abs(new_freq), -abs(new_freq), params['sample_absolute_trig'],
+                                                params['sample_trig_mode'], params['sample_trig_invert'])
+                if params['sample_wait_after_setup'] != 0:
+                    toolhead.dwell(params['sample_wait_after_setup'])
+                    toolhead.wait_moves()
+            else:
+                toolhead.flush_step_generation()
+                clock = self.mcu_probe.sensor._mcu.print_time_to_clock(toolhead.print_time)
+                self.mcu_probe.sensor._cmd_set_trig_freq_with_timer(
+                    abs(new_freq), -abs(new_freq), clock,
+                    params['sample_absolute_trig'],
+                    params['sample_trig_mode'],
+                    params['sample_trig_invert']
+                )
+        max_accel_bak = toolhead.max_accel
+        z_accel = toolhead.kin.max_z_accel
+        try:
+            if speed is None:
+                speed = params['probe_speed']
+            if params['probe_accel'] != max_accel_bak:
+                toolhead.set_accel(params['probe_accel'])
+            toolhead.kin.max_z_accel = params['probe_z_accel']
+            epos = self.mcu_probe.probing_move(pos, speed, params['samples_axis'])
+        except self.printer.command_error as e:
+            reason = str(e)
+            if "Timeout during endstop homing" in reason:
+                reason += HINT_TIMEOUT
+            raise self.printer.command_error(reason)
+        finally:
+            if toolhead.max_accel != max_accel_bak:
+                toolhead.set_accel(max_accel_bak)
+            toolhead.kin.max_z_accel = z_accel
+
+        # Allow axis_twist_compensation to update results
+        self.printer.send_event("probe:update_results", epos)
+        # Report results
+        gcode = self.printer.lookup_object('gcode')
+
+        if params['samples_axis'] == AXIS_Z_INDEX:
+            gcode.respond_info("probe at x: %.3f, y: %.3f is z=%.6f"
+                            % (epos[0], epos[1], epos[2]))
+        elif params['samples_axis'] == AXIS_X_INDEX:
+            gcode.respond_info("probe at y: %.3f, z: %.3f is x=%.6f"
+                            % (epos[1], epos[2], epos[0]))
+        else:
+            gcode.respond_info("probe at x: %.3f, z: %.3f is y=%.6f"
+                % (epos[0], epos[2], epos[1]))
+        return epos[:3]
+    def run_probe(self, gcmd):
+        if not self.multi_probe_pending:
+            self._probe_state_error()
+        params = self.get_probe_params(gcmd)
+        toolhead = self.printer.lookup_object('toolhead')
+        probe_positions = toolhead.get_position()[:3]
+        retries = 0
+        positions = []
+        sample_count = params['samples']
+        discard = params['samples_discard']
+        # First fast probe if probe count is larger than 1
+        if sample_count > 2:
+            fast_speed = params.get('probe_fast_speed', params['probe_speed'] * 2.0)
+            pos = self._probe(gcmd, fast_speed)
+            # Retract after fast probe
+            probe_positions[params['samples_axis']] = pos[params['samples_axis']] + params['sample_retract_dist'] * params['samples_retract_dir']
+            toolhead.manual_move(probe_positions, params['lift_speed'])
+            sample_count -= 1
+        sample_count += discard*2
+        gcmd.respond_info(f'sample {sample_count}, discard {discard*2}')
+        while len(positions) < sample_count:
+            # Probe position
+            pos = self._probe(gcmd, params['probe_speed'])
+            positions.append(pos)
+            # Check samples tolerance
+            z_positions = [p[params['samples_axis']] for p in positions]
+            if max(z_positions)-min(z_positions) > params['samples_tolerance']:
+                if retries >= params['samples_tolerance_retries']:
+                    message = '{"coded": "0003-0530-%4d-0008", "msg":"%s"}' % (
+                                params['samples_axis'], "Probe samples exceed samples_tolerance")
+                    raise gcmd.error(message)
+                    # raise gcmd.error("Probe samples exceed samples_tolerance")
+                gcmd.respond_info("Probe samples exceed tolerance. Retrying...")
+                retries += 1
+                positions = []
+            # Retract
+            if len(positions) < sample_count:
+                probe_positions[params['samples_axis']] = pos[params['samples_axis']] + params['sample_retract_dist'] * params['samples_retract_dir']
+                toolhead.manual_move(probe_positions, params['lift_speed'])
+        # check if need discard samples data
+        if discard > 0:
+            sorted_pos = sorted(positions, key=lambda positions: positions[params['samples_axis']])
+            filter_pos = sorted_pos[discard: -discard]
+        else:
+            filter_pos = positions
+        # save result for slow speed
+        if params.get('log_file') != None:
+            logdir = '/userdata/gcodes/calibration_data'
+            if not os.path.exists(logdir):
+                os.makedirs(logdir)
+            content = ""
+            for p in filter_pos:
+                content += f'{p[0]:.6f}, {p[1]:.6f}, {p[2]:.6f}\n'
+            content += ' , , \n'
+            try:
+                queuefile.async_append_file(f'{logdir}/{params["log_file"]}', content)
+            except Exception as e:
+                logging.exception(f"Failed to append to file {params['log_file']}: {e}")
+        # Calculate result
+        epos = calc_probe_z_average(filter_pos, params['samples_result'])
+        self.results.append(epos)
+    def pull_probed_results(self):
+        res = self.results
+        self.results = []
+        return res
+
+# Helper to read the xyz probe offsets from the config
+class ProbeOffsetsHelper:
+    def __init__(self, config):
+        self.x_offset = config.getfloat('x_offset', 0.)
+        self.y_offset = config.getfloat('y_offset', 0.)
+        self.z_offset = config.getfloat('z_offset')
+    def get_offsets(self):
+        return self.x_offset, self.y_offset, self.z_offset
+
+
+######################################################################
+# Tools for utilizing the probe
+######################################################################
+
+# Helper code that can probe a series of points and report the
+# position at each point.
+class ProbePointsHelper:
+    def __init__(self, config, finalize_callback, default_points=None, probe_point_callback=None):
+        self.printer = config.get_printer()
+        self.finalize_callback = finalize_callback
+        self.probe_point_callback = probe_point_callback
+        self.probe_points = default_points
+        self.name = config.get_name()
+        self.gcode = self.printer.lookup_object('gcode')
+        # Read config settings
+        if default_points is None or config.get('points', None) is not None:
+            self.probe_points = config.getlists('points', seps=(',', '\n'),
+                                                parser=float, count=2)
+        def_move_z = config.getfloat('horizontal_move_z', 5.)
+        self.default_horizontal_move_z = def_move_z
+        self.fast_horizontal_move_z = config.getfloat('fast_horizontal_move_z', None)
+        self.speed = config.getfloat('speed', 50., above=0.)
+        self.min_x_grid_size_for_fast_move = config.getint('min_x_grid_size_for_fast_move', 5, minval=1)
+        self.min_y_grid_size_for_fast_move = config.getint('min_y_grid_size_for_fast_move', 5, minval=1)
+        self.use_offsets = False
+        # Internal probing state
+        self.lift_speed = self.speed
+        self.probe_offsets = (0., 0., 0.)
+        self.manual_results = []
+        self.allow_fast_horizontal_move = True
+        gcode_macro = self.printer.load_object(config, 'gcode_macro')
+        self.first_raise_tool_gcode = gcode_macro.load_template(
+            config, 'first_raise_tool_gcode', '')
+    def minimum_points(self,n):
+        if len(self.probe_points) < n:
+            raise self.printer.config_error(
+                "Need at least %d probe points for %s" % (n, self.name))
+    def update_probe_points(self, points, min_points):
+        self.probe_points = points
+        self.minimum_points(min_points)
+        bed_mesh = self.printer.lookup_object('bed_mesh', None)
+        if bed_mesh is not None:
+            mesh_config = bed_mesh.bmc.mesh_config
+            x_count = mesh_config.get('x_count', 0)
+            y_count = mesh_config.get('y_count', 0)
+            if x_count < self.min_x_grid_size_for_fast_move or y_count < self.min_y_grid_size_for_fast_move:
+                self.allow_fast_horizontal_move = False
+            else:
+                self.allow_fast_horizontal_move = True
+    def use_xy_offsets(self, use_offsets):
+        self.use_offsets = use_offsets
+    def get_lift_speed(self):
+        return self.lift_speed
+    def _move(self, coord, speed):
+        self.printer.lookup_object('toolhead').manual_move(coord, speed)
+    def _raise_tool(self, is_first=False, horizontal_move_z=None):
+        speed = self.lift_speed
+        if is_first:
+            # Use full speed to first probe position
+            speed = self.speed
+        h_move_z = self.horizontal_move_z
+        if horizontal_move_z is not None:
+            h_move_z = horizontal_move_z
+        self._move([None, None, h_move_z], speed)
+    def _invoke_callback(self, results):
+        # Flush lookahead queue
+        toolhead = self.printer.lookup_object('toolhead')
+        toolhead.get_last_move_time()
+        # Invoke callback
+        res = self.finalize_callback(self.probe_offsets, results)
+        return res != "retry"
+    def _move_next(self, probe_num):
+        # Move to next XY probe point
+        nextpos = list(self.probe_points[probe_num])
+        if self.use_offsets:
+            nextpos[0] -= self.probe_offsets[0]
+            nextpos[1] -= self.probe_offsets[1]
+        self._move(nextpos, self.speed)
+    def start_probe(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead')
+        manual_probe.verify_no_manual_probe(self.printer)
+        # Lookup objects
+        probe = self.printer.lookup_object('probe', None)
+        method = gcmd.get('METHOD', 'automatic').lower()
+        def_move_z = self.default_horizontal_move_z
+        self.horizontal_move_z = gcmd.get_float('HORIZONTAL_MOVE_Z',
+                                                def_move_z)
+        fast_horizontal_move_z = gcmd.get_float('FAST_HORIZONTAL_MOVE_Z', self.fast_horizontal_move_z)
+        if probe is None or method == 'manual':
+            # Manual probe
+            self.lift_speed = self.speed
+            self.probe_offsets = (0., 0., 0.)
+            self.manual_results = []
+            self._manual_probe_start()
+            return
+        # Perform automatic probing
+        self.lift_speed = probe.get_probe_params(gcmd)['lift_speed']
+        self.probe_offsets = probe.get_offsets()
+        if self.horizontal_move_z < self.probe_offsets[2]:
+            raise gcmd.error("horizontal_move_z can't be less than"
+                             " probe's z_offset")
+        probe_session = probe.start_probe_session(gcmd)
+        probe_num = 0
+        try:
+            while 1:
+                h_move_z = None
+                if probe_num and fast_horizontal_move_z is not None and self.allow_fast_horizontal_move:
+                    pos = toolhead.get_position()
+                    h_move_z  = pos[2] + fast_horizontal_move_z
+                    # gcmd.respond_info("pos[2]: %.5f, h_move_z: %.5f" % (pos[2], h_move_z))
+                self._raise_tool(not probe_num, h_move_z)
+                if probe_num >= len(self.probe_points):
+                    results = probe_session.pull_probed_results()
+                    done = self._invoke_callback(results)
+                    if done:
+                        break
+                    # Caller wants a "retry" - restart probing
+                    probe_num = 0
+                self._move_next(probe_num)
+                if not probe_num:
+                    self.first_raise_tool_gcode.run_gcode_from_command()
+                probe_session.run_probe(gcmd)
+                probe_num += 1
+                if self.probe_point_callback is not None:
+                    self.probe_point_callback([probe_num, len(self.probe_points)])
+        finally:
+            self._raise_tool(True)
+            if probe_session.multi_probe_pending:
+                probe_session.end_probe_session()
+    def _manual_probe_start(self):
+        self._raise_tool(not self.manual_results)
+        if len(self.manual_results) >= len(self.probe_points):
+            done = self._invoke_callback(self.manual_results)
+            if done:
+                return
+            # Caller wants a "retry" - clear results and restart probing
+            self.manual_results = []
+        self._move_next(len(self.manual_results))
+        gcmd = self.gcode.create_gcode_command("", "", {})
+        manual_probe.ManualProbeHelper(self.printer, gcmd,
+                                       self._manual_probe_finalize)
+    def _manual_probe_finalize(self, kin_pos):
+        if kin_pos is None:
+            return
+        self.manual_results.append(kin_pos)
+        self._manual_probe_start()
+
+# Helper to obtain a single probe measurement
+def run_single_probe(probe, gcmd):
+    probe_session = probe.start_probe_session(gcmd)
+    probe_session.run_probe(gcmd)
+    pos = probe_session.pull_probed_results()[0]
+    probe_session.end_probe_session()
+    return pos
+
+
+######################################################################
+# Handle [probe] config
+######################################################################
+
+# Endstop wrapper that enables probe specific features
+class ProbeEndstopWrapper:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.position_endstop = config.getfloat('z_offset')
+        self.stow_on_each_sample = config.getboolean(
+            'deactivate_on_each_sample', True)
+        gcode_macro = self.printer.load_object(config, 'gcode_macro')
+        self.activate_gcode = gcode_macro.load_template(
+            config, 'activate_gcode', '')
+        self.deactivate_gcode = gcode_macro.load_template(
+            config, 'deactivate_gcode', '')
+        # Create an "endstop" object to handle the probe pin
+        ppins = self.printer.lookup_object('pins')
+        self.mcu_endstop = ppins.setup_pin('endstop', config.get('pin'))
+        # Wrappers
+        self.get_mcu = self.mcu_endstop.get_mcu
+        self.add_stepper = self.mcu_endstop.add_stepper
+        self.get_steppers = self.mcu_endstop.get_steppers
+        self.home_start = self.mcu_endstop.home_start
+        self.home_wait = self.mcu_endstop.home_wait
+        self.query_endstop = self.mcu_endstop.query_endstop
+        # multi probes state
+        self.multi = 'OFF'
+    def _raise_probe(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        start_pos = toolhead.get_position()
+        self.deactivate_gcode.run_gcode_from_command()
+        if toolhead.get_position()[:3] != start_pos[:3]:
+            raise self.printer.command_error(
+                "Toolhead moved during probe deactivate_gcode script")
+    def _lower_probe(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        start_pos = toolhead.get_position()
+        self.activate_gcode.run_gcode_from_command()
+        if toolhead.get_position()[:3] != start_pos[:3]:
+            raise self.printer.command_error(
+                "Toolhead moved during probe activate_gcode script")
+    def multi_probe_begin(self):
+        if self.stow_on_each_sample:
+            return
+        self.multi = 'FIRST'
+    def multi_probe_end(self):
+        if self.stow_on_each_sample:
+            return
+        self._raise_probe()
+        self.multi = 'OFF'
+    def probing_move(self, pos, speed, axis=AXIS_Z_INDEX):
+        phoming = self.printer.lookup_object('homing')
+        return phoming.probing_coil_move(self, pos, speed, axis)
+    def probe_prepare(self, hmove):
+        if self.multi == 'OFF' or self.multi == 'FIRST':
+            self._lower_probe()
+            if self.multi == 'FIRST':
+                self.multi = 'ON'
+    def probe_finish(self, hmove):
+        if self.multi == 'OFF':
+            self._raise_probe()
+    def get_position_endstop(self):
+        return self.position_endstop
+
+class ExtruderOffsetCalibration:
+    extruder_mapping = {
+        'T0': 'extruder',
+        'T1': 'extruder1',
+        'T2': 'extruder2',
+        'T3': 'extruder3',
+    }
+
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object('gcode')
+        self.machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        self.lock = self.printer.get_reactor().mutex()
+        self.calibration_step = 'idle'
+        self.bed_plate_check = False
+        self.is_prehoming = False
+        self.status = None
+        self.manual_clean_nozzle_status = {
+            'extruder': False,
+            'extruder1': False,
+            'extruder2': False,
+            'extruder3': False,
+        }
+        self.last_xyz_result = {
+            'extruder':  None,
+            'extruder1': None,
+            'extruder2': None,
+            'extruder3': None,
+        }
+
+        # Register G-code commands
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_PRESTART",
+            self.cmd_EXTRUDER_OFFSET_ACTION_PRESTART)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_PREHOMING",
+            self.cmd_EXTRUDER_OFFSET_ACTION_PREHOMING)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_DETECT_PLATE",
+            self.cmd_EXTRUDER_OFFSET_ACTION_DETECT_PLATE)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_PREHEAT",
+            self.cmd_EXTRUDER_OFFSET_ACTION_PREHEAT)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_MANUAL_CLEAN",
+            self.cmd_EXTRUDER_OFFSET_ACTION_MANUAL_CLEAN)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_HEAT",
+            self.cmd_EXTRUDER_OFFSET_ACTION_HEAT)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_AUTO_CLEAN",
+            self.cmd_EXTRUDER_OFFSET_ACTION_AUTO_CLEAN)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_WAIT_COOL",
+            self.cmd_EXTRUDER_OFFSET_ACTION_WAIT_COOL)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_CHECK_TARGET_TEMP",
+            self.cmd_EXTRUDER_OFFSET_ACTION_CHECK_TARGET_TEMP)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_PROBE_CALIBRATE",
+            self.cmd_EXTRUDER_OFFSET_ACTION_PROBE_CALIBRATE)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_SAVE_RESULT",
+            self.cmd_EXTRUDER_OFFSET_ACTION_SAVE_RESULT)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_EXIT",
+            self.cmd_EXTRUDER_OFFSET_ACTION_EXIT)
+        self.gcode.register_command(
+            "EXTRUDER_OFFSET_ACTION_GET_STATUS",
+            self.cmd_EXTRUDER_OFFSET_ACTION_GET_STATUS)
+
+        self.gcode.register_command("DETECT_BED_PLATE", self.cmd_DETECT_PLATE)
+        self.printer.register_event_handler("stepper_enable:motor_off", self._motor_off)
+        self.printer.register_event_handler("klippy:ready", self._handle_ready)
+
+        # Register abork webhooks
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint(
+            "extruder_offset_calibration/probe_abort", self._probe_xyz_offset_abort
+        )
+
+    def get_status(self, eventtime):
+        sts = {
+            'calibration_step': self.calibration_step,
+            'bed_plate_check': self.bed_plate_check,
+            'is_prehoming': self.is_prehoming,
+        }
+        last_xyz_result = {f"{key}_last_xyz_result": value for key, value in self.last_xyz_result.items()}
+        manual_clean_nozzle = {f"{key}_nozzle_clean": value for key, value in self.manual_clean_nozzle_status.items()}
+        sts.update(last_xyz_result)
+        sts.update(manual_clean_nozzle)
+        return sts
+
+    def reset_xyz_probe_positions(self):
+        for extruder in self.last_xyz_result.keys():
+            self.last_xyz_result[extruder] = None
+
+    def reset_manual_clean_nozzle_status(self):
+        for extruder in self.manual_clean_nozzle_status.keys():
+            self.manual_clean_nozzle_status[extruder] = False
+    def _motor_off(self, print_time):
+        with self.lock:
+            self._cleanup_resources()
+
+    def _handle_ready(self):
+        self.machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+
+    def _cleanup_resources(self):
+        self.bed_plate_check = False
+        self.is_prehoming = False
+        self.reset_xyz_probe_positions()
+        self.reset_manual_clean_nozzle_status()
+
+    def _verify_calibration_state(self, operation=None):
+        if (self.machine_state_manager and
+            str(self.machine_state_manager.get_status()['main_state']) != "XYZ_OFFSET_CALIBRATE"):
+            if operation:
+                message = '{"coded": "0003-0530-0000-0009", "msg":"%s"}' % (
+                            f"Operation '{operation}' requires XYZ_OFFSET_CALIBRATE main state")
+                raise self.printer.command_error(message)
+                # raise self.printer.command_error(
+                #     f"Operation '{operation}' requires XYZ_OFFSET_CALIBRATE main state")
+            else:
+                message = '{"coded": "0003-0530-0000-0009", "msg":"%s"}' % (
+                            "Current main state is not XYZ_OFFSET_CALIBRATE")
+                raise self.printer.command_error(message)
+    def _probe_xyz_offset_abort(self, web_request):
+        try:
+            self.printer.send_event("probe_xyz_offset:abort")
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to abort probe xyz_offset: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
+
+    def _get_filament_temp(self, extruder):
+        print_task_config = self.printer.lookup_object('print_task_config', None)
+        filament_parameters = self.printer.lookup_object('filament_parameters', None)
+        if print_task_config is None or filament_parameters is None:
+            return 200
+
+        status = print_task_config.get_status()
+        temp = filament_parameters.get_flow_temp(
+                status['filament_vendor'][extruder],
+                status['filament_type'][extruder],
+                status['filament_sub_type'][extruder])
+        return temp - 20
+
+    def _get_filament_soft(self, extruder):
+        print_task_config = self.printer.lookup_object('print_task_config', None)
+        filament_parameters = self.printer.lookup_object('filament_parameters', None)
+        if print_task_config is None or filament_parameters is None:
+            return False
+
+        status = print_task_config.get_status()
+        return filament_parameters.get_is_soft(
+                status['filament_vendor'][extruder],
+                status['filament_type'][extruder],
+                status['filament_sub_type'][extruder])
+
+    def cmd_EXTRUDER_OFFSET_ACTION_GET_STATUS(self, gcmd):
+        gcmd.respond_info("{}".format(self.get_status(0)))
+
+    def cmd_EXTRUDER_OFFSET_ACTION_PRESTART(self, gcmd):
+        # State validation
+        # TODOï¼
+        # if self.calibration_step != 'idle':
+        #     raise gcmd.error(f"Cannot start calibration in {self.calibration_step}")
+
+        try:
+            # TODO Hardware readiness check
+            # if not self._check_hardware_ready():
+            #     raise gcmd.error("Hardware not ready for calibration")
+            self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=XYZ_OFFSET_CALIBRATE")
+            with self.lock:
+                self.calibration_step = 'ready'
+                self._cleanup_resources()
+
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_PRESTART', None)
+            if macro:
+                self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_PRESTART")
+
+        except Exception as e:
+            # with self.lock:
+            #     self.calibration_step = 'error'
+            raise gcmd.error(str(e))
+        finally:
+            pass
+
+    def cmd_EXTRUDER_OFFSET_ACTION_PREHOMING(self, gcmd):
+        # if self.calibration_step != 'ready':
+        #     raise gcmd.error("Calibration in progress, cannot perform homing")
+        self._verify_calibration_state("EXTRUDER_OFFSET_ACTION_PREHOMING")
+        try:
+            with self.lock:
+                # Set state to prehoming
+                self.calibration_step = 'prehoming'
+                self.is_prehoming = False
+
+            default_force_homing = True
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_PREHOMING', None)
+            if macro is not None:
+                default_force_homing = macro.variables.get('force_homing', True)
+
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=HOMING")
+            # Get force homing parameter
+            force_homing = gcmd.get_int('FORCE_HOMING', default_force_homing)
+            curtime = self.printer.get_reactor().monotonic()
+            homed_axes_list = self.printer.lookup_object('toolhead').get_status(curtime)['homed_axes']
+            if force_homing or homed_axes_list != "xyz":
+                self.gcode.run_script_from_command("G28 SAMPLES_TOLERANCE 0.1")
+            self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_PREHOMING")
+
+            # # Update state to prehoming_done
+            with self.lock:
+                self.calibration_step = 'prehoming_done'
+                self.is_prehoming = True
+
+        except Exception as e:
+            # Handle error
+            with self.lock:
+                self.calibration_step = 'prehoming_error'
+            raise gcmd.error(str(e))
+
+        finally:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+
+    def cmd_DETECT_PLATE(self, gcmd):
+        HOLE_POSITION = [30, 134, 3]
+        SOLID_POSITION = [30, 100, 3]
+        MOVE_SPEED = 200
+        CHECK_OK_LIFT_Z = 5
+        CHECK_FAIL_LIFT_Z = 150
+        toolhead = self.printer.lookup_object('toolhead')
+        try:
+            # with self.lock:
+            #     self.calibration_step = 'plate_detecting'
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=DETECT_PLATE")
+            presence = gcmd.get_int('PRESENCE', 1)
+            hole_position =  copy.deepcopy(HOLE_POSITION)
+            solid_position =  copy.deepcopy(SOLID_POSITION)
+            solid_x, solid_y, solid_z = solid_position
+            hole_x, hole_y, hole_z = hole_position
+            default_delta_z = 1
+            default_move_speed = MOVE_SPEED
+            default_check_ok_lift_z = CHECK_OK_LIFT_Z
+            default_check_fail_lift_z = CHECK_FAIL_LIFT_Z
+            macro = self.printer.lookup_object('gcode_macro _DETECT_PLATE', None)
+            if macro is not None:
+                hole_position = [
+                    macro.variables.get('hole_x', hole_x),
+                    macro.variables.get('hole_y', hole_y),
+                    macro.variables.get('hole_z', hole_x)
+                ]
+                solid_position = [
+                    macro.variables.get('solid_x', solid_x),
+                    macro.variables.get('solid_y', solid_y),
+                    macro.variables.get('solid_z', solid_z)
+                ]
+                default_delta_z = macro.variables.get('delta_z', default_delta_z)
+                default_move_speed = macro.variables.get('move_speed', MOVE_SPEED)
+                default_check_ok_lift_z = macro.variables.get('check_ok_lift_z', CHECK_OK_LIFT_Z)
+                default_check_fail_lift_z = macro.variables.get('check_fail_lift_z', CHECK_FAIL_LIFT_Z)
+            gcmd.respond_info("hole_position: {}, solid_position: {}".format(hole_position, solid_position))
+            toolhead.wait_moves()
+            default_check_ok_lift_z = gcmd.get_int('CHECK_OK_LIFT_Z', default_check_ok_lift_z)
+            default_check_fail_lift_z = gcmd.get_int('CHECK_FAIL_LIFT_Z', default_check_fail_lift_z)
+            default_delta_z = gcmd.get_int('DELTA_Z', default_delta_z)
+            safe_move_y_pos = gcmd.get_float('SAFE_MOVE_Y_POS', 250, minval=0.)
+            pos = toolhead.get_position()
+            self.printer.send_event("inductance_coil:probe_start")
+            toolhead.manual_move([None, None, solid_position[2]], default_move_speed)
+            if pos[1] > safe_move_y_pos:
+                toolhead.manual_move([None, safe_move_y_pos, None], 200)
+            toolhead.manual_move([solid_position[0], solid_position[1], None], default_move_speed)
+            # self.gcode.run_script_from_command("PROBE SAMPLES=3")
+            self.gcode.run_script_from_command("_DETECT_PLATE")
+            solid_z = self.printer.lookup_object('probe').get_status(0)['last_z_result']
+            toolhead.manual_move([None, None, hole_position[2]], default_move_speed)
+            toolhead.manual_move([hole_position[0], hole_position[1], None], default_move_speed)
+            # self.gcode.run_script_from_command("PROBE SAMPLES=3")
+            self.gcode.run_script_from_command("_DETECT_PLATE")
+            hole_z = self.printer.lookup_object('probe').get_status(0)['last_z_result']
+            if presence:
+                if abs(solid_z - hole_z) >= default_delta_z:
+                    message = '{"coded": "0003-0530-0000-0010", "msg":"%s"}' % ("The plate has been removed")
+                    raise gcmd.error(message)
+                    # raise gcmd.error("The plate has been removed.")
+            else:
+                if abs(solid_z - hole_z) <= default_delta_z:
+                    message = '{"coded": "0003-0530-0000-0011", "msg":"%s"}' % ("The plate has not been removed")
+                    raise gcmd.error(message)
+                    # raise gcmd.error("The plate has not been removed.")
+            toolhead.manual_move([None, None, default_check_ok_lift_z], default_move_speed)
+            # with self.lock:
+            #     self.calibration_step = 'plate_detected'
+            #     self.bed_plate_check = True
+        except Exception as e:
+            # with self.lock:
+            #     self.calibration_step = 'plate_detection_error'
+            try:
+                toolhead.manual_move([None, None, default_check_fail_lift_z], default_move_speed)
+            except:
+                pass
+
+            raise gcmd.error(str(e))
+        finally:
+            self.printer.send_event("inductance_coil:probe_end")
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+
+    def cmd_EXTRUDER_OFFSET_ACTION_DETECT_PLATE(self, gcmd):
+        try:
+            with self.lock:
+                self.calibration_step = 'plate_detecting'
+                self.bed_plate_check = False
+            self.cmd_DETECT_PLATE(gcmd)
+            with self.lock:
+                self.calibration_step = 'plate_detected'
+                self.bed_plate_check = True
+        except Exception as e:
+            with self.lock:
+                self.calibration_step = 'plate_detection_error'
+            raise
+        finally:
+            pass
+
+    def cmd_EXTRUDER_OFFSET_ACTION_PREHEAT(self, gcmd):
+        try:
+            # with self.lock:
+            #     self.calibration_step = 'preheat'
+            #     self.error_message = None
+            params = {}
+            bed_temp = gcmd.get_int('BED_TEMP', None)
+            if bed_temp is not None:
+                params['BED_TEMP'] = bed_temp
+
+            for tool_id in range(4):
+                key = f"T{tool_id}_TEMP"
+                value = gcmd.get_int(key, None)
+                if value is not None:
+                    params[key] = value
+
+            args = []
+            if 'BED_TEMP' in params:
+                args.append(f"BED_TEMP={params['BED_TEMP']}")
+
+            for tool_id in range(4):
+                key = f"T{tool_id}_TEMP"
+                if key in params:
+                    args.append(f"{key}={params[key]}")
+
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_PREHEAT', None)
+            if macro is not None:
+                gcode_script = "_EXTRUDER_OFFSET_ACTION_PREHEAT"
+                if args:
+                    gcode_script += " " + " ".join(args)
+                self.gcode.run_script_from_command(gcode_script)
+        except Exception as e:
+            # with self.lock:
+            #     self.calibration_step = 'idle'
+            #     self.error_message = str(e)
+            raise gcmd.error(str(e))
+        finally:
+            pass
+
+    def cmd_EXTRUDER_OFFSET_ACTION_MANUAL_CLEAN(self, gcmd):
+        self._verify_calibration_state("EXTRUDER_OFFSET_ACTION_MANUAL_CLEAN")
+        try:
+            tool_id = gcmd.get('TOOL_ID', None)
+            if tool_id is None:
+                raise gcmd.error('EXTRUDER_OFFSET_ACTION_MANUAL_CLEAN: TOOL_ID is required')
+            extruder = self.extruder_mapping.get(tool_id)
+            if extruder is not None:
+                with self.lock:
+                    self.calibration_step = '{}_nozzle_clean'.format(extruder)
+                self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=MANUAL_CLEAN_{}".format(extruder.upper()))
+
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_MANUAL_CLEAN_{}'.format(tool_id), None)
+            if macro is not None:
+                self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_MANUAL_CLEAN_{}".format(tool_id))
+
+            if extruder is not None:
+                with self.lock:
+                    self.manual_clean_nozzle_status[extruder] = True
+
+        except Exception as e:
+            # with self.lock:
+            #     self.calibration_step = 'idle'
+            #     self.error_message = str(e)
+            raise gcmd.error(str(e))
+        finally:
+            pass
+
+    def cmd_EXTRUDER_OFFSET_ACTION_HEAT(self, gcmd):
+        self._verify_calibration_state("EXTRUDER_OFFSET_ACTION_HEAT")
+        try:
+            tool_id = gcmd.get('TOOL_ID', None)
+            if tool_id is None:
+                raise gcmd.error('EXTRUDER_OFFSET_ACTION_HEAT: TOOL_ID is required')
+
+            extruder = self.extruder_mapping.get(tool_id, None)
+            if extruder is None:
+                supported_tools = list(self.extruder_mapping.keys())
+                raise gcmd.error(f'EXTRUDER_OFFSET_ACTION_HEAT: Unsupported TOOL_ID={tool_id}. Supported IDs: {supported_tools}')
+
+            extruder_index = None
+            heat_temp = 200
+            if tool_id is not None:
+                extruder_index = int(tool_id[1:])
+                heat_temp = gcmd.get_float('HEAT_TEMP', self._get_filament_temp(extruder_index), minval=0.)
+
+            with self.lock:
+                self.calibration_step = '{}_heating'.format(extruder)
+
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_HEAT_{}'.format(tool_id), None)
+            if macro is not None:
+                self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_HEAT_{} HEAT_TEMP={}".format(tool_id, heat_temp))
+
+            with self.lock:
+                self.calibration_step = '{}_heated'.format(extruder)
+        except Exception as e:
+            with self.lock:
+                self.calibration_step = 'heat_extruder_error'
+            raise gcmd.error(str(e))
+
+    def cmd_EXTRUDER_OFFSET_ACTION_AUTO_CLEAN(self, gcmd):
+        self._verify_calibration_state("EXTRUDER_OFFSET_ACTION_AUTO_CLEAN")
+        try:
+            tool_id = gcmd.get('TOOL_ID', None)
+            if tool_id is None:
+                raise gcmd.error('EXTRUDER_OFFSET_ACTION_AUTO_CLEAN: TOOL_ID is required')
+
+            extruder = self.extruder_mapping.get(tool_id, None)
+            if extruder is None:
+                supported_tools = list(self.extruder_mapping.keys())
+                raise gcmd.error(f'EXTRUDER_OFFSET_ACTION_AUTO_CLEAN: Unsupported TOOL_ID={tool_id}. Supported IDs: {supported_tools}')
+
+            with self.lock:
+                self.calibration_step = '{}_nozzle_auto_cleaning'.format(extruder)
+
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=AUTO_CLEAN_NOZZLE")
+
+            # not need
+            # safe_move_y_pos = gcmd.get_float('SAFE_MOVE_Y_POS', None, minval=0.)
+            # if safe_move_y_pos is not None:
+            #     toolhead = self.printer.lookup_object('toolhead')
+            #     toolhead.wait_moves()
+            #     pos = toolhead.get_position()
+            #     if pos[1] > safe_move_y_pos:
+            #         toolhead.manual_move([None, safe_move_y_pos, None], 200)
+
+            extruder_index = None
+            is_soft = False
+            if tool_id is not None:
+                extruder_index = int(tool_id[1:])
+                is_soft = int(self._get_filament_soft(extruder_index))
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_AUTO_CLEAN_{}'.format(tool_id), None)
+            if macro is not None:
+                self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_AUTO_CLEAN_{} SOFT={}".format(tool_id, is_soft))
+
+            with self.lock:
+                self.calibration_step = '{}_nozzle_auto_cleaned'.format(extruder)
+        except Exception as e:
+            with self.lock:
+                self.calibration_step = 'nozzle_auto_clean_failed'
+            raise gcmd.error(str(e))
+        finally:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+
+    def cmd_EXTRUDER_OFFSET_ACTION_WAIT_COOL(self, gcmd):
+        self._verify_calibration_state("EXTRUDER_OFFSET_ACTION_WAIT_COOL")
+        try:
+            tool_id = gcmd.get('TOOL_ID', None)
+            if tool_id is None:
+                raise gcmd.error('EXTRUDER_OFFSET_ACTION_WAIT_COOL: TOOL_ID is required')
+
+            extruder = self.extruder_mapping.get(tool_id, None)
+            if extruder is None:
+                supported_tools = list(self.extruder_mapping.keys())
+                raise gcmd.error(f'EXTRUDER_OFFSET_ACTION_WAIT_COOL: Unsupported TOOL_ID={tool_id}. Supported IDs: {supported_tools}')
+
+            with self.lock:
+                self.calibration_step = '{}_wait_cooling'.format(extruder)
+
+            toolhead = self.printer.lookup_object('toolhead')
+            toolhead.wait_moves()
+            pos = toolhead.get_position()
+            safe_move_y_pos = gcmd.get_float('SAFE_MOVE_Y_POS', 250, minval=0.)
+            if pos[1] > safe_move_y_pos:
+                toolhead.manual_move([None, safe_move_y_pos, None], 200)
+
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=WAIT_NOZZLE_COOLING")
+
+            temp = gcmd.get_float('TEMP', 130, minval=0.)
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_WAIT_COOL_{}'.format(tool_id), None)
+            if macro is not None:
+                self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_WAIT_COOL_{} TEMP={}".format(tool_id, temp))
+
+            with self.lock:
+                self.calibration_step = '{}_wait_cooled'.format(extruder)
+        except Exception as e:
+            with self.lock:
+                self.calibration_step = 'wait_cooling_failed'
+            raise gcmd.error(str(e))
+        finally:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+
+    def cmd_EXTRUDER_OFFSET_ACTION_CHECK_TARGET_TEMP(self, gcmd):
+        heater_type = gcmd.get('HEATER', 'all')
+        extruder_range = gcmd.get_float('EXTRUDER_RANGE', 5.0)
+        bed_range = gcmd.get_float('BED_RANGE', 1.5)
+
+        expected_targets = {
+            'heater_bed': gcmd.get_int('BED_TARGET', None),
+            'extruder': gcmd.get_int('EXTRUDER_TARGET', None),
+            'extruder1': gcmd.get_int('EXTRUDER1_TARGET', None),
+            'extruder2': gcmd.get_int('EXTRUDER2_TARGET', None),
+            'extruder3': gcmd.get_int('EXTRUDER3_TARGET', None)
+        }
+
+        heaters = {
+            'heater_bed': 'heater_bed',
+            'extruder': 'extruder',
+            'extruder1': 'extruder1',
+            'extruder2': 'extruder2',
+            'extruder3': 'extruder3',
+            'all': ['heater_bed', 'extruder', 'extruder1', 'extruder2', 'extruder3']
+        }
+
+        heater_names = heaters.get(heater_type.lower())
+        if heater_names is None:
+            raise gcmd.error("Unknown heater type: %s" % (heater_type,))
+
+        if not isinstance(heater_names, list):
+            heater_names = [heater_names]
+
+        not_reached = []
+        curtime = self.printer.get_reactor().monotonic()
+        for name in heater_names:
+            heater = self.printer.lookup_object(name, None)
+            if heater is None:
+                continue
+            status = heater.get_status(curtime)
+            expected_target = expected_targets.get(name)
+            if expected_target is not None and status['target'] != expected_target:
+                not_reached.append(f"{name} (expected target: {expected_target}, actual: {status['target']})")
+                continue
+
+            if status['target'] == 0:
+                continue
+
+            target_range = bed_range if name == 'heater_bed' else extruder_range
+            if abs(status['temperature'] - status['target']) > target_range:
+                not_reached.append(name)
+
+        if not_reached:
+            raise gcmd.error("Heaters not reached target temperature: %s" % (not_reached,))
+
+    def cmd_EXTRUDER_OFFSET_ACTION_PROBE_CALIBRATE(self, gcmd):
+        self._verify_calibration_state("EXTRUDER_OFFSET_ACTION_PROBE")
+        try:
+            # with self.lock:
+            #     self.calibration_step = 'calibrating'
+            #     self.error_message = None
+            extruder = tool_id = None
+            tool_id = gcmd.get('TOOL_ID', None)
+            if tool_id == None:
+                raise gcmd.error('EXTRUDER_OFFSET_ACTION_PROBE_CALIBRATE: TOOL_ID is required')
+
+            extruder = self.extruder_mapping.get(tool_id, None)
+            if extruder is None:
+                supported_tools = list(self.extruder_mapping.keys())
+                raise gcmd.error(f'EXTRUDER_OFFSET_ACTION_PROBE: Unsupported TOOL_ID={tool_id}. Supported IDs: {supported_tools}')
+
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION={}_XYZ_OFFSET_PROBE".format(
+                                                extruder.upper()))
+
+            toolhead = self.printer.lookup_object('toolhead')
+            toolhead.wait_moves()
+            pos = toolhead.get_position()
+            safe_move_y_pos = gcmd.get_float('SAFE_MOVE_Y_POS', 250, minval=0.)
+            if pos[1] > safe_move_y_pos:
+                toolhead.manual_move([None, safe_move_y_pos, None], 200)
+
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_PROBE_CALIBRATE_{}'.format(tool_id), None)
+            if macro is not None:
+                with self.lock:
+                    self.calibration_step = '{}_calibrating'.format(extruder)
+
+                self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_PROBE_CALIBRATE_{}".format(tool_id))
+                if extruder in self.last_xyz_result and self.last_xyz_result[extruder] is None:
+                    with self.lock:
+                        self.calibration_step = '{}_calibration_incomplete'.format(extruder)
+                    return
+
+                with self.lock:
+                    completed = True
+                    for position in self.last_xyz_result.values():
+                        if position is None:
+                            completed = False
+                            break
+                    if completed:
+                        self.calibration_step = 'calibration_completed'
+                    else:
+                        self.calibration_step = '{}_calibration_done'.format(extruder)
+                if self.calibration_step == 'calibration_completed':
+                    self.gcode.run_script_from_command("EXTRUDER_OFFSET_ACTION_SAVE_RESULT FORCE_SAVE=0")
+        except Exception as e:
+            if extruder is not None:
+                with self.lock:
+                    self.calibration_step = 'calibration_err_{}'.format(extruder)
+            raise gcmd.error(str(e))
+        finally:
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+
+    def cmd_EXTRUDER_OFFSET_ACTION_SAVE_RESULT(self, gcmd):
+        try:
+            empty_extruders = []
+            force_save = not not gcmd.get_int('FORCE_SAVE', 0)
+            if not force_save:
+                for extruder, position in self.last_xyz_result.items():
+                    if position is None:
+                        empty_extruders.append(extruder)
+
+            if len(empty_extruders) != 0:
+                raise gcmd.error('{} calibration detection not completed'.format(empty_extruders))
+
+            need_save_cfg = False
+            configfile = self.printer.lookup_object('configfile')
+            extruder_list = self.printer.lookup_object('extruder_list', [])
+            extruder_bak = self.printer.lookup_object('extruder_config_bak', None)
+            for i in range(len(extruder_list)):
+                if extruder_list[i].name in self.last_xyz_result and self.last_xyz_result[extruder_list[i].name] is not None:
+                    extruder_list[i].base_position = self.last_xyz_result[extruder_list[i].name]
+                    gcmd.respond_info("{} base_position: {}".format(extruder_list[i].name, extruder_list[i].base_position))
+                    if extruder_bak is None or not os.path.exists(extruder_bak.base_position_config_path):
+                        need_save_cfg = True
+                        configfile.set(extruder_list[i].name, 'base_position',
+                        "\n%.6f, %.6f, %.6f\n" % (extruder_list[i].base_position[0], extruder_list[i].base_position[1], extruder_list[i].base_position[2]))
+                    else:
+                        extruder_bak.update_extruder_config(extruder_list[i].name, "base_position", extruder_list[i].base_position)
+            if need_save_cfg:
+                self.printer.lookup_object('gcode').run_script_from_command("SAVE_CONFIG RESTART=0")
+            self.printer.send_event("probe_inductance_coil: update_extruder_offset")
+            with self.lock:
+                self.calibration_step = 'save_result_completed'
+        except Exception as e:
+            # with self.lock:
+            #     self.calibration_step = 'calibration_save_result_err'
+            raise gcmd.error(str(e))
+        finally:
+            pass
+
+    def cmd_EXTRUDER_OFFSET_ACTION_EXIT(self, gcmd):
+        self._verify_calibration_state("EXTRUDER_OFFSET_ACTION_EXIT")
+        try:
+            # with self.lock:
+            #     self.calibration_step = 'exiting'
+            #     self._cleanup_resources()
+            macro = self.printer.lookup_object('gcode_macro _EXTRUDER_OFFSET_ACTION_EXIT', None)
+            if macro:
+                self.gcode.run_script_from_command("_EXTRUDER_OFFSET_ACTION_EXIT")
+            # with self.lock:
+            #     self.calibration_step = 'idle'
+            #     self._cleanup_resources()
+        except Exception as e:
+            # with self.lock:
+            #     self.calibration_step = 'error'
+            raise gcmd.error(str(e))
+        finally:
+            with self.lock:
+                self.calibration_step = 'idle'
+                self._cleanup_resources()
+            if (self.machine_state_manager and
+                str(self.machine_state_manager.get_status()['main_state']) == "XYZ_OFFSET_CALIBRATE"):
+                self.gcode.run_script_from_command("EXIT_TO_IDLE REQ_FROM_STATE=XYZ_OFFSET_CALIBRATE")
+
+class PrinterProbe:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.mcu_probe = inductance_coil.InductanceCoilEndstopWrapper(config)
+        self.cmd_helper = ProbeCommandHelper(config, self,
+                                             self.mcu_probe.query_endstop)
+        self.probe_offsets = ProbeOffsetsHelper(config)
+        self.probe_session = ProbeSessionHelper(config, self.mcu_probe)
+
+        if self.printer.lookup_object('extruder_offset_calibration', None) is None:
+            self.printer.add_object('extruder_offset_calibration', ExtruderOffsetCalibration(config))
+    def get_probe_params(self, gcmd=None):
+        return self.probe_session.get_probe_params(gcmd)
+    def get_offsets(self):
+        return self.probe_offsets.get_offsets()
+    def get_status(self, eventtime):
+        return self.cmd_helper.get_status(eventtime)
+    def start_probe_session(self, gcmd):
+        return self.probe_session.start_probe_session(gcmd)
+    def set_mcu_probe(self, new_probe):
+        self.mcu_probe = new_probe
+        self.cmd_helper.query_endstop = self.mcu_probe.query_endstop
+        self.probe_session.mcu_probe = self.mcu_probe
+        self.probe_session.homing_helper.mcu_probe = self.mcu_probe
+
+# def load_config_prefix(config):
+#     return PrinterProbe(config)
--- a/klippy/extras/pulse_counter.py
+++ b/klippy/extras/pulse_counter.py
@@ -77,3 +77,7 @@ class FrequencyCounter:
 
     def get_frequency(self):
         return self._freq
+
+    def get_count(self):
+        return self._last_count
+
--- /dev/null
+++ b/klippy/extras/purifier.py
@@ -0,0 +1,290 @@
+import logging, json, copy, os
+from . import fan
+from . import pulse_counter
+
+FAN_STATE_TURN_ON                                   = 0
+FAN_STATE_TURN_OFF                                  = 1
+FAN_STATE_TURNING_OFF                               = 2
+
+FAN_DELAY_TIME_MAX                                  = 600
+FAN_DELAY_TIME_MIN                                  = 1
+DEFAULT_FAN_DELAY_TIME                              = 180
+
+SAVE_PURIFIER_INFO_TIME                             = 360
+
+DEFAULT_POWER_DT_SAMPLE_TIME                        = 0.08
+DEFAULT_POWER_DT_SAMPLE_COUNT                       = 4
+DEFAULT_POWER_DT_REPORT_TIME                        = 0.350
+DEFAULT_POWER_DT_THRESHOLD                          = 0.88
+
+PURIFIER_CONFIG_FILE                                = "purifier_config.json"
+DEFAULT_PURIFIER_CONFIG_STRUCT = {
+    'work_time': 0,
+    'delay_time': DEFAULT_FAN_DELAY_TIME
+}
+
+class PurifierFanTachometer:
+    def __init__(self, printer, pin, ppr, sample_time, poll_time):
+        self._frequence = pulse_counter.FrequencyCounter(printer, pin, sample_time, poll_time)
+        self._ppr = ppr
+
+    def get_status(self, eventtime=None):
+        rpm = None
+        if self._frequence is not None:
+            rpm = self._frequence.get_frequency()  * 30. / self._ppr
+        return {'rpm': rpm}
+
+class Purifier:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        ppins = self.printer.lookup_object('pins')
+        self.reactor = self.printer.get_reactor()
+
+        config_dir = self.printer.get_snapmaker_config_dir()
+        config_name = PURIFIER_CONFIG_FILE
+        self._config_path = os.path.join(config_dir, config_name)
+        self._config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_PURIFIER_CONFIG_STRUCT)
+
+        # read config
+        tach_ppr = config.getint('tachometer_ppr', 2)
+        tach_poll_time = config.getfloat('tachometer_poll_interval', 0.001)
+        extra_fan_tach_pin = config.get('extra_fan_tach_pin')
+
+        # main fan
+        self._fan = fan.Fan(config, default_shutdown_speed=0.)
+        # extra fan
+        sample_time = 1.
+        self._extra_fan_tach = PurifierFanTachometer(self.printer, extra_fan_tach_pin,
+                                    tach_ppr, sample_time, tach_poll_time)
+
+        # power detect
+        power_det_pin = config.get('power_det_pin')
+        self._power_det_threshold = config.getfloat('power_det_threshold', DEFAULT_POWER_DT_THRESHOLD)
+        self._power_det_pin = ppins.setup_pin('adc', power_det_pin)
+        self._power_det_pin.setup_adc_sample(DEFAULT_POWER_DT_SAMPLE_TIME, DEFAULT_POWER_DT_SAMPLE_COUNT)
+        self._power_det_pin.setup_adc_callback(DEFAULT_POWER_DT_REPORT_TIME, self._adc_callback)
+        self._power_detected = False
+        self._power_det_value = 1
+
+        self._fan_state = FAN_STATE_TURN_OFF
+        self._work_time = self._config['work_time']
+        self._delay_time = self._config['delay_time']
+        self._work_time_last = 0
+
+        # timer
+        self._delay_turnoff_timer = self.reactor.register_timer(
+                self._delay_turnoff_handle)
+        self._save_config_timer = self.reactor.register_timer(
+                self._save_config_handle)
+
+        # gcode
+        gcode = self.printer.lookup_object("gcode")
+        gcode.register_command('SET_PURIFIER', self.cmd_SET_PURIFIER)
+        gcode.register_command('GET_PURIFIER', self.cmd_GET_PURIFIER)
+
+        wh = self.printer.lookup_object('webhooks')
+        wh.register_endpoint("control/purifier", self._handle_control_purifier)
+
+        self.printer.register_event_handler("klippy:ready", self._ready)
+
+    def _ready(self):
+         self.reactor.update_timer(self._save_config_timer, self.reactor.NOW)
+
+    def _adc_callback(self, read_time, read_value):
+        self._power_det_value = read_value
+        if (self._power_det_value < self._power_det_threshold):
+            self._power_detected = True
+        else:
+            if self._power_detected:
+                self.fan_turn_off(0)
+            self._power_detected = False
+
+    def fan_turn_on(self, speed):
+        if not self._power_detected:
+            logging.error("Purifier not exist!")
+            return
+
+        if speed > 100:
+            speed = 100
+        if speed < 0:
+            speed = 0
+
+        if self._fan_state == FAN_STATE_TURN_ON:
+            self._fan.set_speed_from_command(speed / 100.0)
+            return
+        elif self._fan_state == FAN_STATE_TURNING_OFF:
+            self.reactor.update_timer(self._delay_turnoff_timer,
+                    self.reactor.NEVER)
+            self._fan.set_speed_from_command(speed / 100.0)
+        else:
+            self._fan.set_speed_from_command(speed / 100.0)
+            self._work_time_last = self.reactor.monotonic()
+
+        self._fan_state = FAN_STATE_TURN_ON
+
+    def fan_turn_off(self, delay_time):
+        if delay_time < FAN_DELAY_TIME_MIN:
+            self._fan.set_speed_from_command(0)
+            if self._fan_state != FAN_STATE_TURN_OFF:
+                self.reactor.update_timer(self._delay_turnoff_timer, self.reactor.NEVER)
+                work_time_tmp = self.reactor.monotonic()
+                if work_time_tmp > self._work_time_last:
+                    self._work_time += work_time_tmp - self._work_time_last
+
+                load_config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                load_config['work_time'] = self._work_time
+                ret = self.printer.update_snapmaker_config_file(self._config_path, load_config, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                if not ret:
+                    logging.error("save purifier failed!")
+
+                self._fan_state = FAN_STATE_TURN_OFF
+        else:
+            self._fan_state = FAN_STATE_TURNING_OFF
+            self.reactor.update_timer(self._delay_turnoff_timer, self.reactor.monotonic() + delay_time)
+
+    def _delay_turnoff_handle(self, eventtime):
+        self._fan.set_speed_from_command(0)
+
+        if self._fan_state != FAN_STATE_TURN_OFF:
+            work_time_tmp = self.reactor.monotonic()
+            if work_time_tmp > self._work_time_last:
+                self._work_time += work_time_tmp - self._work_time_last
+
+                load_config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                load_config['work_time'] = self._work_time
+                ret = self.printer.update_snapmaker_config_file(self._config_path, load_config, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                if not ret:
+                    logging.error("save purifier failed!")
+
+            self._fan_state = FAN_STATE_TURN_OFF
+        return self.reactor.NEVER
+
+    def get_fan_speed(self):
+        return self._fan.last_fan_value
+
+    def _save_config_handle(self, eventtime):
+        if self._fan_state != FAN_STATE_TURN_OFF:
+            work_time_tmp = self.reactor.monotonic()
+            if work_time_tmp > self._work_time_last:
+                self._work_time += work_time_tmp - self._work_time_last
+                self._work_time_last = work_time_tmp
+
+                load_config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                load_config['work_time'] = self._work_time
+                ret = self.printer.update_snapmaker_config_file(self._config_path, load_config, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                if not ret:
+                    logging.error("save purifier failed!")
+
+        return self.reactor.monotonic() + SAVE_PURIFIER_INFO_TIME
+
+    def get_status(self, eventtime):
+        fan_status = self._fan.get_status(eventtime)
+        extra_fan_status = self._extra_fan_tach.get_status(eventtime)
+
+        return {
+            'power_detected': self._power_detected,
+            'power_det_value': self._power_det_value * 3.3,
+            'work_time': int(self._work_time),
+            'fan_state': self._fan_state,
+            'fan_speed': fan_status['speed'],
+            'fan_rpm': fan_status['rpm'],
+            'extra_fan_speed': fan_status['speed'],
+            'extra_fan_rpm': extra_fan_status['rpm'],
+            'delay_time': self._delay_time
+        }
+
+    def cmd_SET_PURIFIER(self, gcmd):
+        fan_speed = gcmd.get_int('FAN_SPEED', None, minval= 0, maxval=100)
+        delay_time = gcmd.get_int('DELAY_TIME', None, minval=0,  maxval=FAN_DELAY_TIME_MAX)
+        work_time = gcmd.get_int('WORK_TIME', None, minval= 0)
+        save = 0
+
+        if work_time is not None:
+            self._work_time = work_time
+            save = 1
+
+        if delay_time is not None:
+            self._delay_time = delay_time
+            save = 1
+
+        if fan_speed is not None:
+            if fan_speed > 0:
+                self.fan_turn_on(fan_speed)
+            else:
+                self.fan_turn_off(self._delay_time)
+
+        if save:
+            load_config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_PURIFIER_CONFIG_STRUCT)
+            load_config['work_time'] = self._work_time
+            load_config['delay_time'] = self._delay_time
+            ret = self.printer.update_snapmaker_config_file(self._config_path, load_config, DEFAULT_PURIFIER_CONFIG_STRUCT)
+            if not ret:
+                gcmd.respond_info("save purifier failed!")
+
+    def cmd_GET_PURIFIER(self, gcmd):
+        eventtime = self.reactor.monotonic()
+        fan_status = self._fan.get_status(eventtime)
+        extra_fan_status = self._extra_fan_tach.get_status(eventtime)
+        msg = ("power_detected = %d\r\n"
+               "power_det_value = %f\r\n"
+               "work_time = %d\r\n"
+               "fan_state = %d\r\n"
+               "fan_speed = %f\r\n"
+               "fan_rpm = %d\r\n"
+               "extra_fan_speed = %f\r\n"
+               "extra_fan_rpm = %d\r\n"
+               "delay_time = %d\r\n"
+               % (self._power_detected,
+                  self._power_det_value * 3.3,
+                  int(self._work_time),
+                  self._fan_state,
+                  fan_status['speed'],
+                  fan_status['rpm'],
+                  fan_status['speed'],
+                  extra_fan_status['rpm'],
+                  self._delay_time))
+        gcmd.respond_info(msg, log=False)
+
+    def _handle_control_purifier(self, web_request):
+        try:
+            fan_speed = web_request.get_int('fan_speed', None)
+            delay_time = web_request.get_int('delay_time', None)
+            work_time = web_request.get_int('work_time', None)
+            save = 0
+
+            if delay_time is not None:
+                if delay_time > FAN_DELAY_TIME_MAX:
+                    delay_time = FAN_DELAY_TIME_MAX
+                if delay_time < 0:
+                    delay_time = 0
+                self._delay_time = delay_time
+                save = 1
+
+            if work_time is not None:
+                if work_time < 0:
+                    work_time = 0
+                self._work_time = work_time
+                save = 1
+
+            if fan_speed is not None:
+                if fan_speed > 0:
+                    self.fan_turn_on(fan_speed)
+                else:
+                    self.fan_turn_off(self._delay_time)
+
+            if save:
+                load_config = self.printer.load_snapmaker_config_file(self._config_path, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                load_config['work_time'] = self._work_time
+                load_config['delay_time'] = self._delay_time
+                ret = self.printer.update_snapmaker_config_file(self._config_path, load_config, DEFAULT_PURIFIER_CONFIG_STRUCT)
+                if not ret:
+                    logging.info("save purifier failed!")
+
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to set purifier: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
+
+def load_config(config):
+    return Purifier(config)
+
--- a/klippy/extras/resonance_tester.py
+++ b/klippy/extras/resonance_tester.py
@@ -6,6 +6,11 @@
 import logging, math, os, time
 from . import shaper_calibrate
 
+STATE_IDLE                              = 'idle'
+STATE_SHAPER_CALIBRATING                = 'shaper_calibrating'
+STATE_COMPLETED                         = 'completed'
+STATE_FAILED                            = 'failed'
+
 class TestAxis:
     def __init__(self, axis=None, vib_dir=None):
         if axis is None:
@@ -122,6 +127,7 @@ class ResonanceTester:
         self.printer = config.get_printer()
         self.move_speed = config.getfloat('move_speed', 50., above=0.)
         self.test = VibrationPulseTest(config)
+        self.state = STATE_IDLE
         if not config.get('accel_chip_x', None):
             self.accel_chip_names = [('xy', config.get('accel_chip').strip())]
         else:
@@ -131,6 +137,16 @@ class ResonanceTester:
             if self.accel_chip_names[0][1] == self.accel_chip_names[1][1]:
                 self.accel_chip_names = [('xy', self.accel_chip_names[0][1])]
         self.max_smoothing = config.getfloat('max_smoothing', None, minval=0.05)
+        self.delta_freq = config.getfloat('delta_freq', 10., minval=5.)
+        self.log_path = config.get('log_path', None)
+        debug = config.getint('debug', 0)
+        start_args = self.printer.get_start_args()
+        factory_mode = start_args.get('factory_mode', False)
+        if debug or factory_mode:
+            self.debug = True
+        else:
+            self.debug = False
+        self.fixed_shaper = config.get('fixed_shaper', 'mzv')
 
         self.gcode = self.printer.lookup_object('gcode')
         self.gcode.register_command("MEASURE_AXES_NOISE",
@@ -142,6 +158,9 @@ class ResonanceTester:
         self.gcode.register_command("SHAPER_CALIBRATE",
                                     self.cmd_SHAPER_CALIBRATE,
                                     desc=self.cmd_SHAPER_CALIBRATE_help)
+        self.gcode.register_command("SM_FAST_SHAPER_CALIBRATE",
+                                    self.cmd_SM_FAST_SHAPER_CALIBRATE,
+                                    desc=self.cmd_SM_FAST_SHAPER_CALIBRATE_help)
         self.printer.register_event_handler("klippy:connect", self.connect)
 
     def connect(self):
@@ -221,6 +240,12 @@ class ResonanceTester:
         return parsed_chips
     def _get_max_calibration_freq(self):
         return 1.5 * self.test.get_max_freq()
+
+    def check_homed(self):
+        curtime = self.printer.get_reactor().monotonic()
+        homed_axes_list = self.printer.lookup_object('toolhead').get_status(curtime)['homed_axes']
+        return ('x' in homed_axes_list and 'y' in homed_axes_list and 'z' in homed_axes_list)
+
     cmd_TEST_RESONANCES_help = ("Runs the resonance test for a specifed axis")
     def cmd_TEST_RESONANCES(self, gcmd):
         # Parse parameters
@@ -270,67 +295,187 @@ class ResonanceTester:
                     point=test_point, max_freq=self._get_max_calibration_freq())
             gcmd.respond_info(
                     "Resonances data written to %s file" % (csv_name,))
+            if self.debug:
+                from multiprocessing import Process
+                # get current file path:
+                script = os.path.join(os.path.dirname(os.path.realpath(__file__)), \
+                                                 '..', '..', 'scripts', 'calibrate_shaper.py')
+                p = Process(target=lambda: os.system(
+                    f'python3 {script} -o {os.path.join(self.log_path, f"calibration_data_{axis.get_name()}_{name_suffix}.png")} {csv_name}'))
+                p.daemon = True
+                p.start()
+
     cmd_SHAPER_CALIBRATE_help = (
         "Simular to TEST_RESONANCES but suggest input shaper config")
     def cmd_SHAPER_CALIBRATE(self, gcmd):
-        # Parse parameters
-        axis = gcmd.get("AXIS", None)
-        if not axis:
-            calibrate_axes = [TestAxis('x'), TestAxis('y')]
-        elif axis.lower() not in 'xy':
-            raise gcmd.error("Unsupported axis '%s'" % (axis,))
-        else:
-            calibrate_axes = [TestAxis(axis.lower())]
-        chips_str = gcmd.get("CHIPS", None)
-        accel_chips = self._parse_chips(chips_str) if chips_str else None
+        machine_state_manager = self.printer.lookup_object('machine_state_manager', None)
+        self.state = STATE_IDLE
+        try:
+            if machine_state_manager is not None:
+                cur_sta = machine_state_manager.get_status()
+                if str(cur_sta["main_state"]) != "PRINTING":
+                    self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=SHAPER_CALIBRATE")
+            # Parse parameters
+            axis = gcmd.get("AXIS", None)
+            if not axis:
+                calibrate_axes = [TestAxis('x'), TestAxis('y')]
+            elif axis.lower() not in 'xy':
+                # self.state = STATE_FAILED
+                raise gcmd.error("Unsupported axis '%s'" % (axis,))
+            else:
+                calibrate_axes = [TestAxis(axis.lower())]
 
-        max_smoothing = gcmd.get_float(
-                "MAX_SMOOTHING", self.max_smoothing, minval=0.05)
+            self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=SHAPER_CALIBRATING")
+            self.state = STATE_SHAPER_CALIBRATING
+            if not self.check_homed():
+                self.gcode.run_script_from_command("G28\r\n")
 
-        name_suffix = gcmd.get("NAME", time.strftime("%Y%m%d_%H%M%S"))
-        if not self.is_valid_name_suffix(name_suffix):
-            raise gcmd.error("Invalid NAME parameter")
+            self.gcode.run_script_from_command("T0 A0\r\n")
+
+            chips_str = gcmd.get("CHIPS", None)
+            accel_chips = self._parse_chips(chips_str) if chips_str else None
+
+            shaper_types = None
+            shaper_types_str = gcmd.get('SHAPER_TYPES', None)
+            if shaper_types_str is not None:
+                shaper_types = [item.lower() for item in shaper_types_str.split(',')]
+                if shaper_calibrate is not None:
+                    types_length = len(shaper_types)
+                    for i in range(types_length):
+                        if shaper_types[i] not in shaper_calibrate.AUTOTUNE_SHAPERS:
+                            del shaper_types[i]
+
+            max_smoothing = gcmd.get_float(
+                    "MAX_SMOOTHING", self.max_smoothing, minval=0.05)
+
+            name_suffix = gcmd.get("NAME", time.strftime("%Y%m%d_%H%M%S"))
+            if not self.is_valid_name_suffix(name_suffix):
+                # self.state = STATE_FAILED
+                raise gcmd.error("Invalid NAME parameter")
+
+            input_shaper = self.printer.lookup_object('input_shaper', None)
 
+            # Setup shaper calibration
+            helper = shaper_calibrate.ShaperCalibrate(self.printer)
+
+            calibration_data = self._run_test(gcmd, calibrate_axes, helper,
+                                            accel_chips=accel_chips)
+
+            configfile = self.printer.lookup_object('configfile')
+            for axis in calibrate_axes:
+                axis_name = axis.get_name()
+                gcmd.respond_info(
+                        "Calculating the best input shaper parameters for %s axis"
+                        % (axis_name,))
+                calibration_data[axis].normalize_to_frequencies()
+                systime = self.printer.get_reactor().monotonic()
+                toolhead = self.printer.lookup_object('toolhead')
+                toolhead_info = toolhead.get_status(systime)
+                scv = toolhead_info['square_corner_velocity']
+                max_freq = self._get_max_calibration_freq()
+                best_shaper = None
+                all_shapers = None
+                select_freq = None
+                select_type = None
+                if shaper_types is None or len(shaper_types) == 0:
+                    best_shaper, all_shapers = helper.find_best_shaper(
+                            calibration_data[axis], max_smoothing=max_smoothing,
+                            scv=scv, max_freq=max_freq, logger=gcmd.respond_info)
+                else:
+                    best_shaper, all_shapers = helper.find_best_shaper(
+                            calibration_data[axis], shapers=shaper_types, max_smoothing=max_smoothing,
+                            scv=scv, max_freq=max_freq, logger=gcmd.respond_info)
+                gcmd.respond_info(
+                        "Recommended shaper_type_%s = %s, shaper_freq_%s = %.1f Hz"
+                        % (axis_name, best_shaper.name,
+                        axis_name, best_shaper.freq))
+                # choose fixed shaper
+                for sp in all_shapers:
+                    if sp.name == self.fixed_shaper:
+                        best_shaper = sp
+                        break
+                select_type = best_shaper.name
+                select_freq = best_shaper.freq
+                if self.fixed_shaper == select_type and input_shaper is not None:
+                    if axis_name == 'x':
+                        if best_shaper.freq < input_shaper.shaper_freq_x_min or best_shaper.freq > input_shaper.shaper_freq_x_max:
+                            gcmd.respond_info("Input shaper x frequency out of range, using default: %f Hz" % (input_shaper.shaper_freq_x_default))
+                            select_freq = input_shaper.shaper_freq_x_default
+                    elif axis_name == 'y':
+                        if best_shaper.freq < input_shaper.shaper_freq_y_min or best_shaper.freq > input_shaper.shaper_freq_y_max:
+                            gcmd.respond_info("Input shaper y frequency out of range, using default: %f Hz" % (input_shaper.shaper_freq_y_default))
+                            select_freq = input_shaper.shaper_freq_y_default
+                gcmd.respond_info(
+                        "Selected shaper_type_%s = %s, shaper_freq_%s = %.1f Hz"
+                        % (axis_name, select_type, axis_name, select_freq))
+                if input_shaper is not None:
+                    helper.apply_params(input_shaper, axis_name, select_type, select_freq)
+                # helper.save_params(configfile, axis_name,
+                #                 best_shaper.name, best_shaper.freq)
+                csv_name = self.save_calibration_data(
+                        'calibration_data', name_suffix, helper, axis,
+                        calibration_data[axis], all_shapers, max_freq=max_freq)
+                gcmd.respond_info(
+                        "Shaper calibration data written to %s file" % (csv_name,))
+                if self.debug:
+                    from multiprocessing import Process
+                    # get current file path:
+                    script = os.path.join(os.path.dirname(os.path.realpath(__file__)), \
+                                                    '..', '..', 'scripts', 'calibrate_shaper.py')
+                    if max_smoothing is not None:
+                        script += f" --max_smoothing {max_smoothing}"
+                    script += f" --scv {scv} -f {max_freq}"
+                    p = Process(target=lambda: os.system(
+                        f'python3 {script} -o {os.path.join(self.log_path, f"calibration_data_{axis.get_name()}_{name_suffix}.png")} {csv_name}'))
+                    p.daemon = True
+                    p.start()
+
+            # gcmd.respond_info(
+            #     "The SAVE_CONFIG command will update the printer config file\n"
+            #     "with these parameters and restart the printer.")
+
+            self.state = STATE_COMPLETED
+        except Exception as e:
+            self.state = STATE_FAILED
+            raise
+        finally:
+            if machine_state_manager is not None:
+                cur_sta = machine_state_manager.get_status()
+                if str(cur_sta["main_state"]) == "PRINTING":
+                    self.gcode.run_script_from_command("SET_ACTION_CODE ACTION=IDLE")
+                elif str(cur_sta["main_state"]) == "SHAPER_CALIBRATE":
+                    self.gcode.run_script_from_command("EXIT_TO_IDLE REQ_FROM_STATE=SHAPER_CALIBRATE")
+
+    # not used yet
+    cmd_SM_FAST_SHAPER_CALIBRATE_help = ("SM CMD: fastly SHAPER_CALIBRATE")
+    def cmd_SM_FAST_SHAPER_CALIBRATE(self, gcmd):
+        gcode = self.printer.lookup_object('gcode')
         input_shaper = self.printer.lookup_object('input_shaper', None)
+        if input_shaper is None:
+            return
 
-        # Setup shaper calibration
-        helper = shaper_calibrate.ShaperCalibrate(self.printer)
+        # axis X
+        freq_start = input_shaper.shapers[0].params.shaper_freq - abs(self.delta_freq)
+        if (freq_start < self.test.min_freq):
+            freq_start = self.test.min_freq
+        freq_end = input_shaper.shapers[0].params.shaper_freq + abs(self.delta_freq)
+        if (freq_end > self.test.max_freq):
+            freq_end = self.test.max_freq
+        shaper_type = input_shaper.shapers[0].params.shaper_type
+        command = "SHAPER_CALIBRATE AXIS=x SHAPER_TYPES=%s FREQ_START=%d FREQ_END=%d" % (shaper_type, freq_start, freq_end)
+        gcode.run_script_from_command(command)
 
-        calibration_data = self._run_test(gcmd, calibrate_axes, helper,
-                                          accel_chips=accel_chips)
+        # axis Y
+        freq_start = input_shaper.shapers[1].params.shaper_freq - abs(self.delta_freq)
+        if (freq_start < self.test.min_freq):
+            freq_start = self.test.min_freq
+        freq_end = input_shaper.shapers[1].params.shaper_freq + abs(self.delta_freq)
+        if (freq_end > self.test.max_freq):
+            freq_end = self.test.max_freq
+        shaper_type = input_shaper.shapers[1].params.shaper_type
+        command = "SHAPER_CALIBRATE AXIS=y SHAPER_TYPES=%s FREQ_START=%d FREQ_END=%d" % (shaper_type, freq_start, freq_end)
+        gcode.run_script_from_command(command)
 
-        configfile = self.printer.lookup_object('configfile')
-        for axis in calibrate_axes:
-            axis_name = axis.get_name()
-            gcmd.respond_info(
-                    "Calculating the best input shaper parameters for %s axis"
-                    % (axis_name,))
-            calibration_data[axis].normalize_to_frequencies()
-            systime = self.printer.get_reactor().monotonic()
-            toolhead = self.printer.lookup_object('toolhead')
-            toolhead_info = toolhead.get_status(systime)
-            scv = toolhead_info['square_corner_velocity']
-            max_freq = self._get_max_calibration_freq()
-            best_shaper, all_shapers = helper.find_best_shaper(
-                    calibration_data[axis], max_smoothing=max_smoothing,
-                    scv=scv, max_freq=max_freq, logger=gcmd.respond_info)
-            gcmd.respond_info(
-                    "Recommended shaper_type_%s = %s, shaper_freq_%s = %.1f Hz"
-                    % (axis_name, best_shaper.name,
-                       axis_name, best_shaper.freq))
-            if input_shaper is not None:
-                helper.apply_params(input_shaper, axis_name,
-                                    best_shaper.name, best_shaper.freq)
-            helper.save_params(configfile, axis_name,
-                               best_shaper.name, best_shaper.freq)
-            csv_name = self.save_calibration_data(
-                    'calibration_data', name_suffix, helper, axis,
-                    calibration_data[axis], all_shapers, max_freq=max_freq)
-            gcmd.respond_info(
-                    "Shaper calibration data written to %s file" % (csv_name,))
-        gcmd.respond_info(
-            "The SAVE_CONFIG command will update the printer config file\n"
-            "with these parameters and restart the printer.")
     cmd_MEASURE_AXES_NOISE_help = (
         "Measures noise of all enabled accelerometer chips")
     def cmd_MEASURE_AXES_NOISE(self, gcmd):
@@ -367,6 +512,10 @@ class ResonanceTester:
         if point:
             name += "_%.3f_%.3f_%.3f" % (point[0], point[1], point[2])
         name += '_' + name_suffix
+        if self.log_path:
+            if not os.path.exists(self.log_path):
+                os.makedirs(self.log_path)
+            return os.path.join(self.log_path, name + ".csv")
         return os.path.join("/tmp", name + ".csv")
 
     def save_calibration_data(self, base_name, name_suffix, shaper_calibrate,
@@ -375,7 +524,22 @@ class ResonanceTester:
         output = self.get_filename(base_name, name_suffix, axis, point)
         shaper_calibrate.save_calibration_data(output, calibration_data,
                                                all_shapers, max_freq)
+        if self.debug:
+            if self.log_path:
+                if not os.path.exists(self.log_path):
+                    os.makedirs(self.log_path)
+                all_shapers_log = os.path.join(self.log_path, f"shaper_type_{axis.get_name()}_{name_suffix}.csv")
+            else:
+                all_shapers_log = os.path.join("/tmp", f"shaper_type_{axis.get_name()}_{name_suffix}.csv")
+            with open(all_shapers_log, 'w') as f:
+                f.write("shaper_type,shaper_freq(Hz),max_accel(mm/s^2), score\n")
+                for shaper in all_shapers:
+                    f.write(f"{shaper.name}, {shaper.freq:.1f}, {shaper.max_accel:.0f}, {shaper.score:.6f}\n")
         return output
 
+    def get_status(self, eventtime=None):
+        return {
+            'state': self.state}
+
 def load_config(config):
     return ResonanceTester(config)
--- /dev/null
+++ b/klippy/extras/setup.py
@@ -0,0 +1,13 @@
+from setuptools import setup
+from Cython.Build import cythonize
+
+# for local test
+# import numpy as np
+# include_dirs=[np.get_include()]
+include_dirs=[]
+
+setup(
+    ext_modules=cythonize("flow_calculator.pyx"),
+    include_dirs=include_dirs,
+    zip_safe=False,
+)
--- a/klippy/extras/shaper_calibrate.py
+++ b/klippy/extras/shaper_calibrate.py
@@ -13,7 +13,7 @@ MAX_SHAPER_FREQ = 150.
 
 TEST_DAMPING_RATIOS=[0.075, 0.1, 0.15]
 
-AUTOTUNE_SHAPERS = ['zv', 'mzv', 'ei', '2hump_ei', '3hump_ei']
+AUTOTUNE_SHAPERS = ['zv', 'zvd', 'mzv', 'ei', '2hump_ei', '3hump_ei']
 
 ######################################################################
 # Frequency response calculation and shaper auto-tuning
@@ -332,9 +332,9 @@ class ShaperCalibrate:
                 scv, max_smoothing, test_damping_ratios, max_freq))
             if logger is not None:
                 logger("Fitted shaper '%s' frequency = %.1f Hz "
-                       "(vibrations = %.1f%%, smoothing ~= %.3f)" % (
+                       "(vibrations = %.1f%%, smoothing ~= %.3f, score = %.6f)" % (
                            shaper.name, shaper.freq, shaper.vibrs * 100.,
-                           shaper.smoothing))
+                           shaper.smoothing, shaper.score))
                 logger("To avoid too much smoothing with '%s', suggested "
                        "max_accel <= %.0f mm/sec^2" % (
                            shaper.name, round(shaper.max_accel / 100.) * 100.))
@@ -347,14 +347,14 @@ class ShaperCalibrate:
                 best_shaper = shaper
         return best_shaper, all_shapers
 
-    def save_params(self, configfile, axis, shaper_name, shaper_freq):
-        if axis == 'xy':
-            self.save_params(configfile, 'x', shaper_name, shaper_freq)
-            self.save_params(configfile, 'y', shaper_name, shaper_freq)
-        else:
-            configfile.set('input_shaper', 'shaper_type_'+axis, shaper_name)
-            configfile.set('input_shaper', 'shaper_freq_'+axis,
-                           '%.1f' % (shaper_freq,))
+    # def save_params(self, configfile, axis, shaper_name, shaper_freq):
+    #     if axis == 'xy':
+    #         self.save_params(configfile, 'x', shaper_name, shaper_freq)
+    #         self.save_params(configfile, 'y', shaper_name, shaper_freq)
+    #     else:
+    #         configfile.set('input_shaper', 'shaper_type_'+axis, shaper_name)
+    #         configfile.set('input_shaper', 'shaper_freq_'+axis,
+    #                        '%.1f' % (shaper_freq,))
 
     def apply_params(self, input_shaper, axis, shaper_name, shaper_freq):
         if axis == 'xy':
--- a/klippy/extras/statistics.py
+++ b/klippy/extras/statistics.py
@@ -56,17 +56,40 @@ class PrinterStats:
         self.stats_timer = reactor.register_timer(self.generate_stats)
         self.stats_cb = []
         self.printer.register_event_handler("klippy:ready", self.handle_ready)
+        self.printer.register_event_handler("klippy:shutdown", self.handle_shutdown)
+        self.shutdown_log_cnt = 50
+        self.printer_is_ready = False
+        self.stats_record_counter = 0
+        self.stats_record_threshold = 2
+        if config.has_section('printer'):
+            printer_config = config.getsection('printer')
+            self.stats_record_threshold = printer_config.getint(
+                'stats_record_threshold', self.stats_record_threshold, minval=0)
     def handle_ready(self):
+        self.shutdown_log_cnt = 50
+        self.printer_is_ready = True
         self.stats_cb = [o.stats for n, o in self.printer.lookup_objects()
                          if hasattr(o, 'stats')]
         if self.printer.get_start_args().get('debugoutput') is None:
             reactor = self.printer.get_reactor()
             reactor.update_timer(self.stats_timer, reactor.NOW)
+    def handle_shutdown(self):
+        self.printer_is_ready = False
     def generate_stats(self, eventtime):
+        if not self.printer_is_ready:
+            if self.shutdown_log_cnt > 0:
+                logging.info("Printer is shutdown, final stats")
+                self.shutdown_log_cnt -= 1
+            else:
+                return eventtime + 1.
         stats = [cb(eventtime) for cb in self.stats_cb]
         if max([s[0] for s in stats]):
-            logging.info("Stats %.1f: %s", eventtime,
-                         ' '.join([s[1] for s in stats]))
+            if self.stats_record_threshold > 0:
+                self.stats_record_counter += 1
+                if self.stats_record_counter >= self.stats_record_threshold:
+                    logging.info("Stats %.1f: %s", eventtime,
+                                ' '.join([s[1] for s in stats]))
+                    self.stats_record_counter = 0
         return eventtime + 1.
 
 def load_config(config):
--- a/klippy/extras/temperature_sensor.py
+++ b/klippy/extras/temperature_sensor.py
@@ -33,9 +33,9 @@ class PrinterSensorGeneric:
         return False, '%s: temp=%.1f' % (self.name, self.last_temp)
     def get_status(self, eventtime):
         return {
-            'temperature': round(self.last_temp, 2),
-            'measured_min_temp': round(self.measured_min, 2),
-            'measured_max_temp': round(self.measured_max, 2)
+            'temperature': round(self.last_temp, 0),
+            'measured_min_temp': round(self.measured_min, 0),
+            'measured_max_temp': round(self.measured_max, 0)
         }
 
 def load_config_prefix(config):
--- a/klippy/extras/temperature_sensors.cfg
+++ b/klippy/extras/temperature_sensors.cfg
@@ -38,6 +38,712 @@
 # Load "temperature_combined" sensor
 [temperature_combined]
 
+########################################
+# Default adc_temperature
+########################################
+[adc_temperature NTC_100K_3950_PRECISE]
+temperature1: -50
+resistance1: 6733216
+temperature2: -49
+resistance2: 6263283
+temperature3: -48
+resistance3: 5829894
+temperature4: -47
+resistance4: 5429936
+temperature5: -46
+resistance5: 5060582
+temperature6: -45
+resistance6: 4719266
+temperature7: -44
+resistance7: 4403653
+temperature8: -43
+resistance8: 4111620
+temperature9: -42
+resistance9: 3841233
+temperature10: -41
+resistance10: 3590732
+temperature11: -40
+resistance11: 3358508
+temperature12: -39
+resistance12: 3140789
+temperature13: -38
+resistance13: 2938858
+temperature14: -37
+resistance14: 2751458
+temperature15: -36
+resistance15: 2577440
+temperature16: -35
+resistance16: 2415752
+temperature17: -34
+resistance17: 2265435
+temperature18: -33
+resistance18: 2125608
+temperature19: -32
+resistance19: 1995465
+temperature20: -31
+resistance20: 1874269
+temperature21: -30
+resistance21: 1733200
+temperature22: -29
+resistance22: 1630408
+temperature23: -28
+resistance23: 1534477
+temperature24: -27
+resistance24: 1444903
+temperature25: -26
+resistance25: 1361220
+temperature26: -25
+resistance26: 1283000
+temperature27: -24
+resistance27: 1209327
+temperature28: -23
+resistance28: 1140424
+temperature29: -22
+resistance29: 1075949
+temperature30: -21
+resistance30: 1015588
+temperature31: -20
+resistance31: 959050
+temperature32: -19
+resistance32: 906011.7
+temperature33: -18
+resistance33: 856288.3
+temperature34: -17
+resistance34: 809650.6
+temperature35: -16
+resistance35: 765886.5
+temperature36: -15
+resistance36: 724800
+temperature37: -14
+resistance37: 685650.7
+temperature38: -13
+resistance38: 648892.9
+temperature39: -12
+resistance39: 614364.9
+temperature40: -11
+resistance40: 581916.9
+temperature41: -10
+resistance41: 551410
+temperature42: -9
+resistance42: 522690.8
+temperature43: -8
+resistance43: 495667.4
+temperature44: -7
+resistance44: 470228.6
+temperature45: -6
+resistance45: 446271.4
+temperature46: -5
+resistance46: 423700
+temperature47: -4
+resistance47: 402056
+temperature48: -3
+resistance48: 381665.8
+temperature49: -2
+resistance49: 362448.8
+temperature50: -1
+resistance50: 344330.1
+temperature51: 0
+resistance51: 327240
+temperature52: 1
+resistance52: 311039.7
+temperature53: 2
+resistance53: 295750.6
+temperature54: 3
+resistance54: 281315.7
+temperature55: 4
+resistance55: 267682
+temperature56: 5
+resistance56: 254800
+temperature57: 6
+resistance57: 242582.7
+temperature58: 7
+resistance58: 231032.1
+temperature59: 8
+resistance59: 220108
+temperature60: 9
+resistance60: 209772.4
+temperature61: 10
+resistance61: 199990
+temperature62: 11
+resistance62: 190557.8
+temperature63: 12
+resistance63: 181631.9
+temperature64: 13
+resistance64: 173182.2
+temperature65: 14
+resistance65: 165180.4
+temperature66: 15
+resistance66: 157600
+temperature67: 16
+resistance67: 150425.3
+temperature68: 17
+resistance68: 143623.4
+temperature69: 18
+resistance69: 137172.6
+temperature70: 19
+resistance70: 131052.8
+temperature71: 20
+resistance71: 125245
+temperature72: 21
+resistance72: 119658.2
+temperature73: 22
+resistance73: 114355.9
+temperature74: 23
+resistance74: 109322.1
+temperature75: 24
+resistance75: 104541.5
+temperature76: 25
+resistance76: 100000
+temperature77: 26
+resistance77: 95819.1
+temperature78: 27
+resistance78: 91839.2
+temperature79: 28
+resistance79: 88049.4
+temperature80: 29
+resistance80: 84439.5
+temperature81: 30
+resistance81: 81000
+temperature82: 31
+resistance82: 77623.8
+temperature83: 32
+resistance83: 74409.1
+temperature84: 33
+resistance84: 71347.2
+temperature85: 34
+resistance85: 68430.1
+temperature86: 35
+resistance86: 65650
+temperature87: 36
+resistance87: 62983.8
+temperature88: 37
+resistance88: 60442
+temperature89: 38
+resistance89: 58018.1
+temperature90: 39
+resistance90: 55706
+temperature91: 40
+resistance91: 53500
+temperature92: 41
+resistance92: 51370.8
+temperature93: 42
+resistance93: 49339.1
+temperature94: 43
+resistance94: 47399.8
+temperature95: 44
+resistance95: 45548.3
+temperature96: 45
+resistance96: 43780
+temperature97: 46
+resistance97: 42055.5
+temperature98: 47
+resistance98: 40409.2
+temperature99: 48
+resistance99: 38836.9
+temperature100: 49
+resistance100: 37335
+temperature101: 50
+resistance101: 35899.9
+temperature102: 51
+resistance102: 34616
+temperature103: 52
+resistance103: 33385.5
+temperature104: 53
+resistance104: 32205.9
+temperature105: 54
+resistance105: 31074.8
+temperature106: 55
+resistance106: 29990
+temperature107: 56
+resistance107: 28905.3
+temperature108: 57
+resistance108: 27866
+temperature109: 58
+resistance109: 26870
+temperature110: 59
+resistance110: 25915.3
+temperature111: 60
+resistance111: 25000
+temperature112: 61
+resistance112: 24109.9
+temperature113: 62
+resistance113: 23256.5
+temperature114: 63
+resistance114: 22438.1
+temperature115: 64
+resistance115: 21653.1
+temperature116: 65
+resistance116: 20900
+temperature117: 66
+resistance117: 20174.1
+temperature118: 67
+resistance118: 19477.4
+temperature119: 68
+resistance119: 18808.7
+temperature120: 69
+resistance120: 18166.6
+temperature121: 70
+resistance121: 17550
+temperature122: 71
+resistance122: 16945.9
+temperature123: 72
+resistance123: 16365.9
+temperature124: 73
+resistance124: 15808.9
+temperature125: 74
+resistance125: 15273.9
+temperature126: 75
+resistance126: 14760
+temperature127: 76
+resistance127: 14281.3
+temperature128: 77
+resistance128: 13820.6
+temperature129: 78
+resistance129: 13377.4
+temperature130: 79
+resistance130: 12950.7
+temperature131: 80
+resistance131: 12540
+temperature132: 81
+resistance132: 12134.7
+temperature133: 82
+resistance133: 11744.7
+temperature134: 83
+resistance134: 11369.4
+temperature135: 84
+resistance135: 11008
+temperature136: 85
+resistance136: 10660
+temperature137: 86
+resistance137: 10324.3
+temperature138: 87
+resistance138: 10001
+temperature139: 88
+resistance139: 9689.5
+temperature140: 89
+resistance140: 9389.3
+temperature141: 90
+resistance141: 9100
+temperature142: 91
+resistance142: 8817.1
+temperature143: 92
+resistance143: 8544.4
+temperature144: 93
+resistance144: 8281.6
+temperature145: 94
+resistance145: 8028.3
+temperature146: 95
+resistance146: 7784
+temperature147: 96
+resistance147: 7553.8
+temperature148: 97
+resistance148: 7331.6
+temperature149: 98
+resistance149: 7117.2
+temperature150: 99
+resistance150: 6910
+temperature151: 100
+resistance151: 6710
+temperature152: 101
+resistance152: 6526.5
+temperature153: 102
+resistance153: 6349
+temperature154: 103
+resistance154: 6177.2
+temperature155: 104
+resistance155: 6010.9
+temperature156: 105
+resistance156: 5850
+temperature157: 106
+resistance157: 5683.2
+temperature158: 107
+resistance158: 5522.1
+temperature159: 108
+resistance159: 5366.3
+temperature160: 109
+resistance160: 5215.6
+temperature161: 110
+resistance161: 5070
+temperature162: 111
+resistance162: 4929.1
+temperature163: 112
+resistance163: 4792.8
+temperature164: 113
+resistance164: 4661
+temperature165: 114
+resistance165: 4533.4
+temperature166: 115
+resistance166: 4410
+temperature167: 116
+resistance167: 4290.6
+temperature168: 117
+resistance168: 4175.1
+temperature169: 118
+resistance169: 4063.2
+temperature170: 119
+resistance170: 3954.9
+temperature171: 120
+resistance171: 3850
+temperature172: 121
+resistance172: 3741
+temperature173: 122
+resistance173: 3635.7
+temperature174: 123
+resistance174: 3533.8
+temperature175: 124
+resistance175: 3435.3
+temperature176: 125
+resistance176: 3340
+temperature177: 126
+resistance177: 3255
+temperature178: 127
+resistance178: 3172.6
+temperature179: 128
+resistance179: 3092.7
+temperature180: 129
+resistance180: 3015.2
+temperature181: 130
+resistance181: 2940
+temperature182: 131
+resistance182: 2863.4
+temperature183: 132
+resistance183: 2789.3
+temperature184: 133
+resistance184: 2717.3
+temperature185: 134
+resistance185: 2647.6
+temperature186: 135
+resistance186: 2580
+temperature187: 136
+resistance187: 2514.4
+temperature188: 137
+resistance188: 2450.7
+temperature189: 138
+resistance189: 2389
+temperature190: 139
+resistance190: 2329.1
+temperature191: 140
+resistance191: 2271
+temperature192: 141
+resistance192: 2213.5
+temperature193: 142
+resistance193: 2157.7
+temperature194: 143
+resistance194: 2103.5
+temperature195: 144
+resistance195: 2051
+temperature196: 145
+resistance196: 2000
+temperature197: 146
+resistance197: 1951.3
+temperature198: 147
+resistance198: 1904
+temperature199: 148
+resistance199: 1858
+temperature200: 149
+resistance200: 1813.4
+temperature201: 150
+resistance201: 1770
+temperature202: 151
+resistance202: 1731.9
+temperature203: 152
+resistance203: 1694.7
+temperature204: 153
+resistance204: 1658.6
+temperature205: 154
+resistance205: 1623.3
+temperature206: 155
+resistance206: 1589
+temperature207: 156
+resistance207: 1552
+temperature208: 157
+resistance208: 1516
+temperature209: 158
+resistance209: 1481.1
+temperature210: 159
+resistance210: 1447.1
+temperature211: 160
+resistance211: 1414
+temperature212: 161
+resistance212: 1381.2
+temperature213: 162
+resistance213: 1349.4
+temperature214: 163
+resistance214: 1318.4
+temperature215: 164
+resistance215: 1288.3
+temperature216: 165
+resistance216: 1259
+temperature217: 166
+resistance217: 1230.1
+temperature218: 167
+resistance218: 1201.9
+temperature219: 168
+resistance219: 1174.5
+temperature220: 169
+resistance220: 1147.9
+temperature221: 170
+resistance221: 1122
+temperature222: 171
+resistance222: 1095.6
+temperature223: 172
+resistance223: 1069.9
+temperature224: 173
+resistance224: 1044.9
+temperature225: 174
+resistance225: 1020.6
+temperature226: 175
+resistance226: 997
+temperature227: 176
+resistance227: 975.7
+temperature228: 177
+resistance228: 955
+temperature229: 178
+resistance229: 934.8
+temperature230: 179
+resistance230: 915.1
+temperature231: 180
+resistance231: 896
+temperature232: 181
+resistance232: 875
+temperature233: 182
+resistance233: 854.7
+temperature234: 183
+resistance234: 834.9
+temperature235: 184
+resistance235: 815.7
+temperature236: 185
+resistance236: 797
+temperature237: 186
+resistance237: 780.6
+temperature238: 187
+resistance238: 764.6
+temperature239: 188
+resistance239: 749
+temperature240: 189
+resistance240: 733.8
+temperature241: 190
+resistance241: 719
+temperature242: 191
+resistance242: 702.9
+temperature243: 192
+resistance243: 687.3
+temperature244: 193
+resistance244: 672.1
+temperature245: 194
+resistance245: 657.4
+temperature246: 195
+resistance246: 643
+temperature247: 196
+resistance247: 630.2
+temperature248: 197
+resistance248: 617.7
+temperature249: 198
+resistance249: 605.5
+temperature250: 199
+resistance250: 593.6
+temperature251: 200
+resistance251: 582
+temperature252: 201
+resistance252: 571.7
+temperature253: 202
+resistance253: 561.7
+temperature254: 203
+resistance254: 551.9
+temperature255: 204
+resistance255: 542.3
+temperature256: 205
+resistance256: 533
+temperature257: 206
+resistance257: 522.5
+temperature258: 207
+resistance258: 512.2
+temperature259: 208
+resistance259: 502.2
+temperature260: 209
+resistance260: 492.5
+temperature261: 210
+resistance261: 483
+temperature262: 211
+resistance262: 473.3
+temperature263: 212
+resistance263: 463.9
+temperature264: 213
+resistance264: 454.7
+temperature265: 214
+resistance265: 445.7
+temperature266: 215
+resistance266: 437
+temperature267: 216
+resistance267: 428.4
+temperature268: 217
+resistance268: 420
+temperature269: 218
+resistance269: 411.8
+temperature270: 219
+resistance270: 403.8
+temperature271: 220
+resistance271: 396
+temperature272: 221
+resistance272: 388.4
+temperature273: 222
+resistance273: 381
+temperature274: 223
+resistance274: 373.9
+temperature275: 224
+resistance275: 366.8
+temperature276: 225
+resistance276: 360
+temperature277: 226
+resistance277: 353.3
+temperature278: 227
+resistance278: 346.7
+temperature279: 228
+resistance279: 340.3
+temperature280: 229
+resistance280: 334.1
+temperature281: 230
+resistance281: 328
+temperature282: 231
+resistance282: 322
+temperature283: 232
+resistance283: 316.1
+temperature284: 233
+resistance284: 310.4
+temperature285: 234
+resistance285: 304.8
+temperature286: 235
+resistance286: 299.3
+temperature287: 236
+resistance287: 294
+temperature288: 237
+resistance288: 288.8
+temperature289: 238
+resistance289: 283.6
+temperature290: 239
+resistance290: 278.6
+temperature291: 240
+resistance291: 273.7
+temperature292: 241
+resistance292: 268.9
+temperature293: 242
+resistance293: 264.2
+temperature294: 243
+resistance294: 259.6
+temperature295: 244
+resistance295: 255.1
+temperature296: 245
+resistance296: 250.7
+temperature297: 246
+resistance297: 246.4
+temperature298: 247
+resistance298: 242.2
+temperature299: 248
+resistance299: 238
+temperature300: 249
+resistance300: 234
+temperature301: 250
+resistance301: 230
+temperature302: 251
+resistance302: 226.2
+temperature303: 252
+resistance303: 222.3
+temperature304: 253
+resistance304: 218.6
+temperature305: 254
+resistance305: 215
+temperature306: 255
+resistance306: 211.4
+temperature307: 256
+resistance307: 207.9
+temperature308: 257
+resistance308: 204.5
+temperature309: 258
+resistance309: 201.1
+temperature310: 259
+resistance310: 197.8
+temperature311: 260
+resistance311: 194.6
+temperature312: 261
+resistance312: 191.4
+temperature313: 262
+resistance313: 188.3
+temperature314: 263
+resistance314: 185.3
+temperature315: 264
+resistance315: 182.3
+temperature316: 265
+resistance316: 179.4
+temperature317: 266
+resistance317: 176.5
+temperature318: 267
+resistance318: 173.7
+temperature319: 268
+resistance319: 171
+temperature320: 269
+resistance320: 168.3
+temperature321: 270
+resistance321: 165.6
+temperature322: 271
+resistance322: 163
+temperature323: 272
+resistance323: 160.4
+temperature324: 273
+resistance324: 157.9
+temperature325: 274
+resistance325: 155.5
+temperature326: 275
+resistance326: 153.1
+temperature327: 276
+resistance327: 150.7
+temperature328: 277
+resistance328: 148.4
+temperature329: 278
+resistance329: 146.1
+temperature330: 279
+resistance330: 143.9
+temperature331: 280
+resistance331: 141.7
+temperature332: 281
+resistance332: 139.6
+temperature333: 282
+resistance333: 137.5
+temperature334: 283
+resistance334: 135.4
+temperature335: 284
+resistance335: 133.4
+temperature336: 285
+resistance336: 131.4
+temperature337: 286
+resistance337: 129.5
+temperature338: 287
+resistance338: 127.5
+temperature339: 288
+resistance339: 125.7
+temperature340: 289
+resistance340: 123.8
+temperature341: 290
+resistance341: 122
+temperature342: 291
+resistance342: 120.2
+temperature343: 292
+resistance343: 118.5
+temperature344: 293
+resistance344: 116.8
+temperature345: 294
+resistance345: 115.1
+temperature346: 295
+resistance346: 113.4
+temperature347: 296
+resistance347: 111.8
+temperature348: 297
+resistance348: 110.2
+temperature349: 298
+resistance349: 108.6
+temperature350: 299
+resistance350: 107.1
+temperature351: 300
+resistance351: 105.6
 
 ########################################
 # Default thermistors
--- /dev/null
+++ b/klippy/extras/timelapse.py
@@ -0,0 +1,175 @@
+# timelapse manager for klippy
+#
+# Copyright (C) 2025-2030  Scott Huang <shili.huang@snapmaker.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+
+import json
+import logging
+import random
+import time, os
+
+
+class TimeLapse:
+    PICTURES_DIR = "/userdata/gcodes/pictures"
+    remote_topic = "camera/request"
+    payload_start_timelapse = {
+        "jsonrpc": "2.0",
+        "method": "camera.start_timelapse",
+        "params": {
+            "mode": "classic",
+            "frame_rate": 24,
+            "type": "new",
+            "gcode_name": None,
+            "gcode_path": None,
+        },
+        "id": 1
+    }
+    payload_stop_timelapse = {
+        "jsonrpc": "2.0",
+        "method": "camera.stop_timelapse",
+        "params": {},
+        "id": 1
+    }
+    payload_take_a_picture = {
+        "jsonrpc": "2.0",
+        "method": "camera.take_a_photo",
+        "params": {
+            "reason": "printing",
+            "timestamp": False,
+            "filepath": "/tmp/tmp.jpg"
+        },
+        "id": 3
+    }
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.gcode = self.printer.lookup_object('gcode')
+        self.webhooks = self.printer.lookup_object('webhooks')
+
+        # Timelapse status
+        self.is_active = False
+
+        self.frame_rate = config.getint('frame_rate', 24)
+        self.task_config = self.printer.lookup_object('print_task_config')
+        # Register GCode commands
+        self.gcode.register_command('TIMELAPSE_START', self.cmd_TIMELAPSE_START,
+                                   desc=self.cmd_TIMELAPSE_START_help)
+        self.gcode.register_command('TIMELAPSE_STOP', self.cmd_TIMELAPSE_STOP,
+                                   desc=self.cmd_TIMELAPSE_STOP_help)
+        self.gcode.register_command('TIMELAPSE_TAKE_FRAME', self.cmd_TIMELAPSE_TAKE_FRAME,
+                                   desc=self.cmd_TIMELAPSE_TAKE_FRAME_help)
+
+    def _call_moonraker_mqtt(self, payload):
+        """Call moonraker's publish_mqtt_topic method via webhooks"""
+        try:
+            jpayload = json.dumps(payload)
+
+            # Call remote method to send MQTT message to moonraker
+            self.webhooks.call_remote_method(
+                'publish_mqtt_topic',
+                topic=self.remote_topic,
+                payload=jpayload,
+                qos=1
+            )
+            logging.info(f"TimeLapse: Sent MQTT message - topic: {self.remote_topic}, params: {payload}")
+        except Exception as e:
+            logging.error(f"TimeLapse: Failed to call moonraker MQTT publish: {e}")
+            raise self.printer.command_error(f"Timelapse MQTT call failed: {e}")
+
+    cmd_TIMELAPSE_START_help = "Start timelapse recording"
+    def cmd_TIMELAPSE_START(self, gcmd):
+        """Start timelapse recording command"""
+
+        if not self.task_config.print_task_config['time_lapse_camera']:
+            gcmd.respond_info("Timelapse is not enabled in print task config")
+            return
+
+        if self.is_active:
+            gcmd.respond_raw("!! Timelapse is already running\n")
+            return
+
+        gcode_name = None
+        gcode_path = None
+        virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+        if virtual_sdcard is not None:
+            gcode_path = virtual_sdcard.get_status(self.reactor.monotonic())['file_path']
+            if gcode_path is not None:
+                gcode_name = os.path.basename(gcode_path).split('.', 1)[0]
+
+        start_type = gcmd.get('TYPE', 'new')
+        if start_type == 'continue':
+            gcmd.respond_info("Continuing existing timelapse")
+        else:
+            gcmd.respond_info("Starting new timelapse")
+
+        try:
+            # turn on the light
+            self.gcode.run_script_from_command("SET_LED LED=cavity_led WHITE=1\r\n")
+            # Generate a random ID for the request
+            self.payload_start_timelapse['id'] = random.randint(1, 10000)
+            self.payload_start_timelapse['params']['frame_rate'] = self.frame_rate
+            self.payload_start_timelapse['params']['type'] = start_type
+            self.payload_start_timelapse['params']['gcode_name'] = gcode_name
+            self.payload_start_timelapse['params']['gcode_path'] = gcode_path
+            # Send start message to moonraker
+            self._call_moonraker_mqtt(self.payload_start_timelapse)
+
+            self.is_active = True
+        except Exception as e:
+            gcmd.error(f"Failed to start timelapse: {e}")
+
+    cmd_TIMELAPSE_STOP_help = "Stop timelapse recording"
+    def cmd_TIMELAPSE_STOP(self, gcmd):
+        """Stop timelapse recording command"""
+        if not self.is_active:
+            gcmd.respond_info("Timelapse is not running")
+            return
+
+        try:
+            # Generate a random ID
+            self.payload_stop_timelapse['id'] = random.randint(1, 10000)
+            # Send stop message to moonraker
+            self._call_moonraker_mqtt(self.payload_stop_timelapse)
+
+            self.is_active = False
+            gcmd.respond_info("Timelapse stopped")
+
+        except Exception as e:
+            gcmd.error(f"Failed to stop timelapse: {e}")
+
+    cmd_TIMELAPSE_TAKE_FRAME_help = "Trigger timelapse photo capture"
+    def cmd_TIMELAPSE_TAKE_FRAME(self, gcmd):
+        """Trigger timelapse photo capture command"""
+        debug = gcmd.get_int('DEBUG', 0)
+        try:
+            if debug != 0:
+                self.payload_take_a_picture['params']['reason'] = 'debug'
+                timestamp = time.strftime("%Y%m%d_%H%M%S")
+                # check if directory to save pictures exists, if not create it
+                if not os.path.exists(self.PICTURES_DIR):
+                    os.makedirs(self.PICTURES_DIR)
+                pic_name = f"{self.PICTURES_DIR}/pic_{timestamp}.jpg"
+                self.payload_take_a_picture['params']['filepath'] = pic_name
+                gcmd.respond_info(f"take a picture for debug, saved to {pic_name}")
+            else:
+                if self.is_active and self.task_config.print_task_config['time_lapse_camera']:
+                    self.payload_take_a_picture['params']['reason'] = 'printing'
+                else:
+                    return
+            # Generate a random ID
+            self.payload_take_a_picture['id'] = random.randint(1, 10000)
+            # Send photo capture message to moonraker
+            self._call_moonraker_mqtt(self.payload_take_a_picture)
+        except Exception as e:
+            gcmd.error(f"Failed to trigger timelapse photo capture: {e}")
+
+    def get_status(self, eventtime):
+        """Get timelapse status"""
+        return {
+            'is_active': self.is_active
+        }
+
+def load_config(config):
+    return TimeLapse(config)
+
--- a/klippy/extras/tmc.py
+++ b/klippy/extras/tmc.py
@@ -214,7 +214,7 @@ class TMCErrorCheck:
             return {'drv_status': None, 'temperature': None}
         temp = None
         if self.adc_temp is not None:
-            temp = round((self.adc_temp - 2038) / 7.7, 2)
+            temp = round((self.adc_temp - 2038) / 7.7, 0)
         last_value, reg_name = self.drv_status_reg_info[:2]
         if last_value != self.last_drv_status:
             self.last_drv_status = last_value
--- a/klippy/extras/tmc2130.py
+++ b/klippy/extras/tmc2130.py
@@ -294,6 +294,7 @@ class TMC2130:
         cmdhelper.setup_register_dump(ReadRegisters)
         self.get_phase_offset = cmdhelper.get_phase_offset
         self.get_status = cmdhelper.get_status
+        self.query_phase = cmdhelper._query_phase
         # Setup basic register values
         tmc.TMCWaveTableHelper(config, self.mcu_tmc)
         tmc.TMCStealthchopHelper(config, self.mcu_tmc)
--- a/klippy/extras/tmc2208.py
+++ b/klippy/extras/tmc2208.py
@@ -195,6 +195,7 @@ class TMC2208:
         cmdhelper.setup_register_dump(ReadRegisters, self.read_translate)
         self.get_phase_offset = cmdhelper.get_phase_offset
         self.get_status = cmdhelper.get_status
+        self.query_phase = cmdhelper._query_phase
         # Setup basic register values
         self.fields.set_field("mstep_reg_select", True)
         tmc.TMCStealthchopHelper(config, self.mcu_tmc)
--- a/klippy/extras/tmc2209.py
+++ b/klippy/extras/tmc2209.py
@@ -71,6 +71,7 @@ class TMC2209:
         cmdhelper.setup_register_dump(ReadRegisters)
         self.get_phase_offset = cmdhelper.get_phase_offset
         self.get_status = cmdhelper.get_status
+        self.query_phase = cmdhelper._query_phase
         # Setup basic register values
         self.fields.set_field("mstep_reg_select", True)
         tmc.TMCStealthchopHelper(config, self.mcu_tmc)
--- a/klippy/extras/tmc2240.py
+++ b/klippy/extras/tmc2240.py
@@ -361,6 +361,7 @@ class TMC2240:
         cmdhelper.setup_register_dump(ReadRegisters)
         self.get_phase_offset = cmdhelper.get_phase_offset
         self.get_status = cmdhelper.get_status
+        self.query_phase = cmdhelper._query_phase
         # Setup basic register values
         tmc.TMCWaveTableHelper(config, self.mcu_tmc)
         self.fields.set_config_field(config, "offset_sin90", 0)
--- a/klippy/extras/tmc2660.py
+++ b/klippy/extras/tmc2660.py
@@ -241,6 +241,7 @@ class TMC2660:
         cmdhelper.setup_register_dump(ReadRegisters)
         self.get_phase_offset = cmdhelper.get_phase_offset
         self.get_status = cmdhelper.get_status
+        self.query_phase = cmdhelper._query_phase
 
         # CHOPCONF
         set_config_field = self.fields.set_config_field
--- a/klippy/extras/tmc5160.py
+++ b/klippy/extras/tmc5160.py
@@ -336,6 +336,7 @@ class TMC5160:
         cmdhelper.setup_register_dump(ReadRegisters)
         self.get_phase_offset = cmdhelper.get_phase_offset
         self.get_status = cmdhelper.get_status
+        self.query_phase = cmdhelper._query_phase
         # Setup basic register values
         tmc.TMCWaveTableHelper(config, self.mcu_tmc)
         tmc.TMCStealthchopHelper(config, self.mcu_tmc)
--- a/klippy/extras/tmc_uart.py
+++ b/klippy/extras/tmc_uart.py
@@ -70,7 +70,7 @@ def lookup_tmc_uart_mutex(mcu):
         pmutexes.mcu_to_mutex[mcu] = mutex
     return mutex
 
-TMC_BAUD_RATE = 40000
+TMC_BAUD_RATE = 9600
 TMC_BAUD_RATE_AVR = 9000
 
 # Code for sending messages on a TMC uart
--- a/klippy/extras/verify_heater.py
+++ b/klippy/extras/verify_heater.py
@@ -120,6 +120,7 @@ class HeaterCheck:
         coded, oneshot, is_persistent = f"0003-{id:04d}-{index:04d}-{code:04d}", 0, 0
         msg = '{"coded": "%s", "oneshot": %d, "msg":"%s"}' % (coded, 0, msg.replace('"',"'"))
         logging.error(msg)
+        self.printer.set_extruder_power('off')
         self.printer.invoke_shutdown(msg + HINT_THERMAL)
         return self.printer.get_reactor().NEVER
 
--- a/klippy/extras/virtual_sdcard.py
+++ b/klippy/extras/virtual_sdcard.py
@@ -4,20 +4,41 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import os, sys, logging, io
+import json, re, copy, tarfile, threading, queuefile
 
+MAX_TOOL_NUMBER = 32
 VALID_GCODE_EXTS = ['gcode', 'g', 'gco']
-
+GENERIC_MOVE_GCODE = {'G0', 'G1', 'G2', 'G3'}
+TOOL_CHANGE_COMMANDS = {f'T{i}' for i in range(MAX_TOOL_NUMBER)}
+NO_PRE_EXTRUDE_COMMANDS = TOOL_CHANGE_COMMANDS | {
+    'BED_MESH_CALIBRATE'
+}
+USE_REALTIME_TEMP_GCODE = {
+    'BED_MESH_CALIBRATE'
+}
 DEFAULT_ERROR_GCODE = """
 {% if 'heaters' in printer %}
    TURN_OFF_HEATERS
 {% endif %}
 """
 
+PL_PRINT_FILE_ENV = "pl_print_file_env.json"
+PL_PRINT_FILE_MOVE_ENV = "pl_print_file_move_env.json"
+PL_PRINT_TEMPERATURE_ENV = "pl_print_temperature_env.json"
+PL_PRINT_FLOW_AND_SPEED_FACTOR_ENV = "pl_print_flow_and_speed_factor_env.json"
+PL_PRINT_PRESSURE_ADVANCE_ENV = "pl_print_pressure_advance_env.json"
+PL_PRINT_LAYER_INFO_ENV = "pl_print_layer_info_env.json"
+PL_PRINT_FAN_INFO_ENV = "pl_print_fan_info_env.json"
+PL_PRINT_Z_ADJUST_POSITION_ENV = "pl_print_z_adjust_position_env.json"
+
 class VirtualSD:
     def __init__(self, config):
         self.printer = config.get_printer()
         self.printer.register_event_handler("klippy:shutdown",
                                             self.handle_shutdown)
+        self.printer.register_event_handler("power_loss_check:mcu_update_complete",
+                                            self.handle_get_mcu_pl_flash_data)
+        self.gcode_move = self.printer.load_object(config, 'gcode_move')
         # sdcard state
         sd = config.get('path')
         self.sdcard_dirname = os.path.normpath(os.path.expanduser(sd))
@@ -30,6 +51,69 @@ class VirtualSD:
         self.must_pause_work = self.cmd_from_sd = False
         self.next_file_position = 0
         self.work_timer = None
+        self.print_task_config = None
+        # PL params
+        config_dir = self.printer.get_snapmaker_config_dir()
+        self.pl_print_file_env_path = os.path.join(config_dir, PL_PRINT_FILE_ENV)
+        self.pl_print_file_move_env_path = os.path.join(config_dir, PL_PRINT_FILE_MOVE_ENV)
+        self.pl_print_temperature_env_path = os.path.join(config_dir, PL_PRINT_TEMPERATURE_ENV)
+        self.pl_print_flow_and_speed_factor_env_path = os.path.join(config_dir, PL_PRINT_FLOW_AND_SPEED_FACTOR_ENV)
+        self.pl_print_pressure_advance_env_path = os.path.join(config_dir, PL_PRINT_PRESSURE_ADVANCE_ENV)
+        self.pl_print_layer_info_env_path = os.path.join(config_dir, PL_PRINT_LAYER_INFO_ENV)
+        self.pl_print_fan_info_env_path = os.path.join(config_dir, PL_PRINT_FAN_INFO_ENV)
+        self.pl_print_z_adjust_position_env_path = os.path.join(config_dir, PL_PRINT_Z_ADJUST_POSITION_ENV)
+        self.pl_switch = False
+        self.lines = 0
+        self.current_line_gcode = ''
+        self.current_file_index = 0
+        self.max_file_count = 50
+        self.pl_mcu_flash_valid_line = 0xFFFFFFFF
+        self.pl_mcu_flash_stepper_z_pos = 0xFFFFFFFF
+        self.pl_mcu_flash_resume_line = 0xFFFFFFFF
+        self.pl_allow_save_env = False
+        self.pl_env_valid = False
+        gcode_macro = self.printer.load_object(config, 'gcode_macro')
+        try:
+            pl_save_variable_macro = self.printer.load_object(config, 'gcode_macro _PL_SAVE_VARIABLE', None)
+        except Exception as e:
+            pl_save_variable_macro = None
+        if pl_save_variable_macro is not None:
+            self.pl_start_save_line = pl_save_variable_macro.variables.get('start_save_line', 5)
+            self.pl_z_compensation_value = pl_save_variable_macro.variables.get('z_compensation_value', 0)
+            self.pl_save_line_interval = pl_save_variable_macro.variables.get('save_line_interval', 1000)
+            self.pl_z_hop_temp = pl_save_variable_macro.variables.get('z_hop_temp', 140)
+            self.pl_pre_extrude_len = pl_save_variable_macro.variables.get('pre_extrude_len', 20)
+            self.pl_speed_pre_extrude = pl_save_variable_macro.variables.get('speed_pre_extrude', 5)
+            self.pl_retract = pl_save_variable_macro.variables.get('retract', 2)
+            self.pl_unretract = pl_save_variable_macro.variables.get('unretract', 2)
+            self.pl_speed_retract = pl_save_variable_macro.variables.get('speed_retract', 30)
+            self.pl_speed_unretract = pl_save_variable_macro.variables.get('speed_unretract', 5)
+            self.pl_speed_resume_z = pl_save_variable_macro.variables.get('speed_resume_z', 30)
+            self.pl_speed_move = pl_save_variable_macro.variables.get('speed_move', 200)
+            self.move_extrude_macro = pl_save_variable_macro.variables.get('move_extrude_macro', '')
+            self.after_extrude_macro = pl_save_variable_macro.variables.get('after_extrude_macro', '')
+            self.z_max_travel = pl_save_variable_macro.variables.get('z_max_travel', 270.5)
+        else:
+            self.pl_start_save_line = 5
+            self.pl_z_compensation_value = -0.2
+            self.pl_save_line_interval = 1000
+            self.pl_z_hop_temp = 140
+            self.pl_pre_extrude_len = 0
+            self.pl_speed_pre_extrude = 5
+            self.pl_retract = 0
+            self.pl_unretract = 0
+            self.pl_speed_retract = 30
+            self.pl_speed_unretract = 5
+            self.pl_speed_resume_z = 30
+            self.pl_speed_move = 200
+            self.move_extrude_macro = ''
+            self.after_extrude_macro = ''
+            self.z_max_travel = 270.5
+        self.pl_notify_start_line = self.pl_next_save_line = self.pl_start_save_line
+
+        # self.fan_state = {}
+        if config.get_prefix_sections("power_loss_check") and config.getboolean("power_loss_check", True):
+            self.pl_switch = True
         # Error handling
         gcode_macro = self.printer.load_object(config, 'gcode_macro')
         self.on_error_gcode = gcode_macro.load_template(
@@ -46,6 +130,12 @@ class VirtualSD:
         self.gcode.register_command(
             "SDCARD_PRINT_FILE", self.cmd_SDCARD_PRINT_FILE,
             desc=self.cmd_SDCARD_PRINT_FILE_help)
+        self.gcode.register_command(
+            "SDCARD_PRINT_TEST", self.cmd_SDCARD_PRINT_TEST)
+        self.gcode.register_command(
+            "SDCARD_PRINT_PL_RESTORE", self.cmd_SDCARD_PRINT_PL_RESTORE)
+        self.gcode.register_command(
+            "SDCARD_PRINT_PL_CLEAR_ENV", self.cmd_SDCARD_PRINT_PL_CLEAR_ENV)
     def handle_shutdown(self):
         if self.work_timer is not None:
             self.must_pause_work = True
@@ -60,6 +150,33 @@ class VirtualSD:
             logging.info("Virtual sdcard (%d): %s\nUpcoming (%d): %s",
                          readpos, repr(data[:readcount]),
                          self.file_position, repr(data[readcount:]))
+    def handle_get_mcu_pl_flash_data(self):
+        try:
+            self.parse_power_loss_move_env(validate_only=True)
+            self.pl_env_valid = True
+            logging.info("Power loss env is valid")
+        except Exception as e:
+            logging.info("Power loss env is invalid: {}".format(str(e)))
+            self.rm_power_loss_info()
+
+    def _update_mcu_flash_valid_line(self):
+        self.pl_mcu_flash_valid_line = 0xFFFFFFFF
+        self.pl_mcu_flash_stepper_z_pos = 0xFFFFFFFF
+        pl_check = self.power_loss_info_check()
+        logging.info("pl_check: {}!!!!!!!!!!!".format(pl_check))
+        if pl_check[0] and pl_check[1] is not None:
+            for key in pl_check[1]:
+                line = pl_check[1][key]['line']
+                position = pl_check[1][key]['position']
+                if line != 0xFFFFFFFF:
+                    if key == 'stepper_z':
+                        self.pl_mcu_flash_stepper_z_pos = position
+                    if self.pl_mcu_flash_valid_line == 0xFFFFFFFF:
+                        self.pl_mcu_flash_valid_line = line
+                    elif self.pl_mcu_flash_valid_line < line:
+                        self.pl_mcu_flash_valid_line = line
+        logging.info("pl_mcu_flash_valid_line: {}".format(self.pl_mcu_flash_valid_line))
+        return (pl_check[0], self.pl_mcu_flash_valid_line)
     def stats(self, eventtime):
         if self.work_timer is None:
             return False, ""
@@ -98,6 +215,7 @@ class VirtualSD:
             'is_active': self.is_active(),
             'file_position': self.file_position,
             'file_size': self.file_size,
+            'pl_env_valid': self.pl_env_valid,
         }
     def file_path(self):
         if self.current_file:
@@ -129,19 +247,49 @@ class VirtualSD:
             self.current_file.close()
             self.current_file = None
             self.print_stats.note_cancel()
+            self.exit_to_idle()
         self.file_position = self.file_size = 0
+    def exit_to_idle(self, rm_pl_env_file=True):
+        try:
+            self.lines = 0
+            self.current_line_gcode = ''
+            self.current_file_index = 0
+            self.pl_notify_start_line = self.pl_next_save_line = self.pl_start_save_line
+            self.pl_mcu_flash_resume_line = 0xFFFFFFFF
+            self.pl_mcu_flash_valid_line = 0xFFFFFFFF
+            # self.fan_state = {}
+            if rm_pl_env_file:
+                self.rm_power_loss_info()
+            self.notify_mcu_enable_power_loss(0)
+            msm = self.printer.lookup_object('machine_state_manager', None)
+            if msm is not None:
+                # state_str = str(msm.main_state)
+                state_str = str(msm.get_status()['main_state'])
+                if state_str == "PRINTING":
+                    self.gcode.run_script_from_command("EXIT_TO_IDLE REQ_FROM_STATE=PRINTING")
+        except Exception as e:
+            logging.exception("{}".format(str(e)))
     # G-Code commands
     def cmd_error(self, gcmd):
         error = '{"coded": "0001-0531-0000-0002", "msg":"%s", "action": "none"}' % ("SD write not supported")
         raise gcmd.error(error)
         # raise gcmd.error("SD write not supported")
-    def _reset_file(self):
+    def _pl_recovery_reset_file(self, rm_pl_env_file=True):
+        if self.current_file is not None:
+            self.do_pause()
+            self.current_file.close()
+            self.current_file = None
+        self.file_position = self.file_size = 0
+        self.print_stats.reset(reprint=True)
+        self.printer.send_event("virtual_sdcard:reset_file")
+    def _reset_file(self, rm_pl_env_file=True):
         if self.current_file is not None:
             self.do_pause()
             self.current_file.close()
             self.current_file = None
         self.file_position = self.file_size = 0
         self.print_stats.reset()
+        self.exit_to_idle(rm_pl_env_file)
         self.printer.send_event("virtual_sdcard:reset_file")
     cmd_SDCARD_RESET_FILE_help = "Clears a loaded SD File. Stops the print "\
         "if necessary"
@@ -151,7 +299,8 @@ class VirtualSD:
             raise gcmd.error(error)
             # raise gcmd.error(
             #     "SDCARD_RESET_FILE cannot be run from the sdcard")
-        self._reset_file()
+        rm_pl_env_file = gcmd.get_int('RM_PL_ENV_FILE', 1)
+        self._reset_file(rm_pl_env_file)
     cmd_SDCARD_PRINT_FILE_help = "Loads a SD file and starts the print.  May "\
         "include files in subdirectories."
     def cmd_SDCARD_PRINT_FILE(self, gcmd):
@@ -159,10 +308,12 @@ class VirtualSD:
             error = '{"coded": "0001-0531-0000-0001", "msg":"%s", "action": "none"}' % ("SD busy")
             raise gcmd.error(error)
             # raise gcmd.error("SD busy")
-        self._reset_file()
+        rm_pl_env_file = gcmd.get_int('RM_PL_ENV_FILE', 1)
+        self._reset_file(rm_pl_env_file)
         filename = gcmd.get("FILENAME")
         if filename[0] == '/':
             filename = filename[1:]
+        self.rm_power_loss_info()
         self._load_file(gcmd, filename, check_subdirs=True)
         self.do_resume()
     def cmd_M20(self, gcmd):
@@ -186,7 +337,65 @@ class VirtualSD:
         if filename.startswith('/'):
             filename = filename[1:]
         self._load_file(gcmd, filename)
-    def _load_file(self, gcmd, filename, check_subdirs=False):
+    def cmd_SDCARD_PRINT_TEST(self, gcmd):
+        self.gcode.respond_info("self.pl_switch: {}  flag: {} pl_env_valid: {}".format(self.pl_switch, self.get_pl_env_flag(), self.pl_env_valid))
+        pl_check = self.power_loss_info_check()
+        if pl_check[0] and pl_check[1] is not None:
+            for key in pl_check[1]:
+                line = pl_check[1][key]['line']
+                position = pl_check[1][key]['position']
+                self.gcode.respond_info("{}: line {}, position {}".format(key, line, position))
+        self.gcode.respond_info("pl_mcu_flash_valid_line: {}".format(self.pl_mcu_flash_valid_line))
+        if self.pl_mcu_flash_valid_line != 0xFFFFFFFF:
+            find_move_restult = self.pl_find_latest_move_env(self.pl_mcu_flash_valid_line)
+            self.gcode.respond_info("find_move_restult index: {}, env_data: {}".format(find_move_restult[0], find_move_restult[1]))
+            save_env = self.parse_power_loss_move_env()
+            if save_env is None:
+                return
+            self.gcode.respond_info("file_path: {}".format(save_env['file_path']))
+            self.gcode.respond_info("power_loss_run_gcode_info: {}".format(save_env['power_loss_run_gcode_info']))
+            self.gcode.respond_info("current_line: {}".format(save_env['current_line']))
+            self.gcode.respond_info("cur_file_pos: {}".format(save_env['cur_file_pos']))
+            self.gcode.respond_info("last_file_pos: {}".format(save_env['last_file_pos']))
+            self.gcode.respond_info("extruder_id: {}".format(save_env['gcode_tracker'].extruder_gcode_id))
+            self.gcode.respond_info("homing_stepper_z_info: {}".format(save_env['homing_stepper_z_info']))
+            self.gcode.respond_info("last_move_file_index: {}".format(save_env['last_move_file_index']))
+            z_info = save_env['homing_stepper_z_info']
+            if z_info is not None and self.pl_mcu_flash_stepper_z_pos != 0xFFFFFFFF:
+                z_adjust_position = self.get_pl_print_z_adjust_position()
+                direction = -1 if z_info['dir_inverted'] else 1
+                pl_save_z_pos = (self.pl_mcu_flash_stepper_z_pos - z_info["stepper_z_pos"])*z_info['step_dist']*direction + z_info['z_pos']
+                gcode_tracker = save_env['gcode_tracker']
+                resum_gcode_position = [
+                    last - base
+                    for last, base in zip(gcode_tracker.last_position, gcode_tracker.base_position)
+                ]
+                self.gcode.respond_info("resum_gcode_position: {}".format(resum_gcode_position))
+                resume_z =  pl_save_z_pos + z_adjust_position + self.pl_z_compensation_value
+                self.gcode.respond_info("pl_save_z_pos: {}, cal z pos: {}, resume z pos: {}!!!!".format(pl_save_z_pos, pl_save_z_pos + z_adjust_position, resume_z))
+            else:
+                self.gcode.respond_info("Invalid z_info or stepper position data")
+    def cmd_SDCARD_PRINT_PL_RESTORE(self, gcmd):
+        msm = self.printer.lookup_object('machine_state_manager', None)
+        if msm is not None:
+            state_str = str(msm.get_status()['main_state'])
+            if state_str != "IDLE":
+                error_msg = '{"coded": "0001-0531-0000-0005", "msg":"%s", "action": "none"}' % (
+                            "Current main state is %s power-loss recovery is not allowed" % (state_str))
+                raise gcmd.error(error_msg)
+                # raise gcmd.error("Current main state is {} power-loss recovery is not allowed".format(state_str))
+        self.restore_print()
+    def cmd_SDCARD_PRINT_PL_CLEAR_ENV(self, gcmd):
+        msm = self.printer.lookup_object('machine_state_manager', None)
+        if msm is not None:
+            state_str = str(msm.get_status()['main_state'])
+            if state_str == "PRINTING":
+                error_msg = '{"coded": "0001-0531-0000-0006", "msg":"%s", "action": "none"}' % (
+                            "Do not delete power-loss info during printing")
+                raise gcmd.error(error_msg)
+                # raise gcmd.error("Do not delete power-loss info during printing")
+        self.rm_power_loss_info()
+    def _load_file(self, gcmd, filename, check_subdirs=False, reprint=False):
         files = self.get_file_list(check_subdirs)
         flist = [f[0] for f in files]
         files_by_lower = { fname.lower(): fname for fname, fsize in files }
@@ -210,7 +419,7 @@ class VirtualSD:
         self.current_file = f
         self.file_position = 0
         self.file_size = fsize
-        self.print_stats.set_current_file(filename)
+        self.print_stats.set_current_file(filename, reprint)
     def cmd_M24(self, gcmd):
         # Start/resume SD print
         self.do_resume()
@@ -240,7 +449,8 @@ class VirtualSD:
         return self.cmd_from_sd
     # Background work timer
     def work_handler(self, eventtime):
-        logging.info("Starting SD card print (position %d)", self.file_position)
+        logging.info("Starting SD card print, file: %s, position %d",
+                     self.current_file.name, self.file_position)
         self.reactor.unregister_timer(self.work_timer)
         try:
             self.current_file.seek(self.file_position)
@@ -248,11 +458,19 @@ class VirtualSD:
             logging.exception("virtual_sdcard seek")
             self.work_timer = None
             return self.reactor.NEVER
+        try:
+            self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=PRINTING")
+        except Exception as e:
+            logging.exception("{}".format(str(e)))
+            self.work_timer = None
+            return self.reactor.NEVER
         self.print_stats.note_start()
         gcode_mutex = self.gcode.get_mutex()
         partial_input = ""
         lines = []
         error_message = None
+        action = 'cancel'
+        interval_start_time = self.reactor.monotonic()
         while not self.must_pause_work:
             if not lines:
                 # Read more data
@@ -267,6 +485,8 @@ class VirtualSD:
                     self.current_file = None
                     logging.info("Finished SD card print")
                     self.gcode.respond_raw("Done printing file")
+                    self.lines = 0
+                    self.current_line_gcode = ''
                     break
                 lines = data.split('\n')
                 lines[0] = partial_input + lines[0]
@@ -278,6 +498,10 @@ class VirtualSD:
             if gcode_mutex.test():
                 self.reactor.pause(self.reactor.monotonic() + 0.100)
                 continue
+
+            if self.must_pause_work:
+                continue
+
             # Dispatch command
             self.cmd_from_sd = True
             line = lines.pop()
@@ -286,18 +510,62 @@ class VirtualSD:
             else:
                 next_file_position = self.file_position + len(line) + 1
             self.next_file_position = next_file_position
+            interval_end_time = self.reactor.monotonic()
+            self.pl_allow_save_env = True
+            self.pl_env_valid = False
             try:
-                self.gcode.run_script(line)
+                try:
+                    toolhead = self.printer.lookup_object('toolhead')
+                    self.lines += 1
+                    toolhead.print_file_line = self.lines
+                    line = self.process_gcode_line(line)
+                    interval_start_time, interval_end_time = \
+                        self.record_power_loss_info(interval_start_time, interval_end_time)
+
+                    self.gcode.run_script(line)
+                    self.current_line_gcode = line
+                    self.record_pl_print_file_move_env(line, self.lines, self.file_position)
+                except Exception as e:
+                    action = None
+                    if hasattr(e, 'action'):
+                        action = e.action
+                    coded_message = self.printer.extract_encoded_message(str(e))
+                    if coded_message is not None:
+                        action = coded_message.get("action", action)
+                    if action != 'none':
+                        logging.info("exit_print: lines=%d, current_line_gcode=%s, file_position=%d" %
+                            (self.lines, self.current_line_gcode, self.file_position))
+                        raise
+
             except self.gcode.error as e:
                 error_message = str(e)
-                try:
-                    self.gcode.run_script(self.on_error_gcode.render())
-                except:
-                    logging.exception("virtual_sdcard on_error")
+                action = e.action
+                coded_message = self.printer.extract_encoded_message(error_message)
+                if coded_message is not None:
+                    action = coded_message.get("action", action)
+                if action == 'pause':
+                    try:
+                        self.gcode.run_script('PAUSE ON_ERROR=1\n')
+                    except:
+                        logging.exception("PAUSE ON_ERROR cmd")
+                        action = 'cancel'
+                elif action == 'pause_runout':
+                    try:
+                        self.gcode.run_script('PAUSE IS_RUNOUT=1\n')
+                    except:
+                        logging.exception("PAUSE IS_RUNOUT cmd")
+                        action = 'cancel'
+                else:
+                    try:
+                        self.gcode.run_script(self.on_error_gcode.render())
+                    except:
+                        logging.exception("virtual_sdcard on_error")
                 break
             except:
                 logging.exception("virtual_sdcard dispatch")
                 break
+            finally:
+                toolhead.print_file_line = None
             self.cmd_from_sd = False
             self.file_position = self.next_file_position
             # Do we need to skip around?
@@ -307,19 +575,1344 @@ class VirtualSD:
                 except:
                     logging.exception("virtual_sdcard seek")
                     self.work_timer = None
+                    self.exit_to_idle()
                     return self.reactor.NEVER
                 lines = []
                 partial_input = ""
-        logging.info("Exiting SD card print (position %d)", self.file_position)
+        logging.info("Exiting SD card print, lines=%d, current_line_gcode=%s, file_position=%d",
+                            self.lines, self.current_line_gcode, self.file_position)
+        self.pl_allow_save_env = False
         self.work_timer = None
         self.cmd_from_sd = False
-        if error_message is not None:
+        if error_message is not None and action not in ['pause', 'pause_runout']:
             self.print_stats.note_error(error_message)
+            self.exit_to_idle()
         elif self.current_file is not None:
-            self.print_stats.note_pause()
+            self.print_stats.note_pause(error_message)
         else:
             self.print_stats.note_complete()
+            self.exit_to_idle()
         return self.reactor.NEVER
 
+    def get_pl_env_flag(self):
+        env_flags = []
+        if self.pl_switch:
+            for name, obj in self.printer.lookup_objects('power_loss_check'):
+                if 'env_flag' in obj.pl_flash_valid:
+                    env_flags.append(obj.pl_flash_valid['env_flag'])
+
+        if not env_flags:
+            return (1, [])
+
+        max_flag = max(env_flags)
+        if max_flag < 4294967294:
+            return (max_flag + 1, env_flags)
+        return (1, env_flags)
+
+    def notify_mcu_enable_power_loss(self, enable, move_line=0xFFFFFFFF):
+        if self.pl_switch:
+            env_flag = self.get_pl_env_flag()[0]
+            mcu_names = []
+            action = "enable" if enable else "disable"
+            for name, obj in self.printer.lookup_objects('power_loss_check'):
+                obj.enable_power_loss_cmd.send([obj._oid, not not enable, env_flag, move_line])
+                mcu_names.append(obj.name)
+            # self.gcode.respond_info("Notify the muc: {} to {} power loss, env_flag: {} move_line: {}".format(mcu_names, action, env_flag, move_line))
+        else:
+            self.gcode.respond_info("Power loss module not detected, Power resume has been disabled")
+
+    def config_pl_allow_save_env(self, allow_save):
+        self.pl_allow_save_env = allow_save
+
+    def record_pl_print_file_env(self, file_name, env_flag, sync=False, flush=True, safe_write=True):
+        data_dict = {
+            'env_flag': env_flag,
+            'file_path': file_name,
+        }
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats is not None:
+            eventtime = self.reactor.monotonic()
+            status = print_stats.get_status(eventtime)
+            data_dict['total_duration'] = status['total_duration']
+            data_dict['print_duration'] = status['print_duration']
+            data_dict['filament_used'] = status['filament_used']
+            self.save_environment_data(self.pl_print_file_env_path, data_dict, sync, flush, safe_write)
+
+    def get_pl_print_file_env(self):
+        if self.pl_switch:
+            if not os.path.exists(self.pl_print_file_env_path):
+                return None
+            try:
+                with open(self.pl_print_file_env_path, 'r') as f:
+                    data = json.load(f)
+                return  data
+            except Exception as e:
+                logging.exception("Failed to read power loss env file")
+                return None
+
+    def rm_power_loss_info(self):
+        try:
+            if not self.printer.is_shutdown():
+                rm_paths = [
+                    self.pl_print_file_env_path,
+                    self.pl_print_file_move_env_path,
+                    self.pl_print_temperature_env_path,
+                    self.pl_print_flow_and_speed_factor_env_path,
+                    self.pl_print_pressure_advance_env_path,
+                    self.pl_print_layer_info_env_path,
+                    self.pl_print_fan_info_env_path,
+                    self.pl_print_z_adjust_position_env_path,
+                    *[self.pl_print_file_move_env_path.replace('.json', f'_{i}.json')
+                        for i in range(self.max_file_count)]
+                ]
+
+                for p in rm_paths:
+                    try:
+                        if os.path.exists(p):
+                            queuefile.sync_delete_file(self.printer.get_reactor(), p)
+                        if os.path.exists(p + '.tmp'):
+                            queuefile.sync_delete_file(self.printer.get_reactor(), p + '.tmp')
+                    except Exception as e:
+                        logging.warning(f"Failed to delete {p} or {p}.tmp: {e}")
+                self.pl_env_valid = False
+                logging.info("rm power_loss info success")
+            else:
+                logging.info("klippy is shutdown, power_loss info is not allowed to be removed")
+        except Exception as err:
+            logging.error(f"rm power_loss info fail, err:{err}")
+
+    def backup_print_env_info(self):
+        try:
+            output_dir = self.printer.get_snapmaker_config_dir()
+            archive_name = "pl_print_env_info.tar.gz"
+            archive_path = os.path.join(output_dir, archive_name)
+
+            file_paths = [
+                self.pl_print_file_env_path,
+                self.pl_print_file_move_env_path,
+                self.pl_print_temperature_env_path,
+                self.pl_print_flow_and_speed_factor_env_path,
+                self.pl_print_pressure_advance_env_path,
+                self.pl_print_layer_info_env_path,
+                self.pl_print_fan_info_env_path,
+                self.pl_print_z_adjust_position_env_path,
+                *[self.pl_print_file_move_env_path.replace('.json', f'_{i}.json')
+                    for i in range(self.max_file_count)]
+            ]
+
+            logging.info("Starting environment backup...")
+            if not os.path.exists(output_dir):
+                os.makedirs(output_dir)
+                logging.info(f"Created output directory: {output_dir}")
+
+            if os.path.exists(archive_path):
+                try:
+                    os.remove(archive_path)
+                    logging.info(f"Removed existing archive: {archive_path}")
+                except Exception as e:
+                    logging.error(f"Failed to remove existing archive: {e}")
+                    return
+
+            valid_files = []
+            for fpath in file_paths:
+                if os.path.exists(fpath):
+                    valid_files.append(fpath)
+
+            if not valid_files:
+                logging.warning("No valid files to backup.")
+                return
+
+            try:
+                with tarfile.open(archive_path, "w:gz") as tar:
+                    for fpath in valid_files:
+                        arcname = os.path.basename(fpath)
+                        tar.add(fpath, arcname=arcname)
+                    logging.info(f"Backup created at: {archive_path}")
+            except Exception as e:
+                logging.error(f"Error creating tar.gz archive: {e}")
+
+        except Exception as e:
+            logging.error(f"Unexpected error during backup process: {e}")
+
+    def power_loss_info_check(self):
+        if self.pl_switch:
+            if not os.path.exists(self.pl_print_file_env_path):
+                return (False, None)
+            try:
+                env_flag = None
+                with open(self.pl_print_file_env_path, 'r') as f:
+                    data = json.load(f)
+                    env_flag = data.get('env_flag')
+                save_stepper_info = {}
+                for name, obj in self.printer.lookup_objects('power_loss_check'):
+                    if 'env_flag' in obj.pl_flash_valid and obj.pl_flash_valid['env_flag'] == env_flag:
+                        save_stepper_info.update(obj.pl_flash_save_data)
+                return (True, save_stepper_info)
+            except Exception as e:
+                logging.exception("Failed to read power loss info file")
+                return (False, None)
+
+    def process_gcode_line(self, line):
+        if not self.pl_switch:
+            return line
+        fan_state = {}
+        stripped_line = line.rstrip("\r\n").lstrip()
+        if stripped_line.startswith(("M106", "M107")):
+            param_list = [" S", " P0", " P1", " P2"]
+            is_m107 = stripped_line.startswith("M107")
+            cmd_prefix = f"M10{'7' if is_m107 else '6'}"
+            for param in param_list:
+                target_prefix = f"{cmd_prefix}{param}"
+                if stripped_line.startswith(target_prefix):
+                    key = f"M106{param}"
+                    value = f"M106{param} S0" if is_m107 else stripped_line
+                    # self.fan_state[key] = value
+                    fan_state[key] = value
+                    break
+            else:
+                if is_m107:
+                    fan_state["M106 S"] = "M106 S0"
+                    # self.fan_state["M106 S"] = "M106 S0"
+            if fan_state:
+                self.record_pl_print_fan_env(fan_state)
+        elif stripped_line.startswith(("M600", "PAUSE")):
+            self.pl_allow_save_env = False
+        return line
+
+    def record_pl_print_fan_env(self, data_dict={}, force_update=False, sync=False, flush=True, safe_write=True):
+        if not self._valid_power_loss_condition():
+            return
+        fan_state = {}
+        if force_update:
+            fan_info =  {
+                            'M106 S':  ['fan', 'M106', 'speed'],
+                            "M106 P2": ['fan_generic cavity_fan', 'M106 P2', 'speed'],
+                            "M106 P3": ['purifier', 'M106 P3', 'fan_speed'],
+                        }
+            for key in fan_info.keys():
+                fan_obj = self.printer.lookup_object(fan_info[key][0], None)
+                # self.gcode.respond_info("fan key: {}".format(key))
+                if fan_obj is not None:
+                    curtime = self.reactor.monotonic()
+                    fan_sta = fan_obj.get_status(curtime)
+                    fan_value = int(fan_sta[fan_info[key][2]] * 255)
+                    fan_state[key] = fan_info[key][1] + ' S{}'.format(fan_value)
+        fan_state.update(data_dict)
+        self.save_environment_data(self.pl_print_fan_info_env_path, fan_state, sync, flush, safe_write)
+
+    def get_pl_print_fan_env(self):
+        if not os.path.exists(self.pl_print_fan_info_env_path):
+            return None
+        try:
+            # Read and parse file content
+            with open(self.pl_print_fan_info_env_path, 'r') as f:
+                file_content = f.read().strip()
+                if not file_content:
+                    return None
+                return json.loads(file_content)
+        except Exception as e:
+            logging.exception("Failed to read print_fan info from file")
+            return None
+
+    def wait_until_not_homing(self, timeout_retries=100, log_interval=20):
+        retry_count = 0
+        homing_xyz_override = self.printer.lookup_object('homing_xyz_override', None)
+        if homing_xyz_override is None:
+            return False
+
+        while homing_xyz_override.is_homing:
+            if retry_count >= timeout_retries:
+                self.gcode.respond_info("Timeout waiting for homing to complete!")
+                return False
+
+            if retry_count % log_interval == 0:
+                self.gcode.respond_info("Waiting for homing to complete...")
+
+            self.reactor.pause(self.reactor.monotonic() + 0.100)
+            retry_count += 1
+
+        return True
+
+    def record_pl_print_file_move_env(self, line, line_count, file_pos, sync=False, flush=True, safe_write=True):
+        need_save = False
+        if self.pl_switch and self.lines >= self.pl_next_save_line:
+            need_save = True
+            # if self.lines == self.pl_start_save_line or ((self.lines - self.pl_start_save_line) % self.pl_save_line_interval == 0):
+            #     need_save = True
+
+        if line.startswith("G28"):
+            need_save = True
+            # self.wait_until_not_homing()
+
+        curtime = self.reactor.monotonic()
+        toolhead = self.printer.lookup_object('toolhead')
+        homed_axes_list = str(toolhead.get_kinematics().get_status(curtime)['homed_axes'])
+        if (not ('x' in homed_axes_list and 'y' in homed_axes_list and 'z' in homed_axes_list)):
+            need_save = False
+
+        extruder_gcode_id = None
+        if need_save:
+            extruder = toolhead.get_extruder()
+            file_path = self.pl_print_file_move_env_path.replace(
+                '.json', f'_{self.current_file_index}.json')
+            if hasattr(extruder, 'gcode_id'):
+                extruder_gcode_id = extruder.gcode_id
+            homing_stepper_z_info = None
+            homing_xyz_override = self.printer.lookup_object('homing_xyz_override', None)
+            if homing_xyz_override is not None:
+                homing_stepper_z_info = homing_xyz_override.homing_stepper_z_info
+            data = {
+                'file_pos': file_pos,
+                'line_count': line_count,
+                'line': line,
+                'extruder': extruder_gcode_id,
+                'speed': self.gcode_move._get_gcode_speed(),
+                'max_accel':toolhead.max_accel,
+                'min_cruise_ratio':toolhead.min_cruise_ratio,
+                'square_corner_velocity':toolhead.square_corner_velocity,
+                'absolute_coord': self.gcode_move.absolute_coord,
+                'absolute_extrude': self.gcode_move.absolute_extrude,
+                'toolhead_pos': list(toolhead.get_position()),
+                'base_position': list(self.gcode_move.base_position),
+                'last_position': list(self.gcode_move.last_position),
+                'homing_position': list(self.gcode_move.homing_position),
+                'homing_stepper_z_info': homing_stepper_z_info,
+            }
+            self.pl_next_save_line += self.pl_save_line_interval
+            self.save_environment_data(file_path, data, sync, flush, safe_write)
+            self.current_file_index = (self.current_file_index + 1) % self.max_file_count
+
+    def parse_power_loss_move_env(self, validate_only=False):
+        file_path = None
+        if not os.path.exists(self.pl_print_file_env_path):
+            raise self.printer.command_error("power loss file not found")
+
+        check_result = self._update_mcu_flash_valid_line()
+        if self.pl_mcu_flash_valid_line == 0xFFFFFFFF:
+            raise self.printer.command_error("mcu_flash_valid_line is 0xFFFFFFFF, no need to recover")
+
+        if self.pl_mcu_flash_stepper_z_pos == 0xFFFFFFFF:
+            raise self.printer.command_error("mcu_flash_stepper_z_pos is 0xFFFFFFFF, no need to recover")
+
+        try:
+            with open(self.pl_print_file_env_path, 'r') as f:
+                env_data = json.load(f)
+                file_path = env_data.get('file_path')
+                if not file_path:
+                    raise self.printer.command_error("No file_path found in power loss env file")
+        except Exception as e:
+            raise self.printer.command_error(f"Failed to parse power loss env file: {e}")
+
+        last_file_index, pl_save_data = self.pl_find_latest_move_env(self.pl_mcu_flash_valid_line)
+        if last_file_index is None:
+            raise self.printer.command_error("No valid move_env file was found")
+
+        required_params = [
+            'file_pos', 'line_count', 'line','extruder',
+            'speed', 'max_accel', 'min_cruise_ratio', 'square_corner_velocity',
+            'absolute_extrude', 'toolhead_pos', 'base_position','last_position',
+            'homing_position','homing_stepper_z_info',
+        ]
+
+        for param in required_params:
+            if param not in pl_save_data:
+                raise self.printer.command_error(
+                    "Missing required parameter in pl_save_data: {}".format(param))
+
+        if validate_only:
+            required_keys = ['stepper_z_pos', 'z_pos', 'dir_inverted', 'step_dist']
+            homing_stepper_z_info = pl_save_data.get('homing_stepper_z_info')
+            if homing_stepper_z_info is None:
+                raise self.printer.command_error("homing_stepper_z_info is None or miss")
+            missing_keys = [key for key in required_keys if key not in homing_stepper_z_info]
+            if missing_keys:
+                raise self.printer.command_error("the saved homing_stepper_z_info data is abnormal")
+            return True
+
+        try:
+            current_line = None
+            first_read = True
+            target_line = self.pl_mcu_flash_valid_line
+            last_file_pos = cur_file_pos = pl_save_data['file_pos']
+            gcode_tracker = GCodeStateTracker(self.printer, pl_save_data)
+            factors = self.get_pl_print_flow_and_speed_factor()
+            logging.info("factors: {}".format(factors))
+            gcode_tracker.set_factors(factors['flow_factor'], factors['speed_factor'], factors['speed_factor_bak'])
+            gcode_tracker.set_print_task_config(self.print_task_config)
+            with io.open(file_path, 'r', newline='') as f:
+                f.seek(pl_save_data['file_pos'])
+                current_line = pl_save_data['line_count']
+                while current_line <= target_line:
+                    line = f.readline()
+                    last_file_pos = cur_file_pos
+                    cur_file_pos = f.tell()
+                    if not line:  # EOF
+                        break
+                    if first_read == False:
+                        gcode_tracker.update_position(line)
+                        current_line += 1
+                    else:
+                        first_read = False
+                    if current_line == target_line:
+                        power_loss_run_gcode_info = gcode_tracker._parse_gcode_line(line)
+                        # self.gcode.respond_info("gcode_tracker target_line: {}".format(parse_gcode))
+                        # self.gcode.respond_info("gcode_tracker:\ncurrent_line: {}, cur_file_pos: {} last_file_pos: {}".format(current_line, cur_file_pos, last_file_pos))
+                        # self.gcode.respond_info("last_position: {}, base_position: {}".format(gcode_tracker.last_position, gcode_tracker.base_position))
+                        return {
+                                    'file_path': file_path,
+                                    'gcode_tracker': gcode_tracker,
+                                    'power_loss_run_gcode_info': power_loss_run_gcode_info,
+                                    'current_line': current_line,
+                                    'cur_file_pos': cur_file_pos,
+                                    'last_file_pos': last_file_pos,
+                                    'homing_stepper_z_info': pl_save_data['homing_stepper_z_info'],
+                                    'last_move_file_index': last_file_index,
+                                    'pl_save_data': pl_save_data,
+                               }
+        except Exception as e:
+            logging.exception("Failed to locate line by number")
+            raise self.printer.command_error(f"Line location error: {str(e)}")
+
+
+    def pl_find_latest_move_env(self, line_cnt):
+        last_file_index = None
+        pl_save_data = None
+        min_diff = float('inf')
+        for i in range(self.max_file_count):
+            file_path = self.pl_print_file_move_env_path.replace('.json', f'_{i}.json')
+            try:
+                if os.path.exists(file_path):
+                    with open(file_path, 'r') as f:
+                        content = json.load(f)
+                        file_line_cnt = content.get('line_count', 0)
+                        diff = line_cnt - file_line_cnt
+                        if diff >= 0 and diff < min_diff:
+                            min_diff = diff
+                            last_file_index = i
+                            pl_save_data = content
+            except Exception as e:
+                logging.warning(f"Error reading file {file_path}: {e}")
+                continue
+        return (last_file_index, pl_save_data) if last_file_index is not None else (None, None)
+
+    def force_refresh_move_env_extruder(self, extruder_name, sync=False, flush=True, safe_write=True):
+        msm = self.printer.lookup_object('machine_state_manager', None)
+        if msm is not None:
+            state_str = str(msm.get_status()['main_state'])
+            if state_str != "PRINTING":
+                raise self.printer.command_error("Cannot refresh move environment while not in printing state")
+
+        if self.print_stats.state != 'paused':
+            raise self.printer.command_error("Cannot refresh move environment while not paused")
+
+        extruder = self.printer.lookup_object(extruder_name, None)
+        if extruder is None:
+            raise self.printer.command_error("Cannot refresh move environment without {}".format(extruder_name))
+
+        mcu_max_line = None
+        for name, obj in self.printer.lookup_objects('power_loss_check'):
+            params = obj.query_power_loss_stepper_info()
+            if params is not None:
+                for stepper_info in params.values():
+                    line = stepper_info.get("line", 0xFFFFFFFF)
+                    if line != 0xFFFFFFFF:
+                        if mcu_max_line is None:
+                            mcu_max_line = line
+                        elif mcu_max_line < line:
+                            mcu_max_line = line
+
+        min_line = min(self.lines, mcu_max_line) if mcu_max_line is not None else self.lines
+        last_file_index, pl_save_data = self.pl_find_latest_move_env(min_line)
+        if last_file_index is None:
+            logging.info("No move environment file found")
+            return
+
+        state = self.gcode_move.saved_states.get("PAUSE_STATE", None)
+        if state is None:
+            raise self.printer.command_error("PAUSE_STATE not found")
+
+        state_copy = copy.deepcopy(state)
+        toolhead = self.printer.lookup_object('toolhead')
+        extruder_switch_gcode = None
+        if hasattr(extruder, 'gcode_id'):
+            extruder_switch_gcode = extruder.gcode_id
+
+        if pl_save_data.get("line_count", 0xFFFFFFFF) != self.lines:
+            _pl_save_data = copy.deepcopy(pl_save_data)
+            _pl_save_data['file_pos'] = self.file_position
+            _pl_save_data['line_count'] = min_line
+            _pl_save_data['line'] = self.current_line_gcode
+            if state_copy.get('gcode_id', None) is not None:
+                _pl_save_data['extruder'] = state_copy['gcode_id']
+            _pl_save_data['speed'] = state_copy['speed'] / state_copy['speed_factor']
+            _pl_save_data['max_accel'] = state_copy['accel']
+            _pl_save_data['min_cruise_ratio'] = toolhead.min_cruise_ratio
+            _pl_save_data['square_corner_velocity'] = toolhead.square_corner_velocity
+            _pl_save_data['absolute_coord'] = state_copy['absolute_coord']
+            _pl_save_data['absolute_extrude'] = state_copy['absolute_extrude']
+            _pl_save_data['homing_position'] = state_copy['homing_position']
+            _pl_save_data['base_position'] = state_copy['base_position']
+            _pl_save_data['last_position'] = state_copy['last_position']
+            data = _pl_save_data
+        else:
+            data = pl_save_data
+        gcode_tracker = GCodeStateTracker(self.printer, data)
+        if extruder_switch_gcode is not None:
+            gcode_tracker.update_position(extruder_switch_gcode)
+            data['extruder'] = extruder_switch_gcode
+        data['homing_position'] = gcode_tracker.homing_position
+        data['base_position'] = gcode_tracker.base_position
+        data['last_position'] = gcode_tracker.last_position
+        self.gcode.respond_info("Restored G-Code state: {}".format(data))
+        move_env_path = self.pl_print_file_move_env_path.replace('.json', f'_{last_file_index}.json')
+        self.rm_power_loss_move_env_file()
+        self.save_environment_data(move_env_path, data, sync, flush, safe_write)
+        self.current_file_index = (last_file_index + 1) % self.max_file_count
+
+    def rm_power_loss_move_env_file(self, save_file_list=[]):
+        failed_files = []
+        total_removed = 0
+        try:
+            for i in range(self.max_file_count):
+                file_path = self.pl_print_file_move_env_path.replace('.json', f'_{i}.json')
+                if not os.path.exists(file_path):
+                    continue
+
+                if not save_file_list or i not in save_file_list:
+                    try:
+                        queuefile.sync_delete_file(self.printer.get_reactor(), file_path)
+                        total_removed += 1
+                        # logging.info(f"Removed move env file: {file_path}")
+                    except Exception as e:
+                        failed_files.append(file_path)
+                        logging.error(f"Failed to remove move env file {file_path}: {e}")
+                        continue
+            logging.info(f"rm_power_loss_move_env completed, removed {total_removed} files")
+
+            if failed_files:
+                logging.error(f"Failed to remove {len(failed_files)} files: {', '.join(failed_files)}")
+
+        except Exception as e:
+            logging.error(f"Unexpected error in rm_power_loss_move_env: {e}")
+    def save_environment_data(self, file_path, data_dict={}, sync=False, flush=True, safe_write=True):
+        if not data_dict:
+            return True
+        existing_data = {}
+        if os.path.exists(file_path):
+            try:
+                with open(file_path, 'r') as f:
+                    existing_data = json.load(f)
+            except Exception as e:
+                logging.exception(f"Failed to read environment file: {file_path}")
+                return False
+
+        existing_data.update(data_dict)
+
+        try:
+            json_content = json.dumps(existing_data, indent=4)
+            if sync:
+                queuefile.sync_write_file(self.printer.get_reactor(), file_path, json_content,
+                                        flush=flush, safe_write=safe_write)
+            else:
+                queuefile.async_write_file(file_path, json_content,
+                                         flush=flush, safe_write=safe_write)
+            return True
+        except Exception as e:
+            logging.exception(f"Failed to write environment file: {file_path}")
+            return False
+
+    def _valid_power_loss_condition(self):
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if not (self.pl_switch and print_stats and print_stats.state == 'printing' and self.pl_allow_save_env == True):
+            return False
+        return True
+
+    def record_pl_print_temperature_env(self, data_dict={}, force_update=False, ignore_pl_condition=False, sync=False, flush=True, safe_write=True):
+        if not ignore_pl_condition and not self._valid_power_loss_condition():
+            return
+
+        temp_data = {}
+        rec_extrusion_temp = {}
+        if force_update:
+            pheaters = self.printer.lookup_object('heaters', None)
+            if pheaters is not None:
+                for name, heater in pheaters.heaters.items():
+                    status = heater.get_status(self.reactor.monotonic())
+                    temp_data[name] = status['target']
+        temp_data.update(data_dict)
+        for key in temp_data.keys():
+            if key.startswith("extruder"):
+                extruder = self.printer.lookup_object(key, None)
+                if (extruder is not None and hasattr(extruder, 'heater') and
+                    (extruder.heater.min_extrude_temp + 10 <= temp_data[key]) and
+                    hasattr(extruder, 'gcode_id')):
+                    rec_extrusion_temp[extruder.gcode_id] = temp_data[key]
+        temp_data.update(rec_extrusion_temp)
+        self.save_environment_data(self.pl_print_temperature_env_path, temp_data, sync, flush, safe_write)
+
+    def get_pl_print_temperature_env(self):
+        pheaters = self.printer.lookup_object('heaters', None)
+        current_heaters = []
+        if pheaters is not None:
+            current_heaters = [name for name, obj in pheaters.heaters.items()]
+        result = {name: 0 for name in current_heaters}
+        saved_temps = {}
+        if not os.path.exists(self.pl_print_temperature_env_path):
+            return (result, saved_temps)
+        try:
+            with open(self.pl_print_temperature_env_path, 'r') as f:
+                saved_temps = json.load(f)
+
+            for name in current_heaters:
+                if name in saved_temps:
+                    result[name] = saved_temps[name]
+        except Exception as e:
+            saved_temps = {}
+            logging.exception("Failed to read temperature info, error: {}".format(str(e)))
+        return (result, saved_temps)
+
+    def record_pl_print_flow_and_speed_factor(self, data_dict={}, force_update=False, sync=False, flush=True, safe_write=True):
+        if not self._valid_power_loss_condition():
+            return
+        temp_data = {}
+        if force_update:
+            temp_data['speed_factor'] = self.gcode_move.speed_factor
+            temp_data['flow_factor'] = self.gcode_move.extrude_factor
+            temp_data['speed_factor_bak'] = self.gcode_move.speed_factor_bak
+        temp_data.update(data_dict)
+        self.save_environment_data(self.pl_print_flow_and_speed_factor_env_path, temp_data, sync, flush, safe_write)
+
+    def get_pl_print_flow_and_speed_factor(self):
+        if not os.path.exists(self.pl_print_flow_and_speed_factor_env_path):
+            return {'speed_factor': None, 'flow_factor': None, 'speed_factor_bak': None}
+        try:
+            with open(self.pl_print_flow_and_speed_factor_env_path, 'r') as f:
+                data = json.load(f)
+                speed = data.get('speed_factor') if isinstance(data, dict) else None
+                flow = data.get('flow_factor') if isinstance(data, dict) else None
+                speed_bak = data.get('speed_factor_bak') if isinstance(data, dict) else None
+                return {'speed_factor': speed, 'flow_factor': flow, 'speed_factor_bak': speed_bak}
+        except Exception as e:
+            logging.exception("Failed to read flow and speed factor info, error: {}".format(str(e)))
+            return {'speed_factor': None, 'flow_factor': None, 'speed_factor_bak': None}
+
+    def record_pl_print_pressure_advance(self, data_dict={}, force_update=False, sync=False, flush=True, safe_write=True):
+        if not self._valid_power_loss_condition():
+            return
+        data_dict_load = {}
+        if force_update:
+            extruder_list = self.printer.lookup_object('extruder_list', [])
+            for i in range(len(extruder_list)):
+                if hasattr(extruder_list[i], 'extruder_stepper') and extruder_list[i].extruder_stepper is not None:
+                    extruder_stepper = extruder_list[i].extruder_stepper
+                    key = extruder_stepper.name
+                    value = [extruder_stepper.pressure_advance, extruder_stepper.pressure_advance_smooth_time]
+                    data_dict_load.update({key: value})
+        data_dict_load.update(data_dict)
+        self.save_environment_data(self.pl_print_pressure_advance_env_path, data_dict_load, sync, flush, safe_write)
+
+    def get_pl_print_pressure_advance(self):
+        if not os.path.exists(self.pl_print_pressure_advance_env_path):
+            return None
+
+        try:
+            with open(self.pl_print_pressure_advance_env_path, 'r') as f:
+                saved_data = json.load(f)
+                if not isinstance(saved_data, dict):
+                    return None
+
+                extruder_steppers = []
+                for extruder in self.printer.lookup_object('extruder_list', []):
+                    if hasattr(extruder, 'extruder_stepper') and extruder.extruder_stepper is not None:
+                        extruder_steppers.append(extruder.extruder_stepper.name)
+
+                return {k: v for k, v in saved_data.items() if k in extruder_steppers}
+
+        except json.JSONDecodeError:
+            logging.error("Invalid JSON in pressure advance file")
+        except Exception as e:
+            logging.error("Failed to read pressure advance: %s", str(e))
+        return None
+
+    def record_pl_print_layer_info(self, data_dict={}, sync=False, flush=True, safe_write=True):
+        if not self._valid_power_loss_condition():
+            return
+        self.save_environment_data(self.pl_print_layer_info_env_path, data_dict, sync, flush, safe_write)
+
+    def get_pl_print_layer_info(self):
+        if self.pl_switch:
+            if not os.path.exists(self.pl_print_layer_info_env_path):
+                return None
+            try:
+                with open(self.pl_print_layer_info_env_path, 'r') as f:
+                    data = json.load(f)
+                return data
+            except Exception as e:
+                logging.exception("Failed to read power loss layer info file")
+                return None
+
+    def flush_pl_print_env(self):
+        self.record_pl_print_fan_env(force_update=True)
+        self.record_pl_print_temperature_env(force_update=True)
+        self.record_pl_print_flow_and_speed_factor(force_update=True)
+        self.record_pl_print_pressure_advance(force_update=True)
+
+    def record_power_loss_info(self, interval_start_time, interval_end_time):
+        if self.pl_switch and self.lines >= self.pl_notify_start_line:
+            if self.lines == self.pl_notify_start_line:
+                self.notify_mcu_enable_power_loss(1, self.pl_mcu_flash_resume_line)
+                self.record_pl_print_file_env(self.current_file.name, self.get_pl_env_flag()[0])
+                self.flush_pl_print_env()
+                interval_start_time = interval_end_time
+
+            if interval_end_time-interval_start_time > 15:
+                interval_start_time = interval_end_time
+                self.record_pl_print_file_env(self.current_file.name, self.get_pl_env_flag()[0])
+        return interval_start_time, interval_end_time
+
+    def record_pl_print_z_adjust_position(self, adjust_position, sync=False, flush=True, safe_write=True):
+        data = {}
+        if os.path.exists(self.pl_print_z_adjust_position_env_path):
+            try:
+                with open(self.pl_print_z_adjust_position_env_path, 'r') as f:
+                    file_content = f.read().strip()
+                    if file_content:
+                        try:
+                            data = json.loads(file_content)
+                        except json.JSONDecodeError:
+                            self.gcode.respond_info(
+                                "Warning: Invalid JSON in z_adjust_position file, resetting data")
+                            data = {}
+            except Exception as e:
+                self.gcode.respond_info(
+                    f"Warning: Failed to read z_adjust_position file: {str(e)}")
+                data = {}
+        if 'z_adjust_position' in data:
+            data['z_adjust_position'] += adjust_position
+        else:
+            data['z_adjust_position'] = adjust_position
+        self.save_environment_data(self.pl_print_z_adjust_position_env_path, data, sync, flush, safe_write)
+
+    def get_pl_print_z_adjust_position(self):
+        try:
+            if not os.path.exists(self.pl_print_z_adjust_position_env_path):
+                return 0.0
+            with open(self.pl_print_z_adjust_position_env_path, 'r') as f:
+                data = json.load(f)
+            return float(data.get('z_adjust_position', 0.0))
+        except Exception as e:
+            return 0.0
+
+    def rm_pl_print_z_adjust_position(self):
+        try:
+            if os.path.exists(self.pl_print_z_adjust_position_env_path):
+                os.remove(self.pl_print_z_adjust_position_env_path)
+                logging.info("Removed z_adjust_position file: %s",
+                            self.pl_print_z_adjust_position_env_path)
+        except Exception as e:
+            logging.error("Failed to remove z_adjust_position file: %s", str(e))
+
+    def flush_pl_z_homing_stepper_z_info(self, z_offset=0):
+        toolhead = self.printer.lookup_object('toolhead')
+        toolhead.wait_moves()
+        kin = toolhead.get_kinematics()
+        steppers = kin.get_steppers()
+        stepper_mcu_pos = [s.get_mcu_position() for s in steppers]
+        z_pos = toolhead.get_position()[2]
+        homing_xyz_override = self.printer.lookup_object('homing_xyz_override', None)
+        if homing_xyz_override is not None:
+            homing_xyz_override.homing_stepper_z_info = {
+                    'stepper_z_pos': stepper_mcu_pos[2],
+                    'z_pos': z_pos - z_offset,
+                    'dir_inverted': kin.rails[2].get_steppers()[0].get_dir_inverted()[0],
+                    'step_dist':  kin.rails[2].get_steppers()[0].get_step_dist(),
+                }
+            return homing_xyz_override.homing_stepper_z_info
+
+    def to_relative_path(self, full_path, base_dir):
+        if full_path.startswith(base_dir):
+            return os.path.relpath(full_path, base_dir)
+        return full_path
+
+    def pl_bed_mesh_restore(self):
+        homing_xyz_override = self.printer.lookup_object('homing_xyz_override', None)
+        if homing_xyz_override is None:
+            return
+        homing_xyz_override._load_bed_mesh_profile()
+    def restore_print(self):
+        msm = self.printer.lookup_object('machine_state_manager', None)
+        self.print_task_config = self.printer.lookup_object('print_task_config', None)
+        try:
+            if msm is not None:
+                self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=PRINTING ACTION=PRINT_PL_RESTORE")
+
+            env = self.parse_power_loss_move_env()
+            if env is None:
+                err_msg = "restore_print failed, environmental prerequisites not met"
+                logging.info(err_msg)
+                raise self.printer.command_error("restore_print failed: {}".format(err_msg))
+
+            gcode_tracker = env['gcode_tracker']
+            power_loss_run_gcode_info = env['power_loss_run_gcode_info']
+            current_line = env['current_line']
+            cur_file_pos = env['cur_file_pos']
+            last_file_pos = env['last_file_pos']
+            last_move_file_index = env['last_move_file_index']
+            pl_save_data = env['pl_save_data']
+            resum_gcode_position = [
+                last - base
+                for last, base in zip(gcode_tracker.last_position, gcode_tracker.base_position)
+            ]
+
+            self.gcode.respond_info("current_line: {}".format(current_line))
+            self.gcode.respond_info("cur_file_pos: {}".format(cur_file_pos))
+            self.gcode.respond_info("last_file_pos: {}".format(last_file_pos))
+            self.gcode.respond_info("extruder_id: {}".format(gcode_tracker.extruder_gcode_id))
+            self.gcode.respond_info("gcode_tracker last_position: \n{}".format(gcode_tracker.last_position))
+            self.gcode.respond_info("gcode_tracker base_position: {}".format(gcode_tracker.base_position))
+            self.gcode.respond_info("gcode_tracker homing_position: {}".format(gcode_tracker.homing_position))
+            self.gcode.respond_info("power_loss_run_gcode_info: {}".format(power_loss_run_gcode_info))
+            self.gcode.respond_info("last_move_file_index: {}".format(last_move_file_index))
+            self.gcode.respond_info("resum_gcode_position: {}".format(resum_gcode_position))
+            self.gcode.respond_info("gcode_tracker.extrude_factor {}".format(gcode_tracker.extrude_factor))
+            self.gcode.respond_info("gcode_tracker.speed_factor {}".format(gcode_tracker.speed_factor))
+            self.gcode.respond_info("gcode_tracker.speed_factor_bak {}".format(gcode_tracker.speed_factor_bak))
+            self.gcode.respond_info("gcode_tracker.speed {}".format(gcode_tracker.speed))
+
+            self.gcode.respond_info("power_loss start do_resume...")
+            self.gcode.respond_info("power_loss start print, filename:%s" % env['file_path'])
+
+            toolhead = self.printer.lookup_object('toolhead')
+            pl_temp_env_info, all_temp_env = self.get_pl_print_temperature_env()
+            self.gcode.respond_info("pl_temp_env_info : {}\nall_temp_env: {}".format(pl_temp_env_info, all_temp_env))
+            bed_temp = pl_temp_env_info.get("heater_bed", 0.0)
+            self.gcode.respond_info("power_loss do_resume heater bed: {}".format(bed_temp))
+            self.gcode.run_script_from_command("M140 S{}".format(bed_temp))
+
+            extruder_list = self.printer.lookup_object('extruder_list', [])
+            extruder_temps = {}
+            for extruder in extruder_list:
+                name = extruder.get_name()
+                if not hasattr(extruder, 'gcode_id') or not name:
+                    continue
+                temp = pl_temp_env_info.get(name, 0.0)
+                extruder_temps[name] = {'gcode_id': extruder.gcode_id, 'temp': temp}
+
+            if len(extruder_temps) > 0:
+                extruder_gcode_id = gcode_tracker.extruder_gcode_id
+                activate_status = toolhead.get_extruder().get_extruder_activate_status()
+                if activate_status[0][1] == 0:
+                    extruder = self.printer.lookup_object(activate_status[0][0], None)
+                    if extruder is not None:
+                        curtime = self.printer.get_reactor().monotonic()
+                        status = extruder.get_status(curtime)
+                        if status['temperature'] + 2 < self.pl_z_hop_temp:
+                            self.gcode.respond_info("power_loss do_resume preheat {}: {}".format(extruder.name, self.pl_z_hop_temp))
+                            self.gcode.run_script_from_command("M109 {} S{} A0".format(extruder.gcode_id, self.pl_z_hop_temp))
+
+            self.gcode.respond_info("power_loss do_resume G28 X Y")
+            z_adjust_position = self.get_pl_print_z_adjust_position()
+            z_info = env['homing_stepper_z_info']
+            homing_xyz_override = self.printer.lookup_object('homing_xyz_override', None)
+            z_hop = homing_xyz_override.z_hop if homing_xyz_override is not None else None
+            if z_info is not None and self.pl_mcu_flash_stepper_z_pos != 0xFFFFFFFF:
+                direction = -1 if z_info['dir_inverted'] else 1
+                pl_save_z_pos = (self.pl_mcu_flash_stepper_z_pos - z_info["stepper_z_pos"])*z_info['step_dist']*direction + z_info['z_pos']
+                cal_z_postion =  pl_save_z_pos + z_adjust_position
+
+                if homing_xyz_override is not None:
+                    homing_z_position = cal_z_postion + (z_hop if z_hop is not None else 0)
+                    if homing_z_position > self.z_max_travel:
+                        adjusted_z_hop = round(self.z_max_travel - cal_z_postion, 2)
+                        z_hop = max(0.0, min(homing_xyz_override.z_hop, adjusted_z_hop))
+                        self.gcode.respond_info("Z position would exceed max travel. Adjusting z_hop from {} to {}".format(homing_xyz_override.z_hop, z_hop))
+                self.gcode.respond_info("cal_z_postion: {}".format(cal_z_postion))
+            else:
+                raise self.printer.command_error("Invalid z_info or stepper position data")
+
+            gcode_cmd = "G28 X Y PL_SAVE_Z_HOP 1"
+            if z_hop is not None:
+                gcode_cmd += " Z_HOP {}".format(z_hop)
+            self.gcode.run_script_from_command(gcode_cmd)
+            self.gcode.run_script_from_command("{} A0".format(gcode_tracker.extruder_gcode_id))
+            toolhead.wait_moves()
+
+            cur_extruder = toolhead.get_extruder()
+            activate_status = cur_extruder.get_extruder_activate_status()
+            if activate_status[0][1] == 0 and cur_extruder.name == activate_status[0][0]:
+                pass
+            else:
+                raise self.printer.command_error("pre-extrude err, Abnormal activate_status: {}, cur_extruder: {}".format(
+                        activate_status[0], cur_extruder.name))
+            self.gcode.run_script_from_command("{}".format(self.move_extrude_macro))
+            toolhead.wait_moves()
+            use_realtime_temp = (power_loss_run_gcode_info.get('cmd', '') in USE_REALTIME_TEMP_GCODE)
+            # self.gcode.respond_info("use_realtime_temp: {}".format(use_realtime_temp))
+            for key in extruder_temps.keys():
+                gcode_id = extruder_temps[key]['gcode_id']
+                if gcode_id == gcode_tracker.extruder_gcode_id and gcode_id in all_temp_env and not use_realtime_temp:
+                    temp = all_temp_env[gcode_id]
+                    self.gcode.respond_info("{}: restore rec extrusion temp: {}".format(gcode_id, temp))
+                else:
+                    temp = extruder_temps[key]['temp']
+                self.gcode.respond_info("power_loss do_resume heat {}: {}".format(gcode_id, temp))
+                self.gcode.run_script_from_command("M104 {} S{} A0".format(gcode_id, temp))
+
+            self.gcode.respond_info("Restoring pressure advance parameters...")
+            pressure_advance_data = self.get_pl_print_pressure_advance()
+            if pressure_advance_data is not None:
+                for extruder in self.printer.lookup_object('extruder_list', []):
+                    extruder_name = extruder.get_name()
+                    if hasattr(extruder, 'extruder_stepper') and extruder.extruder_stepper is not None:
+                        stepper_name = extruder.extruder_stepper.name
+                        if stepper_name in pressure_advance_data:
+                            pa, smooth_time = pressure_advance_data[stepper_name]
+                            try:
+                                self.gcode.run_script_from_command(
+                                    "SET_PRESSURE_ADVANCE EXTRUDER=%s ADVANCE=%.6f SMOOTH_TIME=%.6f" %
+                                    (stepper_name, pa, smooth_time))
+                                self.gcode.respond_info(
+                                    "Restored pressure advance for %s: advance=%.6f, smooth_time=%.6f" %
+                                    (stepper_name, pa, smooth_time))
+                            except Exception as e:
+                                logging.error("Failed to restore pressure advance for %s: %s",
+                                            stepper_name, str(e))
+
+            self.gcode.respond_info("Restoring start fan")
+            fan_info = self.get_pl_print_fan_env()
+            if fan_info is not None:
+                for cmd in fan_info.values():
+                    self.gcode.run_script_from_command("{}".format(cmd))
+
+            heater_bed = self.printer.lookup_object('heater_bed', None)
+            if heater_bed is not None:
+                curtime = self.printer.get_reactor().monotonic()
+                status = heater_bed.get_status(curtime)
+                if status['temperature'] + 2 >= bed_temp:
+                    self.gcode.run_script_from_command("M140 S{}".format(bed_temp))
+                else:
+                    self.gcode.run_script_from_command("M190 S{}".format(bed_temp))
+            for key in extruder_temps.keys():
+                tmp_extruder = self.printer.lookup_object(key, None)
+                curtime = self.printer.get_reactor().monotonic()
+                # self.gcode.respond_info("key: {}".format(key))
+                # self.gcode.respond_info("tmp_extruder: {}".format(tmp_extruder))
+                if tmp_extruder is not None:
+                    status = tmp_extruder.get_status(curtime)
+                    gcode_id = extruder_temps[key]['gcode_id']
+                    temp = extruder_temps[key]['temp']
+                    if gcode_id == gcode_tracker.extruder_gcode_id and gcode_id in all_temp_env:
+                        if (temp < cur_extruder.heater.min_extrude_temp and
+                            all_temp_env[gcode_id] > cur_extruder.heater.min_extrude_temp and
+                            not use_realtime_temp):
+                            temp = all_temp_env[gcode_id]
+                    if status['temperature'] + 2 >= temp:
+                        self.gcode.run_script_from_command("M104 {} S{} A0".format(gcode_id, temp))
+                    else:
+                        self.gcode.run_script_from_command("M109 {} S{} A0".format(gcode_id, temp))
+
+            pos = toolhead.get_position()
+            z_adjust_position = self.get_pl_print_z_adjust_position()
+            # pl_save_z_pos = gcode_tracker.last_position[2]
+            z_info = env['homing_stepper_z_info']
+            if z_info is not None and self.pl_mcu_flash_stepper_z_pos != 0xFFFFFFFF:
+                direction = -1 if z_info['dir_inverted'] else 1
+                pl_save_z_pos = (self.pl_mcu_flash_stepper_z_pos - z_info["stepper_z_pos"])*z_info['step_dist']*direction + z_info['z_pos']
+                pos[2] =  pl_save_z_pos + z_adjust_position + self.pl_z_compensation_value
+                self.gcode.respond_info("pl_save_z_pos: {}, cal z pos: {}, resume z pos: {}!!!!".format(pl_save_z_pos, pl_save_z_pos + z_adjust_position, pos[2]))
+            else:
+                raise self.printer.command_error("Invalid z_info or stepper position data")
+            toolhead.set_position(pos, homing_axes=[2])
+            stepper_z_info = self.flush_pl_z_homing_stepper_z_info(self.pl_z_compensation_value)
+            pos = toolhead.get_position()
+            self.gcode.respond_info("after set position: {}".format(pos[2]))
+            self.pl_bed_mesh_restore()
+            self.gcode_move.base_position = gcode_tracker.base_position
+            self.gcode_move.homing_position = gcode_tracker.homing_position
+            self.rm_pl_print_z_adjust_position()
+            self.rm_power_loss_move_env_file()
+            move_env_path = self.pl_print_file_move_env_path.replace('.json', f'_{last_move_file_index}.json')
+            pl_save_data['homing_stepper_z_info'] = stepper_z_info
+            self.save_environment_data(move_env_path, pl_save_data)
+            # self.current_file_index = (last_move_file_index + 1) % self.max_file_count
+            self.notify_mcu_enable_power_loss(1, current_line)
+            file_env = self.get_pl_print_file_env()
+            file_env['env_flag'] = self.get_pl_env_flag()[0]
+            self.save_environment_data(self.pl_print_file_env_path, file_env)
+
+            self.gcode.respond_info("Restoring start pre-extrude")
+            pre_extrude = False
+            extra_retract_len = 0
+            curtime = self.printer.get_reactor().monotonic()
+            cur_extruder = toolhead.get_extruder()
+            status = cur_extruder.get_status(curtime)
+            can_extrude = (status.get('can_extrude') and cur_extruder.heater.min_extrude_temp < status['target'])
+            need_extrude = not (power_loss_run_gcode_info.get('cmd', '') in NO_PRE_EXTRUDE_COMMANDS)
+            self.gcode.run_script_from_command("M220 S100")
+            self.gcode.run_script_from_command("M221 S100")
+            self.gcode.run_script_from_command("M204 S10000")
+            if power_loss_run_gcode_info.get('cmd', '') in GENERIC_MOVE_GCODE:
+                params = power_loss_run_gcode_info.get('params', {})
+                origline = power_loss_run_gcode_info.get('origline', '')
+                extruded_length = gcode_tracker.get_float(origline, params, 'E', None)
+                if gcode_tracker.absolute_extrude == False and extruded_length is not None and extruded_length < 0:
+                    extra_retract_len = abs(extruded_length)
+                self.gcode.respond_info("extra_retract_len: {}, extruded_length: {}".format(extra_retract_len, extruded_length))
+            if can_extrude and need_extrude:
+                self.gcode.run_script_from_command("M83")
+                self.gcode.run_script_from_command("G0 E{} F{}".format(self.pl_pre_extrude_len, self.pl_speed_pre_extrude*60))
+                self.gcode.run_script_from_command("G0 E{} F{}".format(-1*(self.pl_retract+extra_retract_len), self.pl_speed_retract*60))
+                self.gcode.run_script_from_command("{}".format(self.after_extrude_macro))
+                pre_extrude = True
+
+            self.gcode.run_script_from_command(
+                f"SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY={gcode_tracker.square_corner_velocity} "
+                f"MINIMUM_CRUISE_RATIO={gcode_tracker.min_cruise_ratio}"
+            )
+
+            self.gcode_move.absolute_coord = True
+            self.gcode.respond_info("Restoring x y: {}".format(resum_gcode_position[0], resum_gcode_position[1]))
+            self.gcode.run_script_from_command("G0 Y{} F{}".format(resum_gcode_position[1], self.pl_speed_move*60))
+            self.gcode.run_script_from_command("G0 X{} F{}".format(resum_gcode_position[0], self.pl_speed_move*60))
+
+            self.gcode.respond_info("Restoring z: {}".format(resum_gcode_position[2]))
+            need_restore_z = True
+            if power_loss_run_gcode_info.get('cmd', '') == 'G28':
+                params = power_loss_run_gcode_info.get('params', {})
+                if 'Z' in params or (not {'X', 'Y', 'Z'} & params.keys()):
+                    need_restore_z = False
+            if need_restore_z:
+                self.gcode.run_script_from_command("G0 Z{} F{}".format(resum_gcode_position[2], self.pl_speed_resume_z*60))
+            toolhead.wait_moves()
+            # self.rm_pl_print_z_adjust_position()
+            # May cause the process to power-loss again and not be able to recover!!!
+            # self.rm_power_loss_move_env_file()
+            # stepper_z_info = self.flush_pl_z_homing_stepper_z_info()
+
+            if pre_extrude:
+                self.gcode.run_script_from_command("M83")
+                self.gcode.run_script_from_command("G0 E{} F{}".format(self.pl_unretract, self.pl_speed_unretract*60))
+            self.gcode.run_script_from_command("G92 E{}".format(resum_gcode_position[3]))
+
+            self.gcode_move.absolute_coord = gcode_tracker.absolute_coord
+            self.gcode_move.absolute_extrude = gcode_tracker.absolute_extrude
+
+            self.gcode_move.extrude_factor = gcode_tracker.extrude_factor
+            self.gcode_move.speed_factor = gcode_tracker.speed_factor
+            self.gcode_move.speed_factor_bak = gcode_tracker.speed_factor_bak
+            self.gcode_move.speed = gcode_tracker.speed
+            self.gcode.run_script_from_command("M204 S{}".format(gcode_tracker.max_accel))
+
+            if self.print_task_config is not None:
+                self.print_task_config.set_reprint_info()
+
+            if self.work_timer is not None:
+                raise self.printer.command_error("SD busy")
+
+            self._pl_recovery_reset_file(False)
+            relative_path = self.to_relative_path(env['file_path'], self.sdcard_dirname)
+            if relative_path.startswith('/'):
+                relative_path = relative_path[1:]
+            self._load_file(self.gcode, relative_path, check_subdirs=True, reprint=True)
+
+            skip_line = power_loss_run_gcode_info.get('cmd', '') in GENERIC_MOVE_GCODE
+            if skip_line:
+                self.file_position = env['cur_file_pos']
+                self.lines = env['current_line']
+            else:
+                self.lines = env['current_line'] - 1
+                self.file_position = env['last_file_pos']
+
+            self.pl_notify_start_line = self.lines + 1
+            self.pl_next_save_line = self.lines + self.pl_save_line_interval
+
+            # self.rm_power_loss_move_env_file()
+            # move_env_path = self.pl_print_file_move_env_path.replace('.json', f'_{last_move_file_index}.json')
+            # pl_save_data['homing_stepper_z_info'] = stepper_z_info
+            # self.save_environment_data(move_env_path, pl_save_data)
+            self.current_file_index = (last_move_file_index + 1) % self.max_file_count
+            # self.current_file_index = 0
+            self.pl_mcu_flash_resume_line = self.lines
+            self.gcode.respond_info("pl_mcu_flash_resume_line: {}".format(self.pl_mcu_flash_resume_line))
+            self.gcode.run_script_from_command("TIMELAPSE_START TYPE=continue")
+            self.do_resume()
+        except Exception as e:
+            self.gcode.respond_info("Failed to restore pl_print, error: {}".format(str(e)))
+            self.backup_print_env_info()
+            self.rm_power_loss_info()
+            self.notify_mcu_enable_power_loss(0, 0xFFFFFFFF)
+            if self.print_task_config is not None:
+                self.print_task_config.reset_print_info()
+            if msm is not None:
+                state_str = str(msm.get_status()['main_state'])
+                if state_str == "PRINTING":
+                    self.gcode.run_script_from_command("SET_MAIN_STATE MAIN_STATE=IDLE")
+            # raise restore error
+            str_err = self.printer.extract_coded_message_field(str(e))
+            error_msg = '{"coded": "0001-0531-0000-0005", "msg":"%s", "action": "none"}' % (
+                        "Failed to restore pl_print, %s" % (str_err))
+            raise self.printer.command_error(error_msg)
+            # self.printer.raise_structured_code_exception("0003-0531-0000-0005", error_msg)
+            # raise self.printer.command_error("restore_print failed: {}".format(err_msg))
+        finally:
+            pass
+
+class GCodeStateTracker:
+    def __init__(self, printer, initial_state):
+        self.state = initial_state
+        self.printer = printer
+        self.extrude_factor = 1
+        self.speed_factor = self.speed_factor_bak = 1. / 60.
+        self.print_task_config = None
+        self.speed = initial_state['speed'] * self.speed_factor
+        self.max_accel = initial_state['max_accel']
+        self.min_cruise_ratio = initial_state['min_cruise_ratio']
+        self.square_corner_velocity = initial_state['square_corner_velocity']
+        self.extruder_gcode_id = initial_state['extruder']
+        self.absolute_coord = initial_state['absolute_coord']
+        self.absolute_extrude = initial_state['absolute_extrude']
+        # self.toolhead_pos = initial_state['toolhead_pos']
+        self.base_position = initial_state['base_position']
+        self.last_position = initial_state['last_position']
+        self.homing_position = initial_state['homing_position']
+
+    class sentinel: pass
+    def get(self, gcmd, params, name, default=sentinel, parser=str,
+            minval=None, maxval=None, above=None, below=None):
+        if params is None:
+            raise self.printer.command_error("Params dictionary must be provided")
+        if name is None:
+            raise self.printer.command_error("Parameter name must be specified")
+
+        value = params.get(name.upper())
+        if value is None:
+            if default is self.sentinel:
+                raise self.printer.command_error(
+                    f"Error on '{gcmd}': missing {name}")
+            return default
+
+        try:
+            value = parser(value)
+        except:
+            raise self.printer.command_error(
+                f"Error on '{gcmd}': unable to parse {value}")
+
+        if minval is not None and value < minval:
+            raise self.printer.command_error(
+                f"Error on '{gcmd}': {name} must have minimum of {minval}")
+        if maxval is not None and value > maxval:
+            raise self.printer.command_error(
+                f"Error on '{gcmd}': {name} must have maximum of {maxval}")
+        if above is not None and value <= above:
+            raise self.printer.command_error(
+                f"Error on '{gcmd}': {name} must be above {above}")
+        if below is not None and value >= below:
+            raise self.printer.command_error(
+                f"Error on '{gcmd}': {name} must be below {below}")
+        return value
+
+    def get_int(self, gcmd, params, name, default=sentinel,
+               minval=None, maxval=None):
+        return self.get(gcmd, params, name, default, int, minval, maxval)
+
+    def get_float(self, gcmd, params, name, default=sentinel,
+                 minval=None, maxval=None, above=None, below=None):
+        return self.get(gcmd, params, name, default, float,
+                       minval, maxval, above, below)
+
+    def _get_gcode_speed(self):
+        return self.speed / self.speed_factor
+
+    def _parse_gcode_line(self, line):
+        line = origline = line.strip()
+        if not line or line.startswith(';'):
+            return {}
+
+        if ';' in line:
+            line = line.split(';', 1)[0].strip()
+
+        cmd_match = re.match(r'^([A-Z_]+\d*(?:\.\d+)?)', line, re.IGNORECASE)
+        if not cmd_match:
+            return {}
+        cmd = cmd_match.group(1).upper()
+        line = line[cmd_match.end():].strip()
+        tokens = re.findall(
+            r'([A-Z_]+)\s*=\s*([^=\s]*)|([A-Z_]+)([^=\s]*)',
+            line,
+            re.IGNORECASE
+        )
+
+        params = {}
+        for key1, value, key2, val2 in tokens:
+            key = (key1 or key2).upper()
+            val = (value or val2).strip() if (value or val2) else None
+            params[key] = val
+
+        return {'cmd': cmd, 'origline': origline, 'params': params}
+
+    def set_gcode_offset(self, line, params):
+        move_delta = [0., 0., 0., 0.]
+        for pos, axis in enumerate('XYZE'):
+            # offset = gcmd.get_float(axis, None)
+            offset = self.get_float(line, params, axis, None)
+            if offset is None:
+                # offset = gcmd.get_float(axis + '_ADJUST', None)
+                offset = self.get_float(line, params, axis + '_ADJUST', None)
+                if offset is None:
+                    continue
+                offset += self.homing_position[pos]
+            delta = offset - self.homing_position[pos]
+            move_delta[pos] = delta
+            self.base_position[pos] += delta
+            self.homing_position[pos] = offset
+
+    def update_position(self, line):
+        parsed = self._parse_gcode_line(line)
+        if not parsed:
+            return
+
+        cmd = parsed['cmd']
+        params = parsed['params']
+        line = parsed['origline']
+        # self.printer.lookup_object('gcode').respond_info('parsed line: {}'.format(parsed))
+        if cmd == 'M82':
+            self.absolute_extrude = True
+        elif cmd == 'M83':
+            self.absolute_extrude = False
+        elif cmd == 'G90':
+            self.absolute_coord = True
+        elif cmd == 'G91':
+            self.absolute_coord = False
+        elif cmd == 'G92':
+            offsets = [ self.get_float(line, params, a, None) for a in 'XYZE' ]
+            for i, offset in enumerate(offsets):
+                if offset is not None:
+                    if i == 3:
+                        offset *= self.extrude_factor
+                    self.base_position[i] = self.last_position[i] - offset
+            if offsets == [None, None, None, None]:
+                self.base_position = list(self.last_position)
+        elif cmd == 'M220':
+            # if 'B' in params:
+            #     self.speed_factor_bak = self.speed_factor
+
+            if 'R' in params:
+                value = self.speed_factor_bak
+                self.speed = self._get_gcode_speed() * value
+                self.speed_factor = self.speed_factor_bak
+
+            if 'S' in params:
+                value = self.get_float(line, params, 'S', 100., above=0.) / (60. * 100.)
+                self.speed = self._get_gcode_speed() * value
+                self.speed_factor = value
+        elif cmd == 'M221':
+            new_extrude_factor = self.get_float(line, params, 'S', 100., above=0.) / 100.
+            last_e_pos = self.last_position[3]
+            e_value = (last_e_pos - self.base_position[3]) / self.extrude_factor
+            self.base_position[3] = last_e_pos - e_value * new_extrude_factor
+            self.extrude_factor = new_extrude_factor
+        elif cmd == 'M204':
+            accel = self.get_float(line, params, 'S', None, above=0.)
+            if accel is None:
+                # Use minimum of P and T for accel
+                p = self.get_float(line, params, 'P', None, above=0.)
+                t = self.get_float(line, params, 'T', None, above=0.)
+                if p is None or t is None:
+                    return
+                accel = min(p, t)
+            self.max_accel = accel
+        elif cmd == 'SET_VELOCITY_LIMIT':
+            # max_velocity = self.get_float(cmd, line, 'VELOCITY', None, above=0.)
+            max_accel = self.get_float(line, params, 'ACCEL', None, above=0.)
+            square_corner_velocity = self.get_float(line, params,
+                'SQUARE_CORNER_VELOCITY', None, minval=0.)
+            min_cruise_ratio = self.get_float(line, params,
+                'MINIMUM_CRUISE_RATIO', None, minval=0., below=1.)
+            if min_cruise_ratio is None:
+                req_accel_to_decel = self.get_float(line, params, 'ACCEL_TO_DECEL',
+                                                    None, above=0.)
+                if req_accel_to_decel is not None and max_accel is not None:
+                    min_cruise_ratio = 1. - min(1., req_accel_to_decel / max_accel)
+                elif req_accel_to_decel is not None and max_accel is None:
+                    min_cruise_ratio = 1. - min(1., (req_accel_to_decel
+                                                    / self.max_accel))
+            # if max_velocity is not None:
+            #     self.max_velocity = max_velocity
+            if max_accel is not None:
+                self.max_accel = max_accel
+            if square_corner_velocity is not None:
+                self.square_corner_velocity = square_corner_velocity
+            if min_cruise_ratio is not None:
+                self.min_cruise_ratio = min_cruise_ratio
+        elif cmd == 'SET_GCODE_OFFSET':
+            self.set_gcode_offset(line, params)
+        elif cmd in TOOL_CHANGE_COMMANDS:
+            old_gcode_id = self.extruder_gcode_id
+            try:
+                need_map = self.get_float(line, params, 'A', 1, minval=0)
+                if need_map and self.print_task_config is not None:
+                    try:
+                        extruder_index = int(cmd[1:])
+                        print_task_config_info = self.print_task_config.get_print_task_config()
+                        extruder_map_table = print_task_config_info["reprint_info"]["extruder_map_table"]
+                        if isinstance(extruder_map_table, list) and extruder_index < len(extruder_map_table):
+                            mapped_value = extruder_map_table[extruder_index]
+                            self.extruder_gcode_id = f"T{mapped_value}"
+                        else:
+                            logging.exception("Invalid cmd: '%s'" % (cmd,))
+                    except Exception as e:
+                        logging.exception("Invalid cmd: '%s'" % (cmd,))
+                else:
+                    self.extruder_gcode_id = cmd
+            finally:
+                if old_gcode_id != self.extruder_gcode_id:
+                    for extruder in self.printer.lookup_object('extruder_list', []):
+                        if (extruder.gcode_id == self.extruder_gcode_id and extruder.base_position is not None and
+                            extruder.gcode_offset is not None):
+                            params['X'] = extruder.gcode_offset[0]
+                            params['Y'] = extruder.gcode_offset[1]
+                            params['Z'] = extruder.gcode_offset[2]
+                            self.set_gcode_offset(line, params)
+                            break
+        elif cmd in ('G0', 'G1') or (cmd in ('G2', 'G3') and self.absolute_coord):
+            try:
+                for pos, axis in enumerate('XYZ'):
+                    if axis in params and params[axis] is not None:
+                        v = float(params[axis])
+                        if not self.absolute_coord:
+                            # value relative to position of last move
+                            self.last_position[pos] += v
+                        else:
+                            # value relative to base coordinate position
+                            self.last_position[pos] = v + self.base_position[pos]
+                if 'E' in params and params['E'] is not None:
+                    v = float(params['E']) * self.extrude_factor
+                    if not self.absolute_coord or not self.absolute_extrude:
+                        # value relative to position of last move
+                        self.last_position[3] += v
+                    else:
+                        # value relative to base coordinate position
+                        self.last_position[3] = v + self.base_position[3]
+                if 'F' in params and params['F'] is not None:
+                    gcode_speed = float(params['F'])
+                    if gcode_speed <= 0.:
+                        raise self.printer.command_error("Invalid speed in '%s'" % (line,))
+                    self.speed = gcode_speed * self.speed_factor
+            except Exception as e:
+                logging.exception("Unable to parse move '%s'" % (line,))
+
+    def set_factors(self, extrude_factor=None, speed_factor=None, speed_factor_bak=None):
+        if extrude_factor is not None:
+            self.extrude_factor = extrude_factor
+
+        if speed_factor is not None:
+            self.speed = speed_factor * self.speed / self.speed_factor
+            self.speed_factor = speed_factor
+
+        if speed_factor_bak is not None:
+            self.speed_factor_bak = speed_factor_bak
+    def set_print_task_config(self, print_task_config):
+        self.print_task_config = print_task_config
+
 def load_config(config):
     return VirtualSD(config)
--- a/klippy/gcode.py
+++ b/klippy/gcode.py
@@ -365,9 +365,11 @@ class GCodeDispatch:
         self.printer.request_exit(result)
     cmd_RESTART_help = "Reload config file and restart host software"
     def cmd_RESTART(self, gcmd):
+        logging.info("[gcode] RESTART")
         self.request_restart('restart')
     cmd_FIRMWARE_RESTART_help = "Restart firmware, host, and reload config"
     def cmd_FIRMWARE_RESTART(self, gcmd):
+        logging.info("[gcode] FIRMWARE_RESTART")
         self.request_restart('firmware_restart')
     def cmd_ECHO(self, gcmd):
         gcmd.respond_info(gcmd.get_commandline(), log=False)
--- a/klippy/kinematics/corexy.py
+++ b/klippy/kinematics/corexy.py
@@ -33,6 +33,7 @@ class CoreXYKinematics:
         ranges = [r.get_range() for r in self.rails]
         self.axes_min = toolhead.Coord(*[r[0] for r in ranges], e=0.)
         self.axes_max = toolhead.Coord(*[r[1] for r in ranges], e=0.)
+        self.ignore_check_move_limit = False
     def get_steppers(self):
         return [s for rail in self.rails for s in rail.get_steppers()]
     def calc_position(self, stepper_positions):
@@ -46,6 +47,10 @@ class CoreXYKinematics:
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limits[2] = (1.0, -1.0)
+    def note_x_not_homed(self):
+        self.limits[0] = (1.0, -1.0)
+    def note_y_not_homed(self):
+        self.limits[1] = (1.0, -1.0)
     def home(self, homing_state):
         # Each axis is homed independently and in order
         for axis in homing_state.get_axes():
@@ -66,24 +71,27 @@ class CoreXYKinematics:
         self.limits = [(1.0, -1.0)] * 3
     def _check_endstops(self, move):
         end_pos = move.end_pos
+        axis_names = 'XYZ'
         for i in (0, 1, 2):
             if (move.axes_d[i]
                 and (end_pos[i] < self.limits[i][0]
                      or end_pos[i] > self.limits[i][1])):
                 if self.limits[i][0] > self.limits[i][1]:
-                    raise move.move_error("Must home axis first")
-                raise move.move_error()
+                    raise move.move_error(f"Must home {axis_names[i]} axis first")
+                raise move.move_error(f"Move out of range on {axis_names[i]} axis")
     def check_move(self, move):
-        limits = self.limits
-        xpos, ypos = move.end_pos[:2]
-        if (xpos < limits[0][0] or xpos > limits[0][1]
-            or ypos < limits[1][0] or ypos > limits[1][1]):
-            self._check_endstops(move)
+        if not self.ignore_check_move_limit:
+            limits = self.limits
+            xpos, ypos = move.end_pos[:2]
+            if (xpos < limits[0][0] or xpos > limits[0][1]
+                or ypos < limits[1][0] or ypos > limits[1][1]):
+                self._check_endstops(move)
         if not move.axes_d[2]:
             # Normal XY move - use defaults
             return
         # Move with Z - update velocity and accel for slower Z axis
-        self._check_endstops(move)
+        if not self.ignore_check_move_limit:
+            self._check_endstops(move)
         z_ratio = move.move_d / abs(move.axes_d[2])
         move.limit_speed(
             self.max_z_velocity * z_ratio, self.max_z_accel * z_ratio)
@@ -95,5 +103,9 @@ class CoreXYKinematics:
             'axis_maximum': self.axes_max,
         }
 
+    def set_ignore_check_move_limit(self, enable):
+        # WARNING: Enabling this will disable the detection of XYZ movement coordinates. USE WITH CAUTION!!!
+        self.ignore_check_move_limit = not not enable
+
 def load_kinematics(toolhead, config):
     return CoreXYKinematics(toolhead, config)
--- a/klippy/kinematics/extruder.py
+++ b/klippy/kinematics/extruder.py
@@ -4,11 +4,243 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import math, logging
-import stepper, chelper
+import stepper, chelper, coded_exception, queuefile
+import os, json
+
+class ExtruderParkAction(Exception):
+    pass
+
+class ExtruderUnknownParkStatus(Exception):
+    pass
+
+class ExtruderPickAbnormal(Exception):
+    pass
+
+PARK_DETECTOR_LOOP_CHECK_INTERVAL = 0.1
+PARK_DETECTOR_MAX_EXCEPTION_COUNT = 10
+STRUCTURED_CODE_LIST = []
+
+EXTRUDER_SWITCH_RECORDER = "extruder_switch_recorder.json"
+
+class ExtruderSwitchRecorder:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        # Use persistent directory for config file
+        config_dir = self.printer.get_snapmaker_config_dir("persistent")
+        self.file_path = os.path.join(config_dir, EXTRUDER_SWITCH_RECORDER)
+        # Old config path for migration
+        self.old_file_path = os.path.join(self.printer.get_snapmaker_config_dir(), EXTRUDER_SWITCH_RECORDER)
+        self.save_interval = config.getfloat('save_interval', 30.0)
+        self.individual_maintenance_threshold = config.getint('individual_maintenance_threshold', 25100)
+        self.total_maintenance_threshold = config.getint('total_maintenance_threshold', 100000)
+        self.maintenance_exception_raised = False
+
+        # Migrate data from old location if needed
+        self._migrate_data_if_needed()
+
+        # Load existing data
+        self.data = self._load_data()
+        self.allow_save = False
+        self.dirty = False  # Flag to track unsaved changes
+
+        # Register G-code commands
+        self.gcode = self.printer.lookup_object('gcode')
+        self.gcode.register_command('GET_EXTRUDER_SWITCH_RECORDER', self.cmd_GET_EXTRUDER_SWITCH_RECORDER)
+        self.gcode.register_command('RESET_EXTRUDER_SWITCH_RECORDER', self.cmd_RESET_EXTRUDER_SWITCH_RECORDER)
+        self.gcode.register_command('RESET_EXTRUDER_MAINTENANCE_COUNT', self.cmd_RESET_EXTRUDER_MAINTENANCE_COUNT)
+
+        # Register periodic save timer
+        self.timer = self.reactor.register_timer(self._on_save_timer)
+        self.printer.register_event_handler("klippy:ready", self._handle_ready)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+
+    def _handle_ready(self):
+        self.allow_save = True
+        self.reactor.update_timer(self.timer, self.reactor.NOW)
+
+    def _handle_shutdown(self):
+        self.allow_save = False
+        self.reactor.update_timer(self.timer, self.reactor.NEVER)
+
+    def _check_maintenance_status(self):
+        """Check if maintenance is needed for any extruder or in total"""
+        maintenance_needed = False
+        warning_message = "Maintenance recommended for extruders:\n"
+
+        # Check individual extruder thresholds
+        for extruder_name in sorted(self.data.keys()):
+            self._init_extruder_entry(extruder_name)
+            switch_count_since_maintenance = self.data[extruder_name]['switch_count'] - self.data[extruder_name]['last_maintenance_count']
+            if switch_count_since_maintenance >= self.individual_maintenance_threshold:
+                maintenance_needed = True
+                warning_message += f"  {extruder_name}: {switch_count_since_maintenance} switches since last maintenance\n"
+
+        # Check total threshold
+        total_switch_count = sum(self.data[ext_name].get('switch_count', 0) for ext_name in self.data.keys())
+        total_maintenance_count = sum(self.data[ext_name].get('last_maintenance_count', 0) for ext_name in self.data.keys())
+        total_switches_since_maintenance = total_switch_count - total_maintenance_count
+        if total_switches_since_maintenance >= self.total_maintenance_threshold:
+            maintenance_needed = True
+            warning_message += f"  Total: {total_switches_since_maintenance} switches since last maintenance (threshold: {self.total_maintenance_threshold})\n"
+
+        if maintenance_needed:
+            logging.info(f"[ExtruderSwitchRecorder] {warning_message}")
+
+        return maintenance_needed
+
+    def _migrate_data_if_needed(self):
+        """Migrate data from old location to new location if needed"""
+        # Only migrate if new file doesn't exist but old file does
+        if not os.path.exists(self.file_path) and os.path.exists(self.old_file_path):
+            try:
+                import shutil
+                shutil.copy2(self.old_file_path, self.file_path)
+                logging.info(f"[ExtruderSwitchRecorder] Migrated data from {self.old_file_path} to {self.file_path}")
+            except Exception as e:
+                logging.warning(f"[ExtruderSwitchRecorder] Failed to migrate data: {e}")
+
+    def _load_data(self):
+        try:
+            if os.path.exists(self.file_path):
+                with open(self.file_path, 'r') as f:
+                    raw = f.read().strip()
+                    if raw:
+                        return json.loads(raw)
+        except Exception as e:
+            logging.warning(f"[ExtruderSwitchRecorder] Failed to load data: {e}")
+        return {}
+
+    def _write_to_file(self):
+        try:
+            json_content = json.dumps(self.data, indent=4)
+            queuefile.async_write_file(self.file_path, json_content, safe_write=True)
+            self.dirty = False
+            logging.info(f"[ExtruderSwitchRecorder] Data atomically written to: {self.file_path}")
+            return True
+        except Exception as e:
+            logging.exception(f"[ExtruderSwitchRecorder] Failed to write file: {e}")
+            return False
+    def _init_extruder_entry(self, extruder_name):
+        if extruder_name not in self.data:
+            # If extruder does not exist, create all fields
+            self.data[extruder_name] = {
+                'switch_count': 0,
+                'retry_count': 0,
+                'error_count': 0,
+                'last_maintenance_count': 0  # Switch count at last maintenance
+            }
+        else:
+            # If extruder exists, only add missing fields
+            entry = self.data[extruder_name]
+            for key in ['switch_count', 'retry_count', 'error_count', 'last_maintenance_count']:
+                if key not in entry:
+                    entry[key] = 0
+
+    def _on_save_timer(self, eventtime):
+        # self.gcode.respond_info("path: {}, self.dirty: {}, self.allow_save: {}".format(self.file_path, self.dirty, self.allow_save))
+        if self.dirty and self.allow_save:
+            self._write_to_file()
+
+        if not self.maintenance_exception_raised:
+            need_check = True
+            msm = self.printer.lookup_object('machine_state_manager', None)
+            if msm is not None:
+                state_str = str(msm.get_status()['main_state'])
+                if state_str == "PRINTING":
+                    need_check = False
+            if need_check and self._check_maintenance_status():
+                msg = "Maintenance recommended for extruders"
+                self.printer.raise_structured_code_exception("0001-0523-0000-0037", msg, 0)
+                self.maintenance_exception_raised = True
+        return eventtime + self.save_interval
+
+    def get_data(self):
+        return self.data
+
+    def add_switch_count(self, extruder_name):
+        self._init_extruder_entry(extruder_name)
+        self.data[extruder_name]['switch_count'] += 1
+        self.dirty = True
+        # logging.info(f"[ExtruderSwitchRecorder] Extruder {extruder_name} switch count updated to: {self.data[extruder_name]['switch_count']}")
+
+    def add_retry_count(self, extruder_name):
+        self._init_extruder_entry(extruder_name)
+        self.data[extruder_name]['retry_count'] += 1
+        self.dirty = True
+        # logging.info(f"[ExtruderSwitchRecorder] Extruder {extruder_name} retry count updated to: {self.data[extruder_name]['retry_count']}")
+
+    def add_error_count(self, extruder_name):
+        self._init_extruder_entry(extruder_name)
+        self.data[extruder_name]['error_count'] += 1
+        self.dirty = True
+        # logging.info(f"[ExtruderSwitchRecorder] Extruder {extruder_name} error count updated to: {self.data[extruder_name]['error_count']}")
+
+    def cmd_RESET_EXTRUDER_SWITCH_RECORDER(self, gcmd):
+        """G-code command to reset extruder switch recorder"""
+        # Check if reset is permitted by checking for permission file
+        if not self.printer.check_extruder_config_permission():
+            raise gcmd.error("Reset of extruder switch recorder is not allowed.")
+
+        self.reactor.update_timer(self.timer, self.reactor.NEVER)
+        self.data = {}
+        self._write_to_file()
+        self.printer.clear_structured_code_exception("0001-0523-0000-0037")
+        self.maintenance_exception_raised = False
+        self.reactor.update_timer(self.timer, self.reactor.NOW)
+        gcmd.respond_info("Extruder switch recorder reset")
+
+    def cmd_RESET_EXTRUDER_MAINTENANCE_COUNT(self, gcmd):
+        """G-code command to reset extruder maintenance counter to current switch count"""
+        # Reset maintenance for all extruders
+        self.reactor.update_timer(self.timer, self.reactor.NEVER)
+        for ext_name in self.data.keys():
+            self._init_extruder_entry(ext_name)
+            self.data[ext_name]['last_maintenance_count'] = self.data[ext_name]['switch_count']
+        self.dirty = True
+        self.printer.clear_structured_code_exception("0001-0523-0000-0037")
+        self.maintenance_exception_raised = False
+        self.reactor.update_timer(self.timer, self.reactor.NOW)
+        gcmd.respond_info("Reset maintenance count for all extruders: current switch counts set as new baseline")
+    def cmd_GET_EXTRUDER_SWITCH_RECORDER(self, gcmd):
+        data = self.get_data()
+        if not data:
+            gcmd.respond_info("No recorded extruder data available.")
+            return
+        gcmd.respond_info("dirty: {}, allow_save: {}".format(self.dirty, self.allow_save))
+        gcmd.respond_info("=== Extruder Switch/Retry Data ===")
+        for extruder, stats in data.items():
+            gcmd.respond_info(f"Extruder '{extruder}':")
+            for key, value in stats.items():
+                gcmd.respond_info(f"  {key}: {value}")
+            gcmd.respond_info("-----------------------------")
+        gcmd.respond_info("===============================")
+
+        # Add maintenance status information
+        gcmd.respond_info("=== Extruder Maintenance Status ===")
+        gcmd.respond_info(f"Individual threshold: {self.individual_maintenance_threshold}")
+        gcmd.respond_info(f"Total threshold: {self.total_maintenance_threshold}")
+
+        # Calculate total switch count
+        total_switch_count = sum(self.data[ext_name].get('switch_count', 0) for ext_name in self.data.keys())
+        total_maintenance_count = sum(self.data[ext_name].get('last_maintenance_count', 0) for ext_name in self.data.keys())
+        total_switches_since_maintenance = total_switch_count - total_maintenance_count
+        total_remaining = max(0, self.total_maintenance_threshold - total_switches_since_maintenance)
+
+        gcmd.respond_info(f"Total switches: {total_switch_count}")
+        gcmd.respond_info(f"Total switches since maintenance: {total_switches_since_maintenance}/{self.total_maintenance_threshold} (due in {total_remaining})")
+
+        for ext_name in sorted(self.data.keys()):
+            self._init_extruder_entry(ext_name)
+            switch_count_since_maintenance = self.data[ext_name]['switch_count'] - self.data[ext_name]['last_maintenance_count']
+            remaining = max(0, self.individual_maintenance_threshold - switch_count_since_maintenance)
+            gcmd.respond_info(f"  {ext_name}: {switch_count_since_maintenance}/{self.individual_maintenance_threshold} (due in {remaining})")
+        gcmd.respond_info("==================================")
 
 class ExtruderStepper:
     def __init__(self, config):
         self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
         self.name = config.get_name().split()[-1]
         self.pressure_advance = self.pressure_advance_smooth_time = 0.
         self.config_pa = config.getfloat('pressure_advance', 0., minval=0.)
@@ -88,12 +320,31 @@ class ExtruderStepper:
             raise gcmd.error("Unable to infer active extruder stepper")
         extruder.extruder_stepper.cmd_SET_PRESSURE_ADVANCE(gcmd)
     def cmd_SET_PRESSURE_ADVANCE(self, gcmd):
+        print_stats_state = None
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats is not None:
+            print_stats_state = print_stats.get_status(self.reactor.monotonic())["state"]
+        print_config = self.printer.lookup_object('print_task_config', None)
+        if print_config is not None and print_stats is not None and \
+                print_config.print_task_config['flow_calibrate'] == True:
+            if print_stats_state in ['printing', 'paused']:
+                gcmd.respond_info("flow calibration enabled, so not take effect.")
+                return
+
         pressure_advance = gcmd.get_float('ADVANCE', self.pressure_advance,
                                           minval=0.)
         smooth_time = gcmd.get_float('SMOOTH_TIME',
                                      self.pressure_advance_smooth_time,
                                      minval=0., maxval=.200)
+
+        old_pressure_advance = self.pressure_advance
+        old_smooth_time = self.pressure_advance_smooth_time
         self._set_pressure_advance(pressure_advance, smooth_time)
+        virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+        if (virtual_sdcard is not None and
+            (old_pressure_advance != self.pressure_advance or
+             old_smooth_time != self.pressure_advance_smooth_time)):
+            virtual_sdcard.record_pl_print_pressure_advance({self.name: [self.pressure_advance, self.pressure_advance_smooth_time]})
         msg = ("pressure_advance: %.6f\n"
                "pressure_advance_smooth_time: %.6f"
                % (pressure_advance, smooth_time))
@@ -134,9 +385,15 @@ class PrinterExtruder:
         self.printer = config.get_printer()
         self.name = config.get_name()
         self.last_position = 0.
+        self.reactor = self.printer.get_reactor()
+        self.activating_move = False
+        self.extruder_num = extruder_num
+        self.unipolar_hall = False
         # Setup hotend heater
         pheaters = self.printer.load_object(config, 'heaters')
         gcode_id = 'T%d' % (extruder_num,)
+        self.gcode_id = gcode_id
+        self.extruder_index = extruder_num
         self.heater = pheaters.setup_heater(config, gcode_id)
         # Setup kinematic checks
         self.nozzle_diameter = config.getfloat('nozzle_diameter', above=0.)
@@ -173,20 +430,199 @@ class PrinterExtruder:
             or config.get('rotation_distance', None) is not None):
             self.extruder_stepper = ExtruderStepper(config)
             self.extruder_stepper.stepper.set_trapq(self.trapq)
+        # check if we have a binding probe
+        binding_ind_coil = config.get("inductance_coil", None)
+        if binding_ind_coil != None:
+            self.binding_probe = \
+                self.printer.lookup_object("inductance_coil {}".format(binding_ind_coil), None)
+            if self.binding_probe is None:
+                raise config.error("Must provide binding probe[{}] for extruder[{}]".format(binding_ind_coil, self.name))
+            self.printer_probe = self.printer.lookup_object('probe', None)
+            if self.printer_probe is None:
+                raise config.error("Must register probe firstly!")
+        else:
+            self.binding_probe = None
+        # check if the extruder is associated with park detector
+        park_detector = config.get('park_detector', None)
+        if park_detector is not None:
+            self.park_detector = self.printer.lookup_object("park_detector {}".format(park_detector), None)
+            if self.park_detector is None:
+                raise config.error("Must provide binding park_detector[{}] for extruder[{}]".format(park_detector, self.name))
+        else:
+            self.park_detector = None
+        self.grab_hall_sensor_type = config.getint('grab_hall_sensor_type', 1, minval=0)
+        self.park_check_enable = False
+        self.park_exception_cnt = 0
+        self.check_interval = config.getfloat('check_interval', PARK_DETECTOR_LOOP_CHECK_INTERVAL, above=0.)
+        self.park_detector_loop_check = self.reactor.register_timer(self._park_detector_loop_check)
+        # Getting the necessary information for extruder switchover
+        self.xy_park_position = None
+        self.y_idle_position = None
+        xy_park_position = config.get("xy_park_position", None)
+        xy_park_position_bak = self.get_extruder_config("xy_park_position")
+        if xy_park_position is not None or xy_park_position_bak is not None:
+            if xy_park_position_bak is not None:
+                y_idle_position_bak = self.get_extruder_config("y_idle_position")
+                if y_idle_position_bak is None:
+                    raise config.error("extruder_config.json, {} config error".format(self.name))
+                self.xy_park_position = xy_park_position_bak
+                self.y_idle_position = y_idle_position_bak
+                config.getlists('xy_park_position', None, seps=(',', '\n'), count=2, parser=float)
+                config.getfloat('y_idle_position', 50., minval=0.)
+            else:
+                xy_park_position = config.getlists('xy_park_position', seps=(',', '\n'), count=2, parser=float)
+                self.xy_park_position = list(xy_park_position[0])
+                self.y_idle_position = config.getfloat('y_idle_position', 50., minval=0.)
+            self.grab_dir = config.getboolean('extruder_grab_dir', True)
+            self.horizontal_move_x = config.getfloat('horizontal_move_x', 10., minval=0.)
+            self.retract_x_dist = config.getfloat('retract_x_dist', 1.5, minval=0.)
+            self.fast_move_speed = config.getfloat('fast_move_speed', 200., above=0.)
+            self.slow_move_speed = config.getfloat('slow_move_speed', 30., above=0.)
+            self.grab_speed = config.getfloat('grab_speed', 10., above=0.)
+            self.inser_buffer_dist = config.getfloat('insertion_buffer_dist', 5., minval=0.)
+            self.printer.lookup_object('gcode').register_command(gcode_id, self.cmd_SWITCH_EXTRUDER_ADVANCED)
+            park_command = "PARK_{}".format(self.name).upper()
+            pick_command = "PICK_{}".format(self.name).upper()
+            self.printer.lookup_object('gcode').register_command(park_command, self.cmd_PARK_EXTRUDER)
+            self.printer.lookup_object('gcode').register_command(pick_command, self.cmd_PICK_EXTRUDER)
+            tmp_command = "MOVE_TO_XY_IDLE_POSITION_{}".format(self.name).upper()
+            self.printer.lookup_object('gcode').register_command(tmp_command, self.cmd_MOVE_TO_XY_IDLE_POSITION)
+
+        self.switch_accel = config.getfloat('switch_accel', 5000., above=0.)
+        self.retry_switch_limit = config.getint('retry_switch_limit', 3, minval=0)
+        # Binding print fan
+        self.binding_fan = None
+        fan = config.get("fan", None)
+        if fan is not None and self.printer.lookup_object("{}".format(fan), None) is not None:
+            self.binding_fan = self.printer.lookup_object("{}".format(fan)).fan
+        self.switch_extruder_ctr_fan_pwm = config.getboolean('switch_extruder_ctr_fan_pwm', True)
+
+        # Obtaining the reference position
+        self.base_position = None
+        self.gcode_offset = None
+        base_position_bak = self.get_extruder_config("base_position")
+        if config.get('base_position', None) is not None or base_position_bak is not None:
+            if base_position_bak is not None:
+                self.base_position = base_position_bak
+                base_position = config.getlists('base_position', None, seps=(',', '\n'), parser=float)
+            else:
+                base_position = config.getlists('base_position', seps=(',', '\n'), parser=float)
+                if base_position is not None and len(base_position[0]) == 3:
+                    self.base_position = [base_position[0][i] for i in range(0, 3)]
+        self.vref_sw = None
+        if config.get('vref_sw_pin', None) is not None:
+            self.vref_sw = self.printer.lookup_object("output_pin {}".format(config.get('vref_sw_pin')), None)
+        self.print_config = self.printer.lookup_object('print_task_config', None)
+        self.printing_e_pos = 0.0
+        # handle flow calibration events
+        self.is_calibrating_flow = False
+        self.printer.register_event_handler("flow_calibration:begin", self._handle_flow_calibration_begin)
+        self.printer.register_event_handler("flow_calibration:end", self._handle_flow_calibration_end)
+        self.printer.register_event_handler("virtual_sdcard:reset_file", self._handle_flow_calibration_end)
         # Register commands
+        self.printer.register_event_handler("klippy:connect", self._handle_connect)
+        self.printer.register_event_handler("klippy:ready", self._handle_ready)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+        self.printer.register_event_handler("probe_inductance_coil: update_extruder_offset", self._update_extruder_offset)
+
         gcode = self.printer.lookup_object('gcode')
+        wh = self.printer.lookup_object('webhooks')
         if self.name == 'extruder':
             toolhead.set_extruder(self, 0.)
+            self.gcode_offset = [0, 0, 0]
             gcode.register_command("M104", self.cmd_M104)
             gcode.register_command("M109", self.cmd_M109)
+            gcode.register_command("SET_MAX_E_ACCEL", self.cmd_SET_MAX_E_ACCEL)
+            gcode.register_command("SET_MAX_E_VELOCITY", self.cmd_SET_MAX_E_VELOCITY)
+            wh.register_endpoint("control/extruder_temp", self._handle_control_extruder_temp)
+            if self.park_detector is not None:
+                gcode.register_command("GET_EXTRUDER_ACTIVATE_INFO", self.cmd_GET_EXTRUDER_ACTIVATE_INFO)
         gcode.register_mux_command("ACTIVATE_EXTRUDER", "EXTRUDER",
                                    self.name, self.cmd_ACTIVATE_EXTRUDER,
                                    desc=self.cmd_ACTIVATE_EXTRUDER_help)
+        gcode.register_mux_command("INNER_APPLY_FLOW_K", "EXTRUDER",
+                            self.name, self.cmd_INNER_APPLY_FLOW_K)
+        gcode.register_mux_command("SET_EXTRUDER_BASE_POSITION", "EXTRUDER",
+                                   self.name, self.cmd_SET_EXTRUDER_BASE_POSITION,
+                                   desc="Set extruder base position")
+        gcode.register_mux_command("SET_EXTRUDER_PARK_POSITION", "EXTRUDER",
+                                   self.name, self.cmd_SET_EXTRUDER_PARK_POSITION,
+                                   desc="Set extruder park position")
+    def _handle_connect(self):
+        self.update_extruder_gcode_offset()
+    def _handle_ready(self):
+        if self.park_detector is not None:
+            self.reactor.update_timer(self.park_detector_loop_check, self.reactor.monotonic() + 2)
+    def _handle_shutdown(self):
+        if self.park_detector is not None:
+            self.reactor.update_timer(self.park_detector_loop_check, self.reactor.NEVER)
+            self.check_enable = False
+            self.park_exception_cnt = 0
+    def _handle_flow_calibration_end(self):
+        logging.info("extruder: end flow calibration")
+        self.is_calibrating_flow = False
+    def _handle_flow_calibration_begin(self):
+        logging.info("extruder: begin flow calibration")
+        self.is_calibrating_flow = True
+    def _update_extruder_offset(self):
+        self.update_extruder_gcode_offset()
+        self.active_gcode_offset()
+    def active_binding_probe(self):
+        if self.binding_probe is None:
+            return
+        logging.info("active new eddy current probe: {}".format(
+            self.binding_probe.name))
+        self.printer_probe.set_mcu_probe(self.binding_probe)
+    def active_binding_fan(self):
+        if self.binding_fan is None:
+            return
+        print_fan = self.printer.lookup_object('fan', None)
+        if print_fan is not None:
+            print_fan.fan = self.binding_fan
+            # self.printer.lookup_object('gcode').respond_info("binding {} fan".format(self.name))
+    def get_park_detector_status(self):
+        if self.park_detector is not None:
+            return self.park_detector.get_park_detector_status()
+        else:
+            return None
+    def set_park_detector_enable(self, enable):
+        if self.park_detector is not None:
+            self.park_exception_cnt = 0
+            self.park_check_enable = not not enable
     def update_move_time(self, flush_time, clear_history_time):
         self.trapq_finalize_moves(self.trapq, flush_time, clear_history_time)
+    def active_gcode_offset(self):
+        if self.base_position is None or self.name == 'extruder':
+            return
+        gcode = self.printer.lookup_object('gcode')
+        if self.gcode_offset is not None:
+            gcode.run_script_from_command("SET_GCODE_OFFSET X=%f Y=%f Z=%f" % (self.gcode_offset[0], self.gcode_offset[1], self.gcode_offset[2]))
+    def update_extruder_gcode_offset(self):
+        # Update extruder gcode_offset
+        if self.name == 'extruder':
+            return
+        extruder = self.printer.lookup_object('extruder', None)
+        if extruder is not None:
+            if extruder.base_position is not None and self.base_position is not None:
+                self.gcode_offset = [self.base_position[i] - extruder.base_position[i] for i in range(0, 3)]
     def get_status(self, eventtime):
         sts = self.heater.get_status(eventtime)
-        sts['can_extrude'] = self.heater.can_extrude
+        sts['can_extrude'] = bool(self.heater.can_extrude)
+        sts['extruder_index'] = self.extruder_index
+        sts['printing_e_pos'] = self.printing_e_pos
+        sts['activating_move'] = self.activating_move
+        if self.park_detector is not None:
+            sts.update(self.get_park_detector_status())
+            sts['real_extruder_stats'] = self.get_extruder_activate_status()[0]
+        sts['extruder_offset'] = [0, 0, 0] if self.gcode_offset is None else self.gcode_offset
+        switch_recorder = self.printer.lookup_object('extruder_switch_recorder', None)
+        if switch_recorder is not None:
+            recorder_data = switch_recorder.get_data()
+            extruder_entry = recorder_data.get(self.name, {})
+            sts['switch_count'] = extruder_entry.get('switch_count', 0)
+            sts['retry_count'] = extruder_entry.get('retry_count', 0)
+            sts['error_count'] = extruder_entry.get('error_count', 0)
+            sts['last_maintenance_count'] = extruder_entry.get('last_maintenance_count', 0)
         if self.extruder_stepper is not None:
             sts.update(self.extruder_stepper.get_status(eventtime))
         return sts
@@ -201,16 +637,21 @@ class PrinterExtruder:
     def check_move(self, move):
         axis_r = move.axes_r[3]
         if not self.heater.can_extrude:
-            raise self.printer.command_error(
-                "Extrude below minimum temp\n"
-                "See the 'min_extrude_temp' config option for details")
+            coded = f"0003-0523-{self.extruder_num:04d}-0001"
+            msg = f"{self.name} below minimum temp, temperature: {self.heater.smoothed_temp:.2f}, See the 'min_extrude_temp' config option for details"
+            coded_msg = '{"coded":"%s", "msg":"%s"}' % (coded, msg)
+            raise self.printer.command_error(coded_msg)
         if (not move.axes_d[0] and not move.axes_d[1]) or axis_r < 0.:
             # Extrude only move (or retraction move) - limit accel and velocity
             if abs(move.axes_d[3]) > self.max_e_dist:
-                raise self.printer.command_error(
-                    "Extrude only move too long (%.3fmm vs %.3fmm)\n"
-                    "See the 'max_extrude_only_distance' config"
-                    " option for details" % (move.axes_d[3], self.max_e_dist))
+                coded = f"0003-0523-{self.extruder_num:04d}-0004"
+                msg = "Extrude only move too long (%.3fmm vs %.3fmm), See the 'max_extrude_only_distance' config option for details" % (move.axes_d[3], self.max_e_dist)
+                coded_msg = '{"coded":"%s", "msg":"%s"}' % (coded, msg)
+                raise self.printer.command_error(coded_msg)
+                # raise self.printer.command_error(
+                #     "Extrude only move too long (%.3fmm vs %.3fmm)\n"
+                #     "See the 'max_extrude_only_distance' config"
+                #     " option for details" % (move.axes_d[3], self.max_e_dist), id=523, index=self.extruder_num, code=4, level=1)
             inv_extrude_r = 1. / abs(axis_r)
             move.limit_speed(self.max_e_velocity * inv_extrude_r,
                              self.max_e_accel * inv_extrude_r)
@@ -221,10 +662,15 @@ class PrinterExtruder:
             area = axis_r * self.filament_area
             logging.debug("Overextrude: %s vs %s (area=%.3f dist=%.3f)",
                           axis_r, self.max_extrude_ratio, area, move.move_d)
-            raise self.printer.command_error(
-                "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\n"
-                "See the 'max_extrude_cross_section' config option for details"
-                % (area, self.max_extrude_ratio * self.filament_area))
+            coded = f"0003-0523-{self.extruder_num:04d}-0005"
+            msg = "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\\n" % (area, self.max_extrude_ratio * self.filament_area)
+            msg +="See the 'max_extrude_cross_section' config option for details"
+            coded_msg = '{"coded":"%s", "msg":"%s"}' % (coded, msg)
+            raise self.printer.command_error(coded_msg)
+            # raise self.printer.command_error(
+            #     "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\n"
+            #     "See the 'max_extrude_cross_section' config option for details"
+            #     % (area, self.max_extrude_ratio * self.filament_area), id=523, index=self.extruder_num, code=5, level=1)
     def calc_junction(self, prev_move, move):
         diff_r = move.axes_r[3] - prev_move.axes_r[3]
         if diff_r:
@@ -236,23 +682,325 @@ class PrinterExtruder:
         start_v = move.start_v * axis_r
         cruise_v = move.cruise_v * axis_r
         can_pressure_advance = False
-        if axis_r > 0. and (move.axes_d[0] or move.axes_d[1]):
+        if axis_r > 0. and ((move.axes_d[0] or move.axes_d[1]) or
+                self.is_calibrating_flow):
             can_pressure_advance = True
         # Queue movement (x is extruder movement, y is pressure advance flag)
         self.trapq_append(self.trapq, print_time,
                           move.accel_t, move.cruise_t, move.decel_t,
                           move.start_pos[3], 0., 0.,
                           1., can_pressure_advance, 0.,
-                          start_v, cruise_v, accel)
+                          start_v, cruise_v, accel, move.line)
         self.last_position = move.end_pos[3]
     def find_past_position(self, print_time):
         if self.extruder_stepper is None:
             return 0.
         return self.extruder_stepper.find_past_position(print_time)
-    def cmd_M104(self, gcmd, wait=False):
-        # Set Extruder Temperature
-        temp = gcmd.get_float('S', 0.)
-        index = gcmd.get_int('T', None, minval=0)
+    def check_homing(self):
+        curtime = self.printer.get_reactor().monotonic()
+        homed_axes_list = self.printer.lookup_object('toolhead').get_status(curtime)['homed_axes']
+        return ('x' in homed_axes_list and 'y' in homed_axes_list and 'z' in homed_axes_list)
+    def check_xy_homing(self):
+        curtime = self.printer.get_reactor().monotonic()
+        homed_axes_list = self.printer.lookup_object('toolhead').get_status(curtime)['homed_axes']
+        return ('x' in homed_axes_list and 'y' in homed_axes_list)
+    def get_extruder_activate_status(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        extruder_info = ['unknown extruder', 2]
+        extruder_park = pin_sta = None
+        if self.park_detector is not None:
+            extruder_list = self.printer.lookup_object('extruder_list', [])
+            state_list = [extruder_list[i].get_park_detector_status() for i in range(len(extruder_list))]
+            extruder_park = [state_list[i]['state'] for i in range(len(state_list))]
+            pin_sta = [[state_list[i]['park_pin'], state_list[i]['active_pin'], state_list[i]['grab_valid_pin']] for i in range(len(state_list))]
+            extruder_park_num = extruder_active_num = 0
+            if 'PARKED' in extruder_park:
+                extruder_park_num = extruder_park.count('PARKED')
+            if 'ACTIVATE' in extruder_park:
+                extruder_active_num = extruder_park.count('ACTIVATE')
+
+            if extruder_park_num == len(extruder_park):
+                extruder_info = [toolhead.get_extruder().name, 1]
+            elif extruder_active_num == 1 and extruder_park_num + 1 == len(extruder_park):
+                if 'ACTIVATE' in extruder_park:
+                    index =  extruder_park.index('ACTIVATE')
+                    extruder_info = [extruder_list[index].name, 0]
+        else:
+            extruder_info = [toolhead.get_extruder().name, 0]
+        return [extruder_info, extruder_park, pin_sta]
+    def check_allow_retry_switch_extruder(self):
+        def check_retry_extruder(status_list):
+            if not status_list:
+                return False, -1
+            unknown_indices = [i for i, s in enumerate(status_list) if s == 'UNKNOWN']
+            if len(status_list) == 1:
+                is_valid = len(unknown_indices) == 1
+                return (is_valid, unknown_indices[0] if is_valid else -1)
+            valid = len(unknown_indices) == 1 and all(s == 'PARKED' for s in status_list if s != 'UNKNOWN')
+            return (valid, unknown_indices[0]) if valid else (False, -1)
+
+        activate_status = self.get_extruder_activate_status()
+        if not activate_status or len(activate_status) < 3:
+            return None
+
+        first_item = activate_status[0]
+        extruder_status_list = activate_status[1]
+
+        if not isinstance(first_item, (list, tuple)) or len(first_item) < 2 or first_item[1] != 2:
+            return None
+
+        if not isinstance(extruder_status_list, list):
+            return None
+
+        allow_retry, retry_extruder_index = check_retry_extruder(extruder_status_list)
+        if allow_retry and isinstance(activate_status[2], list) and len(activate_status[2]) > retry_extruder_index:
+            pin_status = activate_status[2][retry_extruder_index]
+            park_pin = pin_status[0]
+            active_pin = pin_status[1]
+            grab_valid_pin = pin_status[2]
+            if park_pin is False and active_pin is False and grab_valid_pin:
+                return retry_extruder_index
+        return None
+
+    def set_vref_sw(self, value):
+        if self.vref_sw is not None:
+            toolhead = self.printer.lookup_object('toolhead')
+            self.vref_sw._set_pin(toolhead.get_last_move_time(), value)
+    def only_enable_current_extruder_vref_sw(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        extruder_list = self.printer.lookup_object('extruder_list', [])
+        for i in range(len(extruder_list)):
+            if extruder_list[i].vref_sw is not None:
+                if extruder_list[i].name == self.name:
+                    extruder_list[i].set_vref_sw(1)
+                else:
+                    extruder_list[i].set_vref_sw(0)
+    def get_extruder_config(self, field_name=None):
+        extruder_bak = self.printer.lookup_object('extruder_config_bak', None)
+        if extruder_bak is None:
+            return None
+        return extruder_bak.get_extruder_config(self.name, field_name)
+
+    def update_extruder_config(self, field_name=None, value=None):
+        extruder_bak = self.printer.lookup_object('extruder_config_bak', None)
+        if extruder_bak is None:
+            return False
+        return extruder_bak.update_extruder_config(self.name, field_name, value)
+
+    def analyze_switch_extruder_error(self, err_state=None):
+        try:
+            if err_state is None:
+                err_state = self.get_extruder_activate_status()
+
+            if not isinstance(err_state, list) or len(err_state) < 3:
+                logging.info("Invalid state format: %s", str(err_state))
+                return None
+
+            if not (isinstance(err_state[0], list) and len(err_state[0]) > 1):
+                logging.info("Invalid header format: %s", str(err_state[0]))
+                return None
+
+            if err_state[0][1] != 2:
+                return None
+
+            states = err_state[1]
+            grips = err_state[2] if len(err_state) > 2 else []
+
+            if len(states) != len(grips):
+                logging.info("State/grip mismatch: states=%d, grips=%d", len(states), len(grips))
+                return None
+
+            MAX_EXTRUDERS = 4
+            if len(states) > MAX_EXTRUDERS:
+                logging.warning("Too many extruders: %d, exceeds maximum: %d", len(states), MAX_EXTRUDERS)
+                return None
+
+            fmt_grip = lambda g: ''.join('T' if x else 'F' for x in g) if isinstance(g, list) else "?"
+
+            activated = []
+            unknown = []
+            error_messages = []
+            all_grip_states = []
+
+            for i, s in enumerate(states):
+                if s == 'ACTIVATE':
+                    activated.append(i)
+                elif s == 'UNKNOWN':
+                    unknown.append(i)
+
+                all_grip_states.append(fmt_grip(grips[i]))
+
+            activated_code = 0
+            unknown_code = 0
+
+            if len(activated) > 1:
+                grip_info = [f"{i}-({all_grip_states[i]})" for i in activated]
+                error_messages.append(f"multi-act: {grip_info}")
+
+                activated_sorted = sorted(activated)
+                extruder_combinations = {
+                    (0, 1): 0,
+                    (0, 2): 1,
+                    (0, 3): 2,
+                    (1, 2): 3,
+                    (1, 3): 4,
+                    (2, 3): 5,
+                    (0, 1, 2): 6,
+                    (0, 1, 3): 7,
+                    (0, 2, 3): 8,
+                    (1, 2, 3): 9,
+                    (0, 1, 2, 3): 10
+                }
+
+                combination_index = extruder_combinations.get(tuple(activated_sorted))
+                if combination_index is not None:
+                    activated_code = combination_index + 1
+
+            if unknown:
+                unknown_info = []
+                for idx in unknown:
+                    grip = grips[idx]
+                    if isinstance(grip, list) and len(grip) >= 2:
+                        if len(grip) >= 3 and self.unipolar_hall:
+                            if not grip[0] and not grip[1]:
+                                if grip[2]:
+                                    unknown_info.append(f"{idx}-(pogopin unconnected)")
+                                else:
+                                    unknown_info.append(f"{idx}-(extruder detached)")
+                            elif grip[0] and grip[1]:
+                                unknown_info.append(f"{idx}-({all_grip_states[idx]})")
+                            else:
+                                unknown_info.append(f"{idx}-({all_grip_states[idx]})")
+                        else:
+                            unknown_info.append(f"{idx}-({all_grip_states[idx]})")
+                    else:
+                        unknown_info.append(f"{idx}-({all_grip_states[idx]})")
+                error_messages.append(f"err-sta: {unknown_info}")
+
+                unknown_sorted = sorted(unknown)
+                unknown_combinations = {
+                    (0,): 0,
+                    (1,): 1,
+                    (2,): 2,
+                    (3,): 3,
+                    (0, 1): 4,
+                    (0, 2): 5,
+                    (0, 3): 6,
+                    (1, 2): 7,
+                    (1, 3): 8,
+                    (2, 3): 9,
+                    (0, 1, 2): 10,
+                    (0, 1, 3): 11,
+                    (0, 2, 3): 12,
+                    (1, 2, 3): 13,
+                    (0, 1, 2, 3): 14
+                }
+
+                unknown_index = unknown_combinations.get(tuple(unknown_sorted))
+                if unknown_index is not None:
+                    unknown_code = unknown_index + 1
+
+            if error_messages:
+                return (
+                    "; ".join(error_messages),
+                    activated,
+                    unknown,
+                    all_grip_states,
+                    activated_code,
+                    unknown_code
+                )
+            return None
+
+        except Exception as e:
+            logging.exception("Error analyzing extruder state: %s", str(e))
+            return None
+
+    def _park_detector_loop_check(self, eventtime):
+        if self.park_detector is None:
+            return self.reactor.NEVER
+        toolhead = self.printer.lookup_object('toolhead')
+        state_message, category = self.printer.get_state_message()
+        exception_record = False
+        if category == 'ready' and self.park_check_enable:
+            state = self.get_park_detector_status()
+            if toolhead.get_extruder() is self:
+                if state['state'] != 'ACTIVATE':
+                    exception_record = True
+            else:
+                if state['state'] != 'PARKED':
+                    exception_record = True
+        if exception_record:
+            if self.park_exception_cnt <= PARK_DETECTOR_MAX_EXCEPTION_COUNT:
+                self.park_exception_cnt += 1
+        else:
+            self.park_exception_cnt = 0
+
+        if self.park_exception_cnt == PARK_DETECTOR_MAX_EXCEPTION_COUNT:
+            self.park_exception_cnt = 0
+            self.printer.invoke_shutdown("current extruder name: {}, {} park detector error, {}".format(toolhead.get_extruder().name, self.name, state))
+            # extruder_list = self.printer.lookup_object('extruder_list', [])
+            # for i in range(len(extruder_list)):
+            #     extruder_list[i].set_park_detector_enable(False)
+            # virtual_sdcard = self.printer.lookup_object('virtual_sdcard', None)
+            # if virtual_sdcard is not None and virtual_sdcard.current_file is not None:
+            #     self.gcode.run_script('CANCEL_PRINT')
+        return eventtime + self.check_interval
+    def _add_structured_code_list(self, e):
+        global STRUCTURED_CODE_LIST
+        try:
+            exception_manager = self.printer.lookup_object('exception_manager', None)
+            if exception_manager is None:
+                logging.warning("Exception manager not found when adding structured code")
+                return
+
+            exc_obj = coded_exception.CodedException.from_exception(e)
+            if exc_obj is None:
+                logging.warning("Failed to create CodedException from exception")
+                return
+
+            id = exc_obj.id
+            index = exc_obj.index
+            code = exc_obj.code
+            message = exc_obj.message
+            oneshot = exc_obj.oneshot
+
+            if message:
+                try:
+                    coded_message = self.printer.extract_encoded_message(message)
+                    if coded_message:
+                        structured_code = coded_message.get("coded")
+                        if structured_code:
+                            parsed = exception_manager._parse_structured_code(structured_code)
+                            id = parsed.get("id", id)
+                            index = parsed.get("index", index)
+                            code = parsed.get("code", code)
+                            level = parsed.get("level", exc_obj.level)
+                        else:
+                            id = coded_message.get("id", id)
+                            index = coded_message.get("index", index)
+                            code = coded_message.get("code", code)
+                            level = coded_message.get("level", exc_obj.level)
+                        oneshot = coded_message.get("oneshot", oneshot)
+                    if id == 523 and oneshot == 0:
+                        structured_code = f"0002-{id:04d}-{index:04d}-{code:04d}"
+                        if structured_code not in STRUCTURED_CODE_LIST:
+                            STRUCTURED_CODE_LIST.append(structured_code)
+                except Exception as parse_err:
+                    logging.warning(f"Error parsing structured code: {str(parse_err)}")
+
+        except Exception as err:
+            logging.error(f"Error in _add_structured_code_list: {str(err)}")
+
+    def _clear_structured_code_list(self):
+        global STRUCTURED_CODE_LIST
+        if STRUCTURED_CODE_LIST:
+            for code in STRUCTURED_CODE_LIST:
+                self.printer.clear_structured_code_exception(code)
+            STRUCTURED_CODE_LIST = []
+
+    def _set_extruder_temp(self, temp, index, map, wait=False):
+        if map != 0 and index is not None and self.print_config is not None:
+            index = self.print_config.get_extruder_map_index(index)
         if index is not None:
             section = 'extruder'
             if index:
@@ -261,17 +1009,42 @@ class PrinterExtruder:
             if extruder is None:
                 if temp <= 0.:
                     return
-                raise gcmd.error("Extruder not configured")
+                raise self.printer.command_error('{"coded":"0001-0523-0000-0006", "msg":"%s not configured"}' % (section))
         else:
             extruder = self.printer.lookup_object('toolhead').get_extruder()
         pheaters = self.printer.lookup_object('heaters')
         pheaters.set_temperature(extruder.get_heater(), temp, wait)
+    # webhook interface
+    def _handle_control_extruder_temp(self, web_request):
+        """Handle extruder temperature setting request"""
+        try:
+            temp = web_request.get_float('S', 0.)
+            index = web_request.get_int('T', None)
+            extruder_map = web_request.get_int('A', 1)
+            if temp < 0:
+                temp = 0
+            self._set_extruder_temp(temp, index, extruder_map, False)
+            web_request.send({'state': 'success'})
+        except Exception as e:
+            logging.error(f'failed to set extruder temp: {str(e)}')
+            web_request.send({'state': 'error', 'message': str(e)})
+
+    def cmd_M104(self, gcmd, wait=False):
+        # Set Extruder Temperature
+        temp = gcmd.get_float('S', 0.)
+        index = gcmd.get_int('T', None, minval=0)
+        extruder_map = gcmd.get_int('A', 1, minval=0)
+        try:
+            self._set_extruder_temp(temp, index, extruder_map, wait)
+        except Exception as e:
+            raise gcmd.error(str(e))
     def cmd_M109(self, gcmd):
         # Set Extruder Temperature and Wait
         self.cmd_M104(gcmd, wait=True)
     cmd_ACTIVATE_EXTRUDER_help = "Change the active extruder"
     def cmd_ACTIVATE_EXTRUDER(self, gcmd):
         toolhead = self.printer.lookup_object('toolhead')
+        self.only_enable_current_extruder_vref_sw()
         if toolhead.get_extruder() is self:
             gcmd.respond_info("Extruder %s already active" % (self.name,))
             return
@@ -279,6 +1052,705 @@ class PrinterExtruder:
         toolhead.flush_step_generation()
         toolhead.set_extruder(self, self.last_position)
         self.printer.send_event("extruder:activate_extruder")
+        self.active_binding_probe()
+        self.active_binding_fan()
+        self.active_gcode_offset()
+    def set_max_accel(self, accel):
+        self.max_e_accel = accel
+    def cmd_SET_MAX_E_ACCEL(self, gcmd):
+        extruder = self.printer.lookup_object('toolhead').get_extruder()
+        accel = gcmd.get_float('A', extruder.max_e_accel)
+        extruder.max_e_accel = accel
+        gcmd.respond_info("{}'s max accel: {}".format(extruder.name, accel))
+    def cmd_SET_MAX_E_VELOCITY(self, gcmd):
+        extruder = self.printer.lookup_object('toolhead').get_extruder()
+        velocity = gcmd.get_float('V', extruder.max_e_velocity)
+        extruder.max_e_velocity = velocity
+        gcmd.respond_info("{}'s max velocity: {}".format(extruder.name, velocity))
+    def cmd_GET_EXTRUDER_ACTIVATE_INFO(self, gcmd):
+        if self.park_detector is not None:
+            activate_status = self.get_extruder_activate_status()
+            gcmd.respond_info("{} grab_complete: {}".format(activate_status, self.printer.lookup_object('toolhead').is_grab_complete))
+    def cmd_PARK_EXTRUDER(self, gcmd):
+        gcmd.get_command_parameters()['ACTION'] = 'PARK'
+        self.cmd_SWITCH_EXTRUDER(gcmd)
+        # gcmd.respond_info("parameters: {}".format(gcmd.get_command_parameters()))
+    def cmd_PICK_EXTRUDER(self, gcmd):
+        gcmd.get_command_parameters()['ACTION'] = 'PICK'
+        self.cmd_SWITCH_EXTRUDER(gcmd)
+    def cmd_SWITCH_EXTRUDER_ADVANCED(self, gcmd):
+        gcmd.get_command_parameters()['ACTION'] = None
+        extruder_map = gcmd.get_int('A', 1, minval=0)
+        # Mapping Extruder Index
+        if extruder_map != 0 and self.print_config is not None:
+            index = int(self.gcode_id.split('T')[1])
+            index = self.print_config.get_extruder_map_index(index)
+            section = 'extruder'
+            if index:
+                section = 'extruder%d' % (index,)
+            extruder = self.printer.lookup_object(section, None)
+            if extruder is not None:
+                extruder.cmd_SWITCH_EXTRUDER(gcmd)
+        else:
+            self.cmd_SWITCH_EXTRUDER(gcmd)
+    def cmd_SWITCH_EXTRUDER(self, gcmd):
+        retry_count = 0
+        toolhead = self.printer.lookup_object('toolhead')
+        gcode = self.printer.lookup_object('gcode')
+        switch_recorder = self.printer.lookup_object('extruder_switch_recorder', None)
+        def handle_retry(error_msg_prefix):
+            nonlocal retry_count
+            nonlocal switch_recorder
+            retry_count += 1
+            if retry_count < self.retry_switch_limit:
+                gcmd.respond_info(f"Failed to switch extruder, retrying... (Attempt: {retry_count})")
+                return True
+            else:
+                retry_extruder_id = self.check_allow_retry_switch_extruder()
+                if "pogopin" in error_msg_prefix and retry_extruder_id is not None:
+                    try:
+                        self._cmd_SWITCH_EXTRUDER(gcmd, forced_park=True)
+                    except Exception as inner_e:
+                        logging.warning("Inner exception during forced park: %s", str(inner_e))
+
+                if switch_recorder is not None:
+                    switch_recorder.add_error_count(self.name)
+                raise gcmd.error(error_msg_prefix, action="pause")
+
+        try:
+            while retry_count < self.retry_switch_limit:
+                try:
+                    if retry_count > 0:
+                        # gcode.run_script_from_command("G28 X Y")
+                        # toolhead.wait_moves()
+                        retry_extruder_id = self.check_allow_retry_switch_extruder()
+                        if retry_extruder_id is not None:
+                            # Forced parking of extruders
+                            if switch_recorder is not None:
+                                extruder_list = self.printer.lookup_object('extruder_list', [])
+                                if len(extruder_list) > retry_extruder_id:
+                                    switch_recorder.add_retry_count(extruder_list[retry_extruder_id].name)
+                            self._cmd_SWITCH_EXTRUDER(gcmd, forced_park=True)
+                    self._cmd_SWITCH_EXTRUDER(gcmd)
+                    break
+
+                except ExtruderUnknownParkStatus as e:
+                    handle_retry(str(e))
+                except ExtruderPickAbnormal as e:
+                    handle_retry(str(e))
+                except Exception as e:
+                    retry_extruder_id = self.check_allow_retry_switch_extruder()
+                    if "pogopin" in str(e) and retry_extruder_id is not None:
+                        try:
+                            self._cmd_SWITCH_EXTRUDER(gcmd, forced_park=True)
+                        except Exception as inner_e:
+                            logging.warning("Inner exception during forced park: %s", str(inner_e))
+
+                    if switch_recorder is not None:
+                        switch_recorder.add_error_count(self.name)
+                    raise
+            self._clear_structured_code_list()
+        except Exception as e:
+            self._add_structured_code_list(e)
+            if hasattr(toolhead.get_kinematics(), "note_x_not_homed"):
+                toolhead.get_kinematics().note_x_not_homed()
+            if hasattr(toolhead.get_kinematics(), "note_y_not_homed"):
+                toolhead.get_kinematics().note_y_not_homed()
+            raise
+
+    def _cmd_SWITCH_EXTRUDER(self, gcmd, forced_park=False):
+        switch_complete = restore_state = False
+        toolhead = self.printer.lookup_object('toolhead')
+        gcode = self.printer.lookup_object('gcode')
+        gcode_move = self.printer.lookup_object('gcode_move')
+        extruder_list = self.printer.lookup_object('extruder_list', [])
+        activate_status = None
+        fan_pwm_set = False
+        action = None
+        params = gcmd.get_command_parameters()
+        is_grab_complete = False
+        if 'ACTION' in params:
+            action = params['ACTION']
+
+        # forced_park: Special handling flag, use with caution
+        if forced_park:
+            action = 'PARK'
+
+        try:
+            if (self.printer.lookup_object('homing_xyz_override', None) is not None or
+                self.printer.lookup_object('safe_z_home', None) is not None):
+                if not self.check_xy_homing():
+                    gcode.run_script_from_command("G28 X Y")
+            else:
+                if not self.check_homing():
+                    gcode.run_script_from_command("G28")
+            toolhead.wait_moves()
+            self.activating_move = True
+            gcmd.respond_info("{} -> {}".format(toolhead.get_extruder().name, self.name))
+            forced_skip = False
+            retry_extruder_id = None
+            for i in range(10):
+                activate_status = self.get_extruder_activate_status()
+                retry_extruder_id = self.check_allow_retry_switch_extruder()
+                if forced_park and retry_extruder_id is not None:
+                    forced_skip = True
+                if activate_status[0][1] != 2 or forced_skip:
+                    break
+                else:
+                    if i == 9:
+                        result = self.analyze_switch_extruder_error(activate_status)
+                        if result:
+                            error_info, activated, unknown, grip_states, activated_code, unknown_code = result
+                            error_msg = "Extruder %s switch is not allowed, %s" % (self.name, error_info)
+                            if "multi-act" in error_info:
+                                if activated_code + 6 < 18:
+                                    message = '{"coded": "0002-0523-%4d-%4d", "oneshot": %d, "msg":"%s", "action": "pause"}' % (self.extruder_num, activated_code + 6, 0, error_msg)
+                            else:
+                                message = '{"coded": "0002-0523-%4d-0018", "oneshot": %d, "msg":"%s", "action": "pause"}' % (self.extruder_num, 0, error_msg)
+                                if self.grab_hall_sensor_type:
+                                    first_unknown_index = None
+                                    for i, idx in enumerate(unknown):
+                                        if grip_states[idx] != 'FFT':
+                                            first_unknown_index = idx
+                                            break
+
+                                    if first_unknown_index is not None:
+                                        grip_state = grip_states[first_unknown_index]
+                                        if grip_state == 'FFF' or grip_state == 'FFT':
+                                            info = "Extruder %s is not allowed to switch, detected that extruder%d is detached. %s" % (self.name, first_unknown_index, error_info)
+                                            message = '{"coded": "0002-0523-%4d-0040", "oneshot": %d, "msg":"%s", "action": "pause"}' % (first_unknown_index, 0, info)
+                                        elif (grip_state == 'TTF' or grip_state == 'TTT'):
+                                            info = "Extruder %s is not allowed to switch, detected conflicting status for extruder%d: both parked and picked states detected. %s" % (self.name, first_unknown_index, error_info)
+                                            message = '{"coded": "0002-0523-%4d-0041", "oneshot": %d, "msg":"%s", "action": "pause"}' % (first_unknown_index, 0, info)
+                        else:
+                            error_msg = f"{activate_status[1]} {activate_status[2]}"
+                            message = f"Extruder {self.name} switch is not allowed, {error_msg}"
+
+                        if retry_extruder_id is not None:
+                            raise ExtruderUnknownParkStatus(message)
+                        else:
+                            raise gcmd.error(message)
+                    gcmd.respond_info("Retrying to get normal extruder activation status (attempt {}), forced_park: {}, retry_extruder_id: {}".format(i,
+                                        forced_park, retry_extruder_id))
+                    toolhead.dwell(0.2)
+                    toolhead.wait_moves()
+
+            # Extruder is already active and does not need to be switched
+            if (activate_status[0][1] == 0 and activate_status[0][0] == self.name and toolhead.get_extruder() is self and
+                ((self.get_park_detector_status() is None and action is None) or (self.get_park_detector_status() is not None and action != 'PARK'))):
+                gcmd.respond_info("Extruder %s already active" % (self.name,))
+                is_grab_complete = True
+                return
+
+            if activate_status[0][1] == 1 and action == 'PARK':
+                gcmd.respond_info("All extruder is parked")
+                return
+
+            print_fan = self.printer.lookup_object('fan', None)
+            print_fan_speed = None
+            current_time = self.printer.get_reactor().monotonic()
+            if print_fan is not None:
+                print_fan_speed = print_fan.get_status(current_time)['speed']
+                print_fan.fan.set_speed_from_command(0)
+
+            # enable pwm pin in order to detect the extruder gripping state
+            for i in range(len(extruder_list)):
+                if extruder_list[i].binding_fan is not None and extruder_list[i].switch_extruder_ctr_fan_pwm:
+                    extruder_list[i].binding_fan.set_speed_from_command(1, False)
+
+            fan_pwm_set = True
+            fan_close_tick = toolhead.reactor.monotonic()
+
+            # Save current environment
+            saved_states = {
+                'absolute_coord': gcode_move.absolute_coord,
+                'absolute_extrude': gcode_move.absolute_extrude,
+                'base_position': list(gcode_move.base_position),
+                'last_position': list(gcode_move.last_position),
+                'homing_position': list(gcode_move.homing_position),
+                'speed': gcode_move.speed, 'speed_factor': gcode_move.speed_factor,
+                'extrude_factor': gcode_move.extrude_factor,
+                'fan_speed': print_fan_speed,
+                'max_accel': toolhead.max_accel,
+            }
+
+            # use lower acceleration to switch toolhead
+            # toolhead.set_accel(5000)
+
+            if activate_status[0][1] == 0 or (forced_park and retry_extruder_id is not None):
+                # Park extruder
+                if not forced_park:
+                    cur_extruder = self.printer.lookup_object(activate_status[0][0], None)
+                    if cur_extruder is None:
+                        raise gcmd.error("The current extruder lookup object failed")
+
+                    cur_extruder_state = cur_extruder.get_park_detector_status()
+                    if cur_extruder_state is not None and cur_extruder_state['state'] != 'ACTIVATE':
+                        state, park_pin = cur_extruder_state['state'], cur_extruder_state['park_pin']
+                        active_pin, grab_valid_pin = cur_extruder_state['active_pin'], cur_extruder_state['grab_valid_pin']
+                        pin_sta = ''.join(['T' if x else 'F' for x in [park_pin, active_pin, grab_valid_pin]])
+                        msg = f"Parking is not allowed for {cur_extruder.name}, status: {state} [{pin_sta}]"
+                        message = '{"coded": "0002-0523-%4d-0019", "oneshot": %d, "msg":"%s", "action": "pause"}' % (cur_extruder.extruder_num, 0, msg)
+                        raise gcmd.error(message)
+                        # raise gcmd.error("Unknown extruder park status, {}: {}".format(activate_status[0][0], cur_extruder_state))
+
+                    if cur_extruder_state is None and action == 'PARK':
+                        cur_extruder = self
+                else:
+                    cur_extruder = extruder_list[retry_extruder_id]
+                    cur_extruder_state = None
+
+                if cur_extruder.xy_park_position is not None and ((activate_status[0][0] != self.name and action is None) or
+                    (cur_extruder_state is None and action == 'PARK') or (cur_extruder_state is not None and
+                    (action == 'PARK' or (action == 'PICK' and activate_status[0][0] != self.name)))):
+                    restore_state = True
+                    # gcode_move.absolute_coord = True
+                    if self.switch_accel != toolhead.max_accel:
+                        toolhead.set_accel(self.switch_accel)
+                    # cur_extruder.set_park_detector_enable(False)
+                    x_move_position = cur_extruder.xy_park_position[0] + [1, -1][not cur_extruder.grab_dir] * \
+                                    (cur_extruder.horizontal_move_x - cur_extruder.retract_x_dist)
+                    gcmd.respond_info("park {} !!!".format(cur_extruder.name))
+                    pos = toolhead.get_position()
+                    if pos[1] > cur_extruder.y_idle_position:
+                        toolhead.manual_move([None, cur_extruder.y_idle_position, None], cur_extruder.fast_move_speed)
+                        # gcmd.respond_info("G0 Y{} F{}".format(cur_extruder.y_idle_position, cur_extruder.fast_move_speed*60))
+
+                        toolhead.manual_move([x_move_position + [1, -1][cur_extruder.grab_dir]*0.5, None, None], cur_extruder.fast_move_speed)
+                        # gcmd.respond_info("G0 X{} F{}".format(x_move_position + [1, -1][cur_extruder.grab_dir]*0.5, cur_extruder.fast_move_speed*60))
+                        toolhead.manual_move([x_move_position, None, None], cur_extruder.fast_move_speed)
+                        # gcmd.respond_info("G0 X{} F{}".format(x_move_position,cur_extruder.fast_move_speed*60))
+                    else:
+                        toolhead.manual_move([x_move_position + [1, -1][cur_extruder.grab_dir]*0.5, None, None], cur_extruder.fast_move_speed)
+                        # gcmd.respond_info("G0 X{} F{}".format(x_move_position + [1, -1][cur_extruder.grab_dir]*0.5, cur_extruder.fast_move_speed*60))
+                        toolhead.manual_move([x_move_position, None, None], cur_extruder.fast_move_speed)
+                        # gcmd.respond_info("G0 X{} F{}".format(x_move_position, cur_extruder.fast_move_speed*60))
+
+                        toolhead.manual_move([None, cur_extruder.y_idle_position, None], cur_extruder.fast_move_speed)
+                        # gcmd.respond_info("G0 Y{} F{}".format(cur_extruder.y_idle_position, cur_extruder.fast_move_speed*60))
+
+                    y_move_position = max(cur_extruder.xy_park_position[1] - cur_extruder.inser_buffer_dist, cur_extruder.y_idle_position)
+                    toolhead.manual_move([None, y_move_position, None], cur_extruder.fast_move_speed)
+                    # gcmd.respond_info("G0 Y{} F{}".format(y_move_position, cur_extruder.fast_move_speed*60))
+                    toolhead.manual_move([None, cur_extruder.xy_park_position[1], None], cur_extruder.slow_move_speed)
+                    # gcmd.respond_info("G0 Y{} F{}".format(cur_extruder.xy_park_position[1], cur_extruder.slow_move_speed*60))
+
+                    toolhead.manual_move([cur_extruder.xy_park_position[0], None, None], cur_extruder.slow_move_speed)
+                    # gcmd.respond_info("G0 X{} F{}".format(cur_extruder.xy_park_position[0], cur_extruder.slow_move_speed*60))
+
+                    toolhead.manual_move([None, cur_extruder.y_idle_position, None], cur_extruder.fast_move_speed)
+                    # gcmd.respond_info("G0 Y{} F{}".format(cur_extruder.y_idle_position, cur_extruder.fast_move_speed*60))
+                    toolhead.wait_moves()
+                    # toolhead.dwell(0.1)
+                    for i in range(10):
+                        cur_extruder_state = cur_extruder.get_park_detector_status()
+                        if not (cur_extruder_state is not None and cur_extruder_state['state'] != 'PARKED'):
+                            break
+                        else:
+                            if i == 9:
+                                if cur_extruder_state is not None:
+                                    state, park_pin = cur_extruder_state['state'], cur_extruder_state['park_pin']
+                                    active_pin, grab_valid_pin = cur_extruder_state['active_pin'], cur_extruder_state['grab_valid_pin']
+                                    pin_sta = ''.join(['T' if x else 'F' for x in [park_pin, active_pin, grab_valid_pin]])
+                                    msg = f"Extruder {cur_extruder.name} malfunction after parking, state: {state} [{pin_sta}]"
+                                    message = '{"coded": "0002-0523-%4d-0020", "oneshot": %d, "msg":"%s", "action": "pause"}' % (cur_extruder.extruder_num, 0, msg)
+                                    if self.grab_hall_sensor_type:
+                                        if pin_sta == 'FTT' or pin_sta == 'FTF':
+                                            msg = f"Extruder {cur_extruder.name} malfunction after parking, {cur_extruder.name} failed to return to park position. state: {state} [{pin_sta}]"
+                                            message = '{"coded": "0002-0523-%4d-0042", "oneshot": %d, "msg":"%s", "action": "pause"}' % (cur_extruder.extruder_num, 0, msg)
+                                        elif pin_sta == 'FFT' or pin_sta == 'FFF':
+                                            msg = f"Extruder {cur_extruder.name} malfunction after parking, {cur_extruder.name} detached detected. state: {state} [{pin_sta}]"
+                                            message = '{"coded": "0002-0523-%4d-0043", "oneshot": %d, "msg":"%s", "action": "pause"}' % (cur_extruder.extruder_num, 0, msg)
+                                        elif pin_sta == 'TTT' or pin_sta == 'TTF':
+                                            msg = f"Extruder {cur_extruder.name} malfunction after parking, conflicting status detected: both parked and picked states. state: {state} [{pin_sta}]"
+                                            message = '{"coded": "0002-0523-%4d-0044", "oneshot": %d, "msg":"%s", "action": "pause"}' % (cur_extruder.extruder_num, 0, msg)
+                                    raise gcmd.error(message)
+                                else:
+                                    raise gcmd.error("Extruder malfunction after parking, {}: {}".format(cur_extruder.name, cur_extruder_state), 'pause')
+                            gcmd.respond_info(f"Post-park check failed for {cur_extruder.name}, retry {i}")
+                            toolhead.dwell(0.2)
+                            toolhead.wait_moves()
+                    # cur_extruder_state = cur_extruder.get_park_detector_status()
+                    # if cur_extruder_state is not None and cur_extruder_state['state'] != 'PARKED':
+                    #     raise gcmd.error("Abnormal state detection after extruder park, {}: {}".format(cur_extruder.name, cur_extruder_state))
+
+            if action == 'PARK':
+                raise ExtruderParkAction("park action success!!!")
+
+            # if self.xy_park_position is not None and not (activate_status[0][0] == self.name and activate_status[0][1] == 0):
+            extruder_state = self.get_park_detector_status()
+            if (self.xy_park_position is not None and (extruder_state is None or (extruder_state is not None and
+                not (activate_status[0][0] == self.name and activate_status[0][1] == 0)))):
+                for i in range(10):
+                    extruder_state = self.get_park_detector_status()
+                    if not (extruder_state is not None and extruder_state['state'] != 'PARKED'):
+                        break
+                    else:
+                        if i == 9:
+                            if extruder_state is not None:
+                                state, park_pin = extruder_state['state'], extruder_state['park_pin']
+                                active_pin, grab_valid_pin = extruder_state['active_pin'], extruder_state['grab_valid_pin']
+                                pin_sta = ''.join(['T' if x else 'F' for x in [park_pin, active_pin, grab_valid_pin]])
+                                msg = f"Picking is not allowed for the {self.name}, status: {state} [{pin_sta}]"
+                                message = '{"coded": "0002-0523-%4d-0021", "oneshot": %d, "msg":"%s", "action": "pause"}' % (self.extruder_num, 0, msg)
+                                raise gcmd.error(message)
+                            else:
+                                raise gcmd.error("Pre-pick check failed for {}, {}".format(self.name, extruder_state), 'pause')
+                        gcmd.respond_info(f"Pre-pick check failed for {self.name}, retry {i}")
+                        toolhead.dwell(0.2)
+                        toolhead.wait_moves()
+
+                # gcode_move.absolute_coord = True
+                restore_state = True
+                if self.switch_accel != toolhead.max_accel:
+                    toolhead.set_accel(self.switch_accel)
+                gcmd.respond_info("pick {} !!!".format(self.name))
+                x_move_position = self.xy_park_position[0]
+                pos = toolhead.get_position()
+                if pos[1] > self.y_idle_position:
+                    toolhead.manual_move([None, self.y_idle_position, None], self.fast_move_speed)
+                    # gcmd.respond_info("G0 Y{} F{}".format(self.y_idle_position, self.fast_move_speed*60))
+
+                    toolhead.manual_move([x_move_position + [1, -1][self.grab_dir]*0.5, None, None], self.fast_move_speed)
+                    # gcmd.respond_info("G0 X{} F{}".format(x_move_position + [1, -1][self.grab_dir]*0.5, self.fast_move_speed*60))
+                    toolhead.manual_move([x_move_position, None, None], self.fast_move_speed)
+                    # gcmd.respond_info("G0 X{} F{}".format(x_move_position, self.fast_move_speed*60))
+                else:
+                    toolhead.manual_move([x_move_position + [1, -1][self.grab_dir]*0.5, None, None], self.fast_move_speed)
+                    # gcmd.respond_info("G0 X{} F{}".format(x_move_position + [1, -1][self.grab_dir]*0.5, self.fast_move_speed*60))
+                    toolhead.manual_move([x_move_position, None, None], self.fast_move_speed)
+                    # gcmd.respond_info("G0 X{} F{}".format(x_move_position, self.fast_move_speed*60))
+
+                    toolhead.manual_move([None, self.y_idle_position, None], self.fast_move_speed)
+                    # gcmd.respond_info("G0 Y{} F{}".format(self.y_idle_position, self.fast_move_speed*60))
+
+                y_move_position = max(self.xy_park_position[1] - self.inser_buffer_dist, self.y_idle_position)
+                toolhead.manual_move([None, y_move_position, None], self.fast_move_speed)
+                # gcmd.respond_info("G0 Y{} F{}".format(y_move_position, self.fast_move_speed*60))
+
+                toolhead.manual_move([None, self.xy_park_position[1], None], self.slow_move_speed)
+                # gcmd.respond_info("G0 Y{} F{}".format(self.xy_park_position[1], self.slow_move_speed*60))
+
+                x_move_position = self.xy_park_position[0] + [-1, 1][self.grab_dir]*self.horizontal_move_x
+                toolhead.manual_move([x_move_position, None, None], self.grab_speed)
+                # gcmd.respond_info("G0 X{} F{}".format(x_move_position, self.grab_speed*60))
+
+                toolhead.manual_move([x_move_position+[1, -1][self.grab_dir]*self.retract_x_dist, None, None], self.grab_speed)
+                # gcmd.respond_info("G0 X{} F{}".format(x_move_position+[1, -1][self.grab_dir]*self.retract_x_dist, self.grab_speed*60))
+
+                toolhead.manual_move([None, self.y_idle_position, None], self.fast_move_speed)
+                # gcmd.respond_info("G0 Y{} F{}".format(self.y_idle_position, self.fast_move_speed*60))
+
+                toolhead.wait_moves()
+                check_tick = toolhead.reactor.monotonic()
+                if extruder_list[i].switch_extruder_ctr_fan_pwm and check_tick - fan_close_tick < 2.5:
+                    gcmd.respond_info("wait_moves {}s!!!".format(2.5 - (check_tick - fan_close_tick)))
+                    toolhead.dwell(2.5 - (check_tick - fan_close_tick))
+                    toolhead.wait_moves()
+                if self.get_park_detector_status() is not None:
+                    for i in range(10):
+                        extruder_state = self.get_extruder_activate_status()
+                        retry_extruder_id = self.check_allow_retry_switch_extruder()
+                        if (extruder_state[0][1] == 0 and extruder_state[0][0] == self.name):
+                            break
+                        else:
+                            if i == 9:
+                                code = 35
+                                msg = "Extruder pickup failed, {}".format(extruder_state)
+                                extruder_num = self.extruder_num
+                                if extruder_state[0][1] == 0:
+                                    code = 22
+                                    msg = f"{self.name} pickup failed, target: {self.name} current: {extruder_state[0][0]}"
+                                elif extruder_state[0][1] == 1:
+                                    code = 23
+                                    msg = f"{self.name} pickup failed"
+                                elif extruder_state[0][1] == 2:
+                                    result = self.analyze_switch_extruder_error(extruder_state)
+                                    if result:
+                                        error_msg, activated, unknown, grip_states, activated_code, unknown_code = result
+                                        if "multi-act" in error_msg:
+                                            if 23 + activated_code < 35:
+                                                code = 23 + activated_code
+                                        else:
+                                            code = 35
+                                            if self.grab_hall_sensor_type:
+                                                first_unknow_state = grip_states[unknown[0]]
+                                                if first_unknow_state == 'FFT':
+                                                    code = 45
+                                                    extruder_num = unknown[0]
+                                                    error_msg = f'detected that extruder{unknown[0]} pogopin not connected. {error_msg}'
+                                                elif first_unknow_state == 'FFF':
+                                                    code = 46
+                                                    extruder_num = unknown[0]
+                                                    error_msg = f'detected that extruder{unknown[0]} is detached. {error_msg}'
+                                                elif first_unknow_state == 'TTT' or first_unknow_state == 'TTF':
+                                                    code = 47
+                                                    extruder_num = unknown[0]
+                                                    error_msg = f'detected conflicting status for extruder{unknown[0]}: both parked and picked states. {error_msg}'
+                                        msg = f"Extruder {self.name} pickup failed, {error_msg}"
+                                message = '{"coded": "0002-0523-%4d-%4d", "oneshot": %d, "msg":"%s", "action": "pause"}' % (extruder_num, code, 0, msg)
+                                if retry_extruder_id is not None:
+                                    raise ExtruderPickAbnormal(message)
+                                else:
+                                    raise gcmd.error(message)
+                            gcmd.respond_info("After picking the extruder, checking retry attempt {}, retry_extruder_id: {}".format(i, retry_extruder_id))
+                            toolhead.dwell(0.2)
+                            toolhead.wait_moves()
+            switch_recorder = self.printer.lookup_object('extruder_switch_recorder', None)
+            if switch_recorder is not None:
+                switch_recorder.add_switch_count(self.name)
+            switch_complete, is_grab_complete = True, True
+        except ExtruderParkAction as e:
+            pass
+        except Exception as e:
+            # if activate_status is not None:
+            #     gcmd.respond_info("extruder state: {}".format(activate_status))
+            raise
+        finally:
+            self.activating_move = False
+            for i in range(len(extruder_list)):
+                if fan_pwm_set and extruder_list[i].binding_fan is not None and extruder_list[i].switch_extruder_ctr_fan_pwm:
+                    extruder_list[i].binding_fan.set_speed_from_command(0)
+                    # print_time = max(extruder_list[i].binding_fan.last_fan_time+0.1, toolhead.get_last_move_time())
+                    # extruder_list[i].binding_fan.mcu_fan.set_pwm(print_time, 0)
+
+                if extruder_list[i].vref_sw is not None:
+                    if extruder_list[i].name == self.name:
+                        toolhead.register_lookahead_callback(lambda print_time: extruder_list[i].vref_sw._set_pin(print_time, 1))
+                        # extruder_list[i].vref_sw._set_pin(toolhead.get_last_move_time(), 1)
+                    else:
+                        toolhead.register_lookahead_callback(lambda print_time: extruder_list[i].vref_sw._set_pin(print_time, 0))
+                        # extruder_list[i].vref_sw._set_pin(toolhead.get_last_move_time(), 0)
+
+            if restore_state == True:
+                # Restore state
+                gcode_move.absolute_coord = saved_states['absolute_coord']
+                gcode_move.absolute_extrude = saved_states['absolute_extrude']
+                gcode_move.base_position = list(saved_states['base_position'])
+                gcode_move.homing_position = list(saved_states['homing_position'])
+                gcode_move.speed = saved_states['speed']
+                gcode_move.speed_factor = saved_states['speed_factor']
+                gcode_move.extrude_factor = saved_states['extrude_factor']
+                # Restore the relative E position
+                e_diff = gcode_move.last_position[3] - saved_states['last_position'][3]
+                gcode_move.base_position[3] += e_diff
+                if saved_states['max_accel'] != toolhead.max_accel:
+                    toolhead.set_accel(saved_states['max_accel'])
+                # gcmd.respond_info("Restore state")
+
+            if switch_complete == True:
+                # Activating extruder
+                gcmd.respond_info("Activating extruder %s" % (self.name,))
+                toolhead.flush_step_generation()
+                toolhead.set_extruder(self, self.last_position)
+                self.printer.send_event("extruder:activate_extruder")
+
+                # binding probe
+                self.active_binding_probe()
+                self.active_binding_fan()
+                # gcmd.respond_info("enable fan,  set turn on {}".format(saved_states['fan_speed']))
+                if saved_states['fan_speed'] is not None and saved_states['fan_speed'] > 0:
+                    print_fan.fan.set_speed_from_command(saved_states['fan_speed'])
+
+                # The current operation forces gcode_offset to be overwritten, and specific optimizations can be added later
+                if self.base_position is not None and self.gcode_offset is not None:
+                    build_params = {}
+                    build_params['X'] = str(self.gcode_offset[0])
+                    build_params['Y'] = str(self.gcode_offset[1])
+                    build_params['Z'] = str(self.gcode_offset[2])
+                    build_params['MOVE'] = '0'
+                    # gcmd.respond_info("gcode offset: {}".format(build_params))
+                    restore_offset_gcmd = gcode.create_gcode_command("", "", build_params)
+                    gcode_move.cmd_SET_GCODE_OFFSET(restore_offset_gcmd)
+            toolhead.set_grab_complete(is_grab_complete)
+
+    def cmd_MOVE_TO_XY_IDLE_POSITION(self, gcmd):
+        gcode_move = self.printer.lookup_object('gcode_move')
+        toolhead = self.printer.lookup_object('toolhead')
+        current_extruder = toolhead.get_extruder()
+        x_offset = gcmd.get_float('X_OFFSET', 0.)
+        y_offset = gcmd.get_float('Y_OFFSET', 0.)
+        z_offset = gcmd.get_float('Z_OFFSET', None)
+        speed = gcmd.get_float('SPEED', 200.)
+        accel = gcmd.get_float('ACCEL', None)
+
+        if not self.check_xy_homing():
+            raise gcmd.error("Activate extruder must home XY first")
+
+        x_idle_position = current_extruder.xy_park_position[0] + [1, -1][not current_extruder.grab_dir] * \
+                (current_extruder.horizontal_move_x - current_extruder.retract_x_dist)
+        if (current_extruder.name == "extruder"):
+            x_idle_position -= 2
+
+        y_idle_position = current_extruder.y_idle_position
+
+        toolhead.wait_moves()
+        gcode_move_status = gcode_move.get_status()
+        gcode_move.absolute_coord = True
+        old_accel = toolhead.max_accel
+        if accel == None:
+            accel = old_accel
+        pos = toolhead.get_position()
+        if not (pos[0] == x_idle_position + x_offset and pos[1] == y_idle_position + y_offset):
+            toolhead.max_accel = accel
+            toolhead._calc_junction_deviation()
+            if z_offset is not None:
+                toolhead.manual_move([None, None, pos[2] + z_offset], speed)
+            if pos[1] > current_extruder.y_idle_position:
+                toolhead.manual_move([None, y_idle_position, None], speed)
+                toolhead.manual_move([x_idle_position+x_offset, None, None], speed)
+                toolhead.manual_move([None, y_idle_position+y_offset, None], speed)
+            else:
+                toolhead.manual_move([x_idle_position+x_offset, None, None], speed)
+                toolhead.manual_move([None, y_idle_position+y_offset, None], speed)
+            toolhead.max_accel = old_accel
+            toolhead._calc_junction_deviation()
+            toolhead.wait_moves()
+
+        if not gcode_move_status['absolute_coordinates']:
+            gcode_move.absolute_coord = False
+
+    def cmd_INNER_APPLY_FLOW_K(self, gcmd):
+        apply = gcmd.get_int('APPLY', None)
+
+        if apply is not None:
+            if apply == 0:
+                self.is_calibrating_flow = False
+            else:
+                self.is_calibrating_flow = True
+    def cmd_SET_EXTRUDER_BASE_POSITION(self, gcmd):
+        # Check if this is the first time setting base_position
+        is_first_time = self.base_position is None
+
+        # Create new base position values
+        new_base_position = list(self.base_position) if self.base_position is not None else [0.0, 0.0, 0.0]
+
+        # Check for invalid use of _ADJUST parameters
+        has_adjust_params = any(gcmd.get_float(axis + '_ADJUST', None) is not None for axis in 'XYZ')
+        if is_first_time and has_adjust_params:
+            raise gcmd.error("Cannot use X_ADJUST, Y_ADJUST, or Z_ADJUST when base_position is not set. Use absolute values (X, Y, Z) instead.")
+
+        # Process parameters using the same pattern as gcode_move.py
+        any_param_specified = False
+        specified_axes = [False, False, False]  # X, Y, Z
+        for pos, axis in enumerate('XYZ'):
+            offset = gcmd.get_float(axis, None)
+            if offset is None:
+                offset = gcmd.get_float(axis + '_ADJUST', None)
+                if offset is None:
+                    continue
+                # Apply adjustment to current value
+                offset += new_base_position[pos]
+            # Set the new value
+            new_base_position[pos] = offset
+            any_param_specified = True
+            specified_axes[pos] = True
+
+        if not any_param_specified:
+            if self.base_position is not None:
+                gcmd.respond_info("Base position for %s: X:%.3f Y:%.3f Z:%.3f" %
+                                 (self.name, self.base_position[0], self.base_position[1], self.base_position[2]))
+            else:
+                gcmd.respond_info("Base position for %s is not set" % (self.name,))
+            return
+
+        # For first time setup, all axes must be specified
+        if is_first_time and not all(specified_axes):
+            raise gcmd.error("When setting base_position for the first time, all three axes (X, Y, Z) must be specified.")
+
+        # Update the base position in memory
+        self.base_position = new_base_position
+
+        # Save to config
+        configfile = self.printer.lookup_object('configfile')
+        extruder_bak = self.printer.lookup_object('extruder_config_bak', None)
+        if extruder_bak is None or not os.path.exists(extruder_bak.base_position_config_path):
+            configfile.set(self.name, 'base_position',
+                        "\n%.6f, %.6f, %.6f\n" % (self.base_position[0], self.base_position[1], self.base_position[2]))
+            self.printer.lookup_object('gcode').run_script_from_command("SAVE_CONFIG RESTART=0")
+        else:
+            if not self.update_extruder_config("base_position", new_base_position):
+                gcmd.respond_info("Warning: Failed to save base position to config file")
+
+        gcmd.respond_info("Base position for %s set to X:%.3f Y:%.3f Z:%.3f" %
+                         (self.name, new_base_position[0], new_base_position[1], new_base_position[2]))
+        # Update the gcode offset
+        self.printer.send_event("probe_inductance_coil: update_extruder_offset")
+
+    def cmd_SET_EXTRUDER_PARK_POSITION(self, gcmd):
+        # Check if park position is already set
+        if self.xy_park_position is None or self.y_idle_position is None:
+            raise gcmd.error("Park position is not set. Cannot modify park position.")
+
+        # Create new park position values
+        new_xy_park_position = list(self.xy_park_position)
+        new_y_idle_position = self.y_idle_position
+
+        # Process XY parameters
+        any_param_specified = False
+        for pos, axis in enumerate('XY'):
+            offset = gcmd.get_float(axis, None)
+            if offset is None:
+                offset = gcmd.get_float(axis + '_ADJUST', None)
+                if offset is None:
+                    continue
+                # Apply adjustment to current value
+                offset += new_xy_park_position[pos]
+            # Set the new value
+            new_xy_park_position[pos] = offset
+            any_param_specified = True
+
+        # Process Y_IDLE parameter
+        y_idle = gcmd.get_float('Y_IDLE', None)
+        if y_idle is None:
+            y_idle = gcmd.get_float('Y_IDLE_ADJUST', None)
+            if y_idle is None:
+                # Keep current value
+                y_idle = new_y_idle_position
+            else:
+                # Apply adjustment to current value
+                y_idle += new_y_idle_position
+                any_param_specified = True
+        else:
+            any_param_specified = True
+
+        if not any_param_specified:
+            # If no parameters specified, just report current values
+            gcmd.respond_info("Park position for %s: X:%.3f Y:%.3f Y_IDLE:%.3f" %
+                             (self.name, self.xy_park_position[0], self.xy_park_position[1], self.y_idle_position))
+            return
+
+        if not self.printer.check_extruder_config_permission():
+            raise gcmd.error("Permission denied. Park position modification not allowed.")
+
+        # Show what values are changing from and to
+        gcmd.respond_info("Park position for %s changed from X:%.3f Y:%.3f Y_IDLE:%.3f to X:%.3f Y:%.3f Y_IDLE:%.3f" %
+                         (self.name,
+                          self.xy_park_position[0], self.xy_park_position[1], self.y_idle_position,
+                          new_xy_park_position[0], new_xy_park_position[1], y_idle))
+
+        # Update the park position in memory
+        self.xy_park_position = new_xy_park_position
+        self.y_idle_position = y_idle
+
+        # Save to config
+        configfile = self.printer.lookup_object('configfile')
+        extruder_bak = self.printer.lookup_object('extruder_config_bak', None)
+        if extruder_bak is None or not os.path.exists(extruder_bak.config_path):
+            configfile.set(self.name, 'xy_park_position',
+                        "\n%.6f, %.6f\n" % (self.xy_park_position[0], self.xy_park_position[1]))
+            configfile.set(self.name, 'y_idle_position', "%.6f" % (self.y_idle_position,))
+            self.printer.lookup_object('gcode').run_script_from_command("SAVE_CONFIG RESTART=0")
+        else:
+            park_data = {
+                'xy_park_position': self.xy_park_position,
+                'y_idle_position': self.y_idle_position
+            }
+            if not self.update_extruder_config(None, park_data):
+                gcmd.respond_info("Warning: Failed to save park position to config file")
+
+        gcmd.respond_info("Park position for %s set to X:%.3f Y:%.3f Y_IDLE:%.3f" %
+                         (self.name, new_xy_park_position[0], new_xy_park_position[1], y_idle))
 
 # Dummy extruder class used when a printer has no extruder at all
 class DummyExtruder:
@@ -300,12 +1772,35 @@ class DummyExtruder:
         raise self.printer.command_error("Extruder not configured")
 
 def add_printer_objects(config):
+    global STRUCTURED_CODE_LIST
+    STRUCTURED_CODE_LIST = []
     printer = config.get_printer()
+    extruder_list = []
+    park_position_config = park_check_config = None
     for i in range(99):
         section = 'extruder'
         if i:
             section = 'extruder%d' % (i,)
         if not config.has_section(section):
             break
+        if 0 == i:
+            extruder_switch_recorder = ExtruderSwitchRecorder(config.getsection(section))
+            printer.add_object('extruder_switch_recorder', extruder_switch_recorder)
         pe = PrinterExtruder(config.getsection(section), i)
+        if 0 == i:
+            pe.active_binding_probe()
+            park_check_config = pe.park_detector
+            park_position_config = pe.xy_park_position
+        else:
+            if (park_check_config is None and pe.park_detector is not None) or (park_check_config is not None and pe.park_detector is None):
+                raise config.error("park_detector config mismatch,  extruder: {},  {}: {} !!!".format(
+                                  ['None', 'config'][park_check_config is not None],
+                                  pe.name, ['None', 'config'][pe.park_detector is not None]))
+
+            if (park_position_config is None and pe.xy_park_position is not None) or (park_position_config is not None and pe.xy_park_position is None):
+                raise config.error("xy_park_position config mismatch, extruder: {},  {}: {} !!!".format(
+                    ['None', 'config'][park_position_config is not None],
+                    pe.name, ['None', 'config'][pe.xy_park_position is not None]))
+        extruder_list.append(pe)
         printer.add_object(section, pe)
+    printer.add_object('extruder_list', extruder_list)
--- a/klippy/klippy.py
+++ b/klippy/klippy.py
@@ -4,9 +4,11 @@
 # Copyright (C) 2016-2024  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import sys, os, gc, optparse, logging, time, collections, importlib
-import util, reactor, queuelogger, msgproto
-import gcode, configfile, pins, mcu, toolhead, webhooks
+import sys, os, gc, optparse, logging, time, collections, importlib, json, copy, re
+import pwd, grp
+import util, reactor, queuelogger, msgproto, queuefile
+import gcode, configfile, pins, mcu, toolhead, webhooks, exception_manager, coded_exception
+# import traceback
 
 message_ready = "Printer is ready"
 
@@ -22,6 +24,8 @@ command to reload the config and restart the host software.
 Printer is halted
 """
 
+SCHED_FIFO_PRIORITY = 10  # SCHED_FIFO priority for the main thread
+
 class Printer:
     config_error = configfile.error
     command_error = gcode.CommandError
@@ -38,6 +42,136 @@ class Printer:
         # Init printer components that must be setup prior to config
         for m in [gcode, webhooks, exception_manager]:
             m.add_early_printer_objects(self)
+    def get_config_dir(self):
+        try:
+            return os.path.dirname(self.start_args['config_file'])
+        except Exception:
+            # return home directory if no config file is specified
+            return os.path.expanduser("~")
+    def set_extruder_power(self, state, extruder=['all']):
+        """Set the extruder power state."""
+        import multiprocessing
+        # run command "lava_io set HEAD_MCU_POWER=on_off" with os.system
+        try:
+            if state == 'on':
+                logging.info("Setting extruder power ON")
+                ps = 1
+                os.system("lava_io set HEAD_MCU_POWER=0 HEAD_MCU0_BOOT=1 HEAD_MCU1_BOOT=1 HEAD_MCU2_BOOT=1 HEAD_MCU3_BOOT=1")
+                time.sleep(0.2)
+            else:
+                logging.info("Setting extruder power OFF")
+                ps = 0
+            cmd = f"lava_io set HEAD_MCU_POWER={ps}"
+            p = multiprocessing.Process(target=os.system, args=(cmd,))
+            p.daemon = True  # Ensure the process exits when the main program exits
+            p.start()
+        except Exception as e:
+            logging.error(f"Failed to set extruder power: {e}")
+            return False
+        return True
+    def set_main_mcu_power(self, state):
+        try:
+            if state == 'on':
+                logging.info("Setting main MCU power ON")
+                os.system("lava_io set MAIN_MCU_POWER=0")
+                time.sleep(0.2)
+                os.system("lava_io set MAIN_MCU_POWER=1")
+            else:
+                logging.info("Setting main MCU power OFF")
+                os.system("lava_io set MAIN_MCU_POWER=0")
+            return True
+        except Exception as e:
+            logging.error(f"Failed to set main power: {e}")
+            return False
+    def get_snapmaker_config_dir(self, dir_name="snapmaker"):
+        dir = os.path.join(self.get_config_dir(), dir_name)
+        try:
+            if not os.path.exists(dir):
+                os.makedirs(dir)
+        except Exception:
+            logging.error("Failed to create Snapmaker config directory")
+            return os.path.expanduser("~")
+        return dir
+
+    def check_extruder_config_permission(self):
+        """Check if extruder config modification is permitted"""
+        config_dir = self.get_snapmaker_config_dir()
+        permission_file = os.path.join(config_dir, ".allow_extruder_modification")
+        if os.path.exists(permission_file):
+            return True
+
+        udisk_permission_file = "/mnt/udisk/.allow_extruder_modification"
+        return os.path.exists(udisk_permission_file)
+
+    def is_valid_json_format(self, obj):
+        if not isinstance(obj, dict):
+            return False
+        try:
+            json.dumps(obj)
+            return True
+        except TypeError:
+            return False
+        except Exception as e:
+            return False
+
+    def load_snapmaker_config_file(self, path=None, default_config=None, format='json',
+                                   create_if_not_exist=False):
+        if path is None:
+            raise ValueError("The path parameter must be specified!")
+        if not format in ['json']:
+            raise ValueError("The file format is not supported: %s" % (format))
+
+        config_info = None
+        if format == 'json':
+            try:
+                with open(path, 'r', encoding='utf-8') as file:
+                    config_info = json.load(file)
+                if default_config is not None:
+                    config_info.update({key: config_info.get(key, default_value) for key, default_value in default_config.items()})
+            except FileNotFoundError as e:
+                logging.error("config file not exits: %s" % (path))
+                if default_config is not None:
+                    config_info = copy.deepcopy(default_config)
+                else:
+                    config_info = {}
+                try:
+                    if create_if_not_exist:
+                        json_content = json.dumps(config_info, indent=4)
+                        queuefile.async_write_file(path, json_content, safe_write=True)
+                except:
+                    logging.error("create config file err: %s" % (path))
+            except Exception as e:
+                if default_config is not None:
+                    config_info = copy.deepcopy(default_config)
+                else:
+                    config_info = {}
+
+        return config_info
+
+    def update_snapmaker_config_file(self, path=None, config_info=None, default_config=None, format='json'):
+        if path is None:
+            raise ValueError("The path parameter must be specified!")
+        if not format in ['json']:
+            raise ValueError("The file format is not supported: %s" % (format))
+
+        update_ok = False
+        if format == 'json':
+            if config_info == None:
+                config_info = {}
+
+            if not self.is_valid_json_format(config_info):
+                raise ValueError("The config_info is not json format!")
+
+            try:
+                json_content = json.dumps(config_info, indent=4)
+                queuefile.async_write_file(path, json_content, safe_write=True)
+                update_ok = True
+            except IOError as e:
+                logging.error(f"Error writing to file: {e}")
+            except Exception as e:
+                logging.error(f"Unknown error: {e}")
+            finally:
+                return update_ok
 
     def extract_encoded_message(self, message):
         try:
@@ -346,6 +480,8 @@ class Printer:
         monotime = self.reactor.monotonic()
         logging.info("Start printer at %s (%.1f %.1f)",
                      time.asctime(time.localtime(systime)), systime, monotime)
+        self.set_main_mcu_power('on')
+        self.set_extruder_power('on')
         # Enter main reactor loop
         try:
             self.reactor.run()
@@ -466,6 +602,74 @@ def arg_dictionary(option, opt_str, value, parser):
         parser.values.dictionary = {}
     parser.values.dictionary[key] = fname
 
+def set_sched_fifo():
+    try:
+        import ctypes
+        SCHED_FIFO = 1
+        class sched_param(ctypes.Structure):
+            _fields_ = [('sched_priority', ctypes.c_int)]
+        param = sched_param(SCHED_FIFO_PRIORITY)
+        libc = ctypes.CDLL('libc.so.6')
+        res = libc.sched_setscheduler(0, SCHED_FIFO, ctypes.byref(param))
+        if res != 0:
+            logging.warning('Failed to set SCHED_FIFO, permission denied or not supported.')
+        else:
+            logging.info('SCHED_FIFO set successfully with priority %d', SCHED_FIFO_PRIORITY)
+    except Exception as e:
+        logging.warning('Exception setting SCHED_FIFO: %s', e)
+
+def switch_user_group(user_name):
+    """Switch the process to run as the specified user and group."""
+    if user_name is None:
+        return
+
+    try:
+        # Get current user info to check if we need to switch
+        current_uid = os.getuid()
+        current_user = pwd.getpwuid(current_uid).pw_name
+
+        # If already running as the target user, no need to switch
+        if current_user == user_name:
+            logging.info("Already running as user '%s'", user_name)
+            return
+
+        # Only root can switch to another user
+        if current_uid != 0:
+            logging.warning("Cannot switch to user '%s': not running as root", user_name)
+            return
+
+        # Get user and group information
+        try:
+            user_info = pwd.getpwnam(user_name)
+        except KeyError:
+            logging.error("User '%s' not found", user_name)
+            return
+
+        user_uid = user_info.pw_uid
+        user_gid = user_info.pw_gid
+        user_home = user_info.pw_dir
+
+        # Get supplementary groups for the user
+        groups = [g.gr_gid for g in grp.getgrall() if user_name in g.gr_mem]
+        groups.append(user_gid)  # Add primary group
+
+        # Switch to the new user and group
+        os.setgroups(groups)  # Set supplementary groups
+        os.setregid(user_gid, user_gid)  # Set real and effective group ID
+        os.setreuid(user_uid, user_uid)  # Set real and effective user ID
+
+        # Set HOME environment variable
+        os.environ['HOME'] = user_home
+        os.environ['USER'] = user_name
+
+        logging.info("Successfully switched to user '%s' (uid=%d, gid=%d)",
+                    user_name, user_uid, user_gid)
+
+    except OSError as e:
+        logging.error("Failed to switch to user '%s': %s", user_name, str(e))
+    except Exception as e:
+        logging.error("Unexpected error switching to user '%s': %s", user_name, str(e))
+
 def main():
     usage = "%prog [options] <config file>"
     opts = optparse.OptionParser(usage)
@@ -487,13 +691,19 @@ def main():
                     help="file to read for mcu protocol dictionary")
     opts.add_option("--import-test", action="store_true",
                     help="perform an import module test")
+    opts.add_option("-u", "--user", dest="run_user", default="lava",
+                    help="run as user (default: lava)")
+    opts.add_option("-f", "--factory", dest="factory_mode", action="store_true",
+                    help="enable factory mode")
     options, args = opts.parse_args()
+    switch_user_group(options.run_user)
     if options.import_test:
         import_test()
     if len(args) != 1:
         opts.error("Incorrect number of arguments")
     start_args = {'config_file': args[0], 'apiserver': options.apiserver,
                   'start_reason': 'startup'}
+    start_args["factory_mode"] = True if options.factory_mode else False
 
     debuglevel = logging.INFO
     if options.verbose:
@@ -513,6 +723,7 @@ def main():
         bglogger = queuelogger.setup_bg_logging(options.logfile, debuglevel)
     else:
         logging.getLogger().setLevel(debuglevel)
+    queuefile.setup_bg_file_operations()
     logging.info("Starting Klippy...")
     git_info = util.get_git_version()
     git_vers = git_info["version"]
@@ -550,7 +761,7 @@ def main():
         logging.warning("No log file specified!"
                         " Severe timing issues may result!")
     gc.disable()
-
+    logging.info(f'start args: {start_args}')
     # Start Printer() class
     while 1:
         if bglogger is not None:
@@ -571,8 +782,11 @@ def main():
     if bglogger is not None:
         bglogger.stop()
 
+    queuefile.clear_bg_file_operations()
+
     if res == 'error_exit':
         sys.exit(-1)
 
 if __name__ == '__main__':
+    set_sched_fifo()
     main()
--- a/klippy/mcu.py
+++ b/klippy/mcu.py
@@ -223,7 +223,7 @@ class MCU_trsync:
             s.note_homing_end()
         return params['trigger_reason']
 
-TRSYNC_TIMEOUT = 0.025
+TRSYNC_TIMEOUT = 0.050
 TRSYNC_SINGLE_MCU_TIMEOUT = 0.250
 
 class TriggerDispatch:
@@ -285,7 +285,7 @@ class TriggerDispatch:
         return res[0]
 
 class MCU_endstop:
-    def __init__(self, mcu, pin_params):
+    def __init__(self, mcu, pin_params, is_pulse_gpio=False):
         self._mcu = mcu
         self._pin = pin_params['pin']
         self._pullup = pin_params['pullup']
@@ -294,6 +294,7 @@ class MCU_endstop:
         self._home_cmd = self._query_cmd = None
         self._mcu.register_config_callback(self._build_config)
         self._rest_ticks = 0
+        self._is_pulse_gpio = is_pulse_gpio
         self._dispatch = TriggerDispatch(mcu)
     def get_mcu(self):
         return self._mcu
@@ -303,8 +304,8 @@ class MCU_endstop:
         return self._dispatch.get_steppers()
     def _build_config(self):
         # Setup config
-        self._mcu.add_config_cmd("config_endstop oid=%d pin=%s pull_up=%d"
-                                 % (self._oid, self._pin, self._pullup))
+        self._mcu.add_config_cmd("config_endstop oid=%d pin=%s pull_up=%d is_pulse_gpio=%d"
+                                 % (self._oid, self._pin, self._pullup, self._is_pulse_gpio))
         self._mcu.add_config_cmd(
             "endstop_home oid=%d clock=0 sample_ticks=0 sample_count=0"
             " rest_ticks=0 pin_value=0 trsync_oid=0 trigger_reason=0"
@@ -494,6 +495,7 @@ class MCU_adc:
         self._oid = self._callback = None
         self._mcu.register_config_callback(self._build_config)
         self._inv_max_adc = 0.
+        self._read_time_tol = self._min_update_ratio = None
     def get_mcu(self):
         return self._mcu
     def setup_adc_sample(self, sample_time, sample_count,
@@ -506,6 +508,9 @@ class MCU_adc:
     def setup_adc_callback(self, report_time, callback):
         self._report_time = report_time
         self._callback = callback
+    def set_read_tolerance(self, read_time_tol, min_update_ratio):
+        self._read_time_tol = read_time_tol
+        self._min_update_ratio = min_update_ratio
     def get_last_value(self):
         return self._last_state
     def _build_config(self):
@@ -536,6 +541,30 @@ class MCU_adc:
         next_clock = self._mcu.clock32_to_clock64(params['next_clock'])
         last_read_clock = next_clock - self._report_clock
         last_read_time = self._mcu.clock_to_print_time(last_read_clock)
+        if self._read_time_tol is not None and self._min_update_ratio is not None:
+            # Get the current print time
+            curtime = self._mcu.get_printer().get_reactor().monotonic()
+            printtime = self._mcu.estimated_print_time(curtime)
+            allow_max_read_time = printtime - self._report_time*self._read_time_tol
+            adc_except_recorder = self._mcu.get_printer().lookup_object('adc_except_recorder', None)
+            mcu_name = self._mcu.get_name()
+            oid = self._oid
+            if last_read_time < allow_max_read_time:
+                if adc_except_recorder is not None:
+                    mcu_dict = adc_except_recorder.setdefault(mcu_name, {})
+                    oid_dict = mcu_dict.setdefault(oid, {})
+                    oid_dict.setdefault('too_late', 0)
+                    oid_dict['too_late'] += 1
+                    oid_dict['last_read_time_too_late'] = printtime - last_read_time
+                return
+            if last_read_time - self._last_state[1] < self._report_time*self._min_update_ratio:
+                if adc_except_recorder is not None:
+                    mcu_dict = adc_except_recorder.setdefault(mcu_name, {})
+                    oid_dict = mcu_dict.setdefault(oid, {})
+                    oid_dict.setdefault('too_fast', 0)
+                    oid_dict['too_fast'] += 1
+                    oid_dict['last_read_time_too_fast'] = last_read_time - self._last_state[1]
+                return
         self._last_state = (last_value, last_read_time)
         if self._callback is not None:
             self._callback(last_read_time, last_value)
@@ -556,7 +585,7 @@ class MCU:
             self._name = self._name[4:]
         # Serial port
         wp = "mcu '%s': " % (self._name)
-        self._serial = serialhdl.SerialReader(self._reactor, warn_prefix=wp)
+        self._serial = serialhdl.SerialReader(self._reactor, warn_prefix=wp, mcu=self)
         self._baud = 0
         self._canbus_iface = None
         canbus_uuid = config.get('canbus_uuid', None)
@@ -604,6 +633,16 @@ class MCU:
         self._mcu_tick_avg = 0.
         self._mcu_tick_stddev = 0.
         self._mcu_tick_awake = 0.
+        self._mcu_err_msg_len = 0
+        self._mcu_err_msg_dest = 0
+        self._mcu_err_msg_sync = 0
+        self._mcu_err_msg_crc = 0
+        adc_except_recorder = self._printer.lookup_object('adc_except_recorder', None)
+        if adc_except_recorder is None:
+            printer.add_object('adc_except_recorder', {})
+        if self._name == 'mcu':
+            gcode = self._printer.lookup_object('gcode')
+            gcode.register_command('QUERY_ADC_EXCEPT_RECORDER', self.cmd_QUERY_ADC_EXCEPT_RECORDER)
         # Register handlers
         printer.load_object(config, "error_mcu")
         printer.register_event_handler("klippy:firmware_restart",
@@ -614,6 +653,10 @@ class MCU:
         printer.register_event_handler("klippy:shutdown", self._shutdown)
         printer.register_event_handler("klippy:disconnect", self._disconnect)
         printer.register_event_handler("klippy:ready", self._ready)
+    def cmd_QUERY_ADC_EXCEPT_RECORDER(self, gcmd):
+        adc_except_recorder = self._printer.lookup_object('adc_except_recorder', None)
+        if adc_except_recorder is not None:
+            gcmd.respond_info("adc_except_recorder: {}".format(adc_except_recorder))
     # Serial callbacks
     def _handle_mcu_stats(self, params):
         count = params['count']
@@ -624,6 +667,14 @@ class MCU:
         diff = count*tick_sumsq - tick_sum**2
         self._mcu_tick_stddev = c * math.sqrt(max(0., diff))
         self._mcu_tick_awake = tick_sum / self._mcu_freq
+        if 'err_len' in params:
+            self._mcu_err_msg_len = params['err_len']
+        if 'err_dest' in params:
+            self._mcu_err_msg_dest = params['err_dest']
+        if 'err_sync' in params:
+            self._mcu_err_msg_sync = params['err_sync']
+        if 'err_crc' in params:
+            self._mcu_err_msg_crc = params['err_crc']
     def _handle_shutdown(self, params):
         if self._is_shutdown:
             return
@@ -841,10 +892,12 @@ class MCU:
             pconfig.runtime_warning(msg)
     # Config creation helpers
     def setup_pin(self, pin_type, pin_params):
-        pcs = {'endstop': MCU_endstop,
+        pcs = {'endstop': MCU_endstop, 'pulse_endstop': MCU_endstop,
                'digital_out': MCU_digital_out, 'pwm': MCU_pwm, 'adc': MCU_adc}
         if pin_type not in pcs:
             raise pins.error("pin type %s not supported on mcu" % (pin_type,))
+        if pin_type == 'pulse_endstop':
+            return pcs[pin_type](self, pin_params, True)
         return pcs[pin_type](self, pin_params)
     def create_oid(self):
         self._oid_count += 1
@@ -896,6 +949,8 @@ class MCU:
         return self._clocksync.print_time_to_clock(print_time)
     def clock_to_print_time(self, clock):
         return self._clocksync.clock_to_print_time(clock)
+    def estimate_clock_systime(self, clock):
+        return self._clocksync.estimate_clock_systime(clock)
     def estimated_print_time(self, eventtime):
         return self._clocksync.estimated_print_time(eventtime)
     def clock32_to_clock64(self, clock32):
--- /dev/null
+++ b/klippy/printer_device_scan.py
@@ -0,0 +1,136 @@
+# device Scanning Processing
+
+import subprocess, re, configparser
+
+SOC_MCU_STRING = "Geschwister Schneider CAN adapter"
+EXTRUDER_MCU_STRING = "usb-Klipper"
+CFG_MCU_SECTION_NAME = ["mcu", "mcu E0", "mcu E1", "mcu E2", "mcu E3"]
+SCAN_RESULT_MAP_INDEX = {'scan_mcu_number': 0, 'mcu': 1, 'mcu E0': 2, 'mcu E1': 3, 'mcu E2': 4, 'mcu E3': 5}
+OPTION_NAME = 'serial'
+
+def run_shell_command(command):
+    try:
+        output = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
+        return [output.returncode, output.stdout.strip(), output.stderr.strip()]
+    except subprocess.CalledProcessError as e:
+        return [e.returncode, e.output, e.stderr]
+    except Exception as e:
+        return [-1, None, str(e)]
+
+def scan_mcu_device():
+    mcu_info_list = [0, None, None, None, None, None]
+    def get_usb_devices():
+        return run_shell_command("lsusb")
+    def get_serial_devices():
+        return run_shell_command("ls /dev/serial/by-id/")
+    def contains_instruction(main_string, instruction):
+        return instruction in main_string
+    def update_mcu_list(device, index):
+        if contains_instruction(device, EXTRUDER_MCU_STRING) and (f"/dev/serial/by-id/{device}") not in mcu_info_list:
+            mcu_info_list[index + 2] = f"/dev/serial/by-id/{device}"
+            mcu_info_list[0] += 1
+            return True
+        return False
+
+    # soc mcu scan
+    # TODO: power down the soc mcu and all extruder mcu's
+    pass
+    # TODO: boot pin configuration, soc mcu normal, mcu0 boot, mcu1 boot, mcu2 boot, mcu3 boot
+    pass
+    # TODO: power on soc mcu
+    pass
+    if get_usb_devices()[0] == 0:
+        devices = re.split(r'\r?\n', get_usb_devices()[1])
+        for device in devices:
+            if contains_instruction(device, SOC_MCU_STRING):
+                mcu_info_list[1] = "/dev/ttyS6"
+                mcu_info_list[0] += 1
+                break
+
+    for index in range(4):
+        # TODO: power down the soc mcu and all extruder mcu's
+        pass
+        # TODO: boot pin configuration, soc mcu, mcu0, mcu1, mcu2, mcu3
+        pass
+        # TODO: power on the specified mcu
+        pass
+        if get_serial_devices()[0] == 0:
+            devices = re.split(r'\r?\n', get_serial_devices()[1])
+            for device in devices:
+                if update_mcu_list(device, index):
+                    break
+    # TODO: power on all mcu
+    print(mcu_info_list)
+    return mcu_info_list
+
+# lists info_list and section_name_list must correspond to each other
+def update_printer_cfg(cfg_file_path, info_list, section_name_list, option):
+    config = configparser.ConfigParser()
+    config.read(cfg_file_path)
+    sections_to_add = []
+    option_to_add = []
+    sections_to_update = []
+
+    for index, mcu_section in enumerate(section_name_list):
+        if not config.has_section(mcu_section):
+            # print(f"no have section {mcu_section}")
+            config.add_section(mcu_section)
+            config.set(mcu_section, option, f"{info_list[index]}")
+            sections_to_add.append([mcu_section, option, info_list[index]])
+        else:
+            if not config.has_option(mcu_section, option):
+                # print(f"no have option {mcu_section}")
+                config.set(mcu_section, option, f"{info_list[index]}")
+                option_to_add.append([mcu_section, option, info_list[index]])
+            elif config.get(mcu_section, option) != info_list[index] and (config.get(mcu_section, option) is not None and info_list[index] is not None):
+                # print(f"update option {mcu_section}")
+                config.set(mcu_section, option, f"{info_list[index]}")
+                sections_to_update.append([mcu_section, option, info_list[index]])
+
+    if len(sections_to_update) or len(sections_to_add) or len(option_to_add):
+        with open(cfg_file_path, 'r') as file:
+            lines = file.readlines()
+
+        updated_lines = []
+        section_name = None
+        is_first_section = True
+
+        for line in lines:
+            if line.startswith(';') or line.startswith('#') or line.strip() == '':
+                updated_lines.append(line)
+                continue
+
+            if line.startswith('['):
+                section_name = line.strip('[]\n')
+                if is_first_section:
+                    wrap = ""
+                    for index in range(len(sections_to_add)):
+                        updated_lines.append(f"{wrap}[{sections_to_add[index][0]}]\n")
+                        updated_lines.append(f"{sections_to_add[index][1]}: {sections_to_add[index][2]}\n")
+                        wrap = '\n'
+                        if index + 1 == len(sections_to_add):
+                            updated_lines.append("\n")
+                    is_first_section = False
+
+                option_to_add_fg = False
+                for index in range(len(option_to_add)):
+                    if section_name == option_to_add[index][0]:
+                        updated_lines.append(line)
+                        updated_lines.append(f"{option_to_add[index][1]}: {option_to_add[index][2]}\n")
+                        option_to_add_fg = True
+                        break
+                if option_to_add_fg:
+                    continue
+            elif line.startswith(option + '=') or line.startswith(option + ':'):
+                for index in range(len(sections_to_update)):
+                    if section_name == sections_to_update[index][0]:
+                        line = f"{sections_to_update[index][1]}: {sections_to_update[index][2]}\n"
+                        break
+            updated_lines.append(line)
+
+        with open(cfg_file_path, 'w') as file:
+            file.writelines(updated_lines)
+
+if __name__ == '__main__':
+    dev_list = scan_mcu_device()
+    # update_printer_cfg("test.cfg", dev_list[1:], CFG_MCU_SECTION_NAME, OPTION_NAME)
\ No newline at end of file
--- /dev/null
+++ b/klippy/queuefile.py
@@ -0,0 +1,261 @@
+import threading, queue, time, os, shutil
+from concurrent.futures import Future
+
+QUEUE_SIZE = 1000
+QUEUE_TIMEOUT = 1.0
+DEFAULT_SYNC_TIMEOUT = 30.0
+
+class FileOperationException(Exception):
+    pass
+
+class FileOperationTimeout(Exception):
+    pass
+
+class FileOperation:
+    def __init__(self, op_type, filename, content=None, flush=False, sync=False, timeout=None, safe_write=False):
+        self.op_type = op_type
+        self.filename = filename
+        self.content = content
+        self.flush = flush
+        self.sync = sync
+        self.timeout = timeout or DEFAULT_SYNC_TIMEOUT
+        self.safe_write = safe_write
+        self.timestamp = time.time()
+        self.future = Future() if sync else None
+        self.result = None
+        self.exception = None
+
+class QueueHandler:
+    def __init__(self, bg_queue):
+        self.bg_queue = bg_queue
+
+    def write_file(self, filename, content, flush=False, safe_write=False):
+        op = FileOperation("write", filename, content, flush, False, None, safe_write)
+        try:
+            self.bg_queue.put_nowait(op)
+        except queue.Full:
+            raise FileOperationException("File operation queue is full")
+
+    def delete_file(self, filename):
+        op = FileOperation("delete", filename)
+        try:
+            self.bg_queue.put_nowait(op)
+        except queue.Full:
+            raise FileOperationException("File operation queue is full")
+
+    def append_file(self, filename, content, flush=False, safe_write=False):
+        op = FileOperation("append", filename, content, flush, False, None, safe_write)
+        try:
+            self.bg_queue.put_nowait(op)
+        except queue.Full:
+            raise FileOperationException("File operation queue is full")
+
+class QueueListener:
+    def __init__(self):
+        self.bg_queue = queue.Queue(maxsize=QUEUE_SIZE)
+        self.bg_thread = threading.Thread(target=self._bg_thread)
+        self.handler = QueueHandler(self.bg_queue)
+        self.bg_thread.start()
+
+    def _bg_thread(self):
+        while True:
+            try:
+                op = self.bg_queue.get(True)
+                if op is None:
+                    break
+                self._process_operation(op)
+                self.bg_queue.task_done()
+            except Exception:
+                continue
+
+    def _process_operation(self, op):
+        try:
+            result = None
+            exception = None
+
+            if op.op_type == "write":
+                directory = os.path.dirname(op.filename)
+                if directory and not os.path.exists(directory):
+                    os.makedirs(directory, exist_ok=True)
+
+                if op.safe_write:
+                    temp_filename = op.filename + ".tmp"
+                    try:
+                        with open(temp_filename, 'w') as f:
+                            if op.content:
+                                f.write(op.content)
+                            if op.flush:
+                                f.flush()
+                                # os.fsync(f.fileno())
+                        os.replace(temp_filename, op.filename)
+                    except Exception:
+                        if os.path.exists(temp_filename):
+                            try:
+                                os.remove(temp_filename)
+                            except:
+                                pass
+                        raise
+                else:
+                    with open(op.filename, 'w') as f:
+                        if op.content:
+                            f.write(op.content)
+                        if op.flush:
+                            f.flush()
+                            # os.fsync(f.fileno())
+                result = True
+
+            elif op.op_type == "delete":
+                if os.path.exists(op.filename):
+                    os.remove(op.filename)
+                elif os.path.isdir(op.filename):
+                    shutil.rmtree(op.filename)
+                result = True
+
+            elif op.op_type == "append":
+                directory = os.path.dirname(op.filename)
+                if directory and not os.path.exists(directory):
+                    os.makedirs(directory, exist_ok=True)
+
+                if op.safe_write:
+                    temp_filename = op.filename + ".tmp"
+                    try:
+                        original_content = ""
+                        if os.path.exists(op.filename):
+                            with open(op.filename, 'r') as f:
+                                original_content = f.read()
+
+                        with open(temp_filename, 'w') as f:
+                            f.write(original_content)
+                            if op.content:
+                                f.write(op.content)
+                            if op.flush:
+                                f.flush()
+                                # os.fsync(f.fileno())
+
+                        os.replace(temp_filename, op.filename)
+                    except Exception:
+                        if os.path.exists(temp_filename):
+                            try:
+                                os.remove(temp_filename)
+                            except:
+                                pass
+                        raise
+                else:
+                    with open(op.filename, 'a') as f:
+                        if op.content:
+                            f.write(op.content)
+                        if op.flush:
+                            f.flush()
+                            # os.fsync(f.fileno())
+                result = True
+
+            if op.sync:
+                if op.future:
+                    if exception:
+                        op.future.set_exception(exception)
+                    else:
+                        op.future.set_result(result)
+                else:
+                    op.result = result
+                    op.exception = exception
+
+        except Exception as e:
+            exception = FileOperationException(f"File operation failed: {str(e)}")
+            if op.sync:
+                if op.future:
+                    op.future.set_exception(exception)
+                else:
+                    op.exception = exception
+
+    def write_file(self, filename, content, flush=False, safe_write=False):
+        return self.handler.write_file(filename, content, flush, safe_write)
+
+    def delete_file(self, filename):
+        return self.handler.delete_file(filename)
+
+    def append_file(self, filename, content, flush=False, safe_write=False):
+        return self.handler.append_file(filename, content, flush, safe_write)
+
+    def stop(self):
+        self.bg_queue.put_nowait(None)
+        self.bg_thread.join()
+
+MainQueueHandler = None
+
+def setup_bg_file_operations():
+    global MainQueueHandler
+    if MainQueueHandler is None:
+        MainQueueHandler = QueueListener()
+    return MainQueueHandler
+
+def clear_bg_file_operations():
+    global MainQueueHandler
+    if MainQueueHandler is not None:
+        MainQueueHandler.stop()
+        MainQueueHandler = None
+
+def async_write_file(filename, content, flush=False, safe_write=False):
+    listener = setup_bg_file_operations()
+    return listener.write_file(filename, content, flush, safe_write)
+
+def async_delete_file(filename):
+    listener = setup_bg_file_operations()
+    return listener.delete_file(filename)
+
+def async_append_file(filename, content, flush=False, safe_write=False):
+    listener = setup_bg_file_operations()
+    return listener.append_file(filename, content, flush, safe_write)
+
+def sync_write_file(reactor, filename, content, flush=False, safe_write=False, timeout=None):
+    listener = setup_bg_file_operations()
+    op = FileOperation("write", filename, content, flush, sync=True, timeout=timeout or DEFAULT_SYNC_TIMEOUT, safe_write=safe_write)
+
+    try:
+        listener.handler.bg_queue.put(op, timeout=1.0)
+    except queue.Full:
+        raise FileOperationException("File operation queue is full")
+
+    deadline = reactor.monotonic() + (timeout or DEFAULT_SYNC_TIMEOUT)
+
+    while not op.future.done():
+        if reactor.monotonic() > deadline:
+            raise FileOperationTimeout("File operation timed out")
+
+        reactor.pause(reactor.monotonic() + 0.01)
+    return op.future.result()
+
+def sync_delete_file(reactor, filename, timeout=None):
+    listener = setup_bg_file_operations()
+    op = FileOperation("delete", filename, None, False, sync=True, timeout=timeout or DEFAULT_SYNC_TIMEOUT)
+
+    try:
+        listener.handler.bg_queue.put(op, timeout=1.0)
+    except queue.Full:
+        raise FileOperationException("File operation queue is full")
+
+    deadline = reactor.monotonic() + (timeout or DEFAULT_SYNC_TIMEOUT)
+
+    while not op.future.done():
+        if reactor.monotonic() > deadline:
+            raise FileOperationTimeout("File operation timed out")
+
+        reactor.pause(reactor.monotonic() + 0.01)
+    return op.future.result()
+
+def sync_append_file(reactor, filename, content, flush=False, safe_write=False, timeout=None):
+    listener = setup_bg_file_operations()
+    op = FileOperation("append", filename, content, flush, sync=True, timeout=timeout or DEFAULT_SYNC_TIMEOUT, safe_write=safe_write)
+
+    try:
+        listener.handler.bg_queue.put(op, timeout=1.0)
+    except queue.Full:
+        raise FileOperationException("File operation queue is full")
+
+    deadline = reactor.monotonic() + (timeout or DEFAULT_SYNC_TIMEOUT)
+
+    while not op.future.done():
+        if reactor.monotonic() > deadline:
+            raise FileOperationTimeout("File operation timed out")
+
+        reactor.pause(reactor.monotonic() + 0.01)
+    return op.future.result()
--- a/klippy/queuelogger.py
+++ b/klippy/queuelogger.py
@@ -5,6 +5,19 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, logging.handlers, threading, queue, time
 
+FILE_SIZE  = 10 * 1024 * 1024   # 10 MiB
+FILE_COUNT = 15                 # 15 files
+
+# Custom formatter to add timestamp with milliseconds
+class MillisecondFormatter(logging.Formatter):
+    def formatTime(self, record, datefmt=None):
+        ct = self.converter(record.created)
+        if datefmt:
+            s = time.strftime(datefmt, ct)
+        else:
+            s = time.strftime("%H:%M:%S", ct)
+        return "%s.%03d" % (s, (record.msecs % 1000))
+
 # Class to forward all messages through a queue to a background thread
 class QueueHandler(logging.Handler):
     def __init__(self, queue):
@@ -21,10 +34,13 @@ class QueueHandler(logging.Handler):
             self.handleError(record)
 
 # Class to poll a queue in a background thread and log each message
-class QueueListener(logging.handlers.TimedRotatingFileHandler):
-    def __init__(self, filename):
-        logging.handlers.TimedRotatingFileHandler.__init__(
-            self, filename, when='midnight', backupCount=5)
+class QueueListener(logging.handlers.RotatingFileHandler):
+    def __init__(self, filename, maxBytes=FILE_SIZE, backupCount=FILE_COUNT):
+        logging.handlers.RotatingFileHandler.__init__(
+            self, filename, maxBytes=maxBytes, backupCount=backupCount)
+        # Add formatter with milliseconds
+        formatter = MillisecondFormatter("%(asctime)s:%(message)s")
+        self.setFormatter(formatter)
         self.bg_queue = queue.Queue()
         self.bg_thread = threading.Thread(target=self._bg_thread)
         self.bg_thread.start()
@@ -46,7 +62,7 @@ class QueueListener(logging.handlers.TimedRotatingFileHandler):
     def clear_rollover_info(self):
         self.rollover_info.clear()
     def doRollover(self):
-        logging.handlers.TimedRotatingFileHandler.doRollover(self)
+        logging.handlers.RotatingFileHandler.doRollover(self)
         lines = [self.rollover_info[name]
                  for name in sorted(self.rollover_info)]
         lines.append(
@@ -57,9 +73,9 @@ class QueueListener(logging.handlers.TimedRotatingFileHandler):
 
 MainQueueHandler = None
 
-def setup_bg_logging(filename, debuglevel):
+def setup_bg_logging(filename, debuglevel, maxBytes=FILE_SIZE):
     global MainQueueHandler
-    ql = QueueListener(filename)
+    ql = QueueListener(filename, maxBytes=maxBytes)
     MainQueueHandler = QueueHandler(ql.bg_queue)
     root = logging.getLogger()
     root.addHandler(MainQueueHandler)
--- a/klippy/serialhdl.py
+++ b/klippy/serialhdl.py
@@ -12,9 +12,10 @@ class error(Exception):
     pass
 
 class SerialReader:
-    def __init__(self, reactor, warn_prefix=""):
+    def __init__(self, reactor, warn_prefix="", mcu=None):
         self.reactor = reactor
         self.warn_prefix = warn_prefix
+        self._mcu = mcu
         # Serial port
         self.serial_dev = None
         self.msgparser = msgproto.MessageParser(warn_prefix=warn_prefix)
@@ -268,6 +269,12 @@ class SerialReader:
         out = []
         out.append("Dumping serial stats: %s" % (
             self.stats(self.reactor.monotonic()),))
+
+        def clock_to_systime(clock):
+            if clock == 0 or self._mcu is None:
+                return 0.0
+            return self._mcu.estimate_clock_systime(clock)
+
         sdata = self.ffi_main.new('struct pull_queue_message[1024]')
         rdata = self.ffi_main.new('struct pull_queue_message[1024]')
         scount = self.ffi_lib.serialqueue_extract_old(self.serialqueue, 1,
@@ -300,6 +307,18 @@ class SerialReader:
         logging.info("%s%s: %s", self.warn_prefix,
                      params['#name'], params['#msg'])
         msg = params.get('#msg', '')
+        if msg.startswith('Timer too close: ') and self._mcu is not None:
+            content = msg[len('Timer too close: '):].strip()
+            parsed = dict(item.strip().split('=', 1) for item in content.split(',') if '=' in item)
+            if all(k in parsed for k in ('waketime', 'timer_read_time')):
+                w, t = parsed['waketime'], parsed['timer_read_time']
+                w, t = int(w), int(t)
+                wclock = self._mcu.clock32_to_clock64(w)
+                tclock = self._mcu.clock32_to_clock64(t)
+                wsysclock = self._mcu.estimate_clock_systime(wclock)
+                tsysclock = self._mcu.estimate_clock_systime(tclock)
+                logging.info("{}Timer too close, wsysclock: {}, tsysclock: {}".format(self.warn_prefix, wsysclock, tsysclock))
+
         if 'Power loss info saved' == msg and self._mcu is not None:
             mcu_index = {'mcu': 0, 'e0': 1, 'e1': 2, 'e2': 3, 'e3': 4}.get(self._mcu._name, 255)
             coded = "0003-0522-%4d-0017" % mcu_index
--- a/klippy/stepper.py
+++ b/klippy/stepper.py
@@ -9,6 +9,21 @@ import chelper
 class error(Exception):
     pass
 
+######################################################################
+# Power_loss need save steppers
+######################################################################
+power_loss_need_save_steppers = ['stepper_x', 'stepper_y', 'stepper_z', 'extruder']
+def get_stepper_type_and_index(stepper):
+    if not isinstance(stepper, str):
+        return (0xFF, 0xFF)
+
+    for idx, name in enumerate(power_loss_need_save_steppers):
+        if stepper.startswith(name):
+            remaining = stepper[len(name):]
+            if remaining.isdigit() or remaining == '':
+                num = int(remaining) if remaining else 0
+                return (idx, num)
+    return (0xFF, 0xFF)
 
 ######################################################################
 # Steppers
@@ -32,6 +47,7 @@ class MCU_stepper:
         self._mcu.register_config_callback(self._build_config)
         self._step_pin = step_pin_params['pin']
         self._invert_step = step_pin_params['invert']
+        self._stepper_type, self._stepper_index = get_stepper_type_and_index(self._name)
         if dir_pin_params['chip'] is not self._mcu:
             raise self._mcu.get_printer().config_error(
                 "Stepper dir pin must be on same mcu as step pin")
@@ -85,12 +101,12 @@ class MCU_stepper:
         step_pulse_ticks = self._mcu.seconds_to_clock(self._step_pulse_duration)
         self._mcu.add_config_cmd(
             "config_stepper oid=%d step_pin=%s dir_pin=%s invert_step=%d"
-            " step_pulse_ticks=%u" % (self._oid, self._step_pin, self._dir_pin,
-                                      invert_step, step_pulse_ticks))
+            " step_pulse_ticks=%u type=%u index=%u" % (self._oid, self._step_pin, self._dir_pin,
+                                      invert_step, step_pulse_ticks, self._stepper_type, self._stepper_index))
         self._mcu.add_config_cmd("reset_step_clock oid=%d clock=0"
                                  % (self._oid,), on_restart=True)
         step_cmd_tag = self._mcu.lookup_command(
-            "queue_step oid=%c interval=%u count=%hu add=%hi").get_command_tag()
+            "queue_step oid=%c interval=%u count=%hu add=%hi line=%u").get_command_tag()
         dir_cmd_tag = self._mcu.lookup_command(
             "set_next_step_dir oid=%c dir=%c").get_command_tag()
         self._reset_cmd_tag = self._mcu.lookup_command(
@@ -337,6 +353,21 @@ class PrinterRail:
             'homing_retract_speed', self.homing_speed, above=0.)
         self.homing_retract_dist = config.getfloat(
             'homing_retract_dist', 5., minval=0.)
+        self.homing_backoff_dist = config.getfloat(
+            'homing_backoff_dist', 0.)
+        self.homing_tolerance = config.getfloat(
+            'homing_tolerance', None, minval=0.)
+        homing_tolerance_retries = 0
+        if self.homing_tolerance is not None:
+            homing_tolerance_retries = 3
+        self.homing_tolerance_retries = config.getint(
+            'homing_tolerance_retries', homing_tolerance_retries, minval=0, maxval=20)
+        self.homing_samples = config.getint(
+            'homing_samples', 2, minval=2, maxval=10)
+        self.homing_before_delay = config.getfloat(
+            'homing_before_delay', 0., minval=0)
+        self.second_homing_before_delay = config.getfloat(
+            'second_homing_before_delay', 0., minval=0)
         self.homing_positive_dir = config.getboolean(
             'homing_positive_dir', None)
         if self.homing_positive_dir is None:
@@ -362,10 +393,15 @@ class PrinterRail:
     def get_homing_info(self):
         homing_info = collections.namedtuple('homing_info', [
             'speed', 'position_endstop', 'retract_speed', 'retract_dist',
-            'positive_dir', 'second_homing_speed'])(
+            'positive_dir', 'second_homing_speed', 'homing_tolerance',
+            'homing_tolerance_retries', 'homing_before_delay',
+            'second_homing_before_delay', 'homing_samples', 'homing_backoff_dist'])(
                 self.homing_speed, self.position_endstop,
                 self.homing_retract_speed, self.homing_retract_dist,
-                self.homing_positive_dir, self.second_homing_speed)
+                self.homing_positive_dir, self.second_homing_speed,
+                self.homing_tolerance, self.homing_tolerance_retries,
+                self.homing_before_delay, self.second_homing_before_delay,
+                self.homing_samples, self.homing_backoff_dist)
         return homing_info
     def get_steppers(self):
         return list(self.steppers)
--- a/klippy/toolhead.py
+++ b/klippy/toolhead.py
@@ -12,7 +12,7 @@ import mcu, chelper, kinematics.extruder
 
 # Class to track each move request
 class Move:
-    def __init__(self, toolhead, start_pos, end_pos, speed):
+    def __init__(self, toolhead, start_pos, end_pos, speed, line=None):
         self.toolhead = toolhead
         self.start_pos = tuple(start_pos)
         self.end_pos = tuple(end_pos)
@@ -23,6 +23,9 @@ class Move:
         self.is_kinematic_move = True
         self.axes_d = axes_d = [end_pos[i] - start_pos[i] for i in (0, 1, 2, 3)]
         self.move_d = move_d = math.sqrt(sum([d*d for d in axes_d[:3]]))
+        self.line = toolhead.print_file_line if line is None else line
+        if self.line is None:
+            self.line = 0xFFFFFFFF
         if move_d < .000000001:
             # Extrude only move
             self.end_pos = (start_pos[0], start_pos[1], start_pos[2],
@@ -77,6 +80,15 @@ class Move:
         return self.toolhead.printer.command_error(m)
     def calc_junction(self, prev_move):
         if not self.is_kinematic_move or not prev_move.is_kinematic_move:
+            if self.toolhead.is_calibrating_flow:
+                extruder_v2 = self.toolhead.extruder.calc_junction(prev_move, self)
+                # Apply limits
+                self.max_start_v2 = min(
+                    extruder_v2, self.max_cruise_v2, prev_move.max_cruise_v2,
+                    prev_move.max_start_v2 + prev_move.delta_v2)
+                self.max_smoothed_v2 = min(
+                    self.max_start_v2
+                    , prev_move.max_smoothed_v2 + prev_move.smooth_delta_v2)
             return
         # Allow extruder to calculate its maximum junction
         extruder_v2 = self.toolhead.extruder.calc_junction(prev_move, self)
@@ -208,7 +220,7 @@ BUFFER_TIME_START = 0.250
 BGFLUSH_LOW_TIME = 0.200
 BGFLUSH_BATCH_TIME = 0.200
 BGFLUSH_EXTRA_TIME = 0.250
-MIN_KIN_TIME = 0.100
+MIN_KIN_TIME = 0.200
 MOVE_BATCH_TIME = 0.500
 STEPCOMPRESS_FLUSH_TIME = 0.050
 SDS_CHECK_TIME = 0.001 # step+dir+step filter in stepcompress.c
@@ -230,6 +242,11 @@ class ToolHead:
         self.lookahead = LookAheadQueue(self)
         self.lookahead.set_flush_time(BUFFER_TIME_HIGH)
         self.commanded_pos = [0., 0., 0., 0.]
+
+        # The maximum number of logical and physical extruders
+        self.max_logical_extruder_num = config.getint('max_logical_extruder_num')
+        self.max_physical_extruder_num = config.getint('max_physical_extruder_num')
+
         # Velocity and acceleration control
         self.max_velocity = config.getfloat('max_velocity', above=0.)
         self.max_accel = config.getfloat('max_accel', above=0.)
@@ -279,6 +296,8 @@ class ToolHead:
         gcode = self.printer.lookup_object('gcode')
         self.Coord = gcode.Coord
         self.extruder = kinematics.extruder.DummyExtruder(self.printer)
+        self.is_grab_complete = True
+        self.print_file_line = None
         kin_name = config.get('kinematics')
         try:
             mod = importlib.import_module('kinematics.' + kin_name)
@@ -291,20 +310,38 @@ class ToolHead:
             msg = "Error loading kinematics '%s'" % (kin_name,)
             logging.exception(msg)
             raise config.error(msg)
+
+        # handle flow calibration mode
+        self.is_calibrating_flow = False
+        self.printer.register_event_handler("flow_calibration:begin", self._handle_flow_calibration_begin)
+        self.printer.register_event_handler("flow_calibration:end", self._handle_flow_calibration_end)
+        self.printer.register_event_handler("virtual_sdcard:reset_file", self._handle_flow_calibration_end)
         # Register commands
+        gcode.register_command('SWITCH_OF_EXTENDED_EXTRUDER', self.cmd_SWITCH_OF_EXTENDED_EXTRUDER)
         gcode.register_command('G4', self.cmd_G4)
         gcode.register_command('M400', self.cmd_M400)
         gcode.register_command('SET_VELOCITY_LIMIT',
                                self.cmd_SET_VELOCITY_LIMIT,
                                desc=self.cmd_SET_VELOCITY_LIMIT_help)
+        gcode.register_command("SET_MAX_Z_ACCEL", self.cmd_SET_MAX_Z_ACCEL)
+        gcode.register_command("SET_MAX_Z_VELOCITY", self.cmd_SET_MAX_Z_VELOCITY)
         gcode.register_command('M204', self.cmd_M204)
+        self.printer.register_event_handler("klippy:ready",
+                                            self._handle_ready)
         self.printer.register_event_handler("klippy:shutdown",
                                             self._handle_shutdown)
         # Load some default modules
         modules = ["gcode_move", "homing", "idle_timeout", "statistics",
-                   "manual_probe", "tuning_tower"]
+                   "manual_probe", "tuning_tower", "machine_state_manager"]
         for module_name in modules:
             self.printer.load_object(config, module_name)
+
+    def _handle_flow_calibration_begin(self):
+        logging.info("toolhead: begin flow calibration")
+        self.is_calibrating_flow = True
+    def _handle_flow_calibration_end(self):
+        logging.info("toolhead: end flow calibration")
+        self.is_calibrating_flow = False
     # Print time and flush tracking
     def _advance_flush_time(self, flush_time):
         flush_time = max(flush_time, self.last_flush_time)
@@ -363,7 +400,7 @@ class ToolHead:
                     move.accel_t, move.cruise_t, move.decel_t,
                     move.start_pos[0], move.start_pos[1], move.start_pos[2],
                     move.axes_r[0], move.axes_r[1], move.axes_r[2],
-                    move.start_v, move.cruise_v, move.accel)
+                    move.start_v, move.cruise_v, move.accel, move.line)
             if move.axes_d[3]:
                 self.extruder.move(next_move_time, move)
             next_move_time = (next_move_time + move.accel_t
@@ -477,8 +514,8 @@ class ToolHead:
         self.commanded_pos[:] = newpos
         self.kin.set_position(newpos, homing_axes)
         self.printer.send_event("toolhead:set_position")
-    def move(self, newpos, speed):
-        move = Move(self, self.commanded_pos, newpos, speed)
+    def move(self, newpos, speed, line=None):
+        move = Move(self, self.commanded_pos, newpos, speed, line)
         if not move.move_d:
             return
         if move.is_kinematic_move:
@@ -591,6 +628,23 @@ class ToolHead:
     def _handle_shutdown(self):
         self.can_pause = False
         self.lookahead.reset()
+    def _handle_ready(self):
+        if len(self.printer.lookup_object('extruder_list', [])) != 0:
+            self.reactor.register_callback(lambda e:self._extruder_auto_activate(), self.reactor.monotonic() + 3)
+    def _extruder_auto_activate(self):
+        state_message, category = self.printer.get_state_message()
+        extruder_list = self.printer.lookup_object('extruder_list', [])
+        if category == 'ready' and len(self.printer.lookup_object('extruder_list', [])) != 0:
+            activate_status = self.get_extruder().get_extruder_activate_status()
+            self.printer.lookup_object('gcode').respond_info("{}".format(activate_status))
+            self.is_grab_complete = True if activate_status[0][1] == 0 else False
+            if activate_status[0][1] == 0 and self.get_extruder().name != activate_status[0][0]:
+                extruder = self.printer.lookup_object(activate_status[0][0], None)
+                if extruder is not None:
+                    self.printer.lookup_object('gcode').run_script("ACTIVATE_EXTRUDER EXTRUDER={}".format(extruder.name))
+            self.get_extruder().only_enable_current_extruder_vref_sw()
+        return self.reactor.NEVER
+
     def get_kinematics(self):
         return self.kin
     def get_trapq(self):
@@ -624,6 +678,28 @@ class ToolHead:
         scv2 = self.square_corner_velocity**2
         self.junction_deviation = scv2 * (math.sqrt(2.) - 1.) / self.max_accel
         self.max_accel_to_decel = self.max_accel * (1. - self.min_cruise_ratio)
+
+    def cmd_SWITCH_OF_EXTENDED_EXTRUDER(self, gcmd):
+        index = gcmd.get_int('INDEX')
+        if index < self.max_physical_extruder_num or index >= self.max_logical_extruder_num:
+            raise gcmd.error(f"[toolhead] invalid extended extruder index: {index}")
+
+        print_task_config = self.printer.lookup_object('print_task_config', None)
+        if print_task_config is None:
+            raise gcmd.error("[toolhead] print_task_config not found")
+
+        extruder = None
+        extruder_index = print_task_config.get_extruder_map_index(index)
+        if extruder_index == 0:
+            extruder = self.printer.lookup_object('extruder', None)
+        else:
+            extruder = self.printer.lookup_object('extruder%d' % extruder_index, None)
+        if extruder is None:
+            raise gcmd.error("[toolhead] extruder not found")
+
+        gcmd._params['A'] = '0'
+        extruder.cmd_SWITCH_EXTRUDER_ADVANCED(gcmd)
+
     def cmd_G4(self, gcmd):
         # Dwell
         delay = gcmd.get_float('P', 0., minval=0.) / 1000.
@@ -666,6 +742,16 @@ class ToolHead:
         if (max_velocity is None and max_accel is None
             and square_corner_velocity is None and min_cruise_ratio is None):
             gcmd.respond_info(msg, log=False)
+    def cmd_SET_MAX_Z_ACCEL(self, gcmd):
+        if self.kin is not None:
+            accel = gcmd.get_float('A', self.kin.max_z_accel)
+            self.kin.max_z_accel = accel
+            gcmd.respond_info("printer max z accel: {}".format(accel))
+    def cmd_SET_MAX_Z_VELOCITY(self, gcmd):
+        if self.kin is not None:
+            velocity = gcmd.get_float('V', self.kin.max_z_velocity)
+            self.kin.max_z_velocity = velocity
+            gcmd.respond_info("printer max z velocity: {}".format(velocity))
     def cmd_M204(self, gcmd):
         # Use S for accel
         accel = gcmd.get_float('S', None, above=0.)
@@ -680,6 +766,14 @@ class ToolHead:
             accel = min(p, t)
         self.max_accel = accel
         self._calc_junction_deviation()
+    def set_accel(self, accel):
+        if accel < 0:
+            return
+        self.wait_moves()
+        self.max_accel = accel
+        self._calc_junction_deviation()
+    def set_grab_complete(self, enable):
+        self.is_grab_complete = not not enable
 
 def add_printer_objects(config):
     config.get_printer().add_object('toolhead', ToolHead(config))
--- a/klippy/util.py
+++ b/klippy/util.py
@@ -222,5 +222,16 @@ def get_git_version(from_file=True):
         logging.debug("Exception on run: %s", traceback.format_exc())
 
     if from_file:
-        git_info["version"] = get_version_from_file(klippy_src)
+        git_info["version"] = get_full_firmware_version()
     return git_info
+
+def get_full_firmware_version():
+    # get full firmware version from /etc/FULLVERSION
+    try:
+        with open("/etc/FULLVERSION", "r") as f:
+            fullver = f.read().strip()
+        logging.info("Full firmware version: %s", fullver)
+        return fullver
+    except Exception as e:
+        logging.error("Error getting full firmware version: %s", e)
+    return "?"
--- a/klippy/webhooks.py
+++ b/klippy/webhooks.py
@@ -405,6 +405,9 @@ class WebHooks:
     def stats(self, eventtime):
         return self.sconn.stats(eventtime)
 
+    def has_remote_method(self, method):
+        return method in self._remote_methods
+
     def call_remote_method(self, method, **kwargs):
         if method not in self._remote_methods:
             raise self.printer.command_error(
--- a/scripts/motan/data_logger.py
+++ b/scripts/motan/data_logger.py
@@ -151,9 +151,11 @@ class DataLogger:
             self.send_subscribe("stepq:" + stepper,
                                 "motion_report/dump_stepper", {"name": stepper})
         # Subscribe to additional sensor data
-        stypes = ["adxl345", "lis2dw", "mpu9250", "angle"]
-        stypes = {st:st for st in stypes}
+        # stypes = ["adxl345", "lis2dw", "mpu9250", "angle"]
+        # stypes = {st:st for st in stypes}
+        stypes = dict()
         stypes['probe_eddy_current'] = 'ldc1612'
+        stypes['inductance_coil'] = 'inductance_coil'
         config = status["configfile"]["settings"]
         for cfgname in config.keys():
             for capprefix, st in sorted(stypes.items()):
--- /dev/null
+++ b/scripts/motan/lava_flow_cali.py
@@ -0,0 +1,664 @@
+#!/usr/bin/env python
+# Log data analyzing functions
+#
+# Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import math, collections
+import sys, optparse, ast, os
+import matplotlib
+import readlog
+try:
+    import urlparse
+except:
+    import urllib.parse as urlparse
+from multiprocessing import Process
+
+######################################################################
+# Analysis code
+######################################################################
+
+# Analyzer handlers: {name: class, ...}
+AHandlers = {}
+
+# Calculate a derivative (position to velocity, or velocity to accel)
+class GenDerivative:
+    ParametersMin = ParametersMax = 1
+    DataSets = [
+        ('derivative(<dataset>)', 'Derivative of the given dataset'),
+    ]
+    def __init__(self, amanager, name_parts):
+        self.amanager = amanager
+        self.source = name_parts[1]
+        amanager.setup_dataset(self.source)
+    def get_label(self):
+        label = self.amanager.get_label(self.source)
+        lname = label['label']
+        units = label['units']
+        if '(mm)' in units:
+            rep = [('Position', 'Velocity'), ('(mm)', '(mm/s)')]
+        elif '(mm/s)' in units:
+            rep = [('Velocity', 'Acceleration'), ('(mm/s)', '(mm/s^2)')]
+        else:
+            return {'label': 'Derivative', 'units': 'Unknown'}
+        for old, new in rep:
+            lname = lname.replace(old, new).replace(old.lower(), new.lower())
+            units = units.replace(old, new).replace(old.lower(), new.lower())
+        return {'label': lname, 'units': units}
+    def generate_data(self):
+        inv_seg_time = 1. / self.amanager.get_segment_time()
+        data = self.amanager.get_datasets()[self.source]
+        deriv = [(data[i+1] - data[i]) * inv_seg_time
+                 for i in range(len(data)-1)]
+        return [deriv[0]] + deriv
+AHandlers["derivative"] = GenDerivative
+
+# Calculate an integral (accel to velocity, or velocity to position)
+class GenIntegral:
+    ParametersMin = 1
+    ParametersMax = 3
+    DataSets = [
+        ('integral(<dataset>)', 'Integral of the given dataset'),
+        ('integral(<dataset1>,<dataset2>)',
+         'Integral with dataset2 as reference'),
+        ('integral(<dataset1>,<dataset2>,<half_life>)',
+         'Integral with weighted half-life time'),
+    ]
+    def __init__(self, amanager, name_parts):
+        self.amanager = amanager
+        self.source = name_parts[1]
+        amanager.setup_dataset(self.source)
+        self.ref = None
+        self.half_life = 0.015
+        if len(name_parts) >= 3:
+            self.ref = name_parts[2]
+            amanager.setup_dataset(self.ref)
+            if len(name_parts) == 4:
+                self.half_life = float(name_parts[3])
+    def get_label(self):
+        label = self.amanager.get_label(self.source)
+        lname = label['label']
+        units = label['units']
+        if '(mm/s)' in units:
+            rep = [('Velocity', 'Position'), ('(mm/s)', '(mm)')]
+        elif '(mm/s^2)' in units:
+            rep = [('Acceleration', 'Velocity'), ('(mm/s^2)', '(mm/s)')]
+        else:
+            return {'label': 'Integral', 'units': 'Unknown'}
+        for old, new in rep:
+            lname = lname.replace(old, new).replace(old.lower(), new.lower())
+            units = units.replace(old, new).replace(old.lower(), new.lower())
+        return {'label': lname, 'units': units}
+    def generate_data(self):
+        seg_time = self.amanager.get_segment_time()
+        src = self.amanager.get_datasets()[self.source]
+        offset = sum(src) / len(src)
+        total = 0.
+        ref = None
+        if self.ref is not None:
+            ref = self.amanager.get_datasets()[self.ref]
+            offset -= (ref[-1] - ref[0]) / (len(src) * seg_time)
+            total = ref[0]
+            src_weight = 1.
+            if self.half_life:
+                src_weight = math.exp(math.log(.5) * seg_time / self.half_life)
+            ref_weight = 1. - src_weight
+        data = [0.] * len(src)
+        for i, v in enumerate(src):
+            total += (v - offset) * seg_time
+            if ref is not None:
+                total = src_weight * total + ref_weight * ref[i]
+            data[i] = total
+        return data
+AHandlers["integral"] = GenIntegral
+
+# Calculate a pointwise 2-norm of several datasets (e.g. compute velocity or
+# accel from its x, y,... components)
+class GenNorm2:
+    ParametersMin = 2
+    ParametersMax = 3
+    DataSets = [
+        ('norm2(<dataset1>,<dataset2>)',
+         'pointwise 2-norm of dataset1 and dataset2'),
+        ('norm2(<dataset1>,<dataset2>,<dataset3>)',
+         'pointwise 2-norm of 3 datasets'),
+    ]
+    def __init__(self, amanager, name_parts):
+        self.amanager = amanager
+        self.datasets = []
+        self.datasets.append(name_parts[1])
+        self.datasets.append(name_parts[2])
+        if len(name_parts) == 4:
+            self.datasets.append(name_parts[3])
+        for dataset in self.datasets:
+            amanager.setup_dataset(dataset)
+    def get_label(self):
+        label = self.amanager.get_label(self.datasets[0])
+        units = label['units']
+        datas = ['position', 'velocity', 'acceleration']
+        data_name = ''
+        for d in datas:
+            if d in label['label']:
+                data_name = d
+                break
+        lname = ''
+        for d in self.datasets:
+            l = self.amanager.get_label(d)['label']
+            for r in datas:
+                l = l.replace(r, '').strip()
+            if lname:
+                lname += '+'
+            lname += l
+        lname += ' ' + data_name + ' norm2'
+        return {'label': lname, 'units': units}
+    def generate_data(self):
+        seg_time = self.amanager.get_segment_time()
+        data = []
+        for dataset in self.datasets:
+            data.append(self.amanager.get_datasets()[dataset])
+        res = [0.] * len(data[0])
+        for i in range(len(data[0])):
+            norm2 = 0.
+            for dataset in data:
+                norm2 += dataset[i] * dataset[i]
+            res[i] = math.sqrt(norm2)
+        return res
+AHandlers["norm2"] = GenNorm2
+
+class GenSmoothed:
+    ParametersMin = 1
+    ParametersMax = 2
+    DataSets = [
+        ('smooth(<dataset>)', 'Generate moving weighted average of a dataset'),
+        ('smooth(<dataset>,<smooth_time>)',
+         'Generate moving weighted average of a dataset with a given'
+         ' smoothing time that defines the window size'),
+    ]
+    def __init__(self, amanager, name_parts):
+        self.amanager = amanager
+        self.source = name_parts[1]
+        amanager.setup_dataset(self.source)
+        self.smooth_time = 0.01
+        if len(name_parts) > 2:
+            self.smooth_time = float(name_parts[2])
+    def get_label(self):
+        label = self.amanager.get_label(self.source)
+        return {'label': 'Smoothed ' + label['label'], 'units': label['units']}
+    def generate_data(self):
+        seg_time = self.amanager.get_segment_time()
+        src = self.amanager.get_datasets()[self.source]
+        n = len(src)
+        data = [0.] * n
+        hst = 0.5 * self.smooth_time
+        seg_half_len = round(hst / seg_time)
+        inv_norm = 1. / sum([min(k + 1, seg_half_len + seg_half_len - k)
+                             for k in range(2 * seg_half_len)])
+        for i in range(n):
+            j = max(0, i - seg_half_len)
+            je = min(n, i + seg_half_len)
+            avg_val = 0.
+            for k, v in enumerate(src[j:je]):
+                avg_val += v * min(k + 1, seg_half_len + seg_half_len - k)
+            data[i] = avg_val * inv_norm
+        return data
+AHandlers["smooth"] = GenSmoothed
+
+# Calculate a kinematic stepper position from the toolhead requested position
+class GenKinematicPosition:
+    ParametersMin = ParametersMax = 1
+    DataSets = [
+        ('kin(<stepper>)', 'Stepper position derived from toolhead kinematics'),
+    ]
+    def __init__(self, amanager, name_parts):
+        self.amanager = amanager
+        stepper = name_parts[1]
+        status = self.amanager.get_initial_status()
+        kin = status['configfile']['settings']['printer']['kinematics']
+        if kin not in ['cartesian', 'corexy']:
+            raise amanager.error("Unsupported kinematics '%s'" % (kin,))
+        if stepper not in ['stepper_x', 'stepper_y', 'stepper_z']:
+            raise amanager.error("Unknown stepper '%s'" % (stepper,))
+        if kin == 'corexy' and stepper in ['stepper_x', 'stepper_y']:
+            self.source1 = 'trapq(toolhead,x)'
+            self.source2 = 'trapq(toolhead,y)'
+            if stepper == 'stepper_x':
+                self.generate_data = self.generate_data_corexy_plus
+            else:
+                self.generate_data = self.generate_data_corexy_minus
+            amanager.setup_dataset(self.source1)
+            amanager.setup_dataset(self.source2)
+        else:
+            self.source1 = 'trapq(toolhead,%s)' % (stepper[-1:],)
+            self.source2 = None
+            self.generate_data = self.generate_data_passthrough
+            amanager.setup_dataset(self.source1)
+    def get_label(self):
+        return {'label': 'Position', 'units': 'Position\n(mm)'}
+    def generate_data_corexy_plus(self):
+        datasets = self.amanager.get_datasets()
+        data1 = datasets[self.source1]
+        data2 = datasets[self.source2]
+        return [d1 + d2 for d1, d2 in zip(data1, data2)]
+    def generate_data_corexy_minus(self):
+        datasets = self.amanager.get_datasets()
+        data1 = datasets[self.source1]
+        data2 = datasets[self.source2]
+        return [d1 - d2 for d1, d2 in zip(data1, data2)]
+    def generate_data_passthrough(self):
+        return self.amanager.get_datasets()[self.source1]
+AHandlers["kin"] = GenKinematicPosition
+
+# Calculate a toolhead x/y position from corexy stepper positions
+class GenCorexyPosition:
+    ParametersMin = ParametersMax = 3
+    DataSets = [
+        ('corexy(x,<stepper>,<stepper>)', 'Toolhead x position from steppers'),
+        ('corexy(y,<stepper>,<stepper>)', 'Toolhead y position from steppers'),
+    ]
+    def __init__(self, amanager, name_parts):
+        self.amanager = amanager
+        self.is_plus = name_parts[1] == 'x'
+        self.source1, self.source2 = name_parts[2:]
+        amanager.setup_dataset(self.source1)
+        amanager.setup_dataset(self.source2)
+    def get_label(self):
+        axis = 'x'
+        if not self.is_plus:
+            axis = 'y'
+        return {'label': 'Derived %s position' % (axis,),
+                'units': 'Position\n(mm)'}
+    def generate_data(self):
+        datasets = self.amanager.get_datasets()
+        data1 = datasets[self.source1]
+        data2 = datasets[self.source2]
+        if self.is_plus:
+            return [.5 * (d1 + d2) for d1, d2 in zip(data1, data2)]
+        return [.5 * (d1 - d2) for d1, d2 in zip(data1, data2)]
+AHandlers["corexy"] = GenCorexyPosition
+
+# Calculate a position deviation
+class GenDeviation:
+    ParametersMin = ParametersMax = 2
+    DataSets = [
+        ('deviation(<dataset1>,<dataset2>)', 'Difference between datasets'),
+    ]
+    def __init__(self, amanager, name_parts):
+        self.amanager = amanager
+        self.source1, self.source2 = name_parts[1:]
+        amanager.setup_dataset(self.source1)
+        amanager.setup_dataset(self.source2)
+    def get_label(self):
+        label1 = self.amanager.get_label(self.source1)
+        label2 = self.amanager.get_label(self.source2)
+        if label1['units'] != label2['units']:
+            return {'label': 'Deviation', 'units': 'Unknown'}
+        parts = label1['units'].split('\n')
+        units = '\n'.join([parts[0]] + ['Deviation'] + parts[1:])
+        return {'label': label1['label'] + ' deviation', 'units': units}
+    def generate_data(self):
+        datasets = self.amanager.get_datasets()
+        data1 = datasets[self.source1]
+        data2 = datasets[self.source2]
+        return [d1 - d2 for d1, d2 in zip(data1, data2)]
+AHandlers["deviation"] = GenDeviation
+
+
+######################################################################
+# Analyzer management and data generation
+######################################################################
+
+# Return a description of available analyzers
+def list_datasets():
+    datasets = []
+    for ah in sorted(AHandlers.keys()):
+        datasets += AHandlers[ah].DataSets
+    return datasets
+
+# Manage raw and generated data samples
+class AnalyzerManager:
+    error = None
+    def __init__(self, lmanager, segment_time, extruder):
+        self.lmanager = lmanager
+        self.error = lmanager.error
+        self.segment_time = segment_time
+        self.raw_datasets = collections.OrderedDict()
+        self.gen_datasets = collections.OrderedDict()
+        self.datasets = {}
+        self.dataset_times = []
+        self.duration = 10.
+        self.initial_start_time = 0.
+        self.extruder = extruder
+    def set_duration(self, duration):
+        self.duration = duration
+    def get_segment_time(self):
+        return self.segment_time
+    def get_datasets(self):
+        return self.datasets
+    def get_dataset_times(self):
+        return self.dataset_times
+    def get_initial_status(self):
+        return self.lmanager.get_initial_status()
+    def setup_dataset(self, name):
+        name = name.strip()
+        if name in self.raw_datasets:
+            return self.raw_datasets[name]
+        if name in self.gen_datasets:
+            return self.gen_datasets[name]
+        name_parts = readlog.name_split(name)
+        if name_parts[0] in self.lmanager.available_dataset_types():
+            hdl = self.lmanager.setup_dataset(name)
+            self.raw_datasets[name] = hdl
+        else:
+            cls = AHandlers.get(name_parts[0])
+            if cls is None:
+                raise self.error("Unknown dataset '%s'" % (name,))
+            num_param = len(name_parts) - 1
+            if num_param < cls.ParametersMin or num_param > cls.ParametersMax:
+                raise self.error("Invalid parameters to dataset '%s'" % (name,))
+            hdl = cls(self, name_parts)
+            self.gen_datasets[name] = hdl
+        self.datasets[name] = []
+        return hdl
+    def get_label(self, dataset):
+        hdl = self.raw_datasets.get(dataset)
+        if hdl is None:
+            hdl = self.gen_datasets.get(dataset)
+            if hdl is None:
+                raise self.error("Unknown dataset '%s'" % (dataset,))
+        return hdl.get_label()
+    def get_initial_start_time(self):
+        return self.initial_start_time
+    def generate_datasets(self):
+        # Generate raw data
+        list_hdls = [(self.datasets[name], hdl)
+                     for name, hdl in self.raw_datasets.items()]
+        self.initial_start_time = self.lmanager.get_initial_start_time()
+        start_time = t = self.lmanager.get_start_time()
+        end_time = start_time + self.duration
+        print("initial_start_time: {}".format(self.initial_start_time))
+        print("start_time: {}".format(start_time))
+        print("end_time: {}".format(end_time))
+        print("raw dtaset:")
+        frequency_hdl = None
+        actual_duration = 0
+        for name, hdl in self.raw_datasets.items():
+            print(name)
+            if name == 'inductance_coil({})'.format(self.extruder):
+                print("got freq handle of {}".format(self.extruder))
+                frequency_hdl = hdl
+        while t < end_time:
+            t += self.segment_time
+            self.dataset_times.append(t - self.initial_start_time)
+            for dl, hdl in list_hdls:
+                if hdl == frequency_hdl:
+                    if hdl.pull_data(t) <= 0:
+                        actual_duration = t - start_time
+                dl.append(hdl.pull_data(t))
+            if actual_duration > 0:
+                print("actual duration: {}, got dura: {}".format(actual_duration, end_time - start_time))
+                if t < end_time - self.segment_time:
+                    for dl, hdl in list_hdls:
+                        dl.pop()
+                    self.dataset_times.pop()
+                break
+        # Generate analyzer data
+        for name, hdl in self.gen_datasets.items():
+            self.datasets[name] = hdl.generate_data()
+
+
+######################################################################
+# Graphing
+######################################################################
+
+def plot_motion(amanager, graphs, log_prefix):
+    # Generate data
+    for graph in graphs:
+        for dataset, plot_params in graph:
+            amanager.setup_dataset(dataset)
+    amanager.generate_datasets()
+    datasets = amanager.get_datasets()
+    times = amanager.get_dataset_times()
+    # Build plot
+    fontP = matplotlib.font_manager.FontProperties()
+    fontP.set_size('x-small')
+    fig, rows = matplotlib.pyplot.subplots(nrows=len(graphs), sharex=True)
+    if len(graphs) == 1:
+        rows = [rows]
+    rows[0].set_title("Motion Analysis (%s)" % (log_prefix,))
+    for graph, graph_ax in zip(graphs, rows):
+        graph_units = graph_twin_units = twin_ax = None
+        for dataset, plot_params in graph:
+            label = amanager.get_label(dataset)
+            ax = graph_ax
+            if graph_units is None:
+                graph_units = label['units']
+                ax.set_ylabel(graph_units)
+            elif label['units'] != graph_units:
+                if graph_twin_units is None:
+                    ax = twin_ax = graph_ax.twinx()
+                    graph_twin_units = label['units']
+                    ax.set_ylabel(graph_twin_units)
+                elif label['units'] == graph_twin_units:
+                    ax = twin_ax
+                else:
+                    graph_units = "Unknown"
+                    ax.set_ylabel(graph_units)
+            pparams = {'label': label['label'], 'alpha': 0.8}
+            pparams.update(plot_params)
+            ax.plot(times, datasets[dataset], **pparams)
+        if twin_ax is not None:
+            li1, la1 = graph_ax.get_legend_handles_labels()
+            li2, la2 = twin_ax.get_legend_handles_labels()
+            twin_ax.legend(li1 + li2, la1 + la2, loc='best', prop=fontP)
+        else:
+            graph_ax.legend(loc='best', prop=fontP)
+        graph_ax.grid(True)
+    rows[-1].set_xlabel('Time (s)')
+    return fig
+
+
+######################################################################
+# Startup
+######################################################################
+
+def setup_matplotlib(output_to_file):
+    global matplotlib
+    if output_to_file:
+        matplotlib.use('Agg')
+    import matplotlib.pyplot, matplotlib.dates, matplotlib.font_manager
+    import matplotlib.ticker
+
+def parse_graph_description(desc):
+    if '?' not in desc:
+        return (desc, {})
+    dataset, params = desc.split('?', 1)
+    params = {k: v for k, v in urlparse.parse_qsl(params)}
+    for fkey in ['alpha']:
+        if fkey in params:
+            params[fkey] = float(params[fkey])
+    return (dataset, params)
+
+def list_datasets():
+    datasets = readlog.list_datasets() + list_datasets()
+    out = ["\nAvailable datasets:\n"]
+    for dataset, desc in datasets:
+        out.append("%-24s: %s\n" % (dataset, desc))
+    out.append("\n")
+    sys.stdout.write("".join(out))
+    sys.exit(0)
+
+def main(arguments=None):
+    # Parse command-line arguments
+    usage = "%prog [options] <logname>"
+    opts = optparse.OptionParser(usage)
+    opts.add_option("-o", "--output", type="string", dest="output",
+                    default=None, help="filename of output graph")
+    opts.add_option("-s", "--skip", type="float", default=0.,
+                    help="Set the start time to graph")
+    opts.add_option("-d", "--duration", type="float", default=10.,
+                    help="Number of seconds to graph")
+    opts.add_option("--segment-time", type="float", default=0.00010,
+                    help="Analysis segment time (default 0.000100 seconds)")
+    opts.add_option("-g", "--graph", help="Graph to generate (python literal)")
+    opts.add_option("-l", "--list-datasets", action="store_true",
+                    help="List available datasets")
+    opts.add_option("-e", "--extruder", type="string", dest="extruder",
+                    default="extruder", help="extruder name")
+
+    if arguments != None:
+        options, args = opts.parse_args(arguments)
+    else:
+        options, args = opts.parse_args()
+    if options.list_datasets:
+        list_datasets()
+    if len(args) != 1:
+        print("args{}, argv: {}".format(args, arguments))
+        opts.error("Incorrect number of arguments")
+    log_prefix = args[0]
+
+    print("Got extruder: {}".format(options.extruder))
+
+    # Open data files
+    lmanager = readlog.LogManager(log_prefix)
+    lmanager.setup_index()
+    lmanager.seek_time(options.skip)
+    amanager = AnalyzerManager(lmanager, options.segment_time, options.extruder)
+    amanager.set_duration(options.duration)
+
+    # Default graphs to draw
+    graph_descs = [
+        ["trapq({},velocity)?color=green".format(options.extruder)],
+        ["trapq({},accel)?color=green".format(options.extruder)],
+    ]
+    if options.graph is not None:
+        graph_descs = ast.literal_eval(options.graph)
+    graphs = [[parse_graph_description(g) for g in graph_row]
+              for graph_row in graph_descs]
+    print("graphs: {}".format(graphs))
+
+    # Draw graph
+    setup_matplotlib(options.output is not None)
+    fig = plot_motion(amanager, graphs, log_prefix)
+
+    # Show graph
+    # matplotlib.pyplot.show()
+    cur_dir = os.getcwd()
+    fig_name = os.path.basename(cur_dir)
+    fig.suptitle("{}".format(fig_name))
+    fig.set_size_inches(32, 24)
+    fig.savefig("{}.png".format(log_prefix))
+
+    # print("graph_descs: {}".format(graph_descs))
+
+    # amanager.setup_dataset('trapq(extruder,accel)')
+    start_time_abs = amanager.get_initial_start_time()
+    dataset = amanager.get_datasets()
+    e_vel = dataset['trapq({},velocity)'.format(options.extruder)]
+    e_accel = dataset['trapq({},accel)'.format(options.extruder)]
+    e_accel_times = amanager.get_dataset_times()
+
+    e_status = 0
+
+    csv = open("{}_accel_timestamp.csv".format(log_prefix), "w+")
+    csv.write("accel_start,position\n")
+    for i in range(len(e_accel)):
+        if e_accel[i] > 0:
+            if e_status <= 0:
+                # print("accel start time: {}".format(start_time_abs + e_accel_times[i]))
+                if e_vel[i-1] <= 2:
+                    csv.write(",\n")
+                csv.write("{:6f},0\n".format(start_time_abs + e_accel_times[i]))
+            e_status = 1
+        elif e_accel[i] < 0:
+            if e_status >= 0:
+                # print("deccel start time: {}".format(start_time_abs + e_accel_times[i]))
+                csv.write("{:6f},0\n".format(start_time_abs + e_accel_times[i]))
+            e_status = -1
+        else:
+            if e_status != 0:
+                # print("cruise start time: {}".format(start_time_abs + e_accel_times[i]))
+                csv.write("{:6f},0\n".format(start_time_abs + e_accel_times[i]))
+            e_status = 0
+
+    csv.write(",\n")
+    csv.close()
+
+    # if arguments is None:
+    #     matplotlib.pyplot.show()
+
+if __name__ == '__main__':
+    arguments = ['-g', '[["trapq(extruder,velocity)"],["trapq(extruder,accel)"],["inductance_coil(extruder)"]]', '-d', '300', 'k0.000']
+
+    if len(sys.argv) > 2:
+        main()
+        sys.exit(0)
+
+    k_list = [
+        '0.000',
+        0.004,
+        0.005,
+        0.008,
+        '0.010',
+        0.012,
+        0.015,
+        0.016,
+        '0.020',
+        0.024,
+        0.025,
+        0.028,
+        '0.030',
+        0.032,
+        0.035,
+        0.036,
+        '0.040',
+        0.044,
+        0.045,
+        0.048,
+        '0.050',
+        0.052,
+        0.055,
+        0.056,
+        '0.060',
+        0.064,
+        0.065,
+        0.068,
+        '0.070',
+        0.075,
+        '0.080',
+        '0.120',
+        '0.160',
+        '0.200',
+        '0.240',
+        '0.280',
+        '0.320',
+        '0.360',
+        '0.400',
+        '0.440',
+        '0.480',
+        '0.520',
+        '0.560',
+        '0.600',
+        '0.640',
+        '0.680',
+    ]
+
+    sub_process = []
+    data_dir = os.path.abspath(sys.argv[1])
+    print("cwd: {}".format(data_dir))
+    os.chdir(data_dir)
+
+    for k in k_list:
+        print("\nStarting to generate data for k{} ...".format(k))
+        data_file = os.path.join(data_dir, "k{}.index.gz".format(k))
+        if not os.path.exists(data_file):
+            print("file {} not exist".format(data_file))
+            continue
+        prefix = "k{}".format(k)
+        arguments[-1] = prefix
+        p = Process(target=main, args=(arguments,))
+        #main(args)
+        p.start()
+        sub_process.append(p)
+    for p in sub_process:
+        p.join()
+
--- /dev/null
+++ b/scripts/motan/lava_flow_cali_calc.py
@@ -0,0 +1,396 @@
+"""
+
+1. Use mean5 to smooth frequencies
+2. Pick 6 out of 10 phrases for each k
+3. Add deceleration factor
+"""
+import os.path, sys
+from math import isnan
+import matplotlib.pyplot as plt
+from matplotlib.ticker import FormatStrFormatter
+import numpy as np
+import pandas as pd
+
+# from sklearn.linear_model import LinearRegression
+
+
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f20-200_creality_ender_pla_0606")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f20-200_esun_epla_hs_0606")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f20-200_esun_petg_0606")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f20-200_lanbo_pla_plus_0606")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f20-200_poly_petg_0606")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f20-200_poly_pla_pro_0606")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f50-200_sanlu_pla_acc3k_0607")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/extrude_xy_f50-200_sanlu_pla_acc3k_0611")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/pla-lanbo-f20-100-acc5k_0613")
+
+# 0613
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-ender-f20-100-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-ender-f20-200-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-lanbo-f20-100-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-lanbo-f20-200-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-poly-f20-100-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-poly-f20-200-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-sanlv-f20-100-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-1/pla-sanlv-f20-200-acc5k-0613-1")
+
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-2/pla-ender-f20-200-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-2/pla-esun-f20-200-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-2/pla-lanbo-f20-100-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-2/pla-lanbo-f20-200-acc5k-0613-1")
+# data_dir = os.path.join("/Users/parachvte/Downloads/SM2024-KValue/A1mini-2/pla-sanlv-f20-200-acc5k-0613-1")
+
+
+AVALIABLE_K_LIST = [
+    0.000,
+    0.004,
+    0.005,
+    0.008,
+    0.010,
+    0.012,
+    0.015,
+    0.016,
+    0.020,
+    0.024,
+    0.025,
+    0.028,
+    0.030,
+    0.032,
+    0.035,
+    0.036,
+    0.040,
+    0.044,
+    0.045,
+    0.048,
+    0.050,
+    0.052,
+    0.055,
+    0.056,
+    0.060,
+    0.064,
+    0.065,
+    0.068,
+    0.070,
+    0.075,
+    0.080,
+    0.120,
+    0.160,
+    0.200,
+    0.240,
+    0.280,
+    0.320,
+    0.360,
+    0.400,
+    0.440,
+    0.480,
+    0.520,
+    0.560,
+    0.600,
+    0.640,
+    0.680,
+]
+
+DEBUG = False
+# DEBUG = True
+
+# DEC_VOLUME_FACTOR= 0.9
+# DEC_VOLUME_FACTOR = 0.95
+DEC_VOLUME_FACTOR = 1.0
+
+
+class KData:
+
+    def __init__(self):
+        pass
+
+
+class Phrase:
+
+    def __init__(self):
+        self.timestamps = []
+        # self.positions = []
+
+        # self.acc_t = 0
+        # self.acc_volume = 0
+        # self.dec_volume = 0
+
+
+def parse_phrases(df):
+    phrases = []
+    phrase_ts = []
+    # positions = []
+    new_line_start = False
+    for index, row in df.iterrows():
+        if isnan(row.iloc[0]):
+            new_line_start = True
+            phrase_ts = []
+            # positions = []
+            continue
+
+        if new_line_start:
+            phrase_ts.append(row.iloc[0])
+            # positions.append(row.iloc[2])
+
+        if len(phrase_ts) == 4:
+            # print("phrase: {}, position: {}".format(phrase_ts, positions))
+
+            # if len(positions) > 0:
+            #     print(
+            #         "    acc_t = {:.04f}, s = {:.04f}, dec_t = {:.04f}, s = {:.04f}, cruise = {:.04f}, s = {:.04f}".format(
+            #             phrase_ts[1] - phrase_ts[0],
+            #             positions[1] - positions[0],
+            #             phrase_ts[3] - phrase_ts[2],
+            #             positions[3] - positions[2],
+            #             phrase_ts[2] - phrase_ts[1],
+            #             positions[2] - positions[1],
+            #         ))
+
+            phrase = Phrase()
+            phrase.timestamps = phrase_ts
+            # phrase.positions = positions
+            phrases.append(phrase)
+            new_line_start = False
+
+    return phrases
+
+
+def pick_volumes(volumes, min_count=5, max_count=5):
+    values = volumes.copy()
+    values.sort()
+
+    return values[min_count:-max_count]
+
+
+def main():
+    data_dir = os.path.abspath(sys.argv[1])
+    print("cwd: {}".format(data_dir))
+    output_dir = os.path.join(data_dir, 'data-{}'.format(DEC_VOLUME_FACTOR))
+    if not os.path.exists(output_dir):
+        os.mkdir(output_dir)
+
+    valid_k_list = []
+    k_volume_list = []
+
+    for k in AVALIABLE_K_LIST:
+        print("===== k = {:.03f} =====".format(k))
+        csv_path = os.path.join(data_dir, "k{:.03f}_accel_timestamp.csv".format(k))
+        if not os.path.exists(csv_path):
+            continue
+
+        valid_k_list.append(k)
+
+        df = pd.read_csv(csv_path, skiprows=10)  # skip 10 rows to avoid bad header
+
+        phrases = parse_phrases(df)
+
+        csv_path = os.path.join(data_dir, "k{:.03f}_freq.csv".format(k))
+        df = pd.read_csv(csv_path)
+        df["Freq"] = df.iloc[:, 1].rolling(window=5).mean().shift(-2)
+
+        # df["Time"] = df.iloc[:, 0].copy()
+        # df["Freq"] = df.iloc[:, 1].copy()
+
+        fig, axes = plt.subplots(2, 1, figsize=(16, 10))
+        fig.suptitle('file: {}'.format(os.path.basename(data_dir)))
+        # fig.tight_layout()
+        axes[0].plot(df.iloc[:, 0], df.iloc[:, 1])
+        axes[0].plot(df.iloc[:, 0], df.Freq)
+        axes[0].set_title("Curve points k = {:.03f}".format(k))
+
+        # axes[0].legend()
+
+        def find_index(index, t):
+            while True:
+                row = df.iloc[index, :]
+
+                tick = float(row.iloc[0])
+                if tick >= t:
+                    return index
+
+                steps = int((t - tick) / 0.001)
+
+                if steps > 5:
+                    index += (steps - 5)
+                else:
+                    index += 1
+
+        index = 0
+        phrases_time = []
+        acc_volumes = []
+        dec_volumes = []
+        for i, phrase in enumerate(phrases):
+            ts = phrase.timestamps
+            # print("phrase {}".format(i))
+            # acc -> cruise
+            # dec -> cruise
+            for t in ts[0:4]:
+                axes[0].axvline(x=t, color="red")
+
+            acc_duration = ts[1] - ts[0]
+            # cruise_t = 0.03125
+            cruise_t = acc_duration * .5
+            safe_cruise_t = acc_duration * 3
+
+            acc_pre_index = find_index(index, ts[0] - cruise_t)
+            index = acc_pre_index + 1
+
+            acc_start_index = find_index(index, ts[0])
+            index = acc_start_index + 1
+
+            acc_end_index = find_index(index, ts[1])
+            index = acc_end_index + 1
+
+            acc_post_index = find_index(index, ts[1] + cruise_t)
+            index = acc_post_index + 1
+
+            dec_pre_index = find_index(index, ts[2] - cruise_t)
+            index = dec_pre_index + 1
+
+            dec_start_index = find_index(index, ts[2])
+            index = dec_start_index + 1
+
+            dec_end_index = find_index(index, ts[3])
+            index = dec_end_index + 1
+
+            dec_post_index = find_index(index, ts[3] + safe_cruise_t)
+            index = dec_post_index + 1
+
+            phrases_time.append([
+                acc_pre_index,
+                acc_start_index,
+                acc_end_index,
+                acc_post_index,
+                dec_pre_index,
+                dec_start_index,
+                dec_end_index,
+                dec_post_index,
+            ])
+
+            w = 5
+            freq_0_ = df.Freq[acc_pre_index]  # np.mean(df.iloc[acc_pre_index - w: acc_pre_index + w, 1])
+            freq_0 = df.Freq[acc_start_index]
+            freq_1 = df.Freq[acc_end_index]
+            freq_1_ = df.Freq[acc_post_index]
+
+            freq_2_ = df.Freq[dec_pre_index]
+            freq_2 = df.Freq[dec_start_index]
+            freq_3 = df.Freq[dec_end_index]
+            freq_3_ = df.Freq[dec_post_index]
+
+            err = 0
+            err += freq_1_ - freq_1
+            err += freq_3 - freq_3_
+
+            volume_1 = np.sum(freq_0_ - df.Freq[acc_start_index: acc_end_index])
+            volume_2 = np.sum(freq_0_ - df.Freq[acc_end_index: acc_post_index])
+
+            volume_3 = np.sum(freq_3_ - df.Freq[dec_start_index: dec_end_index])
+            volume_4 = np.sum(freq_3_ - df.Freq[dec_pre_index: dec_start_index])  # before dec
+
+            axes[0].axvline(x=ts[1] + cruise_t, color="orange")
+            axes[0].axvline(x=ts[2] - cruise_t, color="orange")
+            axes[0].hlines(y=freq_0_, xmin=df.iloc[acc_start_index, 0], xmax=df.iloc[acc_post_index, 0],
+                           color="pink", linestyles="dashed")
+            axes[0].hlines(y=freq_3_, xmin=df.iloc[dec_pre_index, 0], xmax=df.iloc[dec_end_index, 0],
+                           color="cyan", linestyles="dashed")
+
+            # print(" - crs: st = {:.04f}, et = {:.04f}, duration = {:.04f}, hz = {:d}, vol = {:.02f}".format(
+            #     ts[2] - cruise_t, ts[2], cruise_t, dec_start_index - dec_pre_index, volume_4))
+            # print("   t: {}".format(df.iloc[dec_pre_index: dec_start_index, 0].tolist()))
+
+            # print(
+            #     " - dec: st = {:.04f}, et = {:.04f}, duration = {:.04f}, hz = {:d}, vol = {:.02f}, diff = {:.02f}".format(
+            #         ts[2], ts[3], ts[3] - ts[2], dec_end_index - dec_start_index, volume_3, volume_3 - volume_4))
+            # print("   t: {}".format(df.iloc[dec_start_index: dec_end_index, 0].tolist()))
+
+            acc_volumes.append(
+                [ts[0], volume_1 / DEC_VOLUME_FACTOR - volume_2]
+            )
+
+            dec_volumes.append(
+                [ts[0], volume_3 * DEC_VOLUME_FACTOR - volume_4]
+            )
+
+        acc_volumes = np.array(acc_volumes)
+        dec_volumes = np.array(dec_volumes)
+
+        # display volumes
+        bar_offset = 1
+        axes[1].bar(acc_volumes[:, 0], acc_volumes[:, 1], color="r", label="acc")
+        axes[1].bar(dec_volumes[:, 0] + bar_offset, dec_volumes[:, 1], color="g", label="dec")
+
+        k_volume_list.append([
+            pick_volumes(acc_volumes[2:12, 1], min_count=2, max_count=2).sum(),
+            pick_volumes(dec_volumes[2:12, 1], min_count=2, max_count=2).sum(),
+        ])
+
+        fig.savefig("{}/volume_k{:.003f}.png".format(output_dir ,k))
+
+        # temporary break for debugging
+        if DEBUG:
+            plt.show()
+            # break
+
+    valid_k_list = np.array(valid_k_list)
+    k_volume_list = np.array(k_volume_list)
+    # print(k_volume_list[:, 0])
+    # print(k_volume_list[:, 1])
+
+    k_n = len(valid_k_list)
+    min_volume = 1e9
+    min_i = 0
+    min_k = 0.
+    for i, k in enumerate(valid_k_list):
+        if abs(k_volume_list[i, 1]) < min_volume:
+            min_volume = abs(k_volume_list[i, 1])
+            min_k = k
+            min_i = i
+
+    print("Choose k: {:.03f}".format(min_k))
+
+    # figure
+    fig, axes = plt.subplots(3, 1, figsize=(16, 10))
+    fig.suptitle('file: {}'.format(os.path.basename(data_dir)))
+    colors = ['orange'] * k_n
+    bars = axes[0].bar(valid_k_list, k_volume_list[:, 0], width=0.001, color=colors)
+    axes[0].set_title("Acc Volume Diff")
+    for bar in bars:
+        height = bar.get_height()
+        axes[0].annotate('{:.0f}'.format(height),
+                         xy=(bar.get_x() + bar.get_width() / 2, height),
+                         xytext=(0, 3),  # 3 points vertical offset
+                         textcoords="offset points",
+                         ha='center', va='bottom')
+
+    colors = ['green'] * k_n
+    colors[min_i] = 'red'
+    bars = axes[1].bar(valid_k_list, k_volume_list[:, 1], width=0.001, color=colors)
+    axes[1].set_title("Dec Volume Diff (factor = {:f})".format(DEC_VOLUME_FACTOR))
+
+    for bar in bars:
+        height = bar.get_height()
+        axes[1].annotate('{:.0f}'.format(height),
+                         xy=(bar.get_x() + bar.get_width() / 2, height),
+                         xytext=(0, 3),  # 3 points vertical offset
+                         textcoords="offset points",
+                         ha='center', va='bottom')
+
+    colors = ['blue'] * k_n
+    bars = axes[2].bar(valid_k_list, k_volume_list[:, 0] + k_volume_list[:, 1], width=0.001)
+    axes[2].set_title("Sum Volume Diff")
+    for bar in bars:
+        height = bar.get_height()
+        axes[2].annotate('{:.0f}'.format(height),
+                         xy=(bar.get_x() + bar.get_width() / 2, height),
+                         xytext=(0, 3),  # 3 points vertical offset
+                         textcoords="offset points",
+                         ha='center', va='bottom')
+
+    fig.savefig("{}/volume.png".format(output_dir))
+
+    # show figures
+    # plt.show()
+
+
+if __name__ == "__main__":
+    main()
--- /dev/null
+++ b/scripts/motan/lava_flow_freq_calc.py
@@ -0,0 +1,316 @@
+"""
+
+1. Use mean5 to smooth frequencies
+2. Pick 6 out of 10 phrases for each k
+3. Add deceleration factor
+"""
+import os.path, sys
+import pathlib
+from math import isnan
+import matplotlib.pyplot as plt
+from matplotlib.ticker import FormatStrFormatter
+import numpy as np
+import pandas as pd
+
+# from sklearn.linear_model import LinearRegression
+
+K_MIN=0.005*1000
+K_MAX=0.07*1000
+
+DEBUG = False
+# DEBUG = True
+
+# DEC_VOLUME_FACTOR= 0.9
+# DEC_VOLUME_FACTOR = 0.95
+DEC_VOLUME_FACTOR = 1.0
+
+SLOWV = 0.8
+FASTV = 8
+
+class KData:
+
+    def __init__(self):
+        pass
+
+
+class Phrase:
+    def __init__(self):
+        self.timestamps = []
+        # self.positions = []
+
+        # self.acc_t = 0
+        # self.acc_volume = 0
+        # self.dec_volume = 0
+
+
+def parse_phrases(df):
+    phrases = []
+    phrase_ts = []
+    # positions = []
+    new_line_start = False
+    for index, row in df.iterrows():
+        if isnan(row.iloc[0]):
+            continue
+
+        ts = row.iloc[0]
+        sv = row.iloc[2]
+        a  = row.iloc[3]
+
+        if abs(sv - SLOWV) < 0.0001 and a > 1:
+            new_line_start = True
+            phrase_ts = []
+
+
+        if new_line_start:
+            phrase_ts.append(ts)
+
+        if len(phrase_ts) == 4:
+            print("phrase: {}".format(phrase_ts))
+
+            phrase = Phrase()
+            phrase.timestamps = phrase_ts
+            phrases.append(phrase)
+            new_line_start = False
+
+    return phrases
+
+
+def pick_volumes(volumes, min_count=5, max_count=5):
+    values = volumes.copy()
+    values.sort()
+
+    return values[min_count:-max_count]
+
+
+def main():
+    data_dir = pathlib.Path(sys.argv[1])
+    print("cwd: {}".format(data_dir))
+    output_dir = os.path.join(data_dir, 'data-{}'.format(DEC_VOLUME_FACTOR))
+    if not os.path.exists(output_dir):
+        os.mkdir(output_dir)
+
+    valid_k_list = []
+    k_volume_list = []
+
+    for intk in range(int(K_MIN), int(K_MAX), 1):
+        k = intk / 1000
+        freq = data_dir.joinpath(f'freq-k{k:.3f}.csv')
+        accel_ts = data_dir.joinpath(f'accelts-k{k:.3f}.csv')
+        if not freq.exists() or not accel_ts.exists():
+            continue
+        print("===== k = {:.03f} =====".format(k))
+        valid_k_list.append(k)
+
+        df = pd.read_csv(str(accel_ts), skiprows=1)  # skip 1 rows for header
+        phrases = parse_phrases(df)
+
+        df = pd.read_csv(str(freq))
+        df["Freq"] = df.iloc[:, 1].rolling(window=5).mean().shift(-2)
+
+        # df["Time"] = df.iloc[:, 0].copy()
+        # df["Freq"] = df.iloc[:, 1].copy()
+
+        fig, axes = plt.subplots(2, 1, figsize=(16, 10))
+        fig.suptitle('file: {}'.format(os.path.basename(data_dir)))
+        # fig.tight_layout()
+        axes[0].plot(df.iloc[:, 0], df.iloc[:, 1])
+        axes[0].plot(df.iloc[:, 0], df.Freq)
+        axes[0].set_title("Curve points k = {:.03f}".format(k))
+
+        # axes[0].legend()
+
+        def find_index(index, t):
+            while True:
+                row = df.iloc[index, :]
+
+                tick = float(row.iloc[0])
+                if tick >= t:
+                    return index
+
+                steps = int((t - tick) / 0.001)
+
+                if steps > 5:
+                    index += (steps - 5)
+                else:
+                    index += 1
+
+        index = 0
+        phrases_time = []
+        acc_volumes = []
+        dec_volumes = []
+        for i, phrase in enumerate(phrases):
+            ts = phrase.timestamps
+            # print("phrase {}".format(i))
+            # acc -> cruise
+            # dec -> cruise
+            for t in ts[0:4]:
+                axes[0].axvline(x=t, color="red")
+
+            acc_duration = ts[1] - ts[0]
+            # cruise_t = 0.03125
+            cruise_t = acc_duration * .5
+            safe_cruise_t = acc_duration * 3
+
+            acc_pre_index = find_index(index, ts[0] - cruise_t)
+            index = acc_pre_index + 1
+
+            acc_start_index = find_index(index, ts[0])
+            index = acc_start_index + 1
+
+            acc_end_index = find_index(index, ts[1])
+            index = acc_end_index + 1
+
+            acc_post_index = find_index(index, ts[1] + cruise_t)
+            index = acc_post_index + 1
+
+            dec_pre_index = find_index(index, ts[2] - cruise_t)
+            index = dec_pre_index + 1
+
+            dec_start_index = find_index(index, ts[2])
+            index = dec_start_index + 1
+
+            dec_end_index = find_index(index, ts[3])
+            index = dec_end_index + 1
+
+            dec_post_index = find_index(index, ts[3] + safe_cruise_t)
+            index = dec_post_index + 1
+
+            phrases_time.append([
+                acc_pre_index,
+                acc_start_index,
+                acc_end_index,
+                acc_post_index,
+                dec_pre_index,
+                dec_start_index,
+                dec_end_index,
+                dec_post_index,
+            ])
+
+            w = 5
+            freq_0_ = df.Freq[acc_pre_index]  # np.mean(df.iloc[acc_pre_index - w: acc_pre_index + w, 1])
+            freq_0 = df.Freq[acc_start_index]
+            freq_1 = df.Freq[acc_end_index]
+            freq_1_ = df.Freq[acc_post_index]
+
+            freq_2_ = df.Freq[dec_pre_index]
+            freq_2 = df.Freq[dec_start_index]
+            freq_3 = df.Freq[dec_end_index]
+            freq_3_ = df.Freq[dec_post_index]
+
+            err = 0
+            err += freq_1_ - freq_1
+            err += freq_3 - freq_3_
+
+            volume_1 = np.sum(freq_0_ - df.Freq[acc_start_index: acc_end_index])
+            volume_2 = np.sum(freq_0_ - df.Freq[acc_end_index: acc_post_index])
+
+            volume_3 = np.sum(freq_3_ - df.Freq[dec_start_index: dec_end_index])
+            volume_4 = np.sum(freq_3_ - df.Freq[dec_pre_index: dec_start_index])  # before dec
+
+            axes[0].axvline(x=ts[1] + cruise_t, color="orange")
+            axes[0].axvline(x=ts[2] - cruise_t, color="orange")
+            axes[0].hlines(y=freq_0_, xmin=df.iloc[acc_start_index, 0], xmax=df.iloc[acc_post_index, 0],
+                           color="pink", linestyles="dashed")
+            axes[0].hlines(y=freq_3_, xmin=df.iloc[dec_pre_index, 0], xmax=df.iloc[dec_end_index, 0],
+                           color="cyan", linestyles="dashed")
+
+            # print(" - crs: st = {:.04f}, et = {:.04f}, duration = {:.04f}, hz = {:d}, vol = {:.02f}".format(
+            #     ts[2] - cruise_t, ts[2], cruise_t, dec_start_index - dec_pre_index, volume_4))
+            # print("   t: {}".format(df.iloc[dec_pre_index: dec_start_index, 0].tolist()))
+
+            # print(
+            #     " - dec: st = {:.04f}, et = {:.04f}, duration = {:.04f}, hz = {:d}, vol = {:.02f}, diff = {:.02f}".format(
+            #         ts[2], ts[3], ts[3] - ts[2], dec_end_index - dec_start_index, volume_3, volume_3 - volume_4))
+            # print("   t: {}".format(df.iloc[dec_start_index: dec_end_index, 0].tolist()))
+
+            acc_volumes.append(
+                [ts[0], volume_1 / DEC_VOLUME_FACTOR - volume_2]
+            )
+
+            dec_volumes.append(
+                [ts[0], volume_3 * DEC_VOLUME_FACTOR - volume_4]
+            )
+
+        acc_volumes = np.array(acc_volumes)
+        dec_volumes = np.array(dec_volumes)
+
+        # display volumes
+        bar_offset = 1
+        axes[1].bar(acc_volumes[:, 0], acc_volumes[:, 1], color="r", label="acc")
+        axes[1].bar(dec_volumes[:, 0] + bar_offset, dec_volumes[:, 1], color="g", label="dec")
+
+        k_volume_list.append([
+            pick_volumes(acc_volumes[2:12, 1], min_count=2, max_count=2).sum(),
+            pick_volumes(dec_volumes[2:12, 1], min_count=2, max_count=2).sum(),
+        ])
+
+        fig.savefig("{}/volume_k{:.003f}.png".format(output_dir ,k))
+
+        # temporary break for debugging
+        if DEBUG:
+            plt.show()
+            # break
+
+    valid_k_list = np.array(valid_k_list)
+    k_volume_list = np.array(k_volume_list)
+    # print(k_volume_list[:, 0])
+    # print(k_volume_list[:, 1])
+
+    k_n = len(valid_k_list)
+    min_volume = 1e9
+    min_i = 0
+    min_k = 0.
+    for i, k in enumerate(valid_k_list):
+        if abs(k_volume_list[i, 1]) < min_volume:
+            min_volume = abs(k_volume_list[i, 1])
+            min_k = k
+            min_i = i
+
+    print("Choose k: {:.03f}".format(min_k))
+
+    # figure
+    fig, axes = plt.subplots(3, 1, figsize=(16, 10))
+    fig.suptitle('file: {}'.format(os.path.basename(data_dir)))
+    colors = ['orange'] * k_n
+    bars = axes[0].bar(valid_k_list, k_volume_list[:, 0], width=0.001, color=colors)
+    axes[0].set_title("Acc Volume Diff")
+    for bar in bars:
+        height = bar.get_height()
+        axes[0].annotate('{:.0f}'.format(height),
+                         xy=(bar.get_x() + bar.get_width() / 2, height),
+                         xytext=(0, 3),  # 3 points vertical offset
+                         textcoords="offset points",
+                         ha='center', va='bottom')
+
+    colors = ['green'] * k_n
+    colors[min_i] = 'red'
+    bars = axes[1].bar(valid_k_list, k_volume_list[:, 1], width=0.001, color=colors)
+    axes[1].set_title("Dec Volume Diff (factor = {:f})".format(DEC_VOLUME_FACTOR))
+
+    for bar in bars:
+        height = bar.get_height()
+        axes[1].annotate('{:.0f}'.format(height),
+                         xy=(bar.get_x() + bar.get_width() / 2, height),
+                         xytext=(0, 3),  # 3 points vertical offset
+                         textcoords="offset points",
+                         ha='center', va='bottom')
+
+    colors = ['blue'] * k_n
+    bars = axes[2].bar(valid_k_list, k_volume_list[:, 0] + k_volume_list[:, 1], width=0.001)
+    axes[2].set_title("Sum Volume Diff")
+    for bar in bars:
+        height = bar.get_height()
+        axes[2].annotate('{:.0f}'.format(height),
+                         xy=(bar.get_x() + bar.get_width() / 2, height),
+                         xytext=(0, 3),  # 3 points vertical offset
+                         textcoords="offset points",
+                         ha='center', va='bottom')
+
+    fig.savefig("{}/volume.png".format(output_dir))
+
+    # show figures
+    # plt.show()
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
--- a/scripts/motan/readlog.py
+++ b/scripts/motan/readlog.py
@@ -3,6 +3,7 @@
 # Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
+import random, time
 import json, zlib
 
 class error(Exception):
@@ -504,6 +505,69 @@ class HandleEddyCurrent:
             self.data_pos += 1
 LogHandlers["ldc1612"] = HandleEddyCurrent
 
+# Extract inductance coil data
+class HandleInductaCoil:
+    SubscriptionIdParts = 2
+    ParametersMin = 1
+    ParametersMax = 2
+    DataSets = [
+        ('inductance_coil(<name>)', 'Coil resonant frequency')
+    ]
+    def __init__(self, lmanager, name, name_parts):
+        self.name = name
+        self.sensor_name = name_parts[1]
+        if len(name_parts) == 3 and name_parts[2] not in ("period", "z"):
+            raise error("Unknown inductance_coil selection '%s'" % (name_parts[2],))
+        self.report_frequency = True
+        self.jdispatch = lmanager.get_jdispatch()
+        self.next_samp = self.prev_samp = [0., 0.]
+        self.cur_data = []
+        self.data_pos = 0
+        t = time.time() * 1000
+        self.csv = open("{}_freq.csv".format(lmanager.log_prefix), "w+")
+    def __del__(self):
+        try:
+            self.csv.close()
+        except:
+            pass
+
+    def get_label(self):
+        if self.report_frequency:
+            label = '%s frequency' % (self.sensor_name,)
+            return {'label': label, 'units': 'Frequency\n(Hz)'}
+        label = '%s period' % (self.sensor_name,)
+        return {'label': label, 'units': 'Period\n(s)'}
+    def pull_data(self, req_time):
+        while 1:
+            next_time, next_freq = self.next_samp
+            if req_time <= next_time:
+                prev_time, prev_freq = self.prev_samp
+                if self.report_frequency:
+                    next_val = next_freq
+                    prev_val = prev_freq
+                else:
+                    next_val = 1. / next_freq
+                    prev_val = 1. / prev_freq
+                return interpolate(next_val, prev_val, next_time, prev_time,
+                                   req_time)
+            if self.data_pos >= len(self.cur_data):
+                # Read next data block
+                jmsg = self.jdispatch.pull_msg(req_time, self.name)
+                if jmsg is None:
+                    return 0.
+                self.cur_data = jmsg['data']
+                self.data_pos = 0
+                continue
+            self.prev_samp = self.next_samp
+            self.next_samp = self.cur_data[self.data_pos]
+            data_time, data_freq = self.next_samp
+            if data_freq > 0:
+                self.csv.write("{},{}\n".format(data_time, data_freq))
+            else:
+                return 0
+            self.data_pos += 1
+
+LogHandlers["inductance_coil"] = HandleInductaCoil
 
 ######################################################################
 # Log reading
@@ -639,6 +703,7 @@ class LogManager:
         self.start_status = {}
         self.log_subscriptions = {}
         self.status_tracker = None
+        self.log_prefix = log_prefix
     def setup_index(self):
         fmsg = self.index_reader.pull_msg()
         self.initial_status = status = fmsg['status']

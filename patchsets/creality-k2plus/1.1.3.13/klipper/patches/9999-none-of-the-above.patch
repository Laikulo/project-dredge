--- a/klippy/chelper/__init__.py
+++ b/klippy/chelper/__init__.py
@@ -46,12 +46,12 @@ SOURCE_FILES = [
     'pollreactor.c', 'msgblock.c', 'trdispatch.c',
     'kin_cartesian.c', 'kin_corexy.c', 'kin_corexz.c', 'kin_delta.c',
     'kin_deltesian.c', 'kin_polar.c', 'kin_rotary_delta.c', 'kin_winch.c',
-    'kin_extruder.c', 'kin_shaper.c',
+    'kin_extruder.c', 'kin_shaper.c', 'serial_485_queue.c', 'msgblock_485.c', 'filament_change.c',
 ]
 DEST_LIB = "c_helper.so"
 OTHER_FILES = [
     'list.h', 'serialqueue.h', 'stepcompress.h', 'itersolve.h', 'pyhelper.h',
-    'trapq.h', 'pollreactor.h', 'msgblock.h'
+    'trapq.h', 'pollreactor.h', 'msgblock.h', 'serial_485_queue.h', 'msgblock_485.h',
 ]
 
 defs_stepcompress = """
@@ -110,6 +110,13 @@ defs_trapq = """
         double x_r, y_r, z_r;
     };
 
+    typedef struct{
+        double extru_last_position;
+        double next_move_time;
+    }append_return_t;
+
+    append_return_t trapq_append_from_moveq(struct trapq *tq_kinematic, struct trapq *tq_extruder,double next_move_time,unsigned int move_data_h,int move_num);
+
     void trapq_append(struct trapq *tq, double print_time
         , double accel_t, double cruise_t, double decel_t
         , double start_pos_x, double start_pos_y, double start_pos_z
@@ -224,19 +231,40 @@ defs_trdispatch = """
 
 defs_pyhelper = """
     void set_python_logging_callback(void (*func)(const char *));
-    double get_monotonic(void);
 """
 
 defs_std = """
     void free(void*);
 """
 
+defs_serial_485_queue = """
+    #define BUFFER_MAX 512
+    struct pull_message {
+        int len;
+        uint8_t msg[BUFFER_MAX];
+    };
+    void serial_485_queue_send(struct serial_485_queue *sq, uint8_t *msg, int len);
+    void serial_485_queue_pull(struct serial_485_queue *sq, struct pull_message *pqm);
+    void serial_485_queue_get_stats(struct serial_485_queue *sq, char *buf, int len);
+    struct serial_485_queue * serial_485_queue_alloc(int serial_fd, char serial_fd_type);
+    void serial_485_queue_free(struct serial_485_queue *sq);
+    void serial_485_queue_exit(struct serial_485_queue *sq);
+    uint8_t msgblock_485_crc8(const uint8_t *data, uint32_t len);
+"""
+
+defs_filament_change = """
+    typedef struct {
+        uint8_t r, g, b;
+    } rgb_t;
+    int get_flushing_volume(const rgb_t source, const rgb_t target);
+"""
+
 defs_all = [
     defs_pyhelper, defs_serialqueue, defs_std, defs_stepcompress,
     defs_itersolve, defs_trapq, defs_trdispatch,
     defs_kin_cartesian, defs_kin_corexy, defs_kin_corexz, defs_kin_delta,
     defs_kin_deltesian, defs_kin_polar, defs_kin_rotary_delta, defs_kin_winch,
-    defs_kin_extruder, defs_kin_shaper,
+    defs_kin_extruder, defs_kin_shaper, defs_serial_485_queue, defs_filament_change,
 ]
 
 # Update filenames to an absolute path
--- /dev/null
+++ b/klippy/chelper/filament_change.h
@@ -0,0 +1,14 @@
+/*
+ * @Description : 
+ * @Author      : Yufeng Zhang
+ * @Date: 2024-04-23 10:39:48
+ * @LastEditTime: 2024-04-23 13:43:22
+ */
+#include <stdint.h>
+
+typedef struct {
+    uint8_t r, g, b;
+} rgb_t;
+
+int get_flushing_volume(const rgb_t source, const rgb_t target);
+
--- /dev/null
+++ b/klippy/chelper/msgblock_485.h
@@ -0,0 +1,22 @@
+#ifndef MSGBLOCK_485_H
+#define MSGBLOCK_485_H
+
+#include <stdint.h>
+
+/* head + addr + msglen + data, msglen >= 3, data = state + func + data + crc,  */
+#define MESSAGE_BUF_MIN (6)
+#define MESSAGE_485_MIN (3)
+#define MESSAGE_485_MAX (255)
+#define MESSAGE_485_HEAD (0xF7)
+#define MESSAGE_485_POS_HEAD (0)
+#define MESSAGE_485_POS_LEN (2)
+#define MESSAGE_485_HEADER_SIZE (1)
+#define MESSAGE_485_TRAILER_CRC (1) // crc
+#define MESSAGE_485_TRAILER_SIZE (1) // crc
+#define MAX_PENDING_BLOCKS_485 (1) // ask and answer interchangeably
+#define MESSAGE_485_SIZE_OUTSIDE_DATA (3) // head + addr +len
+
+uint8_t msgblock_485_crc8(const uint8_t *data, uint32_t len);
+int msgblock_485_check(uint8_t *need_sync, uint8_t *buf, int buf_len);
+
+#endif /* MSGBLOCK_485_H */
--- /dev/null
+++ b/klippy/chelper/serial_485_queue.h
@@ -0,0 +1,51 @@
+#ifndef SERIAL_485_QUEUE_H
+#define SERIAL_485_QUEUE_H
+
+#include "msgblock_485.h"
+#include "list.h" // struct list_node
+
+#define BUFFER_MAX 512
+
+struct queue_485_message {
+    int len;
+    uint8_t msg[BUFFER_MAX];
+    struct list_node node;
+};
+
+struct pull_message {
+    int len;
+    uint8_t msg[BUFFER_MAX];
+};
+
+struct serial_485_queue {
+    // Input reading
+    struct pollreactor *pr;
+    int serial_fd, serial_fd_type;
+    int pipe_fds[2];
+    uint8_t input_buf[4096];
+    uint8_t need_sync;
+    int input_pos;
+    // Threading
+    pthread_t tid;
+    pthread_mutex_t lock; // protects variables below
+    pthread_cond_t cond;
+    int receive_waiting;
+    // Pending transmission message queues
+    struct queue_485_message *pending_queues;
+    // Received messages
+    // struct list_head receive_queue;
+    struct queue_485_message *receive_queue;
+    // Debugging
+    struct list_head old_sent, old_receive;
+    // Stats
+    uint32_t bytes_write, bytes_read, bytes_invalid;
+};
+
+void serial_485_queue_send(struct serial_485_queue *sq, uint8_t *msg, int len);
+void serial_485_queue_pull(struct serial_485_queue *sq, struct pull_message *pqm);
+void serial_485_queue_get_stats(struct serial_485_queue *sq, char *buf, int len);
+struct serial_485_queue * serial_485_queue_alloc(int serial_fd, char serial_fd_type);
+void serial_485_queue_free(struct serial_485_queue *sq);
+void serial_485_queue_exit(struct serial_485_queue *sq);
+
+#endif /* SERIAL_485_QUEUE_H */
--- a/klippy/chelper/serialqueue.c
+++ b/klippy/chelper/serialqueue.c
@@ -14,14 +14,18 @@
 
 #include <linux/can.h> // // struct can_frame
 #include <math.h> // fabs
+#define __USE_GNU
+#include <sched.h>
 #include <pthread.h> // pthread_mutex_lock
 #include <stddef.h> // offsetof
 #include <stdint.h> // uint64_t
 #include <stdio.h> // snprintf
 #include <stdlib.h> // malloc
 #include <string.h> // memset
+#include <strings.h>
 #include <termios.h> // tcflush
 #include <unistd.h> // pipe
+
 #include "compiler.h" // __visible
 #include "list.h" // list_add_tail
 #include "msgblock.h" // message_alloc
@@ -34,6 +38,9 @@ struct command_queue {
     struct list_node node;
 };
 
+#define PRINTF_FORMAT_STRING_S "F:%d,S:%lld,T:%f,I:%f,L:%d\n"
+#define PRINTF_FORMAT_STRING_R "F:%d,R:%lld,T:%f\n"
+#define PRINTF_BUFF_LEN (40960)
 struct serialqueue {
     // Input reading
     struct pollreactor *pr;
@@ -71,6 +78,9 @@ struct serialqueue {
     struct list_head old_sent, old_receive;
     // Stats
     uint32_t bytes_write, bytes_read, bytes_retransmit, bytes_invalid;
+    uint8_t printf_buf[PRINTF_BUFF_LEN];
+    FILE* debug_file;
+    double last_send_time;
 };
 
 #define SQPF_SERIAL 0
@@ -95,6 +105,34 @@ struct serialqueue {
 #define DEBUG_QUEUE_SENT 100
 #define DEBUG_QUEUE_RECEIVE 100
 
+static void print_send_info(struct serialqueue *sq, uint64_t send_seq){
+    return;
+    int len=strlen((const char*)sq->printf_buf);
+    double cur_time=get_monotonic();
+    if(PRINTF_BUFF_LEN-len<100){
+        // printf("%s",sq->printf_buf);
+        fwrite(sq->printf_buf,1,len,sq->debug_file);
+        bzero(sq->printf_buf,PRINTF_BUFF_LEN);
+        len=0;
+    }
+    sprintf((char*)sq->printf_buf+len,PRINTF_FORMAT_STRING_S,sq->serial_fd,send_seq,cur_time,cur_time-sq->last_send_time,sq->ready_bytes);
+    sq->last_send_time=cur_time;
+    return;
+}
+
+static void print_recv_info(struct serialqueue *sq, uint64_t rev_seq){
+    return;
+    int len=strlen((const char*)sq->printf_buf);
+    double cur_time=get_monotonic();
+    if(PRINTF_BUFF_LEN-len<100){
+        // printf("%s",sq->printf_buf);
+        fwrite(sq->printf_buf,1,len,sq->debug_file);
+        bzero(sq->printf_buf,PRINTF_BUFF_LEN);
+        len=0;
+    }
+    sprintf((char*)sq->printf_buf+len,PRINTF_FORMAT_STRING_R,sq->serial_fd,rev_seq,cur_time);
+    return;
+}
 // Create a series of empty messages and add them to a list
 static void
 debug_queue_alloc(struct list_head *root, int count)
@@ -180,6 +218,8 @@ update_receive_seq(struct serialqueue *sq, double eventtime, uint64_t rseq)
         }
     }
     sq->receive_seq = rseq;
+    // if(sq->receive_seq==sq->wait_ack_seq)
+    //     printf("cur serial %d,receive ack seq=%llu, last_ack_bytes=%d\n",sq->serial_fd,sq->receive_seq,sq->last_ack_bytes);
     pollreactor_update_timer(sq->pr, SQPT_COMMAND, PR_NOW);
 
     // Update retransmit info
@@ -223,6 +263,7 @@ handle_message(struct serialqueue *sq, double eventtime, int len)
     // Calculate receive sequence number
     uint64_t rseq = ((sq->receive_seq & ~MESSAGE_SEQ_MASK)
                      | (sq->input_buf[MESSAGE_POS_SEQ] & MESSAGE_SEQ_MASK));
+    print_recv_info(sq,rseq);
     if (rseq != sq->receive_seq) {
         // New sequence number
         if (rseq < sq->receive_seq)
@@ -356,7 +397,6 @@ kick_event(struct serialqueue *sq, double eventtime)
     pollreactor_update_timer(sq->pr, SQPT_COMMAND, PR_NOW);
 }
 
-// OS write of data to be sent to the mcu
 static void
 do_write(struct serialqueue *sq, void *buf, int buflen)
 {
@@ -504,16 +544,21 @@ static double
 check_send_command(struct serialqueue *sq, int pending, double eventtime)
 {
     if (sq->send_seq - sq->receive_seq >= MAX_PENDING_BLOCKS
-        && sq->receive_seq != (uint64_t)-1)
+        && sq->receive_seq != (uint64_t)-1){
         // Need an ack before more messages can be sent
+        // printf("cur serial %d,wait ack,cur send seq %llu,remain %d ready_bytes,cur receive_seq %llu\n",sq->serial_fd,sq->send_seq,sq->ready_bytes,sq->receive_seq);
         return PR_NEVER;
+    }
     if (sq->send_seq > sq->receive_seq && sq->receive_window) {
         int need_ack_bytes = sq->need_ack_bytes + MESSAGE_MAX;
         if (sq->last_ack_seq < sq->receive_seq)
             need_ack_bytes += sq->last_ack_bytes;
-        if (need_ack_bytes > sq->receive_window)
+        if (need_ack_bytes > sq->receive_window){
             // Wait for ack from past messages before sending next message
+            // sq->wait_ack_seq = sq->send_seq;
+            // printf("cur serial %d,wait ack %llu,cur send seq %llu,cur receive_seq %llu,remain %d ready_bytes,receive_window %d\n",sq->serial_fd,sq->wait_ack_seq,sq->send_seq,sq->receive_seq,sq->ready_bytes,sq->receive_window);
             return PR_NEVER;
+        }
     }
 
     // Check for stalled messages now ready
@@ -589,6 +634,7 @@ command_event(struct serialqueue *sq, double eventtime)
                                    ? eventtime : sq->idle_time);
                 sq->idle_time = idletime + calculate_bittime(sq, buflen);
                 buflen = 0;
+                print_send_info(sq,sq->send_seq);
             }
             if (waketime != PR_NOW)
                 break;
@@ -604,6 +650,7 @@ static void *
 background_thread(void *data)
 {
     struct serialqueue *sq = data;
+    nice(-20);
     pollreactor_run(sq->pr);
 
     pthread_mutex_lock(&sq->lock);
@@ -619,6 +666,9 @@ serialqueue_alloc(int serial_fd, char serial_fd_type, int client_id)
 {
     struct serialqueue *sq = malloc(sizeof(*sq));
     memset(sq, 0, sizeof(*sq));
+    char filename[100];
+    sprintf(filename,"/tmp/klipper_debug_pritf_%d",serial_fd);
+    sq->debug_file = fopen(filename,"w");
     sq->serial_fd = serial_fd;
     sq->serial_fd_type = serial_fd_type;
     sq->client_id = client_id;
@@ -772,18 +822,19 @@ serialqueue_send_batch(struct serialqueue *sq, struct command_queue *cq
                        , struct list_head *msgs)
 {
     // Make sure min_clock is set in list and calculate total bytes
-    int len = 0;
+    int len = 0,count = 0;
     struct queue_message *qm;
     list_for_each_entry(qm, msgs, node) {
         if (qm->min_clock + (1LL<<31) < qm->req_clock
             && qm->req_clock != BACKGROUND_PRIORITY_CLOCK)
             qm->min_clock = qm->req_clock - (1LL<<31);
         len += qm->len;
+        count++;
     }
     if (! len)
         return;
     qm = list_first_entry(msgs, struct queue_message, node);
-
+    // printf("send_batch: cur serial fd %d len=%d count=%d\n",sq->serial_fd,len,count);
     // Add list to cq->stalled_queue
     pthread_mutex_lock(&sq->lock);
     if (list_empty(&cq->ready_queue) && list_empty(&cq->stalled_queue))
--- a/klippy/chelper/trapq.c
+++ b/klippy/chelper/trapq.c
@@ -6,12 +6,18 @@
 
 #include <math.h> // sqrt
 #include <stddef.h> // offsetof
+#include <stdio.h> // printf
 #include <stdlib.h> // malloc
 #include <string.h> // memset
 #include "compiler.h" // unlikely
 #include "trapq.h" // move_get_coord
 
 // Allocate a new 'move' object
+typedef int bool;
+#define true 1
+#define false 0
+
+
 struct move *
 move_alloc(void)
 {
@@ -20,6 +26,82 @@ move_alloc(void)
     return m;
 }
 
+typedef struct _move_data_t_in_trapq_ {
+    double start_pos[4];
+    double end_pos[4];
+    // ????
+    double start_v;
+    double cruise_v;
+    double end_v;
+    double accel_t;
+    double cruise_t;
+    double decel_t;
+
+    double accel;
+    double junction_deviation;
+    bool is_kinematic_move;
+    double axes_d[4];
+    double move_d;
+    double axes_r[4];
+    double min_move_t;
+    double max_start_v2;
+    double max_cruise_v2;
+    double delta_v2;
+    double max_smoothed_v2;
+    double smooth_delta_v2;
+    struct _move_data_t_in_trapq_* next;
+} move_data_t_in_trapq;
+
+append_return_t __visible
+trapq_append_from_moveq(struct trapq *tq_kinematic, struct trapq *tq_extruder,double next_move_time,unsigned int move_data_h,int move_num)
+{
+    // printf("get move head addr 0x%x\n",(unsigned int)move_data_h);
+    move_data_t_in_trapq *move_data = NULL;
+    double next_move_time_ = next_move_time;
+    double extru_last_position=999999999.999;
+    append_return_t return_value;
+    int i = 0;
+    for (move_data = (move_data_t_in_trapq*)move_data_h; move_data != NULL;move_data = move_data->next) { // for each move in move_data_h
+        if (move_data->is_kinematic_move) {
+            trapq_append(tq_kinematic, next_move_time_, move_data->accel_t, move_data->cruise_t,
+                        move_data->decel_t, move_data->start_pos[0],
+                        move_data->start_pos[1], move_data->start_pos[2],
+                        move_data->axes_r[0], move_data->axes_r[1],
+                        move_data->axes_r[2], move_data->start_v,
+                        move_data->cruise_v, move_data->accel);
+        }
+
+        if(move_data->axes_d[3]!=0){
+            double axis_r = (double)move_data->axes_r[3];
+            double accel = move_data->accel * axis_r;
+            double start_v = move_data->start_v * axis_r;
+            double cruise_v = move_data->cruise_v * axis_r;
+            bool can_pressure_advance = false;
+            if (axis_r > 0. && (move_data->axes_d[0] || move_data->axes_d[1]))
+                can_pressure_advance = true;
+            #if 0
+            if((move_data->start_pos[2] <2.0+0.2)&&(move_data->start_pos[2] > 2.0-0.2)){//layer 7,z=2.0
+                printf("layer 7,z=2.0,x:%f,y:%f,z:%f,move_d:%f,accel:%f,start_v:%f,cruise_v:%f,accel_t:%f,cruise_t:%f,decel_t:%f,can_pressure_advance:%d\n",move_data->start_pos[0],move_data->start_pos[1],move_data->start_pos[2],move_data->move_d,accel,start_v,cruise_v,move_data->accel_t,move_data->cruise_t,move_data->decel_t,can_pressure_advance);
+            }else if((move_data->start_pos[2] <9.75+0.2)&&(move_data->start_pos[2] > 9.75-0.2)){//layer 38,z=9.75))
+                printf("layer 38,z=9.75,x:%f,y:%f,z:%f,move_d:%f,accel:%f,start_v:%f,cruise_v:%f,accel_t:%f,cruise_t:%f,decel_t:%f,can_pressure_advance:%d\n",move_data->start_pos[0],move_data->start_pos[1],move_data->start_pos[2],move_data->move_d,accel,start_v,cruise_v,move_data->accel_t,move_data->cruise_t,move_data->decel_t,can_pressure_advance);
+            }
+            #endif
+            trapq_append(tq_extruder, next_move_time_,
+                        move_data->accel_t, move_data->cruise_t, move_data->decel_t,
+                        move_data->start_pos[3], 0., 0.,
+                        1., can_pressure_advance, 0.,
+                        start_v, cruise_v, accel);
+            extru_last_position = move_data->end_pos[3];
+        }
+        next_move_time_ = (next_move_time_ + move_data->accel_t + move_data->cruise_t + move_data->decel_t);
+        i++;
+        if (i == move_num)
+        break;
+    }
+    return_value.extru_last_position = extru_last_position;
+    return_value.next_move_time = next_move_time_;
+    return return_value;
+}
 // Fill and add a move to the trapezoid velocity queue
 void __visible
 trapq_append(struct trapq *tq, double print_time
--- a/klippy/chelper/trapq.h
+++ b/klippy/chelper/trapq.h
@@ -30,7 +30,11 @@ struct pull_move {
     double start_x, start_y, start_z;
     double x_r, y_r, z_r;
 };
-
+typedef struct{
+    double extru_last_position;
+    double next_move_time;
+}append_return_t;
+append_return_t trapq_append_from_moveq(struct trapq *tq_kinematic, struct trapq *tq_extruder,double next_move_time,unsigned int move_data_h,int move_num);
 struct move *move_alloc(void);
 void trapq_append(struct trapq *tq, double print_time
                   , double accel_t, double cruise_t, double decel_t
--- a/klippy/clocksync.py
+++ b/klippy/clocksync.py
@@ -4,13 +4,17 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, math
-
+import mymodule.mymovie as mymovie
+import numpy as np
 RTT_AGE = .000010 / (60. * 60.)
 DECAY = 1. / 30.
 TRANSMIT_EXTRA = .001
 
 class ClockSync:
     def __init__(self, reactor):
+        self._sync_array = [0.0]*4
+        self.sync_array = np.array(self._sync_array, dtype=np.float64)
+        self.sync_array_addr_int = self.sync_array.ctypes.data
         self.reactor = reactor
         self.serial = None
         self.get_clock_timer = reactor.register_timer(self._get_clock_event)
@@ -27,15 +31,26 @@ class ClockSync:
         self.clock_avg = self.clock_covariance = 0.
         self.prediction_variance = 0.
         self.last_prediction_time = 0.
+        self.sync_array[0]=self.mcu_freq
+        self.sync_array[1]=self.clock_est[0]
+        self.sync_array[2]=self.clock_est[1]
+        self.sync_array[3]=self.clock_est[2]
     def connect(self, serial):
         self.serial = serial
         self.mcu_freq = serial.msgparser.get_constant_float('CLOCK_FREQ')
+        self.sync_array[0]=self.mcu_freq
         # Load initial clock and frequency
         params = serial.send_with_response('get_uptime', 'uptime')
+        self.time_avg = params['#sent_time']
+        if not self.time_avg:
+            params = serial.send_with_response('get_uptime', 'uptime')
+            self.time_avg = params['#sent_time']
         self.last_clock = (params['high'] << 32) | params['clock']
         self.clock_avg = self.last_clock
-        self.time_avg = params['#sent_time']
         self.clock_est = (self.time_avg, self.clock_avg, self.mcu_freq)
+        self.sync_array[1]=self.clock_est[0]
+        self.sync_array[2]=self.clock_est[1]
+        self.sync_array[3]=self.clock_est[2]
         self.prediction_variance = (.001 * self.mcu_freq)**2
         # Enable periodic get_clock timer
         for i in range(8):
@@ -50,7 +65,11 @@ class ClockSync:
     def connect_file(self, serial, pace=False):
         self.serial = serial
         self.mcu_freq = serial.msgparser.get_constant_float('CLOCK_FREQ')
+        self.sync_array[0]=self.mcu_freq
         self.clock_est = (0., 0., self.mcu_freq)
+        self.sync_array[1]=self.clock_est[0]
+        self.sync_array[2]=self.clock_est[1]
+        self.sync_array[3]=self.clock_est[2]
         freq = 1000000000000.
         if pace:
             freq = self.mcu_freq
@@ -116,20 +135,24 @@ class ClockSync:
         new_freq = self.clock_covariance / self.time_variance
         pred_stddev = math.sqrt(self.prediction_variance)
         self.serial.set_clock_est(new_freq, self.time_avg + TRANSMIT_EXTRA,
-                                  int(self.clock_avg - 3. * pred_stddev), clock)
+                                  mymovie.Py_fast_convert_to_int(self.clock_avg - 3. * pred_stddev), clock)
         self.clock_est = (self.time_avg + self.min_half_rtt,
                           self.clock_avg, new_freq)
+        self.sync_array[1]=self.clock_est[0]
+        self.sync_array[2]=self.clock_est[1]
+        self.sync_array[3]=self.clock_est[2]
         #logging.debug("regr %.3f: freq=%.3f d=%d(%.3f)",
         #              sent_time, new_freq, clock - exp_clock, pred_stddev)
     # clock frequency conversions
     def print_time_to_clock(self, print_time):
-        return int(print_time * self.mcu_freq)
+        return mymovie.Py_fast_convert_to_int(print_time * self.mcu_freq)
     def clock_to_print_time(self, clock):
         return clock / self.mcu_freq
     # system time conversions
     def get_clock(self, eventtime):
         sample_time, clock, freq = self.clock_est
-        return int(clock + (eventtime - sample_time) * freq)
+        value=clock + (eventtime - sample_time) * freq
+        return mymovie.Py_fast_convert_to_int(value)
     def estimate_clock_systime(self, reqclock):
         sample_time, clock, freq = self.clock_est
         return float(reqclock - clock)/freq + sample_time
@@ -183,7 +206,7 @@ class SecondarySync(ClockSync):
     # clock frequency conversions
     def print_time_to_clock(self, print_time):
         adjusted_offset, adjusted_freq = self.clock_adj
-        return int((print_time - adjusted_offset) * adjusted_freq)
+        return mymovie.Py_fast_convert_to_int((print_time - adjusted_offset) * adjusted_freq)
     def clock_to_print_time(self, clock):
         adjusted_offset, adjusted_freq = self.clock_adj
         return clock / adjusted_freq + adjusted_offset
--- a/klippy/configfile.py
+++ b/klippy/configfile.py
@@ -123,6 +123,8 @@ class ConfigWrapper:
     def get_prefix_options(self, prefix):
         return [o for o in self.fileconfig.options(self.section)
                 if o.startswith(prefix)]
+    def get_options(self):
+        return [o for o in self.fileconfig.options(self.section)]
     def deprecate(self, option, value=None):
         if not self.fileconfig.has_option(self.section, option):
             return
@@ -154,6 +156,10 @@ class PrinterConfig:
         gcode = self.printer.lookup_object('gcode')
         gcode.register_command("SAVE_CONFIG", self.cmd_SAVE_CONFIG,
                                desc=self.cmd_SAVE_CONFIG_help)
+        gcode.register_command("CXSAVE_CONFIG", self.cmd_CXSAVE_CONFIG,
+                               desc=self.cmd_CXSAVE_CONFIG_help)
+        gcode.register_command("REMOVE_CONFIG_SECTION", self.cmd_REMOVE_CONFIG_SECTION,
+                               desc=self.cmd_REMOVE_CONFIG_SECTION_help)
     def get_printer(self):
         return self.printer
     def _read_config_file(self, filename):
@@ -375,6 +381,76 @@ class PrinterConfig:
                     msg = ("SAVE_CONFIG section '%s' option '%s' conflicts "
                            "with included value" % (section, option))
                     raise gcode.error(msg)
+    
+    def get_additional_included_config(self):
+        gcode = self.printer.lookup_object('gcode')
+        # Read in and validate current config file
+        cfgname = self.printer.get_start_args()['config_file']
+        try:
+            data = self._read_config_file(cfgname)
+            regular_data, old_autosave_data = self._find_autosave_data(data)
+        except error as e:
+            msg = "Unable to parse existing config on SAVE_CONFIG"
+            logging.exception(msg)
+            raise gcode.error(msg)
+        # get include config
+        includes = []
+        lines = regular_data.split('\n')
+        for line in lines:
+            # Strip trailing comment
+            pos = line.find('#')
+            if pos >= 0:
+                line = line[:pos]
+            # Process include or buffer line
+            mo = configparser.RawConfigParser.SECTCRE.match(line)
+            header = mo and mo.group('header')
+            if header and header.startswith('include '):
+                dirname = os.path.dirname(cfgname)
+                include_spec = header[8:].strip()
+                include_spec = include_spec.strip()
+                include_glob = os.path.join(dirname, include_spec)
+                includes.append(include_glob)
+        return includes
+
+    def _strip_include_duplicates(self, gcode):
+        if not self.autosave.fileconfig.sections():
+            return
+        includes = self.get_additional_included_config()
+        logging.info("included files = '%d'", len(includes))
+        for cfgname in includes:
+            # Read in and validate current config file
+            try:
+                data = self._read_config_file(cfgname)
+            except error as e:
+                msg = "Unable to parse existing config on SAVE_CONFIG"
+                logging.exception(msg)
+                raise gcode.error(msg)
+            no_duplicate = self._strip_duplicates(data, self.autosave)
+            if no_duplicate == data:
+                continue
+            # The data has been modified
+            data = no_duplicate.rstrip()
+            # Determine filenames
+            datestr = time.strftime("-%Y%m%d_%H%M%S")
+            backup_name = cfgname + datestr
+            temp_name = cfgname + "_autosave"
+            if cfgname.endswith(".cfg"):
+                backup_name = cfgname[:-4] + datestr + ".cfg"
+                temp_name = cfgname[:-4] + "_autosave.cfg"
+            # Create new config file with temporary name and swap with main config
+            logging.info("SAVE_CONFIG to '%s' (backup in '%s')",
+                        cfgname, backup_name)
+            try:
+                f = open(temp_name, 'w')
+                f.write(data)
+                f.close()
+                os.rename(cfgname, backup_name)
+                os.rename(temp_name, cfgname)
+            except:
+                msg = "Unable to write config file during SAVE_CONFIG"
+                logging.exception(msg)
+                raise gcode.error(msg)
+        
     cmd_SAVE_CONFIG_help = "Overwrite config file and restart"
     def cmd_SAVE_CONFIG(self, gcmd):
         if not self.autosave.fileconfig.sections():
@@ -422,3 +498,61 @@ class PrinterConfig:
             raise gcode.error(msg)
         # Request a restart
         gcode.request_restart('restart')
+
+    cmd_CXSAVE_CONFIG_help = "Overwrite config file by cx "
+    def cmd_CXSAVE_CONFIG(self, gcmd):
+        if not self.autosave.fileconfig.sections():
+            return
+        gcode = self.printer.lookup_object('gcode')
+        # Create string containing autosave data
+        autosave_data = self._build_config_string(self.autosave)
+        lines = [('#*# ' + l).strip()
+                 for l in autosave_data.split('\n')]
+        lines.insert(0, "\n" + AUTOSAVE_HEADER.rstrip())
+        lines.append("")
+        autosave_data = '\n'.join(lines)
+        # Read in and validate current config file
+        cfgname = self.printer.get_start_args()['config_file']
+        try:
+            data = self._read_config_file(cfgname)
+            regular_data, old_autosave_data = self._find_autosave_data(data)
+            config = self._build_config_wrapper(regular_data, cfgname)
+        except error as e:
+            msg = "Unable to parse existing config on SAVE_CONFIG"
+            logging.exception(msg)
+            raise gcode.error(msg)
+        regular_data = self._strip_duplicates(regular_data, self.autosave)
+        self._strip_include_duplicates(gcode)
+        self._disallow_include_conflicts(regular_data, cfgname, gcode)
+        data = regular_data.rstrip() + autosave_data
+        # Determine filenames
+        datestr = time.strftime("-%Y%m%d_%H%M%S")
+        backup_name = cfgname + datestr
+        temp_name = cfgname + "_autosave"
+        if cfgname.endswith(".cfg"):
+            backup_name = cfgname[:-4] + datestr + ".cfg"
+            temp_name = cfgname[:-4] + "_autosave.cfg"
+        # Create new config file with temporary name and swap with main config
+        logging.info("SAVE_CONFIG to '%s' (backup in '%s')",
+                     cfgname, backup_name)
+        try:
+            f = open(temp_name, 'w')
+            f.write(data)
+            f.close()
+            os.rename(cfgname, backup_name)
+            os.rename(temp_name, cfgname)
+        except:
+            msg = "Unable to write config file during SAVE_CONFIG"
+            logging.exception(msg)
+            raise gcode.error(msg)
+
+        # Request a restart
+        # gcode.request_restart('restart')
+
+    cmd_REMOVE_CONFIG_SECTION_help = ("Remove config section from config file")
+    def cmd_REMOVE_CONFIG_SECTION(self, gcmd):
+        section = gcmd.get('SECTION', None)
+        if section:
+            configfile = self.printer.lookup_object('configfile')
+            configfile.remove_section(section)
+            self.printer.lookup_object('gcode').run_script_from_command('CXSAVE_CONFIG')
--- a/klippy/console.py
+++ b/klippy/console.py
@@ -5,7 +5,7 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import sys, optparse, os, re, logging
-import util, reactor, serialhdl, msgproto, clocksync
+import util, reactor, serialhdl, pins, msgproto, clocksync
 
 help_txt = """
   This is a debugging console for the Klipper micro-controller.
@@ -43,6 +43,7 @@ class KeyboardReader:
         self.fd = sys.stdin.fileno()
         util.set_nonblock(self.fd)
         self.mcu_freq = 0
+        self.pins = pins.PinResolver(validate_aliases=False)
         self.data = ""
         reactor.register_fd(self.fd, self.process_kbd)
         reactor.register_callback(self.connect)
@@ -222,7 +223,11 @@ class KeyboardReader:
                 return None
             line = ''.join(evalparts)
             self.output("Eval: %s" % (line,))
-        line = line.strip()
+        try:
+            line = self.pins.update_command(line).strip()
+        except:
+            self.output("Unable to map pin: %s" % (line,))
+            return None
         if line:
             parts = line.split()
             if parts[0] in self.local_commands:
--- a/klippy/extras/adxl345.py
+++ b/klippy/extras/adxl345.py
@@ -5,6 +5,8 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, time, collections, threading, multiprocessing, os
 from . import bus, motion_report
+import struct
+from multiprocessing import shared_memory
 
 # ADXL345 registers
 REG_DEVID = 0x00
@@ -83,6 +85,71 @@ class AccelQueryHelper:
                 count += 1
         del samples[count:]
         return self.samples
+
+    def copy_double_to_buffer(self, buffer, offset, val):
+        bytes = struct.pack("d", val)
+
+        # little store
+        try:
+            buffer[offset:offset+8] = bytearray(bytes)
+            del bytes
+        except:
+            gcode = self.printer.lookup_object('gcode')
+            gcode.respond_info("val: %f, bytes: %s, offset: %d" % (val, bytes.hex(), offset))
+
+    def copy_int_to_buffer(self, buffer, offset, val):
+        # little store
+        try:
+            buffer[offset] = val & 0xFF
+            buffer[offset + 1] = (val >> 8) & 0xFF
+            buffer[offset + 2] = (val >> 16) & 0xFF
+            buffer[offset + 3] = (val >> 24) & 0xFF
+        except:
+            gcode = self.printer.lookup_object('gcode')
+            gcode.respond_info("val: %f, offset: %d" % (val, offset))
+
+    def get_samples_to_shared_mem(self):
+        gcode = self.printer.lookup_object('gcode')
+        raw_samples = self._get_raw_samples()
+        if not raw_samples:
+            return self.samples
+        total = sum([len(m['params']['data']) for m in raw_samples])
+        count = 0
+
+        # shm size = (double bytes) * (count of member: samp_time, x, y and z) * total
+        shm_size = 8 * 4 * total
+        shm = shared_memory.SharedMemory(name="psm_samples", create=True, size=shm_size)
+
+        buffer = shm.buf
+        self.copy_int_to_buffer(buffer, 0, count)
+        count += 4
+
+        reactor = self.printer.get_reactor()
+        for msg in raw_samples:
+            for samp_time, x, y, z in msg['params']['data']:
+                if samp_time < self.request_start_time:
+                    continue
+                if samp_time > self.request_end_time:
+                    break
+
+                # 30000 * sizeof(samp_time, x, y, z) + sizeof(count)
+                # switch process
+                if count % 960000 == 4:
+                    reactor.pause(reactor.monotonic() + .1)
+
+                self.copy_double_to_buffer(buffer, count, samp_time)
+                count += 8
+                self.copy_double_to_buffer(buffer, count, x)
+                count += 8
+                self.copy_double_to_buffer(buffer, count, y)
+                count += 8
+                self.copy_double_to_buffer(buffer, count, z)
+                count += 8
+
+        self.copy_int_to_buffer(buffer, 0, count)
+        shm.close()
+        gcode.respond_info("shm_size: %d, double bytes count: %d" % (shm_size, count))
+
     def write_to_file(self, filename):
         def write_impl():
             try:
@@ -114,6 +181,22 @@ class AccelCommandHelper:
         if len(name_parts) == 1:
             if self.name == "adxl345" or not config.has_section("adxl345"):
                 self.register_commands(None)
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("getAdxl345Status",
+                                   self.get_adxl345_status)
+    def get_adxl345_status(self, web_request):
+        adxl345_is_exist = True
+        try:
+            aclient = self.chip.start_internal_client()
+            self.printer.lookup_object('toolhead').dwell(1.)
+            aclient.finish_measurements()
+            values = aclient.get_samples()
+        except Exception as err:
+            logging.error(err)
+            values = ""
+        if not values:
+            adxl345_is_exist = False
+        web_request.send({"adxl345_is_exist": adxl345_is_exist})
     def register_commands(self, name):
         # Register commands
         gcode = self.printer.lookup_object('gcode')
--- /dev/null
+++ b/klippy/extras/auto_addr.py
@@ -0,0 +1,4 @@
+from . import auto_addr_wrapper
+def load_config(config):
+    aa = auto_addr_wrapper.AutoAddrWrapper(config)
+    return aa
--- /dev/null
+++ b/klippy/extras/auto_addr_wrapper.py
@@ -0,0 +1,691 @@
+import logging
+import copy
+from dataclasses import dataclass
+from typing import List, Union
+
+
+########################### 使用说明 ###############################
+# cfg文件添加 [auto_addr]配置项
+# dev_table_map_table 包含三种类型的设备，MB，CLM，BTM 分别表示料盒 闭环电机 皮带张紧电机
+# 如果不需要 注释掉响应的行即可，比如只需要料盒自动分配，可以只保留MB行 
+# 外部模块通过获取 addr_manager_table_xx[i].online 来获取在线状态，如果为1表示在线，否则离线
+# 在线状态是通过online_check来更新，连续3次没回复会认为掉线，有几秒的滞后
+# 本文件所有命令未开启底层重传，有重试需要的在应用层实现
+# 通过 PRINT_ADDR_TABLE 命令可以查看当前地址表的状态
+# 地址列表发生变化后，uniid会保存在 cfg文件末尾，形如
+# #*# [auto_addr]
+# #*# mb_addr_table_uniids = xxx
+
+# 最大包长度
+MAX_DATA_LEN = 100  
+# 最大uid长度
+MAX_UNIID_LEN = 12
+MAX_LOST_CNT = 3
+# 包头
+PACK_HEAD = 0xF7
+# 广播地址
+BROADCAST_ADDR = 0xFF
+BROADCAST_ADDR_MB = 0xFE
+BROADCAST_ADDR_CLM = 0xFD
+BROADCAST_ADDR_BTM = 0xFC
+# 自动地址获取相关命令
+CMD_GET_SLAVE_INFO = 0xA1
+CMD_SET_SLAVE_ADDR = 0xA0
+CMD_ONLINE_CHECK = 0xA2
+CMD_GET_ADDR_TABLE = 0xA3
+CMD_LOADER_TO_APP = 0x0B
+
+# 当前的状态 loader还是app
+MODE_APP = 0
+MODE_LOADER = 1
+
+# 设备类型
+# MB-料盒 CLM-闭环电机 BTM-皮带张紧电机
+DEV_TYPE_MB = 1
+DEV_TYPE_CLM = 2
+DEV_TYPE_BTM = 3
+# 下标偏移量
+DEV_TYPE_INDEX_OFFSET = DEV_TYPE_MB
+
+# CRC8校验计算参数
+POLY = 0x07 
+
+# package status
+STATUS_OK = 0x00 
+# STATUS_ERROR = 1
+
+# online state
+ONLINE_STATE_OFFLINE = 0
+ONLINE_STATE_ONLINE = 1
+ONLINE_STATE_INIT = 2
+ONLINE_STATE_WAIT_FOR_ACK = 3
+
+# 最大设置和获取次数 
+MAX_GET_TIMES = 2
+MAX_SET_TIMES = 2
+
+# 命令超时时间
+TIMEOUT_SHORT_TIME = 0.05
+TIMEOUT_MEDIUM_TIME = 0.1
+TIMEOUT_LONG_TIME = 1.0 
+
+cmd_timeout = { CMD_GET_SLAVE_INFO: TIMEOUT_LONG_TIME,
+                CMD_SET_SLAVE_ADDR: TIMEOUT_SHORT_TIME, 
+                CMD_GET_ADDR_TABLE: TIMEOUT_SHORT_TIME,
+                CMD_ONLINE_CHECK:   TIMEOUT_MEDIUM_TIME,
+                CMD_LOADER_TO_APP:  TIMEOUT_SHORT_TIME }
+name_map = {
+    DEV_TYPE_MB: "mb_addr_table_uniids",
+    # DEV_TYPE_CLM: "clm_addr_table_uniids",
+    # DEV_TYPE_BTM: "btm_addr_table_uniids",
+}
+
+# 包格式
+@dataclass
+class DataPackage:
+    head: int
+    slave_addr: int
+    length: int
+    status: int
+    function_code: int
+    data: List[Union[int, float]]
+    crc: int
+
+# 返回数据的格式
+@dataclass
+class FcAckData:
+    dev_type: int
+    mode: int  # 0: app, 1: loader
+    uniid: List[int]
+
+@dataclass
+class AddrManager:
+    addr: int
+    uniid: List[int]
+    mapped: int
+    online: int
+    acked: int
+    lost_cnt: int
+    mode: int
+
+# 料盒地址
+addr_manager_table_mb = [
+    AddrManager(0x01, [0x00], 0, 0, 0, 0, 0),
+    AddrManager(0x02, [0x00], 0, 0, 0, 0, 0),
+    AddrManager(0x03, [0x00], 0, 0, 0, 0, 0),
+    AddrManager(0x04, [0x00], 0, 0, 0, 0, 0),
+]
+
+# 闭环电机地址
+addr_manager_table_cl_motor = [
+    AddrManager(0x81, [0x00], 0, 0, 0, 0, 0),
+    AddrManager(0x82, [0x00], 0, 0, 0, 0, 0),
+    AddrManager(0x83, [0x00], 0, 0, 0, 0, 0),
+    AddrManager(0x84, [0x00], 0, 0, 0, 0, 0),
+]
+
+# 皮带张紧电机地址
+addr_manager_table_bt_motor = [
+    AddrManager(0x91, [0x00], 0, 0, 0, 0, 0),
+    AddrManager(0x92, [0x00], 0, 0, 0, 0, 0),
+]
+
+class DevTableMap:
+    def __init__(self, dev_type, broadcast_addr, addr_manager_table):
+        self.dev_type = dev_type
+        self.broadcast_addr = broadcast_addr
+        self.addr_manager_table = addr_manager_table
+        self.size = len(addr_manager_table)
+
+dev_table_map_table = [
+    DevTableMap(DEV_TYPE_MB, BROADCAST_ADDR_MB, addr_manager_table_mb),
+    # DevTableMap(DEV_TYPE_CLM, BROADCAST_ADDR_CLM, addr_manager_table_cl_motor),
+    # DevTableMap(DEV_TYPE_BTM, BROADCAST_ADDR_BTM, addr_manager_table_bt_motor),
+]
+
+class AutoAddrWrapper:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.configfile = self.printer.lookup_object('configfile')
+        self.config = config
+        self.gcode = self.printer.lookup_object('gcode')
+        self._serial = self.printer.lookup_object("serial_485 " + "serial485")
+        # self.parse = ParseData()
+        # self.get_finished = False
+        self.debug = config.getint('debug', default=0, minval=0, maxval=1)
+        self.uniid_changed = False
+        self.print_stats = None
+        self.gcode.register_command('PRINT_ADDR_TABLE', self.cmd_PRINT_ADDR_TABLE)
+
+        # 获取保存的地址列表
+        for i in range(len(dev_table_map_table)):
+            dev_table_map = dev_table_map_table[i]
+            self.get_addr_table_uniids(dev_table_map)
+
+        if config.has_section("motor_control") and config.getsection('motor_control').getint('switch')==1:
+            self.printer.register_event_handler('auto_addr:start', self.reg_auto_addr_set)
+        else:
+            self.printer.register_event_handler('klippy:ready', self.reg_auto_addr_set)
+
+        self.printer.register_event_handler('auto_addr:set_finished', self.reg_auto_addr_process)
+
+        self.dprintf("auto addr wrapper init")
+
+    ###################### 获取上次的地址对应的uniid ########################
+    def get_addr_table_uniids(self, dev_table_map):
+        name = name_map[dev_table_map.dev_type]
+        if self.config.get(name, None) is not None:
+            def custom_int_parser(value):
+                try:
+                    if value.startswith('0x') or value.startswith('0X'):
+                        return int(value, 16)
+                    else:
+                        return int(value)
+                except ValueError as e:
+                    raise ValueError(f"Invalid literal for int with base 10 or 16: '{value}'") from e
+            uniids = self.config.getlists(name, seps=(',', '\n'), parser=custom_int_parser)
+            if len(uniids) != dev_table_map.size:
+                self.dprintf("Error: %s, uniids len: %d, dev_table_map.size: %d" % (name, len(uniids), dev_table_map.size))
+            else:
+                self.dprintf("addr table uniid get %s" % name)
+                for i in range(dev_table_map.size):
+                    dev_table_map.addr_manager_table[i].uniid = list(uniids[i])
+                    ## 如果uniid不为空，说明该地址上次关机前已分配，需要置位相关标志
+                    if len(uniids[i]) >= 1:
+                        if uniids[i][0] != 0:
+                            dev_table_map.addr_manager_table[i].mapped = 1
+                            dev_table_map.addr_manager_table[i].online = ONLINE_STATE_INIT 
+                    self.dprintf("addr %d: %s" % (dev_table_map.addr_manager_table[i].addr, dev_table_map.addr_manager_table[i].uniid))
+        else:
+            self.dprintf("Error: %s not exist" % name)
+
+    ###################### 保存地址对应的uniid ########################
+    def save_addr_table_uniids(self, dev_table_map):
+        dev_type = dev_table_map.dev_type
+        name = name_map[dev_type] 
+        self.dprintf("addr table uniid save %s" % name)
+        uniids = ""
+        for i in range(dev_table_map.size):
+            uniids += "\n  "
+            for j in range(len(dev_table_map.addr_manager_table[i].uniid)):
+                uniids += "0x%02X, " % dev_table_map.addr_manager_table[i].uniid[j]
+            uniids = uniids[:-2]
+        self.dprintf("uniids: %s" % uniids)
+        section = "auto_addr"
+        self.configfile.set(section, name, uniids)
+        self.gcode.run_script_from_command("CXSAVE_CONFIG")
+
+    ###################### gcode cmd ########################
+    def cmd_PRINT_ADDR_TABLE(self, gcmd):
+        for i in range(len(dev_table_map_table)):
+            dev_table_map = dev_table_map_table[i]
+            addr_manager_table = dev_table_map.addr_manager_table
+            size = len(addr_manager_table)
+            for i in range(size):
+                response = "0x%02X, " % addr_manager_table[i].addr
+                for j in range(len(addr_manager_table[i].uniid)):
+                    response += "0x%02X, " % addr_manager_table[i].uniid[j]
+                response += "%d, %d, %d, %d, mode:%d" % (addr_manager_table[i].mapped, addr_manager_table[i].online,
+                        addr_manager_table[i].acked, addr_manager_table[i].lost_cnt, addr_manager_table[i].mode)
+                gcmd.respond_info(response)
+
+    ##################### addr allocate #####################
+    def addr_allocate(self, uniid, addr_manager_table):
+        # 优先分配已经分配过，并且uniid对的上的地址
+        size = len(addr_manager_table)
+        for i in range(size):
+            if addr_manager_table[i].mapped == 1:
+                # 如果掉线(或者刚初始化的，在前面的设置和获取环节都没有返回)，则需要重新分配
+                if addr_manager_table[i].online == ONLINE_STATE_OFFLINE or addr_manager_table[i].online == ONLINE_STATE_INIT:
+                    if uniid == addr_manager_table[i].uniid:
+                        addr_manager_table[i].mapped = 1
+                        addr_manager_table[i].online = ONLINE_STATE_WAIT_FOR_ACK
+                        self.dprintf("alloc method 1 addr %d" % addr_manager_table[i].addr)
+                        return addr_manager_table[i].addr
+                # 如果上位机显示在线，但是下位机回复了广播指令，说明下位机重启了，地址变成了广播地址，也需要重新分配地址
+                elif addr_manager_table[i].online == ONLINE_STATE_ONLINE and uniid == addr_manager_table[i].uniid:
+                    self.dprintf("Error: addr already allocated, but broadcast ack happened, maybe slave restarted, "
+                            "clear the arcked flag and try to allocate the addr again")
+                    # 能收到返回说明在线，需要置位
+                    addr_manager_table[i].online = ONLINE_STATE_WAIT_FOR_ACK
+                    addr_manager_table[i].acked = 0
+                    return -1
+        # 然后是未分配，的地址
+        for i in range(size):
+            if addr_manager_table[i].mapped == 0:
+                addr_manager_table[i].mapped = 1
+                addr_manager_table[i].online = ONLINE_STATE_WAIT_FOR_ACK 
+                addr_manager_table[i].uniid = uniid
+                self.uniid_changed = True
+                self.dprintf("alloc method 2 addr %d" % addr_manager_table[i].addr)
+                return addr_manager_table[i].addr
+
+        # 然后是已分配，但是uniid对不上，掉线的地址
+        for i in range(size):
+            if addr_manager_table[i].mapped == 1:
+                if addr_manager_table[i].online == ONLINE_STATE_OFFLINE or addr_manager_table[i].online == ONLINE_STATE_INIT:
+                    if addr_manager_table[i].uniid != uniid:
+                        # 覆盖原来的uniid
+                        addr_manager_table[i].uniid = uniid
+                        addr_manager_table[i].mapped = 1
+                        addr_manager_table[i].online = ONLINE_STATE_WAIT_FOR_ACK
+                        self.uniid_changed = True
+                        self.dprintf("alloc method 3 addr %d" % addr_manager_table[i].addr)
+                        return addr_manager_table[i].addr
+        # 如果没有满足条件的地址，返回-1
+        return -1
+
+    def print_buff(self, buff):
+        _len = len(buff)
+        message = ""
+        for i in range(_len):
+            message += "0x%02X " % buff[i]
+        self.dprintf(message)
+
+    def crc8_cal(self, data, len):
+        crc = 0
+        for i in range(len):
+            crc ^= data[i]
+            for j in range(8):
+                if crc & 0x80:
+                    crc = (crc << 1) ^ POLY
+                else:
+                    crc <<= 1
+                crc &= 0xFF
+        return crc
+
+    def cal_pack_crc(self, package):
+        crc_buff = [package.length, package.status, package.function_code]
+        crc_buff += package.data
+        return self.crc8_cal(crc_buff, len(crc_buff))
+
+    def is_dev_type_valid(self, dev_type):
+        if dev_type == DEV_TYPE_BTM or dev_type == DEV_TYPE_CLM or dev_type == DEV_TYPE_MB:
+            return 1
+        else:
+            return 0
+
+    def function_code_cb(self, package):
+        function_code = package.function_code
+        size = 0
+        ack_data = None
+        if function_code == CMD_SET_SLAVE_ADDR or function_code == CMD_GET_SLAVE_INFO \
+            or function_code == CMD_ONLINE_CHECK or function_code == CMD_GET_ADDR_TABLE:
+            ack_data = FcAckData(package.data[0], package.data[1], package.data[2:])
+        
+        ## 记录是否在loader的标记
+        if ack_data is not None:
+            addr_manager_table = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].addr_manager_table
+            uniid = ack_data.uniid
+            size = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].size
+            for i in range(size):
+                if addr_manager_table[i].uniid == uniid:
+                    addr_manager_table[i].mode = ack_data.mode 
+                    if ack_data.mode == MODE_LOADER:
+                        self.dprintf("addr 0x%02X in loader mode" % addr_manager_table[i].addr)
+                    break
+
+        if function_code == CMD_SET_SLAVE_ADDR:
+            # ack_data = FcAckData(package.data[0], package.data[1], package.data[2:])
+            if self.is_dev_type_valid(ack_data.dev_type):
+                # self.dprintf("uniid:")
+                # self.print_buff(ack_data.uniid)
+                addr_manager_table = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].addr_manager_table
+                size = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].size
+                addr = package.slave_addr
+                uniid = ack_data.uniid
+                self.dprintf("received addr %d uniid %s" % (addr, uniid))
+                for i in range(size):
+                    self.dprintf("table[%d]: online %d addr %d uniid %s acked %d" % \
+                                 (i, addr_manager_table[i].online, addr_manager_table[i].addr, addr_manager_table[i].uniid, addr_manager_table[i].acked))
+                    if (addr_manager_table[i].online == ONLINE_STATE_INIT or addr_manager_table[i].online == ONLINE_STATE_WAIT_FOR_ACK) and \
+                        addr_manager_table[i].addr == addr and \
+                        addr_manager_table[i].uniid == uniid and \
+                        addr_manager_table[i].acked == 0:
+                        addr_manager_table[i].acked = 1
+                        addr_manager_table[i].online = ONLINE_STATE_ONLINE
+                        addr_manager_table[i].lost_cnt = 0
+                        self.dprintf("addr %d acked" % addr_manager_table[i].addr)
+                        break
+        elif function_code == CMD_GET_SLAVE_INFO:
+            # ack_data = FcAckData(package.data[0], package.data[1], package.data[2:])
+            if self.is_dev_type_valid(ack_data.dev_type):
+                self.dprintf("dev_type: %d" % ack_data.dev_type)
+                self.dprintf("mode: %d" % ack_data.mode)
+                self.dprintf("uniid:")
+                self.print_buff(ack_data.uniid)
+                addr_manager_table = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].addr_manager_table
+                size = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].size
+                addr = self.addr_allocate(ack_data.uniid, addr_manager_table)
+                self.dprintf("addr: %d" % addr)
+
+        elif function_code == CMD_ONLINE_CHECK:
+            # ack_data = FcAckData(package.data[0], package.data[1], package.data[2:])
+            if self.is_dev_type_valid(ack_data.dev_type):
+                self.dprintf("uniid:")
+                self.print_buff(ack_data.uniid)
+                addr_manager_table = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].addr_manager_table
+                size = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].size
+                addr = package.slave_addr
+                uniid = ack_data.uniid
+                for i in range(size):
+                    if addr_manager_table[i].addr == addr and \
+                        addr_manager_table[i].uniid == uniid:
+                        addr_manager_table[i].acked = 1
+                        addr_manager_table[i].online = ONLINE_STATE_ONLINE
+                        addr_manager_table[i].lost_cnt = 0
+                        self.dprintf("addr %d acked" % addr_manager_table[i].addr)
+                        break
+
+        elif function_code == CMD_GET_ADDR_TABLE:
+            # ack_data = FcAckData(package.data[0], package.data[1], package.data[2:])
+            if self.is_dev_type_valid(ack_data.dev_type):
+                self.dprintf("uniid:")
+                self.print_buff(ack_data.uniid)
+                addr_manager_table = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].addr_manager_table
+                size = dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET].size
+                addr = package.slave_addr
+                uniid = ack_data.uniid
+                for i in range(size):
+                    if addr_manager_table[i].addr == addr:
+                        addr_manager_table[i].uniid = uniid
+                        addr_manager_table[i].mapped = 1
+                        addr_manager_table[i].acked = 1
+                        addr_manager_table[i].online = ONLINE_STATE_ONLINE 
+                        addr_manager_table[i].lost_cnt = 0
+                        self.uniid_changed = True 
+                        self.dprintf("addr %d acked" % addr_manager_table[i].addr)
+                        break
+        else:
+            self.dprintf("unknown function code: %d" % function_code)
+
+        if self.uniid_changed:
+            self.uniid_changed = False
+            self.save_addr_table_uniids(dev_table_map_table[ack_data.dev_type - DEV_TYPE_INDEX_OFFSET])
+
+    def dprintf(self, msg):
+        if self.debug:
+            logging.info(msg)
+
+    def data_handler(self, ret):
+        # bytes经过迭代自动转换为int
+        package = DataPackage(ret[0], ret[1], ret[2], ret[3], ret[4], [b for b in ret[5:-1]], ret[-1])
+        if package.status == STATUS_OK:
+            self.function_code_cb(package)
+        else:
+            self.dprintf("Error: status: %d" % package.status)
+
+    def data_pack(self, slave_addr, cmd, data):
+        _len = len(data)
+        package = DataPackage(PACK_HEAD, slave_addr, _len + 3, STATUS_OK, cmd, data, 0x00)
+        package.crc = self.cal_pack_crc(package)
+        return package
+
+    def send_package(self, package):
+        data_send = bytes([package.slave_addr]) +  \
+                    bytes([package.length]) + \
+                    bytes([package.status]) + \
+                    bytes([package.function_code]) + \
+                    bytes(int(c) for c in package.data)
+        timeout = cmd_timeout[package.function_code]
+        # self.dprintf("data_send: %s" % data_send)
+        # self.dprintf("timeout: %f" % timeout)
+        ret = self._serial.cmd_send_data_with_response(data_send, timeout, False)
+        if ret is None:
+            self.dprintf("Error: no response")
+            return
+        self.dprintf("response is not null")
+        # self.dprintf("type of ret is %s" % type(ret))
+        self.print_buff(ret)
+        # ret 类型是bytes
+        self.data_handler(ret)
+
+    ###################### communication interface ########################
+    def communication_get_addr_table(self, addr):
+        package = self.data_pack(addr, CMD_GET_ADDR_TABLE, [])
+        self.send_package(package)
+
+    def communication_get_slave_info(self, broadcast_addr, send_data):
+        package = self.data_pack(broadcast_addr, CMD_GET_SLAVE_INFO, send_data)
+        self.send_package(package)
+
+    def communication_set_slave_addr(self, broadcast_addr, addr, uniid):
+        send_data = []
+        send_data.append(addr)
+        send_data += uniid
+        # send_data.append(uniid)
+        package = self.data_pack(broadcast_addr, CMD_SET_SLAVE_ADDR, send_data)
+        self.send_package(package)
+
+    def communication_online_check(self, addr):
+        package = self.data_pack(addr, CMD_ONLINE_CHECK, [])
+        self.send_package(package)
+    
+    def communication_loader_check(self, addr):
+        package = self.data_pack(addr, CMD_LOADER_TO_APP, [0x01])
+        self.send_package(package)
+
+    def print_addr_manager_table(self, addr_manager_table):
+        size = len(addr_manager_table)
+        for i in range(size):
+            log_message = ""
+            log_message += "0x%02X, " % addr_manager_table[i].addr
+            for j in range(len(addr_manager_table[i].uniid)):
+                log_message += "0x%02X, " % addr_manager_table[i].uniid[j]
+            log_message += "%d, %d, %d, %d, mode:%d" % (addr_manager_table[i].mapped, addr_manager_table[i].online,
+                    addr_manager_table[i].acked, addr_manager_table[i].lost_cnt, addr_manager_table[i].mode)
+            self.dprintf(log_message)
+
+    ###################### logic interface ########################
+    def get_addr_table(self, dev_table_map):
+        self.dprintf("**************************** get addr table ****************************")
+        size = dev_table_map.size
+        # 如果底层有重试，上层就不需要重试了
+        # 此文件中已经把底层重试关闭，所以此处在应用层添加重试
+        for i in range(MAX_GET_TIMES):
+            self.dprintf("**** get times %d" % (i + 1))
+            for j in range(size):
+                # if dev_table_map.addr_manager_table[j].acked == 0:
+                if dev_table_map.addr_manager_table[j].online != ONLINE_STATE_ONLINE:
+                    self.communication_get_addr_table(dev_table_map.addr_manager_table[j].addr)
+
+            online_slave_num = 0
+            for k in range(size):
+                if dev_table_map.addr_manager_table[k].online == ONLINE_STATE_ONLINE:
+                # if dev_table_map.addr_manager_table[k].acked == 1:
+                    online_slave_num += 1
+            self.dprintf("online slave num: %d" % online_slave_num)
+            # 如果已经获取所有从设备此信息则直接返回 不需要再尝试
+            if online_slave_num == size:
+                self.print_addr_manager_table(dev_table_map.addr_manager_table)
+                self.dprintf("online slave num is max: %d" % online_slave_num)
+                return 
+        self.print_addr_manager_table(dev_table_map.addr_manager_table)
+    
+    def set_addr_table(self, dev_table_map):
+        self.dprintf("**************************** set addr table ****************************")
+        addr_manager_table = dev_table_map.addr_manager_table
+        size = dev_table_map.size
+        broadcast_addr = dev_table_map.broadcast_addr
+        self.dprintf("before set addr table")
+        self.print_addr_manager_table(addr_manager_table) 
+        for i in range(MAX_SET_TIMES):
+            self.dprintf("**** set times %d" % (i + 1))
+            mapped_cnt = 0
+            for i in range(size):
+                if addr_manager_table[i].mapped == 1:
+                    if addr_manager_table[i].online == ONLINE_STATE_INIT:
+                        mapped_cnt += 1
+                        self.communication_set_slave_addr(broadcast_addr, addr_manager_table[i].addr, addr_manager_table[i].uniid)
+
+            valid_slave_num = 0
+            for k in range(size):
+                if addr_manager_table[k].online == ONLINE_STATE_ONLINE:
+                    valid_slave_num += 1
+            self.dprintf("valid slave num: %d" % valid_slave_num)
+            # 如果所有设备都成功设置地址 不需要再尝试
+            if valid_slave_num == mapped_cnt:
+                self.print_addr_manager_table(addr_manager_table)
+                self.dprintf("valid slave num is max: %d" % valid_slave_num)
+                return
+        self.print_addr_manager_table(addr_manager_table) 
+
+    def get_slave_info(self, dev_table_map):
+        broadcast_addr = dev_table_map.broadcast_addr
+        send_data = [broadcast_addr, broadcast_addr]
+        online_slave_num = 0
+        addr_manager_table = dev_table_map.addr_manager_table 
+        size = dev_table_map.size
+        self.dprintf("**************************** get slave info ****************************")
+        for i in range(size):
+            if addr_manager_table[i].online == ONLINE_STATE_ONLINE or addr_manager_table[i].online == ONLINE_STATE_WAIT_FOR_ACK:
+                online_slave_num += 1
+
+        ## 如果全都在线，或者已经处于等待地址回复的状态，则后面不用扫描
+        if online_slave_num == size:
+            self.dprintf("online slave num is max %d" % online_slave_num)
+            return 
+        self.communication_get_slave_info(broadcast_addr, send_data)
+
+    def set_slave_addr(self, dev_table_map):
+        self.dprintf("**************************** set slave addr ****************************")
+        addr_manager_table = dev_table_map.addr_manager_table
+        size = dev_table_map.size
+        broadcast_addr = dev_table_map.broadcast_addr
+        for i in range(size):
+            if addr_manager_table[i].mapped == 1:
+                if addr_manager_table[i].online == ONLINE_STATE_WAIT_FOR_ACK:
+                    self.communication_set_slave_addr(broadcast_addr, addr_manager_table[i].addr, addr_manager_table[i].uniid)
+
+    def online_check(self, dev_table_map):
+        self.dprintf("**************************** online check ****************************")
+        lost_flag = 0
+        mapped_exist = 0
+        addr_manager_table = dev_table_map.addr_manager_table 
+        size = dev_table_map.size
+        for i in range(size):
+            if addr_manager_table[i].mapped == 1:
+                mapped_exist = 1
+                addr_manager_table[i].lost_cnt += 1
+                self.communication_online_check(addr_manager_table[i].addr)
+                if addr_manager_table[i].lost_cnt > MAX_LOST_CNT:
+                    addr_manager_table[i].online = ONLINE_STATE_OFFLINE 
+                    addr_manager_table[i].acked = 0
+                    self.dprintf("Error: addr %.2X offline" % addr_manager_table[i].addr)
+                    lost_flag = 1
+        if mapped_exist == 1:
+            self.print_addr_manager_table(addr_manager_table)
+            if lost_flag == 0:
+                self.dprintf("***************** all online ********************")
+    def loader_check(self, dev_table_map):
+        self.dprintf("**************************** loader check ****************************")
+        addr_manager_table = dev_table_map.addr_manager_table 
+        size = dev_table_map.size
+        for i in range(size):
+            # for test
+            # addr_manager_table[i].mode = MODE_LOADER
+            if addr_manager_table[i].mode == MODE_LOADER:
+                ## 如果在loader模式需要使其进入app模式
+                self.communication_loader_check(BROADCAST_ADDR)
+                return True 
+        return False 
+    ###################### reg process ##########################
+    def reg_auto_addr_get(self):
+        self.reactor.register_callback(self.process_get_addr_table)
+    def reg_auto_addr_set(self):
+        self.print_stats = self.printer.lookup_object('print_stats')
+        self.reactor.register_callback(self.process_set_addr_table)
+    def reg_auto_addr_process(self):
+        # self.reactor.register_callback(self.process_set_slave_addr)
+        # self.reactor.register_callback(self.process_online_check)
+        # self.reactor.register_callback(self.process_loader_check)
+        self.reactor.register_callback(self.process_all)
+        pass
+
+
+    ###################### process ##########################
+    def process_get_addr_table(self, eventtime):
+        for i in range(len(dev_table_map_table)):
+            dev_table_map = dev_table_map_table[i]
+            self.get_addr_table(dev_table_map)
+        # self.get_finished = True
+        self.dprintf("get addr table finished")
+        self.printer.send_event("auto_addr:get_finished")
+
+    def process_set_addr_table(self, eventtime):
+        for i in range(len(dev_table_map_table)):
+            dev_table_map = dev_table_map_table[i]
+            ## 根据上次保存的地址列表，设置设备地址
+            self.set_addr_table(dev_table_map)
+            ## 对于设置不成功的设备，重新获取
+            self.get_addr_table(dev_table_map)
+        # self.get_finished = True
+        self.dprintf("set && get addr table finished")
+        self.printer.send_event("auto_addr:set_finished")
+
+    def process_set_slave_addr(self, eventtime):
+        while True:
+            if self.printer.is_shutdown():
+                return
+            self.dprintf("set slave addr")
+            for i in range(len(dev_table_map_table)):
+                dev_table_map = dev_table_map_table[i]
+                self.get_slave_info(dev_table_map)
+                self.set_slave_addr(dev_table_map)
+            self.reactor.pause(self.reactor.monotonic() + 3.)
+
+    def process_online_check(self, eventtime):
+        while True:
+            time_interval = 1.5
+            if self.print_stats.state == "printing" or self.print_stats.state == "pause":
+                time_interval = 10
+            if self.printer.is_shutdown():
+                return
+            self.dprintf("online check")
+            for i in range(len(dev_table_map_table)):
+                dev_table_map = dev_table_map_table[i]
+                self.online_check(dev_table_map)
+            self.reactor.pause(self.reactor.monotonic() + time_interval)
+    def process_loader_check(self, eventtime):
+        while True:
+            time_interval = 2.0 
+            if self.print_stats.state == "printing" or self.print_stats.state == "pause":
+                time_interval = 10
+            if self.printer.is_shutdown():
+                return
+            self.dprintf("loader check")
+            for i in range(len(dev_table_map_table)):
+                dev_table_map = dev_table_map_table[i]
+                ## 一个周期只需要发送一次即可
+                if True == self.loader_check(dev_table_map):
+                    break
+            self.reactor.pause(self.reactor.monotonic() + time_interval)
+
+    def process_all(self, eventtime):
+        while True:
+            time_interval = 1.0 
+            if self.print_stats.state == "printing" or self.print_stats.state == "pause":
+                time_interval = 10
+            if self.printer.is_shutdown():
+                return
+
+            self.dprintf("set slave addr")
+            for i in range(len(dev_table_map_table)):
+                dev_table_map = dev_table_map_table[i]
+                self.get_slave_info(dev_table_map)
+                self.set_slave_addr(dev_table_map)
+
+            self.dprintf("online check")
+            for i in range(len(dev_table_map_table)):
+                dev_table_map = dev_table_map_table[i]
+                self.online_check(dev_table_map)
+
+            self.dprintf("loader check")
+            for i in range(len(dev_table_map_table)):
+                dev_table_map = dev_table_map_table[i]
+                ## 一个周期只需要发送一次即可
+                if True == self.loader_check(dev_table_map):
+                    break
+            self.reactor.pause(self.reactor.monotonic() + time_interval)
+
--- /dev/null
+++ b/klippy/extras/base_info.py
@@ -0,0 +1,34 @@
+import os, re, logging
+
+class BaseDirSystemInfo:
+    _instance = None
+
+    def __new__(cls):
+        if not cls._instance:
+            cls._instance = super(BaseDirSystemInfo, cls).__new__(cls)
+            cls._instance._base_dir = "/usr/data"
+            cls._instance._h264_encoder_flag = "H264_ENCODER"
+            cls._instance._initialize_base_dir()
+        return cls._instance
+
+    def _initialize_base_dir(self):
+        path = "/etc/openwrt_release"
+        if os.path.exists(path):
+            self._base_dir = "/mnt/UDISK"
+            try:
+                text = ""
+                with open(path, "r") as f:
+                    text = f.read()
+                match = re.search(r"DISTRIB_TARGET='(.*?)'", text)
+                if match:
+                    if "t113" in match.group(0):
+                        self._h264_encoder_flag = "NO_H264_ENCODER"
+            except Exception as err:
+                logging.error(err)
+
+    def get_base_dir(self):
+        return self._base_dir
+
+
+system_info_instance = BaseDirSystemInfo()
+base_dir = system_info_instance.get_base_dir()
--- a/klippy/extras/bed_mesh.py
+++ b/klippy/extras/bed_mesh.py
@@ -6,7 +6,8 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, math, json, collections
 from . import probe
-
+import mymodule.mymovie as mymovie
+import numpy as np
 PROFILE_VERSION = 1
 PROFILE_OPTIONS = {
     'min_x': float, 'max_x': float, 'min_y': float, 'max_y': float,
@@ -87,27 +88,35 @@ def parse_gcmd_coord(gcmd, name):
 class BedMesh:
     FADE_DISABLE = 0x7FFFFFFF
     def __init__(self, config):
+        self._move_array = [0.0]*(9+4)
+        self.move_array = np.array(self._move_array, dtype=np.float64)
+        self.move_array_addr_int = self.move_array.ctypes.data
         self.printer = config.get_printer()
         self.printer.register_event_handler("klippy:connect",
                                             self.handle_connect)
         self.last_position = [0., 0., 0., 0.]
         self.bmc = BedMeshCalibrate(config, self)
         self.z_mesh = None
+        self.z_mesh_bak = None
         self.toolhead = None
         self.horizontal_move_z = config.getfloat('horizontal_move_z', 5.)
-        self.fade_start = config.getfloat('fade_start', 1.)
-        self.fade_end = config.getfloat('fade_end', 0.)
-        self.fade_dist = self.fade_end - self.fade_start
-        if self.fade_dist <= 0.:
-            self.fade_start = self.fade_end = self.FADE_DISABLE
+        self.__fade_start = config.getfloat('fade_start', 1.)
+        self.__fade_end = config.getfloat('fade_end', 0.)
+        self.__fade_dist = self.__fade_end - self.__fade_start
+        if self.__fade_dist <= 0.:
+            self.__fade_start = self.__fade_end = self.FADE_DISABLE
         self.log_fade_complete = False
         self.base_fade_target = config.getfloat('fade_target', None)
         self.fade_target = 0.
         self.gcode = self.printer.lookup_object('gcode')
-        self.splitter = MoveSplitter(config, self.gcode)
+        # self.splitter = MoveSplitter(config, self.gcode)
+        self.splitter = mymovie.PyMoveSplitter(config.getfloat(
+            'split_delta_z', .025, minval=0.01), config.getfloat(
+            'move_check_distance', 5., minval=1.))
         # setup persistent storage
         self.pmgr = ProfileManager(config, self)
         self.save_profile = self.pmgr.save_profile
+        self.load_profile = self.pmgr.load_profile
         # register gcodes
         self.gcode.register_command(
             'BED_MESH_OUTPUT', self.cmd_BED_MESH_OUTPUT,
@@ -121,17 +130,46 @@ class BedMesh:
         self.gcode.register_command(
             'BED_MESH_OFFSET', self.cmd_BED_MESH_OFFSET,
             desc=self.cmd_BED_MESH_OFFSET_help)
+        self.gcode.register_command(
+            'BED_MESH_SAVE', self.cmd_BED_MESH_SAVE,
+            desc=self.cmd_BED_MESH_SAVE_help)
+        self.gcode.register_command(
+            'BED_MESH_RESTORE', self.cmd_BED_MESH_RESTORE,
+            desc=self.cmd_BED_MESH_RESTORE_help)
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("get_mesh", self._get_mesh)
+        webhooks.register_endpoint("update_mesh", self.update_mesh)
         # Register transform
         gcode_move = self.printer.load_object(config, 'gcode_move')
         gcode_move.set_move_transform(self)
         # initialize status dict
+        self.update_status()  
+        self.move_array[9]=self.__fade_start
+        self.move_array[10]=self.__fade_end
+        self.move_array[11]=self.__fade_dist
+    def _get_mesh(self, web_request):
+        probed_matrix = [[]]
+        try:
+            probed_matrix = self.z_mesh.get_probed_matrix()
+        except Exception as err:
+            logging.error(err)
+        web_request.send({'probed_matrix': probed_matrix})
+    def update_mesh(self, web_request):
+        probed_matrix = web_request.get("probed_matrix", [[]])
+        self.z_mesh.update_mesh_probed_matrix(probed_matrix)
+        self.set_mesh(self.z_mesh)
         self.update_status()
+        self.save_profile(self.pmgr.get_current_profile())
+        self.load_profile(self.pmgr.get_current_profile())
+        self.gcode.run_script_from_command('CXSAVE_CONFIG')
+        probed_matrix = self.z_mesh.get_probed_matrix()
+        web_request.send({'probed_matrix': probed_matrix})
     def handle_connect(self):
         self.toolhead = self.printer.lookup_object('toolhead')
         self.bmc.print_generated_points(logging.info)
         self.pmgr.initialize()
     def set_mesh(self, mesh):
-        if mesh is not None and self.fade_end != self.FADE_DISABLE:
+        if mesh is not None and self.__fade_end != self.FADE_DISABLE:
             self.log_fade_complete = True
             if self.base_fade_target is None:
                 self.fade_target = mesh.avg_z
@@ -149,27 +187,30 @@ class BedMesh:
                         "range\nmin: %.4f, max: %.4f, fade_target: %.4f"
                         % (min_z, max_z, err_target))
             min_z, max_z = mesh.get_z_range()
-            if self.fade_dist <= max(abs(min_z), abs(max_z)):
+            if self.__fade_dist <= max(abs(min_z), abs(max_z)):
                 self.z_mesh = None
                 self.fade_target = 0.
                 raise self.gcode.error(
                     "bed_mesh:  Mesh extends outside of the fade range, "
                     "please see the fade_start and fade_end options in"
                     "example-extras.cfg. fade distance: %.2f mesh min: %.4f"
-                    "mesh max: %.4f" % (self.fade_dist, min_z, max_z))
+                    "mesh max: %.4f" % (self.__fade_dist, min_z, max_z))
         else:
             self.fade_target = 0.
         self.z_mesh = mesh
-        self.splitter.initialize(mesh, self.fade_target)
+        if self.z_mesh is not None:
+            self.splitter.initialize(mesh.info_array_addr_int, self.fade_target)
+        else:
+            self.splitter.initialize(0, self.fade_target)
         # cache the current position before a transform takes place
         gcode_move = self.printer.lookup_object('gcode_move')
         gcode_move.reset_last_position()
         self.update_status()
     def get_z_factor(self, z_pos):
-        if z_pos >= self.fade_end:
-            return 0.
-        elif z_pos >= self.fade_start:
-            return (self.fade_end - z_pos) / self.fade_dist
+        if z_pos >= self.__fade_end:
+            return 0.0
+        elif z_pos >= self.__fade_start:
+            return (self.__fade_end - z_pos) / self.__fade_dist
         else:
             return 1.
     def get_position(self):
@@ -184,21 +225,27 @@ class BedMesh:
             max_adj = self.z_mesh.calc_z(x, y)
             factor = 1.
             z_adj = max_adj - self.fade_target
-            if min(z, (z - max_adj)) >= self.fade_end:
+            if min(z, (z - max_adj)) >= self.__fade_end:
                 # Fade out is complete, no factor
                 factor = 0.
-            elif max(z, (z - max_adj)) >= self.fade_start:
+            elif max(z, (z - max_adj)) >= self.__fade_start:
                 # Likely in the process of fading out adjustment.
                 # Because we don't yet know the gcode z position, use
                 # algebra to calculate the factor from the toolhead pos
-                factor = ((self.fade_end + self.fade_target - z) /
-                          (self.fade_dist - z_adj))
+                factor = ((self.__fade_end + self.fade_target - z) /
+                          (self.__fade_dist - z_adj))
                 factor = constrain(factor, 0., 1.)
             final_z_adj = factor * z_adj + self.fade_target
             self.last_position[:] = [x, y, z - final_z_adj, e]
         return list(self.last_position)
+    def set_z_temp_compensation(self):
+        if self.z_mesh is None:
+            return
+        self.z_mesh.set_z_temp_compensation()
     def move(self, newpos, speed):
-        factor = self.get_z_factor(newpos[2])
+        # factor = self.get_z_factor(newpos[2])
+        factor = mymovie.Py_get_z_factor(self.move_array_addr_int,newpos[2])
+        # if self.z_mesh is None or not factor:
         if self.z_mesh is None or not factor:
             # No mesh calibrated, or mesh leveling phased out.
             x, y, z, e = newpos
@@ -209,12 +256,30 @@ class BedMesh:
                     % (z, self.fade_target))
             self.toolhead.move([x, y, z + self.fade_target, e], speed)
         else:
-            self.splitter.build_move(self.last_position, newpos, factor)
-            while not self.splitter.traverse_complete:
-                split_move = self.splitter.split()
-                if split_move:
-                    self.toolhead.move(split_move, speed)
-                else:
+            # self.move_array[0:9] = self.last_position+newpos+[factor]
+            self.move_array[0]=self.last_position[0]
+            self.move_array[1]=self.last_position[1]
+            self.move_array[2]=self.last_position[2]
+            self.move_array[3]=self.last_position[3]
+            self.move_array[4]=newpos[0]
+            self.move_array[5]=newpos[1]
+            self.move_array[6]=newpos[2]
+            self.move_array[7]=newpos[3]
+            self.move_array[8]=factor
+            self.move_array[12]=speed
+            self.set_z_temp_compensation()
+            self.splitter.build_move(self.move_array_addr_int)
+            while 1:
+                self.splitter.split_for_loop(self.move_array_addr_int)
+                if self.move_array[4] == 0:
+                    self.toolhead.simple_move(self.move_array[0:4])
+                elif self.move_array[4] == 7:
+                    break
+                elif self.move_array[4] == -1:
+                    raise self.gcode.error(
+                        "bed_mesh: Slice distance is negative "
+                        "or greater than entire move length")
+                elif self.move_array[4] == -2:
                     raise self.gcode.error(
                         "Mesh Leveling: Error splitting move ")
         self.last_position[:] = newpos
@@ -277,6 +342,13 @@ class BedMesh:
             gcode_move.reset_last_position()
         else:
             gcmd.respond_info("No mesh loaded to offset")
+    cmd_BED_MESH_SAVE_help = "Save the Mesh to bak"
+    def cmd_BED_MESH_SAVE(self, gcmd):
+        if self.z_mesh is not None:
+            self.z_mesh_bak = self.z_mesh
+    cmd_BED_MESH_RESTORE_help = "Restore the bak Mesh to Mesh"
+    def cmd_BED_MESH_RESTORE(self, gcmd):
+        self.set_mesh(self.z_mesh_bak)
 
 
 class BedMeshCalibrate:
@@ -716,7 +788,7 @@ class BedMeshCalibrate:
                         "Probed table length: %d Probed Table:\n%s") %
                     (len(probed_matrix), str(probed_matrix)))
 
-        z_mesh = ZMesh(params)
+        z_mesh = ZMesh(params,self.printer)
         try:
             z_mesh.build_mesh(probed_matrix)
         except BedMeshError as e:
@@ -744,77 +816,29 @@ class BedMeshCalibrate:
                 "  %-4d| %-17s| %-25s| %s" % (i, gen_pt, probed_pt, corr_pt))
 
 
-class MoveSplitter:
-    def __init__(self, config, gcode):
-        self.split_delta_z = config.getfloat(
-            'split_delta_z', .025, minval=0.01)
-        self.move_check_distance = config.getfloat(
-            'move_check_distance', 5., minval=3.)
-        self.z_mesh = None
-        self.fade_offset = 0.
-        self.gcode = gcode
-    def initialize(self, mesh, fade_offset):
-        self.z_mesh = mesh
-        self.fade_offset = fade_offset
-    def build_move(self, prev_pos, next_pos, factor):
-        self.prev_pos = tuple(prev_pos)
-        self.next_pos = tuple(next_pos)
-        self.current_pos = list(prev_pos)
-        self.z_factor = factor
-        self.z_offset = self._calc_z_offset(prev_pos)
-        self.traverse_complete = False
-        self.distance_checked = 0.
-        axes_d = [self.next_pos[i] - self.prev_pos[i] for i in range(4)]
-        self.total_move_length = math.sqrt(sum([d*d for d in axes_d[:3]]))
-        self.axis_move = [not isclose(d, 0., abs_tol=1e-10) for d in axes_d]
-    def _calc_z_offset(self, pos):
-        z = self.z_mesh.calc_z(pos[0], pos[1])
-        offset = self.fade_offset
-        return self.z_factor * (z - offset) + offset
-    def _set_next_move(self, distance_from_prev):
-        t = distance_from_prev / self.total_move_length
-        if t > 1. or t < 0.:
-            raise self.gcode.error(
-                "bed_mesh: Slice distance is negative "
-                "or greater than entire move length")
-        for i in range(4):
-            if self.axis_move[i]:
-                self.current_pos[i] = lerp(
-                    t, self.prev_pos[i], self.next_pos[i])
-    def split(self):
-        if not self.traverse_complete:
-            if self.axis_move[0] or self.axis_move[1]:
-                # X and/or Y axis move, traverse if necessary
-                while self.distance_checked + self.move_check_distance \
-                        < self.total_move_length:
-                    self.distance_checked += self.move_check_distance
-                    self._set_next_move(self.distance_checked)
-                    next_z = self._calc_z_offset(self.current_pos)
-                    if abs(next_z - self.z_offset) >= self.split_delta_z:
-                        self.z_offset = next_z
-                        return self.current_pos[0], self.current_pos[1], \
-                            self.current_pos[2] + self.z_offset, \
-                            self.current_pos[3]
-            # end of move reached
-            self.current_pos[:] = self.next_pos
-            self.z_offset = self._calc_z_offset(self.current_pos)
-            # Its okay to add Z-Offset to the final move, since it will not be
-            # used again.
-            self.current_pos[2] += self.z_offset
-            self.traverse_complete = True
-            return self.current_pos
-        else:
-            # Traverse complete
-            return None
+
 
 
 class ZMesh:
-    def __init__(self, params):
+    def __init__(self, params,printer):
+        self._info_array = [0.0]*(12+1)
+        self.info_array = np.array(self._info_array, dtype=np.float64)
+        self.info_array_addr_int = self.info_array.ctypes.data
+
+        self.printer = printer
+        self.isenable = True
+        self.info_array[1]=self.isenable
         self.probed_matrix = self.mesh_matrix = None
+        if self.mesh_matrix is None:
+            self.info_array[4]=0
+        else:
+            self.info_array[4]=1
+            self.__mesh_matrix[0:] = self.mesh_matrix
         self.mesh_params = params
+        self.uuid = self.info_array[0]=printer.get_reactor().monotonic()
         self.avg_z = 0.
         self.mesh_offsets = [0., 0.]
-        logging.debug('bed_mesh: probe/mesh parameters:')
+        self.info_array[2:4] = self.mesh_offsets
         for key, value in self.mesh_params.items():
             logging.debug("%s :  %s" % (key, value))
         self.mesh_x_min = params['min_x']
@@ -839,6 +863,10 @@ class ZMesh:
         py_cnt = params['y_count']
         self.mesh_x_count = (px_cnt - 1) * mesh_x_pps + px_cnt
         self.mesh_y_count = (py_cnt - 1) * mesh_y_pps + py_cnt
+
+        self.__mesh_matrix = np.full(self.mesh_y_count * self.mesh_x_count, 0., dtype=np.float64)
+        self.__mesh_matrix_addr = self.__mesh_matrix.ctypes.data
+        self.info_array[12]=self.__mesh_matrix_addr
         self.x_mult = mesh_x_pps + 1
         self.y_mult = mesh_y_pps + 1
         logging.debug("bed_mesh: Mesh grid size - X:%d, Y:%d"
@@ -847,6 +875,19 @@ class ZMesh:
                            (self.mesh_x_count - 1)
         self.mesh_y_dist = (self.mesh_y_max - self.mesh_y_min) / \
                            (self.mesh_y_count - 1)
+        self.gcode = self.printer.lookup_object('gcode')
+        if "BED_MESH_SET_DISABLE" not in self.gcode.ready_gcode_handlers:
+            self.gcode.register_command(
+                'BED_MESH_SET_DISABLE', self.cmd_BED_MESH_SET_DISABLE,
+                desc=self.cmd_BED_MESH_SET_DISABLE_helper)
+        if "BED_MESH_SET_ENABLE" not in self.gcode.ready_gcode_handlers:
+            self.gcode.register_command(
+                'BED_MESH_SET_ENABLE', self.cmd_BED_MESH_SET_ENABLE,
+                desc=self.cmd_BED_MESH_SET_ENABLE_helper)
+        self.info_array[5:11]=[self.mesh_x_min,self.mesh_x_count,self.mesh_x_dist,self.mesh_y_min,self.mesh_y_count,self.mesh_y_dist]
+        self.info_array[11] = 0.0
+        self.last_z_temp_compensation = self.info_array[11]
+        self.z_temp_compensation_callbak=None
     def get_mesh_matrix(self):
         if self.mesh_matrix is not None:
             return [[round(z, 6) for z in line]
@@ -857,6 +898,9 @@ class ZMesh:
             return [[round(z, 6) for z in line]
                     for line in self.probed_matrix]
         return [[]]
+    def update_mesh_probed_matrix(self, probed_matrix):
+        if self.probed_matrix is not None:
+            self.probed_matrix = tuple(map(tuple, probed_matrix))
     def get_mesh_params(self):
         return self.mesh_params
     def print_probed_matrix(self, print_func):
@@ -904,21 +948,45 @@ class ZMesh:
         for i, o in enumerate(offsets):
             if o is not None:
                 self.mesh_offsets[i] = o
+        self.info_array[2:4] = self.mesh_offsets
     def get_x_coordinate(self, index):
         return self.mesh_x_min + self.mesh_x_dist * index
     def get_y_coordinate(self, index):
         return self.mesh_y_min + self.mesh_y_dist * index
+
+    def cmd_BED_MESH_SET_DISABLE(self, gcmd):
+        self.isenable = False
+        self.info_array[1]=self.isenable
+    cmd_BED_MESH_SET_DISABLE_helper = " set  MESH disable"
+    def cmd_BED_MESH_SET_ENABLE(self, gcmd):
+        self.isenable = True
+        self.info_array[1]=self.isenable
+    cmd_BED_MESH_SET_ENABLE_helper = "set  MESH enable "
     def calc_z(self, x, y):
-        if self.mesh_matrix is not None:
-            tbl = self.mesh_matrix
-            tx, xidx = self._get_linear_index(x + self.mesh_offsets[0], 0)
-            ty, yidx = self._get_linear_index(y + self.mesh_offsets[1], 1)
-            z0 = lerp(tx, tbl[yidx][xidx], tbl[yidx][xidx+1])
-            z1 = lerp(tx, tbl[yidx+1][xidx], tbl[yidx+1][xidx+1])
-            return lerp(ty, z0, z1)
+        return mymovie.Py_zmesh_calc_c(x,y,self.info_array_addr_int)
+        if self.isenable:
+            if self.mesh_matrix is not None:
+                tbl = self.mesh_matrix
+                tx, xidx = self._get_linear_index(x + self.mesh_offsets[0], 0)
+                ty, yidx = self._get_linear_index(y + self.mesh_offsets[1], 1)
+                z0 = lerp(tx, tbl[yidx][xidx], tbl[yidx][xidx+1])
+                z1 = lerp(tx, tbl[yidx+1][xidx], tbl[yidx+1][xidx+1])
+                return lerp(ty, z0, z1)
+            else:
+                pass
+                # No mesh table generated, no z-adjustment
+        return 0.
+    def set_z_temp_compensation_callbak(self,ck):
+        self.z_temp_compensation_callbak=ck
+    def set_z_temp_compensation(self):
+        if self.z_temp_compensation_callbak is not None:
+            temp = self.z_temp_compensation_callbak()
         else:
-            # No mesh table generated, no z-adjustment
-            return 0.
+            temp = 0.0
+        if self.last_z_temp_compensation!= temp:
+            self.last_z_temp_compensation = temp
+            self.info_array[11] = self.last_z_temp_compensation
+
     def get_z_range(self):
         if self.mesh_matrix is not None:
             mesh_min = min([min(x) for x in self.mesh_matrix])
@@ -946,6 +1014,11 @@ class ZMesh:
         return constrain(t, 0., 1.), idx
     def _sample_direct(self, z_matrix):
         self.mesh_matrix = z_matrix
+        if self.mesh_matrix is None:
+            self.info_array[4]=0
+        else:
+            self.info_array[4]=1
+            self.__mesh_matrix[0:]=self.mesh_matrix
     def _sample_lagrange(self, z_matrix):
         x_mult = self.x_mult
         y_mult = self.y_mult
@@ -972,6 +1045,11 @@ class ZMesh:
                     continue
                 y = self.get_y_coordinate(j)
                 self.mesh_matrix[j][i] = self._calc_lagrange(ypts, y, i, 1)
+        if self.mesh_matrix is None:
+            self.info_array[4]=0
+        else:
+            self.info_array[4]=1
+            self.__mesh_matrix[0:] = [item for row in self.mesh_matrix for item in row]
     def _get_lagrange_coords(self):
         xpts = []
         ypts = []
@@ -1025,6 +1103,11 @@ class ZMesh:
                     continue
                 pts = self._get_y_ctl_pts(x, y)
                 self.mesh_matrix[y][x] = self._cardinal_spline(pts, c)
+        if self.mesh_matrix is None:
+            self.info_array[4]=0
+        else:
+            self.info_array[4]=1
+            self.__mesh_matrix[0:] = [item for row in self.mesh_matrix for item in row]
     def _get_x_ctl_pts(self, x, y):
         # Fetch control points and t for a X value in the mesh
         x_mult = self.x_mult
@@ -1194,18 +1277,21 @@ class ProfileManager:
             % (prof_name))
     def load_profile(self, prof_name):
         profile = self.profiles.get(prof_name, None)
-        if profile is None:
-            raise self.gcode.error(
-                "bed_mesh: Unknown profile [%s]" % prof_name)
-        probed_matrix = profile['points']
-        mesh_params = profile['mesh_params']
-        z_mesh = ZMesh(mesh_params)
-        try:
-            z_mesh.build_mesh(probed_matrix)
-        except BedMeshError as e:
-            raise self.gcode.error(str(e))
-        self.current_profile = prof_name
-        self.bedmesh.set_mesh(z_mesh)
+        if profile is not None:
+            probed_matrix = profile['points']
+            mesh_params = profile['mesh_params']
+            z_mesh = ZMesh(mesh_params,self.printer)
+            try:
+                z_mesh.build_mesh(probed_matrix)
+            except BedMeshError as e:
+                raise self.gcode.error(str(e))
+            self.current_profile = prof_name
+            self.bedmesh.set_mesh(z_mesh)
+        else:
+            self.gcode.respond_info("bed_mesh: Unknown profile [%s]" % (prof_name,))
+            # raise self.gcode.error(
+            #     "bed_mesh: Unknown profile [%s]" % prof_name)
+
     def remove_profile(self, prof_name):
         if prof_name in self.profiles:
             configfile = self.printer.lookup_object('configfile')
--- /dev/null
+++ b/klippy/extras/belt_mdl.py
@@ -0,0 +1,621 @@
+# Support for Automatic belt tensioning module
+#
+# Copyright 
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+
+import numpy as np
+from .box_wrapper import BoxAction
+
+class COM:
+    def __init__(self):
+        self.head = 0xf7     #帧头
+        self.addr = 0x21     #设备地址
+        self.len  = 3        #数据长度
+        self.star = 0x00	 #状态码
+        self.fun  = 0x00     #功能码
+        self.data = []       #数据
+        self.crc  = 0xff     #校验位
+        pass
+
+class STA:
+    def __init__(self):
+        self.read_version_cmd = 0      #读模块固件版本指令
+        self.read_version_resp = 0     #读模块固件版本回复
+        self.read_flash_cmd = 2        #读保存在flash里的变量指令
+        self.read_flash_resp = 2       #读保存在flash里的变量回复
+        self.write_flash_cmd = 4       #写保存在flash里的变量指令
+        self.write_flash_resp = 4      #写保存在flash里的变量回复
+        self.read_adc_cmd = 6          #读当前应变片ADC值指令
+        self.read_adc_resp = 6         #读当前应变片ADC值回复
+        self.move_slider_cmd = 8       #让滑块移动的距离指令
+        self.move_slider_resp = 8      #让滑块移动的距离回复
+        pass
+
+
+def split_to_bytes(data):   #一个32位数据转化为4个8位数据
+    # 确保输入为32位无符号整型
+    data = data & 0xFFFFFFFF
+    return [((data >> (8 * i)) & 0xFF) for i in range(4)][::-1]
+
+def bytes_to_int(byte_array):    #4个8位数据转化为一个32位数据
+    # 确保字节数据长度为4
+    assert len(byte_array) == 4
+    result = 0
+    for i, byte in enumerate(byte_array):
+        # 将字节左移相应的位数，并与结果进行按位或操作
+        result |= (byte & 0xFF) << (8 * (3 - i))
+    # 返回合并后的32位整数
+    return result    
+
+
+
+
+class MDL:
+    def __init__(self, val):
+        self.value = val             #序号
+        # self.name = None           #传感器名称
+        self.softversion = 0         #传感器固件版本*
+        self.halversion = 0          #传感器硬件版本*
+        self.current_status = 0      #模块当前状态标志
+        self.total_place = 0         #滑块可以运动的总行程，单位 1um
+        self.total_tension = 0       #应变片的总量程，单位 0.01N
+        self.idl_adc = 0xffffffff            #应变片校准拉力值1时的 ADC 值
+        self.full_adc = 0xffffffff           #应变片校准拉力值2时的 ADC 值
+        self.current_place_adc = 0xffffffff  #滑块当前应变片的 ADC 值*
+        self.current_place = 0x0000          #当前滑块位置，单位 1um*
+        self.current_tension = 0             #应变片当前所受拉/推力，单位 1N
+        self.target_place = 0                #滑块期望位置
+        self.target_move = 0             #滑块移动距离
+        self.target_tension = 0          #应变片期望受力
+        self.target_error = 0            #应变片正常受力范围值
+        self.error_result = 0            #应变片受力结果
+        self.tension_correction_dir = 0  #应变片校准方向
+        self.uart_pin = None             #串口通信引脚
+        self.convert = False             #是否更新数据
+        self.read_flash = False          #是否获取flash值
+        self.slope = 0                   #数据拟合参数:斜率
+        self.intercept = 0               #数据拟合参数:截距
+        self.mistake = 0.02              #自动张紧控制误差范围 
+        self.adjustnum1 = 140            #校准拉力值1
+        self.adjustnum2 = 160            #校准拉力值2
+        pass
+
+class BELT_MDL:
+    def __init__(self, config):
+        self.config = config
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object("gcode")
+
+        name_parts = config.get_name().split()
+        self.base_name = name_parts[0]
+        self.name = name_parts[-1]
+
+        self.mdl = {}
+        self.mdl = MDL(self)
+        self.com = {}
+        self.com = COM()
+        self.sta = {}
+        self.sta = STA()
+        
+        self.mdl.total_place = config.getint('ch_max_dis', default=5, minval=0, maxval=10)
+        self.mdl.target_tension = config.getint('ch_best_n', default=140, minval=0, maxval=300)
+        self.mdl.target_error = config.getfloat('ch_best_error', default=0.05, minval=0.001, maxval=1)
+
+        self._serial = self.printer.lookup_object("serial_485 " + "serial485")
+        
+        
+        self.gcode.register_mux_command("BELT_MDL_INFO", "MDL_NAME", self.name,            #获取给定模块的详细参数，所有寄存器的值。
+                                   self.cmd_BELT_MDL_INFO,desc=self.cmd_BELT_MDL_INFO_help)
+        self.gcode.register_mux_command("BELT_MDL_MOVE", "MDL_NAME", self.name,            #设置模块滑块的位置
+                                   self.cmd_BELT_MDL_MOVE,desc=self.cmd_BELT_MDL_MOVE_help)
+        self.gcode.register_mux_command("BELT_MDL_SET", "MDL_NAME", self.name,             #设定模块推/拉力值
+                                   self.cmd_BELT_MDL_SET,desc=self.cmd_BELT_MDL_SET_help)
+        self.gcode.register_mux_command("BELT_MDL_CALI", "MDL_NAME", self.name,            #主要是未安装皮带着，对行程和压力进行校正
+                                   self.cmd_BELT_MDL_CALI,desc=self.cmd_BELT_MDL_CALI_help)
+        self.gcode.register_mux_command("BELT_MDL_TEST", "MDL_NAME", self.name,            #用于检测皮带张紧力是否处于正常的范围
+                                   self.cmd_BELT_MDL_TEST,desc=self.cmd_BELT_MDL_TEST_help)
+        
+        self.webhooks = self.printer.lookup_object('webhooks')
+        self.webhooks.register_mux_endpoint("belt_mdl_test", "MDL_NAME", self.name,
+                                 self._belt_mdl_test)
+        pass
+
+
+    def get_mdl_data(self):   #用于检测当前的皮带张紧力是否在正常的范围内
+        self.config_addr()   
+        self.mdl_info_cmd()
+        self.error_result = 1
+        target_max = self.mdl.target_tension*(1+self.mdl.target_error)
+        target_min = self.mdl.target_tension*(1-self.mdl.target_error)
+        if((self.mdl.current_tension>target_min)&(self.mdl.current_tension<target_max)):
+            self.error_result = 0
+        self.gcode.respond_info("MDL_NAME: %s"%(self.name,))
+        result = {'current_tension': self.mdl.current_tension, 'target_error': self.error_result}
+        return result
+
+    cmd_BELT_MDL_TEST_help = "BELT_MDL_TEST."
+    def cmd_BELT_MDL_TEST(self, gcmd):
+        self.gcode.respond_info("get_mdl_data: %s" % (self.get_mdl_data()))
+        pass
+
+    def _belt_mdl_test(self, web_request):
+        web_request.send(self.get_mdl_data())
+        pass
+
+
+    def mdl_info_cmd(self):
+        self.gcode.respond_info("ACK_mdl_info")
+        self.Get_version()
+        self.get_flash_data()
+        self.init_adc_to_num()
+        self.get_adc()
+        self.adc_to_num(self.mdl.current_place_adc)
+
+        # reactor = self.printer.get_reactor()
+        # self.gcode.respond_info("reactor: %s"%(reactor,))
+        # self.gcode.respond_info("reactor1: %s"%(reactor.monotonic(),))
+        # reactor.pause(reactor.monotonic() + 10.0)
+        # self.gcode.respond_info("reactor2: %s"%(reactor,))
+        # self.gcode.respond_info("reactor3: %s"%(reactor.monotonic(),))
+        # self.get_flash_data()
+        # self.init_adc_to_num()
+        # self.get_adc()
+        # self.adc_to_num(self.mdl.current_place_adc)
+        # self.mdl_info.send([self.oid])
+        # self.Get_version()
+        # self.get_flash_data()
+        # self.get_adc()
+        # self.set_move(1,0x11223344)
+        # self.write_flash()
+        # mdl_info_buf = self.mdl_info.send([self.oid])
+        # self.gcode.respond_info("ACK_mdl_info: %s"%str(mdl_info_buf))
+        pass
+
+    def set_place(self):         #设置滑块绝对位置
+        self.gcode.respond_info("ACK_mdl_pos")
+        if((self.mdl.current_place==0xffffffff)):
+            if self.name == 'mdlx':
+                raise self.printer.command_error("""{"code":"key714", "msg":"Belt tension module strain gauge not calibrated abnormal: '%s' set_place_error", "values": []}"""% (self.name))
+            if self.name == 'mdly':
+                raise self.printer.command_error("""{"code":"key715", "msg":"Belt tension module strain gauge not calibrated abnormal: '%s' set_place_error", "values": []}"""% (self.name))
+        self.target_move = self.target_place - self.mdl.current_place
+        self.mdl.current_place = self.target_place
+        movedir = 1 if self.target_move>0 else 0
+        movenum = abs(self.target_move)
+        self.set_move(movedir,movenum)
+        self.write_flash()
+        # mdl_pos_buf = self.mdl_pos.send([self.oid, 0])
+        # self.gcode.respond_info("ACK_mdl_pos: %s"%str(mdl_pos_buf))
+        pass
+
+
+    def run_tension(self):    
+        movetimes = 0
+        while(1):
+            movetimes += 1 
+            self.gcode.respond_info("times:%s"%movetimes)
+            if(movetimes > 200):                                      #调节次数超过200次，说明丝杆严重非线性导致调节失败，抛出异常
+                return 0
+            aimpull = self.target_tension - self.mdl.current_tension   #获得拉力期望差距值
+            aimpull = abs(aimpull)                                     #取绝对值
+            aimpull = 10 if aimpull > 10 else aimpull                  #限幅
+            aimmove = int(aimpull) + 2                                 #非线性算法，使得差距大时运动行程大，差距小时运动行程小
+            if(aimmove > movetimes):                                   #位移行程随调节次数衰减，避免丝杆非线性导致的震荡，强行收敛
+                aimmove = aimmove - movetimes                          #根据调节次数强行衰减位移量，提高精度
+            elif(movetimes > 110):                                      #前80次不能调整成功，说明出现丝杆严重非线性导致的震荡
+                aimmove = 1                                            #以最小步数进行微调，以抵抗非线性带来的震荡，提高精度
+            elif(movetimes > 70):                                      #前50次不能调整成功，说明出现丝杆非线性导致的震荡  
+                aimmove = 2                                            #此处的aimmove是调节步长，步长越小，调节越精确，但调节次数越多时间越长
+            elif(movetimes > 50):                                      #前30次不能调整成功，说明出现丝杆非线性导致的震荡
+                aimmove = 3                                            #每种步长的调节总长度都要比前一种步长的调节总长度大，以保证覆盖调节范围
+            elif(movetimes > 40):                                      #前20次不能调整成功，说明出现丝杆非线性导致的震荡
+                aimmove = 4                                            #以小步数进行微调，以抵抗非线性带来的震荡，提高精度
+            elif(movetimes > 20):                                      #多测一轮线性降低行程，提高调节概率，增加行程
+                if(aimmove > (movetimes-20)):                          
+                    aimmove = aimmove + 20 - movetimes 
+            if(self.target_tension*(1+self.mdl.mistake) <  self.mdl.current_tension):
+                # self.set_move(0,aimmove)
+                # self.mdl.current_place = self.mdl.current_place - aimmove
+                self.get_adc()
+                self.adc_to_num(self.mdl.current_place_adc)
+                return 1
+            elif(self.target_tension*(1-self.mdl.mistake) >  self.mdl.current_tension):
+                self.set_move(1,aimmove)
+                self.mdl.current_place = self.mdl.current_place + aimmove
+                self.get_adc()
+                self.adc_to_num(self.mdl.current_place_adc)
+            else:
+                return 1    
+    
+    def set_tension(self):
+        self.init_adc_to_num()
+        self.get_adc()
+        self.adc_to_num(self.mdl.current_place_adc)
+        for i in range(2):
+            self.run_tension()
+            self.gcode.run_script_from_command("RESET_HOME_AXES_XY")
+            self.gcode.run_script_from_command("MOTOR_CONTROL NUM=1 DATA=2")  
+            self.gcode.run_script_from_command("MOTOR_CONTROL NUM=2 DATA=2")
+            self.printer.get_reactor().pause(self.printer.get_reactor().monotonic() + 0.3)
+            self.gcode.run_script_from_command("FORCE_MOVE STEPPER=stepper_x DISTANCE=-200 VELOCITY=60")
+            self.gcode.run_script_from_command("FORCE_MOVE STEPPER=stepper_y DISTANCE=200 VELOCITY=60")
+            self.gcode.run_script_from_command("M400")
+            self.gcode.run_script_from_command("FORCE_MOVE STEPPER=stepper_x DISTANCE=200 VELOCITY=60")
+            self.gcode.run_script_from_command("FORCE_MOVE STEPPER=stepper_y DISTANCE=-200 VELOCITY=60")
+            self.gcode.run_script_from_command("M400")
+            self.gcode.run_script_from_command("MOTOR_CONTROL NUM=1 DATA=1")
+            self.gcode.run_script_from_command("MOTOR_CONTROL NUM=2 DATA=1")
+            self.gcode.run_script_from_command("M84")
+        run_result = self.run_tension()
+        if(run_result == 0):
+            if self.name == 'mdlx':
+                raise self.printer.command_error("""{"code":"key718", "msg":"Belt tensioning timeout: '%s'", "values": []}"""% (self.name))
+            if self.name == 'mdly':
+                raise self.printer.command_error("""{"code":"key719", "msg":"Belt tensioning timeout: '%s'", "values": []}"""% (self.name))
+        self.write_flash()
+        pass
+
+    def set_tension_correction(self):
+        if(self.tension_correction_dir==0):
+            self.mdl.current_place = 0 
+            self.write_flash()
+        elif(self.tension_correction_dir==1):
+            self.mdl.adjustnum1 = self.tension_correction_ten
+            self.get_adc()
+            self.mdl.idl_adc = self.mdl.current_place_adc
+            self.write_flash()
+        elif(self.tension_correction_dir==2):
+            self.mdl.adjustnum2 = self.tension_correction_ten
+            self.get_adc()
+            self.mdl.full_adc = self.mdl.current_place_adc
+            self.write_flash()
+        
+            # self.get_flash_data()
+        
+        # mdl_init_buf = self.mdl_init.send([self.oid, self.tension_correction_dir])
+        # self.gcode.respond_info("ACK_mdl_init: %s"%str(mdl_init_buf))
+        pass
+
+    cmd_BELT_MDL_INFO_help = "obtain detailed parameters for the given module"
+    def cmd_BELT_MDL_INFO(self, gcmd):  
+        self.config_addr()   
+        self.mdl_info_cmd()
+        self.gcode.respond_info("MDL_NAME: %s"%(self.name,))
+        pass
+    
+    cmd_BELT_MDL_MOVE_help = "set the position of the module slider."
+    def cmd_BELT_MDL_MOVE(self, gcmd):
+        self.config_addr() 
+        self.target_place= gcmd.get_int('POS', 0)
+        self.set_place()
+        self.gcode.respond_info("MDL_NAME: %s"%(self.name,))
+        pass
+
+    cmd_BELT_MDL_SET_help = "set the module tension value."
+    def cmd_BELT_MDL_SET(self, gcmd):
+        self.config_addr() 
+        self.target_tension= gcmd.get_int('MDL_N', 140.0)
+        self.set_tension()
+        self.gcode.respond_info("MDL_NAME: %s"%(self.name,))
+        pass
+
+    cmd_BELT_MDL_CALI_help = "calibrate stroke and pressure."
+    def cmd_BELT_MDL_CALI(self, gcmd):
+        self.config_addr() 
+        self.tension_correction_dir= gcmd.get_int('DIR', 0)
+        self.tension_correction_ten= gcmd.get_int('TEN', None)
+        self.set_tension_correction()
+        self.gcode.respond_info("MDL_NAME: %s"%(self.name,))
+        pass
+
+    def Get_version(self):                   #获取版本号
+        sendbuf = self.send_sensor_data(self.sta.read_version_cmd,[])
+        # self.gcode.respond_info("sendbuf: %s"%sendbuf)
+        uartbuf = self.send_data(sendbuf) 
+        # self.gcode.respond_info("resetbuf: %s"%uartbuf)
+        redata = self.recv_sensor_data(uartbuf)
+        if(redata[0] == 0):
+            self.gcode.respond_info("reset:start error")
+            return redata
+        if(redata[1] != self.sta.read_version_resp):   #校验功能码
+            self.gcode.respond_info("reset:comfun error")
+            redata = 0,-5,0
+            return redata
+        if(redata[1] == self.sta.read_version_resp):   #功能码正常
+            self.mdl.halversion  = redata[2][:2]    #硬件版本号
+            self.mdl.softversion = redata[2][2:]    #软件版本号
+            self.gcode.respond_info("halversion:%s"%self.mdl.halversion)
+            self.gcode.respond_info("softversion:%s"%self.mdl.softversion)
+        pass
+
+    def Get_flash(self,flash_num):                   #获取flash信息
+        sendbuf = self.send_sensor_data(self.sta.read_flash_cmd,[flash_num])
+        # self.gcode.respond_info("sendbuf: %s"%sendbuf)
+        uartbuf = self.send_data(sendbuf)
+        # self.gcode.respond_info("resetbuf: %s"%uartbuf)
+        redata = self.recv_sensor_data(uartbuf)
+        if(redata[0] == 0):
+            self.gcode.respond_info("reset:start error")
+            return redata
+        if(redata[1] != self.sta.read_flash_resp):   #校验功能码
+            self.gcode.respond_info("reset:comfun error")
+            redata = 0,-5,0
+            return redata
+        if(redata[1] == self.sta.read_flash_resp):   #功能码正常
+            # print("redata",redata)
+            return redata
+        pass
+
+    def get_flash_data(self):                 
+        flash_buf = self.Get_flash(3)
+        # self.gcode.respond_info("flash_data:%s"%flash_buf[2])
+        if(flash_buf[0] == 0):   #数据异常
+            return None
+        if(flash_buf[0] == 1):
+            flash_data_num = flash_buf[2][0]  #获取数据长度
+            flash_data0 = flash_buf[2][1:5]   #获取数据4位一组
+            flash_data1 = flash_buf[2][5:9]
+            flash_data2 = flash_buf[2][9:13]
+            flash_data_num0 = bytes_to_int(flash_data0)   #把4位一组的数据转换为32位的数值
+            flash_data_num1 = bytes_to_int(flash_data1)
+            flash_data_num2 = bytes_to_int(flash_data2)
+            self.mdl.current_place = flash_data_num0       #当前滑块位置，单位 0.01mm*
+            self.mdl.idl_adc = flash_data_num1             #应变片空载时的 ADC 值，即 去皮/归零*
+            self.mdl.full_adc = flash_data_num2            #应变片满载时的 ADC 值，即 最大负载*
+            self.gcode.respond_info("current_place:%s"%self.mdl.current_place)
+            self.gcode.respond_info("idl_adc:%s"%self.mdl.idl_adc)
+            self.gcode.respond_info("full_adc:%s"%self.mdl.full_adc)
+            if((self.mdl.current_place==0xffffffff)|(self.mdl.idl_adc==0xffffffff)|(self.mdl.full_adc==0xffffffff)):
+                if self.name == 'mdlx':
+                    raise self.printer.command_error("""{"code":"key714", "msg":"Belt tension module strain gauge not calibrated abnormal: '%s'", "values": []}"""% (self.name))
+                if self.name == 'mdly':
+                    raise self.printer.command_error("""{"code":"key715", "msg":"Belt tension module strain gauge not calibrated abnormal: '%s'", "values": []}"""% (self.name))
+        pass
+
+    def write_flash_buf(self,flash_num,flash_data):   #写入flash信息，写入数据数量+数据内容
+        flash_data_buf = [flash_num]
+        flash_data_buf.extend(flash_data)
+        sendbuf = self.send_sensor_data(self.sta.write_flash_cmd,flash_data_buf)
+        # self.gcode.respond_info("sendbuf: %s"%sendbuf)
+        uartbuf = self.send_data(sendbuf)
+        # self.gcode.respond_info("resetbuf: %s"%uartbuf)
+        redata = self.recv_sensor_data(uartbuf)
+        if(redata[0] == 0):
+            self.gcode.respond_info("reset:start error")
+            return redata
+        if(redata[1] != self.sta.write_flash_resp):    #校验功能码
+            self.gcode.respond_info("reset:comfun error")
+            redata = 0,-5,0
+            return redata
+        if(redata[1] == self.sta.write_flash_resp):    #功能码正常
+            # print("redata",redata)
+            return redata
+        pass   
+
+    def write_flash(self):               #写入flash信息
+        data0 = self.mdl.current_place       #当前滑块位置，单位 0.01mm*
+        data1 = self.mdl.idl_adc             #应变片空载时的 ADC 值，即 去皮/归零*
+        data2 = self.mdl.full_adc            #应变片满载时的 ADC 值，即 最大负载*
+        buf_data0 = split_to_bytes(data0)   #把32位的数值转换成4个8位的数据
+        buf_data1 = split_to_bytes(data1)   
+        buf_data2 = split_to_bytes(data2)
+        data_buf = buf_data0                #把数据合成一个列表
+        data_buf.extend(buf_data1)
+        data_buf.extend(buf_data2)
+        flash_buf = self.write_flash_buf(3,data_buf)   #发送3个数据
+        self.gcode.respond_info("flash_data:%s"%flash_buf[2])
+        if(flash_buf[0] == 0):    #校验返回的数据是否正常
+            return None
+        if(flash_buf[0] == 1):
+            flash_data_num = flash_buf[2][0]   #数据长度
+            flash_data0 = flash_buf[2][1:5]    #数据内容
+            flash_data1 = flash_buf[2][5:9]
+            flash_data2 = flash_buf[2][9:13]
+            flash_data_num0 = bytes_to_int(flash_data0)     #把数据由4个8位数据转换位32位数值
+            flash_data_num1 = bytes_to_int(flash_data1)
+            flash_data_num2 = bytes_to_int(flash_data2)
+            if((self.mdl.current_place == flash_data_num0)|(self.mdl.idl_adc == flash_data_num1)|(self.mdl.full_adc == flash_data_num2)): 
+                return 1     #flash写入成功，写读数据一致
+            else:
+                return -1    #flash写入失败，写读数据不一致
+        pass 
+
+    def get_adc_buf(self):                       #获取ADC数据
+        sendbuf = self.send_sensor_data(self.sta.read_adc_cmd,[])         
+        # self.gcode.respond_info("sendbuf: %s"%sendbuf)
+        uartbuf = self.send_data(sendbuf)
+        # self.gcode.respond_info("resetbuf: %s"%uartbuf)
+        redata = self.recv_sensor_data(uartbuf)
+        if(redata[0] == 0):
+            self.gcode.respond_info("reset:start error")
+            return redata
+        if(redata[1] != self.sta.read_adc_resp):     #校验功能码
+            self.gcode.respond_info("reset:comfun error")
+            redata = 0,-5,0
+            return redata
+        if(redata[1] == self.sta.read_adc_resp):     #功能码正常
+            # self.gcode.respond_info("redata:%s"%redata[2])
+            return redata
+        pass 
+
+    def get_adc(self):                       #获取ADC值
+        adc_buf = self.get_adc_buf()
+        self.gcode.respond_info("adc_buf:%s"%adc_buf[2])
+        if(adc_buf[0] == 0):   #校验返回的数据是否正常
+            return None 
+        if(adc_buf[0]==1):
+            adc_num = bytes_to_int(adc_buf[2])
+            self.mdl.current_place_adc = adc_num   #滑块当前位置应变片的 ADC 值*
+            self.gcode.respond_info("adc_num:%s"%adc_num)
+            return adc_num
+        pass 
+
+    def set_move_buf(self,dir,rang_buf):                   #滑块移动，传入方向+数据
+        set_move_buf = [dir]
+        set_move_buf.extend(rang_buf)
+        sendbuf = self.send_sensor_data(self.sta.move_slider_cmd,set_move_buf)
+        # self.gcode.respond_info("sendbuf: %s"%sendbuf)
+        uartbuf = self.send_data(sendbuf)
+        # self.gcode.respond_info("resetbuf: %s"%uartbuf)
+        redata = self.recv_sensor_data(uartbuf)
+        if(redata[0] == 0):
+            self.gcode.respond_info("reset:start error")
+            return redata
+        if(redata[1] != self.sta.move_slider_resp):     #校验功能码
+            self.gcode.respond_info("reset:comfun error")
+            redata = 0,-5,0 
+            return redata
+        if(redata[1] == self.sta.move_slider_resp):
+            # print("redata",redata)
+            return redata
+        pass 
+    
+    def set_move(self,dir,rang_num):           #滑块移动 传入方向+数值
+        if((rang_num >= 0)&(rang_num < 0xffff)):
+            rang_buf = []
+            rang_buf = split_to_bytes(rang_num)    #把32位数值转换为4个8位的数据
+            move_buf = self.set_move_buf(dir,rang_buf)
+            delaytime = rang_num * 0.0132
+            # delaytime = int(delaytime)
+            reactor = self.printer.get_reactor()
+            reactor.pause(reactor.monotonic() + delaytime)
+            self.gcode.respond_info("move_buf:%s"%move_buf[2])
+            if(move_buf[0] == 0):   #校验返回的数据是否正常
+                return None 
+            if(move_buf[0]==1):
+                move_num_buf = move_buf[2][1:]
+                move_num = bytes_to_int(move_num_buf)
+                self.gcode.respond_info("move_num:%s"%move_num)
+                self.gcode.respond_info("current_place:%s"%self.mdl.current_place)
+                return move_num
+        else:
+            self.gcode.respond_info("move_num error:%s"%move_num)
+        pass 
+
+    def init_adc_to_num(self):    #根据现有的参数对adc和拉力做数据拟合
+        if((self.mdl.current_place==0xffffffff)|(self.mdl.idl_adc==0xffffffff)|(self.mdl.full_adc==0xffffffff)):
+            if self.name == 'mdlx':
+                raise self.printer.command_error("""{"code":"key714", "msg":"Belt tension module strain gauge not calibrated abnormal: '%s'adc_to_num_error", "values": []}"""% (self.name))
+            if self.name == 'mdly':
+                raise self.printer.command_error("""{"code":"key715", "msg":"Belt tension module strain gauge not calibrated abnormal: '%s'adc_to_num_error", "values": []}"""% (self.name))
+        if((self.mdl.idl_adc==0x00000000)|(self.mdl.full_adc==0x00000000)):
+            if self.name == 'mdlx':
+                raise self.printer.command_error("""{"code":"key720", "msg":"The calibration value of the strain gauge is zero: '%s'calibration_num_error", "values": []}"""% (self.name))
+            if self.name == 'mdly':
+                raise self.printer.command_error("""{"code":"key721", "msg":"The calibration value of the strain gauge is zero: '%s'calibration_num_error", "values": []}"""% (self.name))
+        # adc_difference = abs(self.mdl.idl_adc-self.mdl.full_adc)
+        # if(adc_difference<30000):
+        #     if self.name == 'mdlx':
+        #         raise self.printer.command_error("""{"code":"key720", "msg":"The calibration value of the strain gauge is too small: '%s'calibration_num_error", "values": []}"""% (self.name))
+        #     if self.name == 'mdly':
+        #         raise self.printer.command_error("""{"code":"key721", "msg":"The calibration value of the strain gauge is too small: '%s'calibration_num_error", "values": []}"""% (self.name))
+        xd = [self.mdl.idl_adc,self.mdl.full_adc]
+        yd = [self.mdl.adjustnum1,self.mdl.adjustnum2]
+        xn = np.array(xd)
+        yn = np.array(yd)
+        # 使用numpy的polyfit函数进行线性拟合
+        # polyfit的第三个参数是多项式的度数，这里设置为1表示线性拟合
+        coefficients = np.polyfit(xn, yn, 1)
+        slope, intercept = coefficients
+        self.mdl.slope = slope
+        self.mdl.intercept = intercept
+        self.gcode.respond_info("slope:%s"%slope)
+        self.gcode.respond_info("intercept:%s"%intercept)
+        pass
+
+    def adc_to_num(self,adc_data):     #在完成初始化后，输入adc值返回对应的拉力
+        if((self.mdl.slope == 0)&(self.mdl.intercept == 0)):
+            return None   #error ADC parameters must be initialized first
+        adc_num = adc_data * self.mdl.slope + self.mdl.intercept
+        self.mdl.current_tension = adc_num
+        self.gcode.respond_info("pull_num:%s"%adc_num)
+        if((adc_num>600)|(adc_num<-300)):     #张紧力大于600，小于-300时，张紧力过于异常，报错
+            if self.name == 'mdlx':
+                raise self.printer.command_error("""{"code":"key716", "msg":"Abnormal belt tension: '%s' pull_num_error", "values": []}"""% (self.name))
+            if self.name == 'mdly':
+                raise self.printer.command_error("""{"code":"key717", "msg":"Abnormal belt tension: '%s' pull_num_error", "values": []}"""% (self.name))
+        return adc_num
+        pass
+    
+    def config_addr(self):
+        self.com.addr = 0x22 if self.name == 'mdly' else 0x21
+        pass
+
+        
+
+    def send_sensor_data(self,sen_fun,sen_data):   #组包485协议数据包 ，传入两个参数1：功能码，2：需要发送的数据
+        # com = COM()
+        self.com.len  = len(sen_data)+3
+        self.com.data = sen_data
+        self.com.fun  = sen_fun
+        self.com.crc  = 0
+        combuf = []
+        combuf.append(self.com.head)    #数据头
+        combuf.append(self.com.addr)    #数据地址
+        combuf.append(self.com.len)     #数据长度
+        combuf.append(self.com.star)    #状态码
+        combuf.append(self.com.fun)     #功能码
+        combuf.extend(self.com.data)    #需要发送的数据
+        combuf.append(self.com.crc)     #crc校验
+        return combuf
+        pass
+
+    def recv_sensor_data(self,rec_data):    #接收数据解码函数
+        # com = COM()
+        if(rec_data == None):          #判断接收数据是否为空
+            self.gcode.respond_info("reset:resetbuf is None")
+            if self.name == 'mdlx':
+                raise self.printer.command_error("""{"code":"key712", "msg":"Communication abnormality of belt automatic tensioning module 485: '%s'", "values": []}"""% (self.name))
+            if self.name == 'mdly':
+                raise self.printer.command_error("""{"code":"key713", "msg":"Communication abnormality of belt automatic tensioning module 485: '%s'", "values": []}"""% (self.name))
+            #通信数据为空，异常报错，结束当前指令，提示异常模块
+            return 0,-1,0
+        if(len(rec_data)<3):           #判断数据长度是否正常
+            self.gcode.respond_info("reset: <3")
+            return 0,-2,0
+        if(rec_data[0] != self.com.head):   #判断数据头是否正常
+            self.gcode.respond_info("reset: head error")
+            return 0,-3,0
+        if(rec_data[1] != self.com.addr):   #判断数据地址是否正常
+            self.gcode.respond_info("reset: head error")
+            return 0,-4,0
+        leng = rec_data[2]             #获取数据长度
+        # print("leng",leng)
+        sen_fun = rec_data[4]          #获取功能码
+        sen_data = rec_data[5:leng-3+5]  #获取接收的数据
+        return 1,sen_fun,sen_data      #返回的数据[0]0为异常1为正常，[1]负数为异常值，正数为功能码，[2]数据
+        pass
+
+    def send_data(self,hex_data):
+        hexsendbuf = hex_data[1:-1]
+        readbuf = self._serial.cmd_send_data_with_response(hexsendbuf, 1)
+        return readbuf
+
+    def get_status(self, eventime):
+        return dict(tension=self.mdl.current_tension)
+
+def load_config(config):      #一个模块的初始化入口
+    prt = BELT_MDL(config)
+    # config.get_printer().add_object('probe', probe.PrinterProbe(config, prt))
+    return prt
+
+def load_config_prefix(config):    #多个模块的初始化入口
+    prt = BELT_MDL(config)
+    # config.get_printer().add_object('probe', probe.PrinterProbe(config, prt))
+    return prt
+
+
+
+
+ 
+
+
+
+
+
+
+
+
+
+
--- /dev/null
+++ b/klippy/extras/bl24c16f.py
@@ -0,0 +1,301 @@
+# Support for i2c based temperature sensors
+#
+# Copyright (C) 2020  Eric Callahan <arksine.code@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging
+import struct
+from . import bus
+
+BL24C16F_CHIP_ADDR_0 = 0x50
+BL24C16F_CHIP_ADDR_1 = 0x51
+BL24C16F_CHIP_ADDR_2 = 0x52
+BL24C16F_CHIP_ADDR_3 = 0x53
+BL24C16F_CHIP_ADDR_4 = 0x54
+BL24C16F_CHIP_ADDR_5 = 0x55
+BL24C16F_CHIP_ADDR_6 = 0x56
+BL24C16F_CHIP_ADDR_7 = 0x57
+
+class EEPROMCommandHelper:
+    def __init__(self, config, chip):
+        self.printer = config.get_printer()
+        self.chip = chip
+        name_parts = config.get_name().split()
+        self.base_name = name_parts[0]
+        self.name = name_parts[-1]
+        self.register_commands(self.name)
+        if len(name_parts) == 1:
+            if self.name == "bl24c16f" or not config.has_section("bl24c16f"):
+                self.register_commands(None)
+
+    def register_commands(self, name):
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_mux_command("EEPROM_DEBUG_READ", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_READ,
+                                   desc=self.cmd_EEPROM_DEBUG_READ_help)
+        gcode.register_mux_command("EEPROM_DEBUG_WRITE_BYTE", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_WRITE_BYTE,
+                                   desc=self.cmd_EEPROM_DEBUG_WRITE_BYTE_help)
+        gcode.register_mux_command("EEPROM_DEBUG_WRITE_INT", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_WRITE_INT,
+                                   desc=self.cmd_EEPROM_DEBUG_WRITE_INT_help)
+        gcode.register_mux_command("EEPROM_DEBUG_WRITE_FLOAT", "CHIP", name,
+                                   self.cmd_EEPROM_DEBUG_WRITE_FLOAT,
+                                   desc=self.cmd_EEPROM_DEBUG_WRITE_FLOAT_help)
+        
+        gcode.register_mux_command("EEPROM_READ", "CHIP", name,
+                                   self.cmd_EEPROM_READ,
+                                   desc=self.cmd_EEPROM_READ_help)
+        gcode.register_mux_command("EEPROM_WRITE_BYTE", "CHIP", name,
+                                   self.cmd_EEPROM_WRITE_BYTE,
+                                   desc=self.cmd_EEPROM_WRITE_BYTE_help)
+        gcode.register_mux_command("EEPROM_WRITE_INT", "CHIP", name,
+                                   self.cmd_EEPROM_WRITE_INT,
+                                   desc=self.cmd_EEPROM_WRITE_INT_help)
+        gcode.register_mux_command("EEPROM_WRITE_FLOAT", "CHIP", name,
+                                   self.cmd_EEPROM_WRITE_FLOAT,
+                                   desc=self.cmd_EEPROM_WRITE_FLOAT_help)
+        
+        gcode.register_mux_command("EEPROM_IS_FIRST_USED", "CHIP", name,
+                                   self.cmd_EEPROM_IS_FIRST_USED)
+        gcode.register_mux_command("EEPROM_POS", "CHIP", name,
+                                   self.cmd_EEPROM_POS)
+        gcode.register_mux_command("EEPROM_PRINTER_INFO", "CHIP", name,
+                                   self.cmd_EEPROM_PRINTER_INFO)
+
+    def cmd_EEPROM_IS_FIRST_USED(self, gcmd):
+        val = self.chip.read_reg(1, 1)
+        state = False if int.from_bytes(val, 'little') != 255 else True
+        gcmd.respond_info("EEPROM_IS_USED val:%s state:%s" % (int.from_bytes(val, 'little'), state))
+        if int.from_bytes(val, 'little') != 255:
+            return False
+        else:
+            return True
+    
+    def cmd_EEPROM_POS(self, gcmd):
+        pos = self.chip.read_reg(0, 1)
+        gcmd.respond_info("EEPROM_POS int_pos:%s, pos:%s" % (int.from_bytes(pos, 'little'), pos))
+        
+    def cmd_EEPROM_PRINTER_INFO(self, gcmd):
+        pos = int.from_bytes(self.chip.read_reg(0, 1), 'little')
+        file_position = self.chip.read_reg(pos*8, 4)
+        base_position_e = self.chip.read_reg(pos*8+4, 4)
+        ret =  {"file_position": int.from_bytes(file_position, 'little'), "base_position_e": struct.unpack('f', base_position_e)[0]}
+        gcmd.respond_info("EEPROM_PRINTER_INFO ret:%s" % str(ret))
+
+    def cmd_EEPROM_DEBUG_READ(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        size = gcmd.get("SIZE", minval=0, maxval=56, parser=lambda x: int(x, 0))
+        vals = self.chip.read_reg(addr, size)
+        gcmd.respond_info("EEPROM_DEBUG_READ size: 0x%x" % size)
+        reg_vals = 'read vals: '
+        for i in range(size):
+            if i % 16 == 0:
+                reg_vals += '\n'
+            reg_vals += '0x%x ' % vals[i]
+
+        gcmd.respond_info(reg_vals)
+
+    cmd_EEPROM_DEBUG_READ_help = "Read data bytes from eeprom"
+
+    def cmd_EEPROM_DEBUG_WRITE_BYTE(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=255, parser=lambda x: int(x, 0))
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_BYTE : ADDR[0x%x] = 0x%x" % (addr, val))
+        self.chip.write_reg(addr, val)
+
+    cmd_EEPROM_DEBUG_WRITE_BYTE_help = "Write byte data to eeprom"
+
+    def cmd_EEPROM_DEBUG_WRITE_INT(self, gcmd):
+        pos = self.chip.read_reg(0, 1)
+        gcmd.respond_info("EEPROM_POS int_pos:%s" % int.from_bytes(pos, 'little'))
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=4294967296, parser=lambda x: int(x, 0))
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_INT : val = %d" % val)
+        vals = [val & 0xFF]
+        vals += [   (val >> 8) & 0xFF,
+                    (val >> 16) & 0xFF,
+                    (val >> 24) & 0xFF,
+                ]
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_INT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+
+    cmd_EEPROM_DEBUG_WRITE_INT_help = "Write int (4 byte) data to eeprom"
+
+    def cmd_EEPROM_DEBUG_WRITE_FLOAT(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get_float("VAL", 0.)
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_FLOAT : val = %f" % val)
+        bs = struct.pack("f", val)
+        data = int.from_bytes(bs, byteorder="little")
+
+        vals = [data & 0xFF]
+        vals += [   (data >> 8) & 0xFF, 
+                    (data >> 16) & 0xFF,
+                    (data >> 24) & 0xFF
+                ]
+        gcmd.respond_info("EEPROM_DEBUG_WRITE_FLOAT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                        % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+
+    cmd_EEPROM_DEBUG_WRITE_FLOAT_help = "Write float (4 byte) data to eeprom"
+    
+    def cmd_EEPROM_READ(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        size = gcmd.get("SIZE", minval=0, maxval=56, parser=lambda x: int(x, 0))
+        vals = self.chip.read_reg(addr, size)
+        # gcmd.respond_info("EEPROM_READ size: 0x%x" % size)
+        reg_vals = 'read vals: '
+        for i in range(size):
+            if i % 16 == 0:
+                reg_vals += '\n'
+            reg_vals += '0x%x ' % vals[i]
+        # gcmd.respond_info(reg_vals)
+    cmd_EEPROM_READ_help = "Read data bytes from eeprom"
+
+    def cmd_EEPROM_WRITE_BYTE(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=255, parser=lambda x: int(x, 0))
+        # gcmd.respond_info("EEPROM_WRITE_BYTE : ADDR[0x%x] = 0x%x" % (addr, val))
+        self.chip.write_reg(addr, val)
+    cmd_EEPROM_WRITE_BYTE_help = "Write byte data to eeprom"
+
+    def cmd_EEPROM_WRITE_INT(self, gcmd):
+        # pos = self.chip.read_reg(0, 1)
+        # gcmd.respond_info("EEPROM_POS int_pos:%s" % int.from_bytes(pos, 'little'))
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get("VAL", minval=0, maxval=4294967296, parser=lambda x: int(x, 0))
+        # gcmd.respond_info("EEPROM_WRITE_INT : val = %d" % val)
+        vals = [val & 0xFF]
+        vals += [   (val >> 8) & 0xFF,
+                    (val >> 16) & 0xFF,
+                    (val >> 24) & 0xFF,
+                ]
+        # gcmd.respond_info("EEPROM_WRITE_INT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                # % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+    cmd_EEPROM_WRITE_INT_help = "Write int (4 byte) data to eeprom"
+
+    def cmd_EEPROM_WRITE_FLOAT(self, gcmd):
+        addr = gcmd.get("ADDR", minval=0, maxval=2047, parser=lambda x: int(x, 0))
+        val = gcmd.get_float("VAL", 0.)
+        # gcmd.respond_info("EEPROM_WRITE_FLOAT : val = %f" % val)
+        bs = struct.pack("f", val)
+        data = int.from_bytes(bs, byteorder="little")
+
+        vals = [data & 0xFF]
+        vals += [   (data >> 8) & 0xFF, 
+                    (data >> 16) & 0xFF,
+                    (data >> 24) & 0xFF
+                ]
+        # gcmd.respond_info("EEPROM_WRITE_FLOAT : ADDR[0x%x] = 0x%02x 0x%02x 0x%02x 0x%02x"
+                        # % (addr, vals[0], vals[1], vals[2], vals[3]))
+        self.chip.write_reg(addr, vals)
+    cmd_EEPROM_WRITE_FLOAT_help = "Write float (4 byte) data to eeprom"  
+
+class BL24C16F:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        EEPROMCommandHelper(config, self)
+        self.name = config.get_name().split()[-1]
+        self.reactor = self.printer.get_reactor()
+        self.i2c0 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_0, default_speed=400000)
+        self.i2c1 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_1, default_speed=400000)
+        self.i2c2 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_2, default_speed=400000)
+        self.i2c3 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_3, default_speed=400000)
+        self.i2c4 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_4, default_speed=400000)
+        self.i2c5 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_5, default_speed=400000)
+        self.i2c6 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_6, default_speed=400000)
+        self.i2c7 = bus.MCU_I2C_from_config(
+            config, default_addr=BL24C16F_CHIP_ADDR_7, default_speed=400000)
+        self.mcu = self.i2c0.get_mcu()
+        self.printer.add_object("bl24c16f " + self.name, self)
+        self.printer.register_event_handler("klippy:connect",
+                                            self.handle_connect)
+
+    def handle_connect(self):
+        self._init_bl24c16f()
+
+    def _init_bl24c16f(self):
+        logging.info("bl24c16f init...")
+
+    def read_reg(self, addr, read_len):
+        index = addr // 256
+        offset = addr % 256
+        reg = [offset]
+
+        if index == 0 :
+            params = self.i2c0.i2c_read(reg, read_len)
+        elif index == 1 :
+            params = self.i2c1.i2c_read(reg, read_len)
+        elif index == 2 :
+            params = self.i2c2.i2c_read(reg, read_len)
+        elif index == 3 :
+            params = self.i2c3.i2c_read(reg, read_len)
+        elif index == 4 :
+            params = self.i2c4.i2c_read(reg, read_len)
+        elif index == 5 :
+            params = self.i2c5.i2c_read(reg, read_len)
+        elif index == 6 :
+            params = self.i2c6.i2c_read(reg, read_len)
+        elif index == 7 :
+            params = self.i2c7.i2c_read(reg, read_len)
+
+        return bytearray(params['response'])
+
+    def write_reg(self, addr, data):
+        if type(data) is not list:
+            data = [data]
+
+        index = addr // 256
+        offset = addr % 256
+        data.insert(0, offset)
+        if index == 0 :
+            self.i2c0.i2c_write(data)
+        if index == 1 :
+            self.i2c1.i2c_write(data)
+        if index == 2 :
+            self.i2c2.i2c_write(data)
+        if index == 3 :
+            self.i2c3.i2c_write(data)
+        if index == 4 :
+            self.i2c4.i2c_write(data)
+        if index == 5 :
+            self.i2c5.i2c_write(data)
+        if index == 6 :
+            self.i2c6.i2c_write(data)
+        if index == 7 :
+            self.i2c7.i2c_write(data)
+
+    def setEepromDisable(self):
+        self.write_reg(1, 255)
+
+    def checkEepromFirstEnable(self):
+        val = self.read_reg(1, 1)
+        if int.from_bytes(val, 'little') != 255:
+            return False
+        else:
+            return True
+        
+    def eepromReadHeader(self):
+        pos = self.read_reg(0, 1)
+        return int.from_bytes(pos, 'little')
+    
+    def eepromReadBody(self, pos):
+        file_position = self.read_reg(pos*8, 4)
+        base_position_e = self.read_reg(pos*8+4, 4)
+        return {"file_position": int.from_bytes(file_position, 'little'), "base_position_e": struct.unpack('f', base_position_e)[0]}
+
+def load_config(config):
+    return BL24C16F(config)
+
+def load_config_prefix(config):
+    return BL24C16F(config)
--- /dev/null
+++ b/klippy/extras/box.py
@@ -0,0 +1,4 @@
+from .box_wrapper import MultiColorMeterialBoxWrapper
+def load_config(config):
+    return(MultiColorMeterialBoxWrapper(config))
+
--- /dev/null
+++ b/klippy/extras/custom_macro.py
@@ -0,0 +1,144 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import time
+
+class CUSTOM_MACRO:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object('gcode')
+        self.pheaters = None
+        self.heater_hot = None
+        self.extruder_temp=None
+        self.bed_temp=None
+        self.prtouch = None
+        self.gcode.register_command("CX_PRINT_LEVELING_CALIBRATION", self.cmd_CX_PRINT_LEVELING_CALIBRATION, desc=self.cmd_CX_PRINT_LEVELING_CALIBRATION_help)
+        self.gcode.register_command("CX_CLEAN_CALIBRATION_FLAGS", self.cmd_CX_CLEAN_CALIBRATION_FLAGS, desc=self.cmd_CX_CLEAN_CALIBRATION_FLAGS_help)
+        self.gcode.register_command("CX_PRINT_DRAW_ONE_LINE", self.cmd_CX_PRINT_DRAW_ONE_LINE, desc=self.cmd_CX_PRINT_DRAW_ONE_LINE_help)
+        self.gcode.register_command("CX_ROUGH_G28", self.cmd_CX_ROUGH_G28, desc=self.cmd_CX_ROUGH_G28_help)
+        self.gcode.register_command("CX_NOZZLE_CLEAR", self.cmd_CX_NOZZLE_CLEAR, desc=self.cmd_CX_NOZZLE_CLEAR_help)
+        self.default_extruder_temp = config.getfloat("default_extruder_temp", default=240.0)
+        self.default_bed_temp = config.getfloat("default_bed_temp", default=50.0)
+        self.g28_ext_temp = config.getfloat("g28_ext_temp", default=140.0)
+        self.nozzle_clear = config.getboolean('nozzle_clear', True)
+        self.calibration = config.getint('calibration', default=0)
+        self.leveling_calibration = 0
+        self.qmode_flag = 0
+        self.gcode.register_command("SET_QMODE_FLAG", self.cmd_SET_QMODE_FLAG, desc=self.cmd_SET_QMODE_FLAG_help)
+        pass
+
+
+    def get_status(self, eventtime):
+        return {
+            'leveling_calibration': self.leveling_calibration,
+            'default_extruder_temp': self.default_extruder_temp,
+            'default_bed_temp': self.default_bed_temp,
+            'g28_ext_temp': self.g28_ext_temp,
+            'qmode_flag': self.qmode_flag
+        }
+
+    cmd_CX_PRINT_LEVELING_CALIBRATION_help = "Start Print function,three parameter:EXTRUDER_TEMP(180-300),BED_TEMP(0-100),CALIBRATION(0 or 1)"
+    def cmd_CX_PRINT_LEVELING_CALIBRATION(self, gcmd):
+        self.gcode.run_script_from_command('CHECK_BED_MESH AUTO_G29=1')
+        pass
+
+    cmd_CX_CLEAN_CALIBRATION_FLAGS_help = "Clean calibration flags"
+    def cmd_CX_CLEAN_CALIBRATION_FLAGS(self, gcmd):
+        self.leveling_calibration = 0
+        pass
+
+    cmd_CX_PRINT_DRAW_ONE_LINE_help = "Draw one line before printing"
+    def cmd_CX_PRINT_DRAW_ONE_LINE(self, gcmd):
+        self.gcode.run_script_from_command('G28 X Y')
+        self.gcode.run_script_from_command('M83')
+        self.gcode.run_script_from_command('G1 X10 Y10 Z2 F6000')
+        self.gcode.run_script_from_command('G1 Z0.1 F600')
+        self.pheaters = self.printer.lookup_object('heaters')
+        self.heater_hot = self.printer.lookup_object('extruder').heater
+        self.gcode.respond_info("can_break_flag = %d" % (self.pheaters.can_break_flag))
+        self.gcode.run_script_from_command('M104 S%d' % (self.extruder_temp))
+        self.gcode.run_script_from_command('M140 S%d' % (self.bed_temp))
+        self.pheaters.set_temperature(self.heater_hot, self.extruder_temp, True)
+        self.gcode.respond_info("can_break_flag = %d" % (self.pheaters.can_break_flag))
+        while self.pheaters.can_break_flag == 1:
+            time.sleep(1)
+        self.gcode.respond_info("can_break_flag = %d" % (self.pheaters.can_break_flag))
+        if self.pheaters.can_break_flag == 3:
+            self.pheaters.can_break_flag = 0
+            self.gcode.respond_info("can_break_flag is 3")
+            self.gcode.run_script_from_command('G21')
+            self.gcode.run_script_from_command('G1 F2400 E-0.5')
+            self.gcode.run_script_from_command('SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=5')
+            self.gcode.run_script_from_command('M204 S12000')
+            self.gcode.run_script_from_command('G21')
+            self.gcode.run_script_from_command('SET_VELOCITY_LIMIT ACCEL_TO_DECEL=6000')
+            # self.gcode.run_script_from_command('SET_PRESSURE_ADVANCE ADVANCE=0.04')
+            # self.gcode.run_script_from_command('SET_PRESSURE_ADVANCE SMOOTH_TIME=0.04')
+            self.gcode.run_script_from_command('M220 S100')
+            # self.gcode.run_script_from_command('M221 S100')
+            self.gcode.run_script_from_command('G1 Z2.0 F1200')
+            self.gcode.run_script_from_command('G1 X0.1 Y20 Z0.3 F6000.0')
+            self.gcode.run_script_from_command('G1 X0.1 Y180.0 Z0.3 F3000.0 E10.0')
+            self.gcode.run_script_from_command('G1 X0.4 Y180.0 Z0.3 F3000.0')
+            self.gcode.run_script_from_command('G1 X0.4 Y20.0 Z0.3 F3000.0 E10.0')
+            self.gcode.run_script_from_command('G1 Y10.0 F3000.0')
+            self.gcode.run_script_from_command('G1 Z2.0 F600.0')
+            self.gcode.run_script_from_command('G1 Z0.3 F600.0')
+            self.gcode.run_script_from_command('G1 Z2.0 F600.0')
+            # self.gcode.run_script_from_command('G1 X0.4 Y10.0 Z0.3 F6000.0')
+            self.gcode.run_script_from_command('M82')
+            self.gcode.run_script_from_command('G92 E0')
+            # self.gcode.run_script_from_command('G1 Z2.0 F600')
+            self.gcode.run_script_from_command('G1 F12000')
+            self.gcode.run_script_from_command('G21')
+        pass
+
+    cmd_CX_ROUGH_G28_help = "rough G28"
+    def cmd_CX_ROUGH_G28(self, gcmd):
+        self.extruder_temp = gcmd.get_float('EXTRUDER_TEMP', default=self.default_extruder_temp, minval=180.0, maxval=320.0)
+        self.g28_ext_temp = self.extruder_temp - 70
+        if self.g28_ext_temp > 180.0:
+            self.g28_ext_temp = 180.0
+        try:
+            self.prtouch = self.printer.lookup_object('prtouch_v2')
+        except:
+            self.prtouch = self.printer.lookup_object('prtouch')
+            gcmd.respond_info("self.prtouch = prtouch")
+        self.prtouch.change_hot_min_temp(self.g28_ext_temp)
+        self.bed_temp = gcmd.get_float('BED_TEMP', default=self.default_bed_temp, minval=0.0, maxval=130.0)
+        self.leveling_calibration = gcmd.get_int('LEVELING_CALIBRATION', default=1, minval=0, maxval=1)
+        self.gcode.run_script_from_command('M104 S%d' % (self.g28_ext_temp))
+        self.gcode.run_script_from_command('M140 S%d' % (self.bed_temp))
+        self.gcode.run_script_from_command('M204 S500')
+        self.gcode.run_script_from_command('G28')
+        # self.gcode.run_script_from_command('NOZZLE_CLEAR HOT_MIN_TEMP=%d HOT_MAX_TEMP=%d BED_MAX_TEMP=%d' % (self.g28_ext_temp, self.extruder_temp - 20, self.bed_temp))
+        pass
+
+    cmd_CX_NOZZLE_CLEAR_help = "nozzle clear with temperature"
+    def cmd_CX_NOZZLE_CLEAR(self, gcmd):
+        self.gcode.run_script_from_command('NOZZLE_CLEAR HOT_MIN_TEMP=%d HOT_MAX_TEMP=%d BED_MAX_TEMP=%d' % (self.g28_ext_temp, self.extruder_temp - 20, self.bed_temp))
+        pass
+    cmd_SET_QMODE_FLAG_help = "set qmode flag"
+    def cmd_SET_QMODE_FLAG(self, gcmd):
+        self.qmode_flag =  gcmd.get_int('FLAG', default=1, minval=0, maxval=1)
+        gcmd.respond_info("[cmd_SET_QMODE_FLAG] self.qmode_flag={}".format(self.qmode_flag))
+        import json, logging
+        try:
+            print_stats = self.printer.lookup_object('print_stats')
+            v_sd = self.printer.lookup_object('virtual_sdcard')
+            speed_mode_path = v_sd.speed_mode_path
+            if print_stats.state == "printing" and self.qmode_flag == 1:
+                result = {}
+                result["speed_mode"] = 2
+                with open(speed_mode_path, "w") as f:
+                    f.write(json.dumps(result))
+                    f.flush()
+        except Exception as err:
+            err_msg = "cmd_SET_QMODE_FLAG err %s" % str(err)
+            logging.error(err_msg)
+        pass
+
+def load_config(config):
+    return CUSTOM_MACRO(config)
--- /dev/null
+++ b/klippy/extras/dirzctl.py
@@ -0,0 +1,111 @@
+# Support for button detection and callbacks
+#
+# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import mcu
+import time
+
+class DirZCtl:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.toolhead = None
+        self.mcu = mcu.get_printer_mcu(self.printer, config.get('use_mcu'))
+        self.oid = self.mcu.create_oid()
+        self.steppers = []
+        self.mcu.register_config_callback(self._build_config)
+        self.mcu.register_response(self._handle_debug_dirzctl, "debug_dirzctl", self.oid)
+        self.mcu.register_response(self._handle_result_dirzctl, "result_dirzctl", self.oid)
+        self.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+        self.printer.register_event_handler("klippy:disconnect", self._handle_disconnect)
+        self.gcode = self.printer.lookup_object("gcode")
+        self.gcode.register_command('DIRZCTL', self.cmd_DIRZCTL, desc=self.cmd_DIRZCTL_help)
+        self.all_params = []
+        self.hx711s = None
+        self.mcu_freq = 72000000
+        self.step_base = config.getfloat('step_base', default=2, minval=1, maxval=6)
+        self.last_send_heart = 0.
+        self.is_shutdown = True
+        self.is_timeout = True
+        pass
+
+    def _handle_mcu_identify(self):
+        self.hx711s = self.printer.lookup_object('hx711s')
+        self.steppers = []
+        self.toolhead = self.printer.lookup_object('toolhead')
+        for stepper in self.toolhead.get_kinematics().get_steppers():
+            if stepper.is_active_axis('z'):
+                self.steppers.append(stepper)
+        self.mcu_freq = self.mcu.get_constant_float('CLOCK_FREQ')   
+
+        # self.send_heart_beat_cmd = self.mcu.lookup_query_command(
+        # "heart_beat_dirzctl oid=%c",
+        # "heart_beat_dirzctl_result oid=%c",
+        # oid=self.oid, cq=None)
+
+        self.is_shutdown = False
+        self.is_timeout = False
+        pass
+
+    def _build_config(self):
+        self.mcu.add_config_cmd("config_dirzctl oid=%d z_count=%d" % (self.oid, len(self.steppers)))
+        for i in range(len(self.steppers)):
+            dir_pin, step_pin, ivt_dir, ivt_step = self.steppers[i].get_pin_info()
+            self.mcu.add_config_cmd("add_dirzctl oid=%d index=%d dir_pin=%s step_pin=%s dir_invert=%d step_invert=%d" % (self.oid, i, dir_pin, step_pin, ivt_dir, ivt_step))
+
+        # self.run_cmd = self.mcu.lookup_command("run_dirzctl oid=%c direct=%c step_us=%u step_cnt=%u is_ck_con=%c", cq=None)
+        self.run_cmd = self.mcu.lookup_command("run_dirzctl oid=%c direct=%c step_us=%u step_cnt=%u", cq=None)
+        pass
+
+    def _handle_shutdown(self):
+        self.is_shutdown = True
+        pass
+    
+    def _handle_disconnect(self):
+        self.is_timeout = True
+        pass
+
+    def _handle_debug_dirzctl(self, params):
+        self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def _handle_result_dirzctl(self, params):
+        self.all_params.append(params)
+        # self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def get_params(self):
+        return self.all_params, (self.all_params[0]['tick'] if len(self.all_params) > 0 else 0)
+
+    def check_and_run(self, direct, step_us, step_cnt, wait_finish=True, is_ck_con=False):
+        if self.is_shutdown or self.is_timeout:
+            pass
+        if step_cnt != 0:
+            self.all_params = []
+        # self.run_cmd.send([self.oid, direct, step_us, step_cnt, 1 if is_ck_con else 0])
+        self.run_cmd.send([self.oid, direct, step_us, step_cnt])
+        t_start = time.time()
+        while not (self.is_shutdown or self.is_timeout) and wait_finish and ((time.time() - t_start) < (1.5 * 1000 * 1000 * step_us * step_cnt)) and len(self.all_params) != 2:
+            self.hx711s.delay_s(0.05)
+        pass
+
+    def send_heart_beat(self):
+        #if time.time() - self.last_send_heart > 0.1:
+        #    self.send_heart_beat_cmd.send([self.oid])
+        #    self.last_send_heart = time.time()
+        pass
+
+    cmd_DIRZCTL_help = "Test DIRZCTL."
+    # DIRZCTL DIRECT=1 STEP_US=1500 STEP_CNT=100
+    def cmd_DIRZCTL(self, gcmd):
+        index = gcmd.get_int('INDEX', len(self.steppers), minval=0, maxval=len(self.steppers))
+        direct = gcmd.get_int('DIRECT', 1, minval=0, maxval=1)
+        step_us = gcmd.get_int('STEP_US', 1500, minval=4, maxval=100000)
+        step_cnt = gcmd.get_int('STEP_CNT', 256, minval=0, maxval=10000)
+        self.check_and_run(direct, step_us, step_cnt, False, False)
+        pass
+
+
+def load_config(config):
+    return DirZCtl(config)
--- a/klippy/extras/exclude_object.py
+++ b/klippy/extras/exclude_object.py
@@ -34,6 +34,12 @@ class ExcludeObject:
         self.gcode.register_command(
             'EXCLUDE_OBJECT_DEFINE', self.cmd_EXCLUDE_OBJECT_DEFINE,
             desc=self.cmd_EXCLUDE_OBJECT_DEFINE_help)
+        self.gcode.register_command('EXCLUDE_OBJECT_RESET', self.cmd_EXCLUDE_OBJECT_RESET)
+    def cmd_EXCLUDE_OBJECT_RESET(self, gcmd):
+        if self.objects:
+            self.gcode.run_script_from_command("M400")
+            self.gcode.run_script_from_command("EXCLUDE_OBJECT_DEFINE RESET=1")
+            self.gcode.run_script_from_command("M400")
 
     def _register_transform(self):
         if self.next_transform is None:
@@ -220,6 +226,9 @@ class ExcludeObject:
         reset = gcmd.get('RESET', None)
         current = gcmd.get('CURRENT', None)
         name = gcmd.get('NAME', '').upper()
+        if name == self.current_object:
+            self.gcode.respond_info("Forbidden EXCLUDE_OBJECT current_print_object:%s" % self.current_object)
+            return
 
         if reset:
             if name:
@@ -243,6 +252,10 @@ class ExcludeObject:
             self._list_excluded_objects(gcmd)
 
     cmd_EXCLUDE_OBJECT_DEFINE_help = "Provides a summary of an object"
+
+    # def cmd_GET_EXCLUDE_OBJECTS(self, gcmd):
+    #     self.objects = json.load(open('/tmp/objects.json', 'r'))
+
     def cmd_EXCLUDE_OBJECT_DEFINE(self, gcmd):
         reset = gcmd.get('RESET', None)
         name = gcmd.get('NAME', '').upper()
@@ -260,10 +273,16 @@ class ExcludeObject:
             obj.update(parameters)
 
             if center != None:
-                obj['center'] = json.loads('[%s]' % center)
+                try:
+                    obj['center'] = json.loads('[%s]' % center)
+                except Exception as err:
+                    logging.exception(err)
 
             if polygon != None:
-                obj['polygon'] = json.loads(polygon)
+                try:
+                    obj['polygon'] = json.loads(polygon)
+                except Exception as err:
+                    logging.exception(err)
 
             self._add_object_definition(obj)
 
@@ -271,8 +290,9 @@ class ExcludeObject:
             self._list_objects(gcmd)
 
     def _add_object_definition(self, definition):
-        self.objects = sorted(self.objects + [definition],
-                              key=lambda o: o["name"])
+        # self.objects = sorted(self.objects + [definition],
+        #                       key=lambda o: o["name"])
+        self.objects = self.objects + [definition]
 
     def _exclude_object(self, name):
         self._register_transform()
--- a/klippy/extras/fan.py
+++ b/klippy/extras/fan.py
@@ -67,8 +67,9 @@ class Fan:
         self.last_fan_value = value
     def set_speed_from_command(self, value):
         toolhead = self.printer.lookup_object('toolhead')
-        toolhead.register_lookahead_callback((lambda pt:
-                                              self.set_speed(pt, value)))
+        self.set_speed(toolhead.print_time, value)
+        # toolhead.register_lookahead_callback((lambda pt:
+        #                                       self.set_speed(pt, value)))
     def _handle_request_restart(self, print_time):
         self.set_speed(print_time, 0.)
 
--- /dev/null
+++ b/klippy/extras/fan_feedback.py
@@ -0,0 +1,159 @@
+import logging
+
+
+class FanFeedback:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+
+        self.print_delay_time = config.getfloat('print_delay_time', 3.)
+        self.current_delay_time = config.getfloat('current_delay_time', 2.)
+
+        ppins = self.printer.lookup_object('pins')
+
+        self.params = []
+        # 主mcu上的风扇
+        fan0_pin_sensor_pin = config.getlist("fan0_pin", None)
+        self.mcu_fan_count = len(fan0_pin_sensor_pin)
+        pins_count = 0
+        # 获取第一个引脚
+        pin_sensor_pin = fan0_pin_sensor_pin[pins_count]
+        fan0_pin_params = ppins.lookup_pin(pin_sensor_pin, can_invert=False, can_pullup=True)
+        mcu = fan0_pin_params['chip']
+        mcu_oid = mcu.create_oid()
+        mcu_config_cmd = "config_fancheck oid=%d fan_num=%d " % (mcu_oid, self.mcu_fan_count)
+        mcu_config_cmd += " fan%d_pin=%s pull_up%d=%s" % (pins_count, fan0_pin_params["pin"], pins_count, fan0_pin_params["pullup"])
+        # 获取第二个之后的引脚
+        for i in range(self.mcu_fan_count - 1):
+            pins_count += 1
+            pin_sensor_pin = fan0_pin_sensor_pin[pins_count]
+            fan0_pin_params = ppins.lookup_pin(pin_sensor_pin, can_invert=False, can_pullup=True)
+            mcu_config_cmd += " fan%d_pin=%s pull_up%d=%s" % (pins_count, fan0_pin_params["pin"], pins_count, fan0_pin_params["pullup"])
+        # 补全协议
+        for i in range(5 - self.mcu_fan_count):
+            pins_count += 1
+            mcu_config_cmd += " fan%d_pin=%s pull_up%d=%s" % (pins_count, fan0_pin_params["pin"], pins_count, fan0_pin_params["pullup"])
+        
+        mcu.add_config_cmd(mcu_config_cmd)
+        mcu.register_response(self._handle_result_fan_check0, "fan_status", mcu_oid)
+        param = 0, mcu_config_cmd, fan0_pin_params, mcu, mcu_oid
+        self.params.append(param)
+
+        # 喷头mcu上的风扇
+        fan1_pin_sensor_pin = config.get("fan1_pin")
+        fan2_pin_sensor_pin = config.get("fan2_pin")
+        self.nozzle_mcu_fan_count = 2
+        fan1_pin_params = ppins.lookup_pin(fan1_pin_sensor_pin, can_invert=False, can_pullup=True)
+        fan2_pin_params = ppins.lookup_pin(fan2_pin_sensor_pin, can_invert=False, can_pullup=True)
+        nozzle_mcu = fan1_pin_params['chip']
+        nozzle_mcu_oid = nozzle_mcu.create_oid()
+        # fan_num是风扇数量 pull_up1之后的参数可以填和前面相同的值,做占位用
+        nozzle_mcu_config_cmd = "config_fancheck oid=%d fan_num=%d fan0_pin=%s pull_up0=%s" \
+                        " fan1_pin=%s pull_up1=%s fan2_pin=%s pull_up2=%s fan3_pin=%s" \
+                        " pull_up3=%s fan4_pin=%s pull_up4=%s" % (
+            nozzle_mcu_oid, self.nozzle_mcu_fan_count,
+            fan1_pin_params['pin'], fan1_pin_params["pullup"],
+            fan2_pin_params['pin'], fan2_pin_params["pullup"],
+            fan2_pin_params['pin'], fan2_pin_params["pullup"],
+            fan2_pin_params['pin'], fan2_pin_params["pullup"],
+            fan2_pin_params['pin'], fan2_pin_params["pullup"]
+        )
+        nozzle_mcu.add_config_cmd(nozzle_mcu_config_cmd)
+        nozzle_mcu.register_response(self._handle_result_fan_check1, "fan_status", nozzle_mcu_oid)
+        param = 1, nozzle_mcu_config_cmd, fan1_pin_params, nozzle_mcu, nozzle_mcu_oid
+        self.params.append(param)
+        self.gcode = config.get_printer().lookup_object('gcode')
+        self.gcode.register_command("QUERY_FAN_CHECK", self.cmd_QUERY_FAN_CHECK, desc=self.cmd_QUERY_FAN_CHECK_help)
+        self.gcode.register_command("QUERY_PTC_FAN_CHECK", self.cmd_QUERY_PTC_FAN_CHECK, desc=self.cmd_QUERY_PTC_FAN_CHECK_help)
+        self.print_stats = self.printer.load_object(config, 'print_stats')
+        self.printer.register_event_handler("klippy:ready", self.handle_ready)
+
+        self.ptc_fan_speed = {}
+        self.cx_fan_status = {}
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("get_cx_fan_status",
+                                   self._get_cx_fan_status)
+
+    def handle_ready(self):
+        reactor = self.printer.get_reactor()
+        reactor.register_timer(
+            self.cx_fan_status_update_event, reactor.monotonic()+1.)
+
+    def delay_s(self, delay_s):
+        toolhead = self.printer.lookup_object("toolhead")
+        reactor = self.printer.get_reactor()
+        eventtime = reactor.monotonic()
+        if not self.printer.is_shutdown():
+            toolhead.get_last_move_time()
+            eventtime = reactor.pause(eventtime + delay_s)
+            pass
+
+    def _get_cx_fan_status(self):
+        return self.cx_fan_status
+
+    def cx_fan_status_update_event(self, eventtime):
+        if self.print_stats.get_status(eventtime).get("state") != "printing":
+            next_time = eventtime + self.current_delay_time
+        else:
+            next_time = eventtime + self.print_delay_time
+        for obj in self.params:
+            cmd = "query_fancheck oid=%c which_fan=%c"
+            oid = obj[4]
+            mcu = obj[3]
+            query_cmd = mcu.lookup_command(cmd, cq=None)
+            # log_cmd = "query_fancheck oid=%s which_fan=%s" % (oid, 31)
+            # logging.info("%s" % log_cmd)
+            # which_fan 是位操作 2的风扇个数次方-1,下位机做查询风扇时使用 
+            which_fan = 0
+            if mcu._name == "mcu":
+                which_fan = 2**self.mcu_fan_count - 1
+            elif mcu._name == "nozzle_mcu":
+                which_fan = 2**self.nozzle_mcu_fan_count - 1
+            query_cmd.send([oid, which_fan])
+        return next_time
+
+    cmd_QUERY_FAN_CHECK_help = "Check CXSW Special Fan Status"
+    def cmd_QUERY_FAN_CHECK(self, gcmd):
+        self.gcode.respond_info("%s" % self.cx_fan_status)
+
+    cmd_QUERY_PTC_FAN_CHECK_help = "Check CXSW Special PTC Fan Status"
+    def cmd_QUERY_PTC_FAN_CHECK(self, gcmd):
+        self.gcode.respond_info("multi ptc %s" % self.ptc_fan_speed)
+
+    def _handle_result_fan_check0(self, params):
+        # logging.info("_handle_result_fan_check0: %s" % params)
+        # self.cx_fan_status["fan0_speed"] = params.get("fan0_speed", 0)
+        fan0_speed = params.get("fan0_speed", 0)
+        if self.mcu_fan_count > 1:
+            ptc_fan_abnormal = False
+            for i in range(self.mcu_fan_count):
+                fan_key = "fan%d_speed" % i
+                self.ptc_fan_speed[fan_key] = fan_x_speed = params.get(fan_key, 0)
+                if fan_x_speed == 0:
+                    ptc_fan_abnormal = True
+            # 转速异常
+            if ptc_fan_abnormal:
+                fan0_speed = 0
+        self.cx_fan_status = {
+            "fan0_speed": fan0_speed,
+            "fan1_speed": self.cx_fan_status.get("fan1_speed", 0),
+            "fan2_speed": self.cx_fan_status.get("fan2_speed", 0),
+            "fan3_speed": self.cx_fan_status.get("fan3_speed", 0),
+            "fan4_speed": self.cx_fan_status.get("fan4_speed", 0),
+        }
+
+    def _handle_result_fan_check1(self, params):
+        # logging.info("_handle_result_fan_check1: %s" % params)
+        # self.cx_fan_status["fan1_speed"] = params.get("fan1_speed", 0)
+        self.cx_fan_status = {
+            "fan0_speed": self.cx_fan_status.get("fan0_speed", 0),
+            "fan1_speed": params.get("fan0_speed", 0),
+            "fan2_speed": params.get("fan1_speed", 0),
+            "fan3_speed": self.cx_fan_status.get("fan3_speed", 0),
+            "fan4_speed": self.cx_fan_status.get("fan4_speed", 0),
+        }
+
+    def get_status(self, eventtime):
+        return self.cx_fan_status
+
+def load_config(config):
+    return FanFeedback(config)
--- /dev/null
+++ b/klippy/extras/filament_rack.py
@@ -0,0 +1,4 @@
+from .filament_rack_wrapper import FilamentRackWrapper
+def load_config(config):
+    return(FilamentRackWrapper(config))
+
--- a/klippy/extras/filament_switch_sensor.py
+++ b/klippy/extras/filament_switch_sensor.py
@@ -71,7 +71,9 @@ class RunoutHelper:
             return
         # Determine "printing" status
         idle_timeout = self.printer.lookup_object("idle_timeout")
-        is_printing = idle_timeout.get_status(eventtime)["state"] == "Printing"
+        print_stats = self.printer.lookup_object('print_stats')
+        is_printing = print_stats.state == "printing"
+        # is_printing = idle_timeout.get_status(eventtime)["state"] == "Printing"
         # Perform filament action associated with status change (if any)
         if is_filament_present:
             if not is_printing and self.insert_gcode is not None:
@@ -105,7 +107,7 @@ class RunoutHelper:
 
 class SwitchSensor:
     def __init__(self, config):
-        printer = config.get_printer()
+        self.printer = printer = config.get_printer()
         buttons = printer.load_object(config, 'buttons')
         switch_pin = config.get('switch_pin')
         buttons.register_buttons([switch_pin], self._button_handler)
@@ -113,6 +115,8 @@ class SwitchSensor:
         self.get_status = self.runout_helper.get_status
     def _button_handler(self, eventtime, state):
         self.runout_helper.note_filament_present(state)
+        if state:
+            self.printer.send_event("box:extrude_process_stage7")
 
 def load_config_prefix(config):
     return SwitchSensor(config)
--- /dev/null
+++ b/klippy/extras/filter.py
@@ -0,0 +1,125 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from logging import Filter
+from os import remove
+from time import time
+import mcu
+import math
+
+
+class RCTFilter:
+    def __init__(self):
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = []
+        if len(vals) < 3:
+            return vals
+        for i in range(len(vals) - 2):   
+            tmp = [math.fabs(vals[i]), math.fabs(vals[i + 1]), math.fabs(vals[i + 2])]
+            index = tmp.index(min(tmp))
+            out_vals.append(vals[index + i])
+        out_vals.append(vals[-2])
+        out_vals.append(vals[-1])
+        return out_vals
+
+
+class RCHFilter:
+    def __init__(self, cut_frq_hz, acq_frq_hz):
+        self.cut_frq_hz = cut_frq_hz
+        self.acq_frq_hz = acq_frq_hz
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = [0]
+        rc = 1. / 2. / math.pi / self.cut_frq_hz
+        coff = rc / (rc + 1. / self.acq_frq_hz)
+        for i in range(1, len(vals)):
+            out_vals.append((vals[i] - vals[i - 1] + out_vals[-1]) * coff)
+        return out_vals
+
+
+class RCLFilter:
+    def __init__(self, k1_new):
+        self.k1_new = k1_new
+        pass
+
+    def ftr_val(self, vals):
+        out_vals = [vals[0]]
+        for i in range(1, len(vals)):
+            out_vals.append(out_vals[-1] * (1 - self.k1_new) + vals[i] * self.k1_new)
+        return out_vals
+
+
+class Filter:
+    def __init__(self, config):
+        self.hft_hz = config.getfloat('hft_hz', default=5, minval=0.1, maxval=10.)
+        self.lft_k1 = config.getfloat('lft_k1', default=0.8, minval=0., maxval=1.)
+        self.lft_k1_oft = config.getfloat('lft_k1_oft', default=0.8, minval=0., maxval=1.)
+        self.lft_k1_cal = config.getfloat('lft_k1_cal', default=0.8, minval=0., maxval=1.)
+        pass
+    
+    def get_tft(self):
+        return RCTFilter()
+
+    def get_lft(self, k1):
+        return RCLFilter(k1)
+
+    def get_hft(self, cut_hz, acq_hz):
+        return RCHFilter(cut_frq_hz=cut_hz, acq_frq_hz=acq_hz)
+
+    def cal_offset_by_vals(self, s_count, new_valss, lft_k1, cut_len):
+        out_vals = []
+        tmp_vals = [[], [], [], []]
+        tft = RCTFilter()
+        lft = RCLFilter(lft_k1)
+        for i in range(s_count):
+            tmp_vals[i] = tft.ftr_val(new_valss[i])
+            tmp_vals[i] = lft.ftr_val(tmp_vals[i])
+        for i in range(len(tmp_vals[0])):
+            sums = 0
+            for j in range(s_count):
+                if i < len(tmp_vals[j]):
+                    sums += math.fabs(tmp_vals[j][i])
+            out_vals.append(sums)
+        if len(out_vals) > cut_len:
+            del out_vals[0:(len(out_vals) - cut_len)]
+        for i in range(s_count):
+            if len(tmp_vals[i]) > cut_len:
+                del tmp_vals[i][0:(len(tmp_vals[i]) - cut_len)]
+            for j in range(len(tmp_vals[i])):
+                tmp_vals[i][j] = abs(tmp_vals[i][j])
+        return out_vals, tmp_vals
+
+
+    def cal_filter_by_vals(self, s_count, now_valss, hft_hz, lft_k1, cut_len):
+        out_vals = []
+        tmp_vals = [[], [], [], []]
+        tft = RCTFilter()
+        hft = RCHFilter(hft_hz, 80)
+        lft = RCLFilter(lft_k1)
+        for i in range(0, s_count):
+            tmp_vals[i] = tft.ftr_val(now_valss[i])
+            tmp_vals[i] = hft.ftr_val(tmp_vals[i])
+            tmp_vals[i] = lft.ftr_val(tmp_vals[i])
+        for i in range(len(tmp_vals[0])):
+            sums = 0
+            for j in range(s_count):
+                if i < len(tmp_vals[j]):
+                    sums += math.fabs(tmp_vals[j][i])
+            out_vals.append(sums)
+        if len(out_vals) > cut_len:
+            del out_vals[0:(len(out_vals) - cut_len)]
+        for i in range(s_count):
+            if len(tmp_vals[i]) > cut_len:
+                del tmp_vals[i][0:(len(tmp_vals[i]) - cut_len)]
+            for j in range(len(tmp_vals[i])):
+                tmp_vals[i][j] = abs(tmp_vals[i][j])
+        return out_vals, tmp_vals
+
+
+def load_config(config):
+    return Filter(config)
\ No newline at end of file
--- a/klippy/extras/force_move.py
+++ b/klippy/extras/force_move.py
@@ -30,6 +30,7 @@ def calc_move_time(dist, speed, accel):
 
 class ForceMove:
     def __init__(self, config):
+        self.config = config
         self.printer = config.get_printer()
         self.steppers = {}
         # Setup iterative solver
@@ -113,6 +114,11 @@ class ForceMove:
         self._restore_enable(stepper, was_enable)
     cmd_FORCE_MOVE_help = "Manually move a stepper; invalidates kinematics"
     def cmd_FORCE_MOVE(self, gcmd):
+        if self.config.has_section("motor_control") and self.config.getsection('motor_control').getint('switch')==1:
+            if self.printer.lookup_object('motor_control').is_ready == False:
+                gcode = self.printer.lookup_object('gcode')
+                gcode.respond_info("The motor parameters are initializing, Please try again later...")
+                return
         stepper = self._lookup_stepper(gcmd)
         distance = gcmd.get_float('DISTANCE')
         speed = gcmd.get_float('VELOCITY', above=0.)
--- a/klippy/extras/gcode_macro.py
+++ b/klippy/extras/gcode_macro.py
@@ -188,6 +188,21 @@ class GCodeMacro:
         v = dict(self.variables)
         v[variable] = literal
         self.variables = v
+        try:
+            import os, json
+            if "z_safe_pause" in variable:
+                logging.info("SET_GCODE_VARIABLE variable:%s literal:%s" % (variable, literal))
+                v_sd = self.printer.lookup_object('virtual_sdcard', None)
+                if os.path.exists(v_sd.print_file_name_path):
+                    result = {}
+                    with open(v_sd.print_file_name_path, "r") as f:
+                        result = (json.loads(f.read()))
+                        result["variable_z_safe_pause"] = literal
+                    with open(v_sd.print_file_name_path, "w") as f:
+                        f.write(json.dumps(result))
+                        f.flush()
+        except Exception as err:
+            logging.error("SET_GCODE_VARIABLE save z_safe_pause err:%s" % err)
     def cmd(self, gcmd):
         if self.in_script:
             # raise gcmd.error("Macro %s called recursively" % (self.alias,))
@@ -197,10 +212,15 @@ class GCodeMacro:
         kwparams['params'] = gcmd.get_command_parameters()
         kwparams['rawparams'] = gcmd.get_raw_command_parameters()
         self.in_script = True
+        if self.alias == "PAUSE":
+            self.printer.lookup_object('pause_resume').pause_start = True
         try:
             self.template.run_gcode_from_command(kwparams)
         finally:
             self.in_script = False
-
+            if self.alias == "PAUSE":
+                self.printer.lookup_object('pause_resume').pause_start = False
+            elif self.alias == "MOTOR_CANCEL_PRINT":
+                self.printer.lookup_object('pause_resume').motor_cancel_print_start = False
 def load_config_prefix(config):
     return GCodeMacro(config)
--- a/klippy/extras/gcode_move.py
+++ b/klippy/extras/gcode_move.py
@@ -7,6 +7,11 @@ import logging
 
 class GCodeMove:
     def __init__(self, config):
+        self.config = config
+        self.variable_safe_z = 0
+        if config.has_section('gcode_macro PRINTER_PARAM'):
+            PRINTER_PARAM = config.getsection('gcode_macro PRINTER_PARAM')
+            self.variable_safe_z = PRINTER_PARAM.getfloat('variable_z_safe_g28', 0.0)
         self.printer = printer = config.get_printer()
         printer.register_event_handler("klippy:ready", self._handle_ready)
         printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
@@ -36,6 +41,8 @@ class GCodeMove:
         gcode.register_command('M114', self.cmd_M114, True)
         gcode.register_command('GET_POSITION', self.cmd_GET_POSITION, True,
                                desc=self.cmd_GET_POSITION_help)
+        gcode.register_command('SET_POSITION', self.cmd_SET_POSITION, True, desc=self.cmd_SET_POSITION_help)
+        gcode.gcode_move = self
         self.Coord = gcode.Coord
         # G-Code coordinate manipulation
         self.absolute_coord = self.absolute_extrude = True
@@ -49,6 +56,51 @@ class GCodeMove:
         self.saved_states = {}
         self.move_transform = self.move_with_transform = None
         self.position_with_transform = (lambda: [0., 0., 0., 0.])
+        gcode.register_command('RESET_HOME_AXES_XY', self.cmd_reset_home_axes_xy, desc=self.cmd_RESET_HOME_AXES_XY_help)
+        gcode.register_command('SET_LIMITS', self.cmd_set_limits, desc=self.cmd_SET_LIMITS_help)
+        gcode.register_command('RESTORE_LIMITS', self.cmd_restore_limits, desc=self.cmd_RESTORE_LIMITS_help)
+        gcode.register_command('SET_Z_LIMIT', self.cmd_set_z_limit)
+        gcode.register_command('RESTORE_Z_LIMIT', self.cmd_restore_zlimit)
+    cmd_RESET_HOME_AXES_XY_help = ("reset_home_axes")
+    def cmd_reset_home_axes_xy(self, gcmd):
+        min_x = 1.0
+        max_x = -1.0
+        min_y = 1.0
+        max_y = -1.0
+        self.printer.lookup_object('toolhead').kin.set_limits(min_x,max_x,min_y,max_y)
+    def cmd_set_z_limit(self, gcmd):
+        zmax_safe_pox_diff = 0
+        if self.config.has_section('z_align'):
+            zmax_safe_pox_diff = self.printer.lookup_object('z_align').zmax_safe_pox_diff
+        # 获取网床均值数据
+        fade_target = 0
+        if self.config.has_section('prtouch_v3'):
+            prtouch_v3 = self.printer.lookup_object('prtouch_v3')
+            if isinstance(prtouch_v3.bed_mesh.fade_target, int) or isinstance(prtouch_v3.bed_mesh.fade_target, float):
+                fade_target = abs(prtouch_v3.bed_mesh.fade_target)
+        if fade_target > 5:
+            logging.info("set_z_limit fade_target: {} > 5, reset to 0".format(fade_target))
+            fade_target = 0
+        logging.info("set_z_limit fade_target: {}".format(fade_target))
+        # 冗余设置, 保证断电续打打印最大尺寸模型
+        offset_value = 0.2
+        min_z = self.config.getsection('stepper_z').getfloat('position_min', default=-10)      
+        max_z = self.config.getsection('stepper_z').getfloat('position_max', default=360) - zmax_safe_pox_diff + fade_target + offset_value
+        self.printer.lookup_object('toolhead').kin.set_z_limit(min_z, max_z)
+    def cmd_restore_zlimit(self, gcmd):
+        min_z = self.config.getsection('stepper_z').getfloat('position_min', default=-10)      
+        max_z = self.config.getsection('stepper_z').getfloat('position_max', default=360)
+        self.printer.lookup_object('toolhead').kin.set_z_limit(min_z, max_z)
+    cmd_SET_LIMITS_help = ("SET NEW LIMITS MAXY 400")
+    def cmd_set_limits(self, gcmd):
+        min_x = self.config.getsection('stepper_x').getfloat('position_min', default=-12)      
+        max_x = self.config.getsection('stepper_x').getfloat('position_max', default=356) 
+        min_y = self.config.getsection('stepper_y').getfloat('position_min', default=-10)      
+        max_y = self.config.getsection('stepper_y').getfloat('position_max', default=400) 
+        self.printer.lookup_object('toolhead').kin.set_limits(min_x,max_x,min_y,max_y)
+    cmd_RESTORE_LIMITS_help = ("RESTORE_LIMITS")
+    def cmd_restore_limits(self, gcmd):
+        self.printer.lookup_object('toolhead').kin.restore_limits()
     def _handle_ready(self):
         self.is_printer_ready = True
         if self.move_transform is None:
@@ -109,6 +161,59 @@ class GCodeMove:
     def reset_last_position(self):
         if self.is_printer_ready:
             self.last_position = self.position_with_transform()
+    def simple_cmd_G1(self, line):
+        cpos = line.find(';')
+        if cpos > 0:
+            line = line[:cpos]
+        parts=line.split()
+        try:
+            for part in parts[1:]:
+                if part[0]=="E" or part[0]=="e":
+                    if not self.absolute_coord or not self.absolute_extrude:
+                        # value relative to position of last move
+                        self.last_position[3] += float(part[1:]) * self.extrude_factor
+                    else:
+                        # value relative to base coordinate position
+                        self.last_position[3] = float(part[1:]) * self.extrude_factor + self.base_position[3]
+                elif part[0]=="X" or part[0]=="x":
+                    if not self.absolute_coord:
+                            # value relative to position of last move
+                        self.last_position[0] += float(part[1:])
+                    else:
+                        # value relative to base coordinate position
+                        self.last_position[0] = float(part[1:]) + self.base_position[0]
+                elif part[0]=="Y" or part[0]=="y":
+                    if not self.absolute_coord:
+                            # value relative to position of last move
+                        self.last_position[1] += float(part[1:])
+                    else:
+                        # value relative to base coordinate position
+                        self.last_position[1] = float(part[1:]) + self.base_position[1]
+                elif part[0]=="Z" or part[0]=="z":
+                    toolhead = self.printer.lookup_object('toolhead')
+                    print_stats = self.printer.lookup_object('print_stats')
+                    max_z = toolhead.kin.limits[2][1]+5
+                    curtime = self.printer.get_reactor().monotonic()
+                    if 'z' in toolhead.get_status(curtime)['homed_axes'] and float(part[1:]) > max_z or (not self.absolute_coord and self.last_position[2]+float(part[1:])>max_z):
+                        m = """{"code":"587","msg":"Move out of range %s", "values":[]}""" % str(part)
+                        self.printer.lookup_object('gcode')._respond_error(m)
+                        if print_stats.state == "printing" and self.printer.lookup_object('pause_resume').pause_start == False and self.printer.lookup_object('virtual_sdcard').is_move_out_of_range_in_printing==False:
+                            self.printer.lookup_object('virtual_sdcard').is_move_out_of_range_in_printing=True
+                        return
+                    if not self.absolute_coord:
+                            # value relative to position of last move
+                        self.last_position[2] += float(part[1:])
+                    else:
+                        # value relative to base coordinate position
+                        self.last_position[2] = float(part[1:]) + self.base_position[2]
+                elif part[0]=="F" or part[0]=="f":
+                    gcode_speed = float(part[1:])
+                    if gcode_speed <= 0.:
+                        raise Exception("""{"code":"key272": "msg":"Invalid speed in '%s'", "values":["%s"]}"""% (line,line))
+                    self.speed =  gcode_speed* self.speed_factor
+        except ValueError as e:
+            raise Exception("""{"code":"key273": "msg":"Unable to parse move '%s'", "values":["%s"]}"""% (line,line))
+        self.move_with_transform(self.last_position, self.speed)
     # G-Code movement commands
     def cmd_G1(self, gcmd):
         # Move
@@ -123,6 +228,14 @@ class GCodeMove:
                     else:
                         # value relative to base coordinate position
                         self.last_position[pos] = v + self.base_position[pos]
+            if 'Z' in params:
+                print_stats = self.printer.lookup_object('print_stats')
+                if print_stats.state != "printing":
+                    toolhead = self.printer.lookup_object('toolhead')
+                    curtime = self.printer.get_reactor().monotonic()
+                    if 'z' in toolhead.get_status(curtime)['homed_axes'] and self.last_position[2] < -2:
+                        logging.info("Minimum Limit -2 last_position[2]:%s"%self.last_position[2])
+                        self.last_position[2] = -2
             if 'E' in params:
                 v = float(params['E']) * self.extrude_factor
                 if not self.absolute_coord or not self.absolute_extrude:
@@ -179,6 +292,22 @@ class GCodeMove:
         value = gcmd.get_float('S', 100., above=0.) / (60. * 100.)
         self.speed = self._get_gcode_speed() * value
         self.speed_factor = value
+        import json
+        try:
+            SAVE = int(gcmd.get('SAVE', 0))
+            speed_S = int(gcmd.get_float('S', 100., above=0.))
+            v_sd = self.printer.lookup_object('virtual_sdcard')
+            speed_mode_path = v_sd.speed_mode_path
+            if SAVE==1:
+                result = {}
+                result["speed_mode"] = 1
+                result["value"] = speed_S
+                with open(speed_mode_path, "w") as f:
+                    f.write(json.dumps(result))
+                    f.flush()
+        except Exception as err:
+            err_msg = "cmd_M220 err %s" % str(err)
+            logging.error(err_msg)
     def cmd_M221(self, gcmd):
         # Set extrude factor override percentage
         new_extrude_factor = gcmd.get_float('S', 100., above=0.) / 100.
@@ -186,6 +315,20 @@ class GCodeMove:
         e_value = (last_e_pos - self.base_position[3]) / self.extrude_factor
         self.base_position[3] = last_e_pos - e_value * new_extrude_factor
         self.extrude_factor = new_extrude_factor
+        import json
+        try:
+            SAVE = int(gcmd.get('SAVE', 0))
+            speed_S = int(gcmd.get_float('S', 100., above=0.))
+            v_sd = self.printer.lookup_object('virtual_sdcard')
+            if SAVE==1:
+                result = {}
+                result["value"] = speed_S
+                with open(v_sd.flow_rate_path, "w") as f:
+                    f.write(json.dumps(result))
+                    f.flush()
+        except Exception as err:
+            err_msg = "cmd_M221 err %s" % str(err)
+            logging.error(err_msg)
     cmd_SET_GCODE_OFFSET_help = "Set a virtual offset to g-code positions"
     def cmd_SET_GCODE_OFFSET(self, gcmd):
         move_delta = [0., 0., 0., 0.]
@@ -206,6 +349,275 @@ class GCodeMove:
             for pos, delta in enumerate(move_delta):
                 self.last_position[pos] += delta
             self.move_with_transform(self.last_position, speed)
+    def recordPrintFileName(self, path, file_name, fan_state={}, filament_used=0, last_print_duration=0, pressure_advance=""):
+        import json, os
+        fan = {}
+        M204_accel = ""
+        old_filament_used = 0
+        old_last_print_duration = 0
+        old_pressure_advance = ""
+        set_gcode_offset = -5
+        if os.path.exists(path):
+            with open(path, "r") as f:
+                result = (json.loads(f.read()))
+                # fan = result.get("fan_state", "")
+                fan = result.get("fan_state", {})
+                M204_accel = result.get("M204", "")
+                old_filament_used = result.get("filament_used", 0)
+                old_last_print_duration = result.get("last_print_duration", 0)
+                set_gcode_offset = result.get("SET_GCODE_OFFSET", -5)
+                old_pressure_advance = result.get("pressure_advance", "")
+        if fan_state.get("M106 S") and fan_state.get("M106 S", "") != fan.get("M106 S", ""):
+            fan["M106 S"] = fan_state.get("M106 S")
+        elif fan_state.get("M106 P0") and fan_state.get("M106 P0", "") != fan.get("M106 P0", ""):
+            fan["M106 P0"] = fan_state.get("M106 P0")
+        elif fan_state.get("M106 P1")  and fan_state.get("M106 P1", "") != fan.get("M106 P1", ""):
+            fan["M106 P1"] = fan_state.get("M106 P1")
+        elif fan_state.get("M106 P2")  and fan_state.get("M106 P2", "") != fan.get("M106 P2", ""):
+            fan["M106 P2"] = fan_state.get("M106 P2")
+
+        if filament_used and filament_used != old_filament_used:
+            pass
+        else:
+            filament_used = old_filament_used
+        if last_print_duration and last_print_duration != old_last_print_duration:
+            pass
+        else:
+            last_print_duration = old_last_print_duration
+        if pressure_advance and pressure_advance != old_pressure_advance:
+            pass
+        else:
+            pressure_advance = old_pressure_advance
+        toolhead = self.printer.lookup_object('toolhead')
+        data = {
+            'file_path': file_name,
+            'absolute_coord': self.absolute_coord,
+            'absolute_extrude': self.absolute_extrude,
+            # 'fan_state': state,
+            'fan_state': fan,
+            'M204': M204_accel,
+            'filament_used': filament_used,
+            'last_print_duration': last_print_duration,
+            'SET_GCODE_OFFSET': set_gcode_offset,
+            'pressure_advance': pressure_advance,
+            'max_accel':toolhead.get_max_accel(),
+            'requested_accel_to_decel':toolhead.requested_accel_to_decel,
+            'square_corner_velocity':toolhead.square_corner_velocity
+        }
+        with open(path, "w") as f:
+            f.write(json.dumps(data))
+            f.flush()
+    cmd_CX_RESTORE_GCODE_STATE_help = "Restore a previously saved G-Code state"
+    def cmd_CX_RESTORE_GCODE_STATE(self, print_info, file_name_path, XYZET):
+        toolhead = self.printer.lookup_object('toolhead')
+        try:
+            max_accel = toolhead.get_max_accel()
+            requested_accel_to_decel = toolhead.requested_accel_to_decel
+            square_corner_velocity = toolhead.square_corner_velocity
+            state = {
+                "absolute_extrude": True,
+                "file_position": 0,
+                "extrude_factor": 1.0,
+                "speed_factor": 0.016,
+                "homing_position": [0.0, 0.0, 0.0, 0.0],
+                "last_position": [0.0, 0.0, 0.0, 0.0],
+                "speed": 25.0,
+                "file_path": "",
+                "base_position": [0.0, 0.0, 0.0, -0.0],
+                "absolute_coord": True,
+                # "fan_state": "",
+                "fan_state": {},
+                "variable_z_safe_pause": 0,
+                "M204": "",
+                "filament_used": 0,
+                "last_print_duration": 0,
+                "pressure_advance": "",
+                'max_accel':max_accel,
+                'requested_accel_to_decel':requested_accel_to_decel,
+                'square_corner_velocity':square_corner_velocity
+            }
+            import os, json
+            base_position_e = -1
+            state["file_position"] = print_info.get("file_position", 0)
+            state["base_position"] = [0.0, 0.0, 0.0, print_info.get("base_position_e", -1)]
+            base_position_e = print_info.get("base_position_e", -1)
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE base_position_e:%s" % base_position_e)
+            with open(file_name_path, "r") as f:
+                file_info = json.loads(f.read())
+                state["file_path"] = file_info.get("file_path", "")
+                state["absolute_extrude"] = file_info.get("absolute_extrude", True)
+                state["absolute_coord"] = file_info.get("absolute_coord", True)
+                state["fan_state"] = file_info.get("fan_state", {})
+                state["variable_z_safe_pause"] = file_info.get("variable_z_safe_pause", 0)
+                state["M204"] = file_info.get("M204", "")
+                state["SET_GCODE_OFFSET"] = file_info.get("SET_GCODE_OFFSET", -5)
+                state["pressure_advance"] = file_info.get("pressure_advance", "")
+                state["max_accel"] = file_info.get("max_accel", max_accel)
+                state["requested_accel_to_decel"] = file_info.get("requested_accel_to_decel", requested_accel_to_decel)
+                state["square_corner_velocity"] = file_info.get("square_corner_velocity", square_corner_velocity)
+            # XYZET: {"X": 0, "Y": 0, "Z": 0, "E": 0, "T": ""}
+            state["last_position"] = [XYZET["X"], XYZET["Y"], XYZET["Z"], XYZET["E"]+base_position_e]
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE state:%s" % str(state))
+
+            # Restore state
+            self.absolute_coord = state['absolute_coord']
+            # self.absolute_extrude = state['absolute_extrude']
+            self.base_position = list(state['base_position'])
+            self.homing_position = list(state['homing_position'])
+            self.speed = state['speed']
+            self.speed_factor = state['speed_factor']
+            self.extrude_factor = state['extrude_factor']
+            # Restore the relative E position
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE base_position:%s" % str(self.base_position))
+            e_diff = self.last_position[3] - state['last_position'][3] - 0.7 + 5.0
+            self.base_position[3] += e_diff 
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE self.last_position[3]:%s, state['last_position'][3]:%s, e_diff:%s, \
+                         base_position[3]:%s" % (self.last_position[3], state['last_position'][3], e_diff, self.base_position[3]))
+            # Move the toolhead back if requested
+            gcode = self.printer.lookup_object('gcode')
+            if state["fan_state"]:
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE fan fan_state:%s" % str(state["fan_state"]))
+                for key in state["fan_state"]:
+                    logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE fan set fan:%s#" % str(state["fan_state"].get(key, "")))
+                    gcode.run_script_from_command(state["fan_state"].get(key, ""))
+                # gcode.run_script_from_command(state["fan_state"])
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE before G28 X Y self.last_position:%s" % str(self.last_position))
+            gcode.run_script_from_command("G28 X Y")
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE after G28 X Y self.last_position:%s" % str(self.last_position))
+            x = self.last_position[0]
+            y = self.last_position[1]
+            z = state['last_position'][2] + self.variable_safe_z + state["variable_z_safe_pause"]
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE self.last_position[2]:%s, state['last_position'][2]:%s, self.variable_safe_z:%s, \
+                state['variable_z_safe_pause']:%s" % (self.last_position[2], state['last_position'][2], self.variable_safe_z, state["variable_z_safe_pause"]))
+            # 获取补偿值，解决断电续打虚层、压层问题
+            offset_value = self.printer.lookup_object('virtual_sdcard').offset_value
+            toolhead = self.printer.lookup_object("toolhead")
+            if self.config.has_section("z_align"):
+                gcode.run_script_from_command("BED_MESH_CLEAR")
+                z_align = self.printer.lookup_object('z_align')
+                gcode = self.printer.lookup_object('gcode')
+                gcmd = gcode.create_gcode_command("", "", {})
+                z_align.cmd_ZDOWN(gcmd)
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE BED_MESH_PROFILE LOAD='default'")
+                gcode.run_script_from_command('BED_MESH_PROFILE LOAD="default"')
+                now_pos = toolhead.get_position()
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE after cmd_ZDOWN now_pos:%s"%str(now_pos))
+                adjustments_diff = 0
+#                if self.config.has_section("z_tilt"):
+#                    try:
+#                        z_tilt = self.printer.lookup_object('z_tilt')
+#                        adjustments = z_tilt.get_adjustments()
+#                        logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE z_tilt.get_adjustments:%s" % str(adjustments))
+#                        if adjustments:
+#                            negative = False
+#                            if abs(adjustments[0]) < abs(adjustments[1]):
+#                                if adjustments[1] < 0:
+#                                    negative = True
+#                            else:
+#                                if adjustments[0] < 0:
+#                                    negative = True
+#                            adjustments_diff = abs(adjustments[0]-adjustments[1])/2
+#                            adjustments_diff = adjustments_diff*(-1.0) if negative else adjustments_diff
+#                    except Exception as err:
+#                        logging.exception("RESTORE z_tilt.get_adjustments err:%s" % err)
+#                if adjustments_diff != 0 and abs(adjustments_diff)>4.0:
+#                    logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE adjustments_diff:%s > 3.0" % adjustments_diff)
+#                    adjustments_diff =  adjustments_diff/10
+                cur_z = now_pos[2]+adjustments_diff + offset_value
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE cur_z:%s adjustments_diff:%s" % (cur_z, adjustments_diff))
+                toolhead.set_position([now_pos[0], now_pos[1], cur_z, self.last_position[3]], homing_axes=(2,))
+            else:
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE BED_MESH_PROFILE LOAD='default'")
+                gcode.run_script_from_command('BED_MESH_PROFILE LOAD="default"')
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE toolhead.set_position:%s" % str([x, y, z+offset_value, self.last_position[3]]))
+                toolhead.set_position([x, y, z+offset_value, self.last_position[3]], homing_axes=(2,))
+            speed = self.speed
+            self.last_position[:3] = state['last_position'][:3]
+            box = self.printer.lookup_object("box", None)
+            if box:
+                data = {}
+                try:
+                    with open(box.box_state.tn_save_data_path, "r") as f:
+                        data = json.load(f)
+                except Exception as err:
+                    logging.error(err)
+                box_enable = data.get("enable", -1)
+                logging.info("data:%s" % str(data))
+                gcode.run_script_from_command("BOX_POWER_LOSS_RESTORE")
+                if box_enable == 0:
+                    logging.info("start box.flush_material")
+                    box.flush_material()
+                else:
+                    if XYZET["T"]:
+                        logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE :%s" % XYZET["T"])
+                        gcode.run_script_from_command("M400")
+                        gcode.run_script_from_command(XYZET["T"])
+                        gcode.run_script_from_command("M400")
+                    else:
+                        logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+                        gcode.run_script_from_command("G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            else:
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+                gcode.run_script_from_command("G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE move_with_transform:%s, speed:%s" % (self.last_position, speed))
+            self.move_with_transform(self.last_position, speed)
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            gcode.run_script_from_command("G1 X%s Y%s F3000" % (state['last_position'][0], state['last_position'][1]))
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE M400")
+            gcode.run_script_from_command("M400")
+            gcode.run_script_from_command("SET_Z_LIMIT")
+            if state["M204"]:
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE SET M204:%s#" % state["M204"])
+                gcode.run_script_from_command(state["M204"])
+            self.absolute_extrude = state['absolute_extrude']
+            try:
+                if os.path.exists(gcode.exclude_object_info):
+                    reactor = self.printer.get_reactor()
+                    with open(gcode.exclude_object_info, "r") as f:
+                        exclude_object_cmds = json.loads(f.read())
+                        EXCLUDE_OBJECT_DEFINE = exclude_object_cmds.get("EXCLUDE_OBJECT_DEFINE", [])
+                        EXCLUDE_OBJECT = exclude_object_cmds.get("EXCLUDE_OBJECT", [])
+                        for line in EXCLUDE_OBJECT_DEFINE:
+                            reactor.pause(reactor.monotonic() + 0.001)
+                            gcode.run_script_from_command(line)
+                            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE %s" % str(line))
+                        for line in EXCLUDE_OBJECT:
+                            reactor.pause(reactor.monotonic() + 0.001)
+                            gcode.run_script_from_command(line)
+                            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE %s" % str(line))
+                        gcode.run_script_from_command("M400")
+            except Exception as err:
+                logging.exception("RESTORE EXCLUDE_OBJECT err:%s" % err)
+            try:
+                if state["SET_GCODE_OFFSET"] != -5:
+                    if state["SET_GCODE_OFFSET"] > 0:
+                        params = "-%.3f" % state["SET_GCODE_OFFSET"]
+                    elif state["SET_GCODE_OFFSET"] < 0:
+                        params = "%.3f" % abs(state["SET_GCODE_OFFSET"])
+                    else:
+                        params = "0"
+                    gcode.run_script_from_command("SET_GCODE_OFFSET Z_ADJUST=%s MOVE=0" % params)
+                    gcode.run_script_from_command("Z_OFFSET_APPLY_PROBE")
+                    gcode.run_script_from_command("M400")
+                    logging.info("power_loss SET_GCODE_OFFSET Z_ADJUST:-%s MOVE=0" % state["SET_GCODE_OFFSET"])
+            except Exception as err:
+                logging.error("RESTORE SET_GCODE_OFFSET err:%s" % err)
+            if state["pressure_advance"]:
+                gcode.run_script_from_command("M400")
+                logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE SET pressure_advance:%s#" % state["pressure_advance"])
+                gcode.run_script_from_command(state["pressure_advance"])
+            toolhead.set_max_accel(state["max_accel"])
+            toolhead.requested_accel_to_decel = state["requested_accel_to_decel"]
+            toolhead.square_corner_velocity = state["square_corner_velocity"]
+            logging.info("power_loss max_accel=%s requested_accel_to_decel=%s square_corner_velocity=%s" % (
+                toolhead.get_max_accel(),
+                toolhead.requested_accel_to_decel,
+                toolhead.square_corner_velocity
+            ))
+            logging.info("power_loss cmd_CX_RESTORE_GCODE_STATE done")
+        except Exception as err:
+            logging.exception("cmd_CX_RESTORE_GCODE_STATE err:%s" % err)
+  
     cmd_SAVE_GCODE_STATE_help = "Save G-Code coordinate state"
     def cmd_SAVE_GCODE_STATE(self, gcmd):
         state_name = gcmd.get('NAME', 'default')
@@ -272,5 +684,24 @@ class GCodeMove:
                           % (mcu_pos, stepper_pos, kin_pos, toolhead_pos,
                              gcode_pos, base_pos, homing_pos))
 
+    cmd_SET_POSITION_help = (
+        "SET_POSITION information on the current location of the toolhead")
+    def cmd_SET_POSITION(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead', None)
+        if toolhead is None:
+            raise gcmd.error("""{"code": "key283", "msg": ""Printer not ready"}""")
+        position = toolhead.get_position()
+        x = position[0]
+        y = position[1]
+        z = position[2]
+        e = position[3]
+        X = gcmd.get_float('X', x)
+        Y = gcmd.get_float('Y', y)
+        Z = gcmd.get_float('Z', z)
+        E = gcmd.get_float('E', e)
+        toolhead.set_position([X, Y, Z, E], homing_axes=(2,))
+        position = toolhead.get_position()
+        msg = "toolhead get_position X:%s, Y:%s, Z:%s, E:%s" % (position[0], position[1], position[2], position[3])
+        gcmd.respond_info(msg)
 def load_config(config):
     return GCodeMove(config)
--- a/klippy/extras/heater_bed.py
+++ b/klippy/extras/heater_bed.py
@@ -15,9 +15,14 @@ class PrinterHeaterBed:
         gcode = self.printer.lookup_object('gcode')
         gcode.register_command("M140", self.cmd_M140)
         gcode.register_command("M190", self.cmd_M190)
+        self.max_temp = config.getfloat('max_temp', above=0.0)
+        self.heater_bed_state = 0
+        self.last_pwm_value = 0
     def cmd_M140(self, gcmd, wait=False):
         # Set Bed Temperature
         temp = gcmd.get_float('S', 0.)
+        if temp > self.max_temp - 15.0:
+            temp = self.max_temp - 15.0
         pheaters = self.printer.lookup_object('heaters')
         pheaters.set_temperature(self.heater, temp, wait)
     def cmd_M190(self, gcmd):
--- a/klippy/extras/heater_fan.py
+++ b/klippy/extras/heater_fan.py
@@ -18,6 +18,7 @@ class PrinterHeaterFan:
         self.fan = fan.Fan(config, default_shutdown_speed=1.)
         self.fan_speed = config.getfloat("fan_speed", 1., minval=0., maxval=1.)
         self.last_speed = 0.
+        self.is_ptc_fan = config.getint("is_ptc_fan", 0)
     def handle_ready(self):
         pheaters = self.printer.lookup_object('heaters')
         self.heaters = [pheaters.lookup_heater(n) for n in self.heater_names]
@@ -31,6 +32,17 @@ class PrinterHeaterFan:
             current_temp, target_temp = heater.get_temp(eventtime)
             if target_temp or current_temp > self.heater_temp:
                 speed = self.fan_speed
+        # PTC加热风扇和PTC加热器同步 加热时开启 不加热时进行关闭
+        chamber_heater = self.printer.lookup_object("heater_generic chamber_heater", None)
+        heater_bed_state = self.printer.lookup_object('heater_bed').heater_bed_state
+        if self.is_ptc_fan==1 and target_temp > 40 and chamber_heater:
+            if hasattr(chamber_heater.control, "max_delta"):
+                if chamber_heater.last_pwm_value==0:
+                    speed = 0
+                else:
+                    speed = 0.3
+                if chamber_heater.control.count!=20:
+                    speed = 0
         if speed != self.last_speed:
             self.last_speed = speed
             curtime = self.printer.get_reactor().monotonic()
--- a/klippy/extras/heaters.py
+++ b/klippy/extras/heaters.py
@@ -4,8 +4,7 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import os, logging, threading
-
-
+import numpy as np
 ######################################################################
 # Heater
 ######################################################################
@@ -17,6 +16,10 @@ PID_PARAM_BASE = 255.
 
 class Heater:
     def __init__(self, config, sensor):
+        self.config = config
+        self._info_array = [0]*1
+        self.info_array = np.array(self._info_array, dtype=np.int)
+        self.info_array_addr_int = self.info_array.ctypes.data
         self.printer = config.get_printer()
         self.name = config.get_name().split()[-1]
         # Setup sensor
@@ -27,6 +30,7 @@ class Heater:
         self.sensor.setup_callback(self.temperature_callback)
         self.pwm_delay = self.sensor.get_report_time_delta()
         # Setup temperature checks
+        self.verify_heater = config.getboolean('verify_heater', True)
         self.min_extrude_temp = config.getfloat(
             'min_extrude_temp', 170.,
             minval=self.min_temp, maxval=self.max_temp)
@@ -55,12 +59,47 @@ class Heater:
         self.mcu_pwm.setup_cycle_time(pwm_cycle_time)
         self.mcu_pwm.setup_max_duration(MAX_HEAT_TIME)
         # Load additional modules
-        self.printer.load_object(config, "verify_heater %s" % (self.name,))
+        if self.verify_heater:
+            self.printer.load_object(config, "verify_heater %s" % (self.name,))
         self.printer.load_object(config, "pid_calibrate")
         gcode = self.printer.lookup_object("gcode")
         gcode.register_mux_command("SET_HEATER_TEMPERATURE", "HEATER",
                                    self.name, self.cmd_SET_HEATER_TEMPERATURE,
                                    desc=self.cmd_SET_HEATER_TEMPERATURE_help)
+        # PTC加热前一分钟内使用50%功率加热，一分钟后可以开启100%功率加热
+        self.info_array[0]=self.can_extrude
+        self.start_heating_seconds = 0
+        if self.name == "chamber_heater":
+            self.stop_heating = False
+            self.target_temp = 0.
+            self.printer.register_event_handler('klippy:ready', self.register_chamber_heater_timer)
+    def register_chamber_heater_timer(self):
+        reactor = self.printer.get_reactor()
+        self._chamber_heater_do_query_timer = reactor.register_timer(self._handle_check_chamber_heater)
+        reactor.update_timer(self._chamber_heater_do_query_timer, reactor.NOW)
+    def _handle_check_chamber_heater(self, eventtime):
+        gcode = self.printer.lookup_object('gcode')
+        num = 0
+        fan_feedback = None
+        if self.config.has_section('fan_feedback'):
+            fan_feedback = self.printer.lookup_object('fan_feedback')
+            if self.control.heating and self.last_pwm_value > 0 and self.target_temp and fan_feedback.cx_fan_status.get("fan0_speed", 0) == 0:
+                for _ in range(15):
+                    # 判断连续12s内风扇是否都是处于停止状态
+                    self.printer.get_reactor().pause(self.printer.get_reactor().monotonic() + 1.0)
+                    if self.control.heating and self.last_pwm_value > 0 and self.target_temp and fan_feedback.cx_fan_status.get("fan0_speed", 0) == 0:
+                        num += 1
+                    else:
+                        break
+                if num == 15:
+                    self.stop_heating = True
+                    ptc_fan_last_speed = -1
+                    if self.config.has_section("heater_fan chamber_fan"):
+                        ptc_fan_last_speed = self.printer.lookup_object("heater_fan chamber_fan").last_speed
+                    gcode._respond_error("""{"code":"key519", "msg":"PTC fan_speed is 0, turn off PTC heaters, ptc_fan_last_speed:%s", "values":[]}""" % ptc_fan_last_speed)
+                    gcode.run_script_from_command("M141 S0")               
+        return eventtime + 1.0
+
     def set_pwm(self, read_time, value):
         if self.target_temp <= 0.:
             value = 0.
@@ -85,7 +124,9 @@ class Heater:
             adj_time = min(time_diff * self.inv_smooth_time, 1.)
             self.smoothed_temp += temp_diff * adj_time
             self.can_extrude = (self.smoothed_temp >= self.min_extrude_temp)
+            self.info_array[0]=self.can_extrude
         #logging.debug("temp: %.3f %f = %f", read_time, temp)
+
     # External commands
     def get_pwm_delay(self):
         return self.pwm_delay
@@ -94,6 +135,8 @@ class Heater:
     def get_smooth_time(self):
         return self.smooth_time
     def set_temp(self, degrees):
+        if self.name == 'extruder' and hasattr(self.control, 'dynamically_modify_pid'):
+            self.control.dynamically_modify_pid(degrees)
         if degrees and (degrees < self.min_temp or degrees > self.max_temp):
             raise self.printer.command_error(
                 """{"code":"key340", "msg":"Heaters %s Requested temperature (%.1f) out of range (%.1f:%.1f)", "values":["%s", %.1f, %.1f, %.1f]}"""
@@ -138,8 +181,14 @@ class Heater:
     cmd_SET_HEATER_TEMPERATURE_help = "Sets a heater temperature"
     def cmd_SET_HEATER_TEMPERATURE(self, gcmd):
         temp = gcmd.get_float('TARGET', 0.)
+        wait = True if gcmd.get_int('WAIT', 0)==1 else False
+        if self.name == "chamber_heater":
+            self.target_temp = temp
+            # 重置停止加热标识
+            if self.target_temp > 40:
+                self.stop_heating = False 
         pheaters = self.printer.lookup_object('heaters')
-        pheaters.set_temperature(self, temp)
+        pheaters.set_temperature(self, temp, wait=wait)
 
 
 ######################################################################
@@ -148,20 +197,134 @@ class Heater:
 
 class ControlBangBang:
     def __init__(self, heater, config):
+        self.config = config
+        self.printer = config.get_printer()
         self.heater = heater
         self.heater_max_power = heater.get_max_power()
         self.max_delta = config.getfloat('max_delta', 2.0, above=0.)
         self.heating = False
+        self.long_temp =False
+        self.old_temp = 0.0
+        self.cnt_temp = 0
+        self.prev_temp = AMBIENT_TEMP
+        self.temp_coff = 1.
+        self.diff_tempa = 0
+        self.diff_tempb = 0
+        self.count = 0
     def temperature_update(self, read_time, temp, target_temp):
-        if self.heating and temp >= target_temp+self.max_delta:
-            self.heating = False
-        elif not self.heating and temp <= target_temp-self.max_delta:
-            self.heating = True
+        if (temp + 5.0) < target_temp:
+            self.long_temp = True
+            self.old_temp = 0.0
+            self.cnt_temp = 0
+        if target_temp >= 20 and target_temp<=120:
+            if temp + 0.7 > target_temp:
+                self.long_temp =False
+            if self.long_temp:
+                if self.old_temp <= 0.01 or self.old_temp < temp:
+                    self.old_temp = temp
+                    self.cnt_temp = 0
+                    # self.diff_tempa = 16.1 + (119-16.1)/100.*(target_temp-20.0)
+                    # self.diff_tempb = 16.3 + (119.5-16.3)/100.*(target_temp-20.0)
+                    self.diff_tempa = 16.1 + 1.029 * (target_temp-20.0)
+                    self.diff_tempb = 16.3 + 1.032 * (target_temp-20.0)
+                elif self.old_temp > temp:
+                    self.cnt_temp = self.cnt_temp + 1
+                    if self.cnt_temp > 10:
+                        self.long_temp =False
+            else:
+                # self.diff_tempa = 19.1 + (119.7-19.1)/100.*(target_temp-20.0)
+                # self.diff_tempb = 19.3 + (120.2-19.3)/100.*(target_temp-20.0)
+                self.diff_tempa = 19.1 + 1.006 * (target_temp-20.0)
+                self.diff_tempb = 19.3 + 1.009 * (target_temp-20.0)
+            if self.heating and temp >= self.diff_tempb:
+                self.heating = False
+            elif not self.heating and temp <= self.diff_tempa:
+                self.heating = True
+        else:
+            if self.heating and temp >= target_temp:
+                self.heating = False
+            elif not self.heating and temp <= target_temp-self.max_delta:
+                self.heating = True
+        fan_speed = 0
+        fan_feedback = None
+        if self.config.has_section('fan_feedback'):
+            fan_feedback = self.printer.lookup_object('fan_feedback')
+            fan_speed = fan_feedback.cx_fan_status.get("fan0_speed", 0)
+        is_chamber_heater = True if self.heater.name == "chamber_heater" else False
+        if is_chamber_heater and target_temp and self.count < 20 and self.heater.last_pwm_value > 0:
+            self.count += 1
+        elif is_chamber_heater and target_temp and self.heater.last_pwm_value == 0:
+            self.count = 0
         if self.heating:
-            self.heater.set_pwm(read_time, self.heater_max_power)
+            if self.prev_temp > 0.1:
+                if self.prev_temp - target_temp > 3.:
+                    self.temp_coff = 0.3 * self.temp_coff
+                elif self.prev_temp - target_temp > 2.:
+                    self.temp_coff = 0.5 *self.temp_coff
+                elif self.prev_temp - target_temp > 1.5:
+                    self.temp_coff = 0.65 * self.temp_coff
+                elif self.prev_temp - target_temp > 1.:
+                    self.temp_coff = 0.8 * self.temp_coff
+                elif self.prev_temp < target_temp:
+                    self.temp_coff = 1.5 * self.temp_coff
+            if (temp + 1.5) < target_temp:
+                self.temp_coff = 1.0
+            if self.temp_coff < 0.3:
+                self.temp_coff = 0.3
+            elif self.temp_coff > 1.0:
+                self.temp_coff = 1.0
+            self.prev_temp = 0.
+            heater_bed_state = self.printer.lookup_object('heater_bed').heater_bed_state
+            heater_bed_last_pwm_value = self.printer.lookup_object('heater_bed').last_pwm_value
+            # 在PTC加热的时候处理热床加热逻辑
+            if is_chamber_heater and heater_bed_state == 1:
+                # 热床加热中,不允许开启PTC加热, PTC加热暂停，优先保证热床加热，热床加热完成，再开始PTC加热
+                self.temp_coff = 0
+                self.heater.start_heating_seconds = 0
+            elif is_chamber_heater and self.temp_coff == 0:
+                self.temp_coff = 1.0
+            elif is_chamber_heater and temp < target_temp-self.max_delta and self.heater.start_heating_seconds < 200:
+                # PTC加热前一分钟内使用50%功率加热 why is 200? REPORT_TIME = 0.300 60/REPORT_TIME=200
+                self.heater.start_heating_seconds += 1
+                self.temp_coff = 0.5
+            # elif is_chamber_heater and heater_bed_last_pwm_value > 0.75 and self.temp_coff > 0.5:
+            #     # 如果热床的PID输出功率超过75%，则PTC加热功率减低到50%，直到热床输出功率降低到75%以下
+            #     self.temp_coff = 0.5
+            # elif is_chamber_heater and self.heater.start_heating_seconds == 200:
+            #     # 一分钟后可以开启100%功率加热
+            #     if temp < target_temp - 1.5:
+            #         self.temp_coff = 1.0      
+            # 使用count来计数PTC加热的时间,count=20的时候,大约是连续加热了6s
+            # temp_coff == 0 时对count进行重置
+            #if is_chamber_heater and target_temp and self.count < 20 and self.heater.last_pwm_value > 0:
+            #    self.count += 1
+            #elif is_chamber_heater and target_temp and self.temp_coff == 0:
+            #    self.count = 0
+            # # 到达目标温度附近时, 加热功率调小到12%
+            # if is_chamber_heater and temp > target_temp+self.max_delta:
+            #     self.temp_coff = 0
+            # elif is_chamber_heater and temp > target_temp:
+            #     self.temp_coff = 0.12
+            # elif is_chamber_heater and temp > target_temp-self.max_delta:
+            #     self.temp_coff = 0.2
+            # PTC在加热 但是PTC风扇转速为0时 关闭PTC加热
+            if is_chamber_heater and self.heater.stop_heating:
+                self.temp_coff = 0
+            self.heater.set_pwm(read_time, self.heater_max_power * self.temp_coff)
         else:
             self.heater.set_pwm(read_time, 0.)
+            if target_temp > 0.1:
+                if self.prev_temp < temp:
+                    self.prev_temp = temp
+            else:
+                self.prev_temp = 0.
+                self.temp_coff = 1.0
+            if is_chamber_heater:
+            #    self.count = 0
+                self.heater.start_heating_seconds = 0 
+
     def check_busy(self, eventtime, smoothed_temp, target_temp):
+
         return smoothed_temp < target_temp-self.max_delta
 
 
@@ -169,16 +332,29 @@ class ControlBangBang:
 # Proportional Integral Derivative (PID) control algo
 ######################################################################
 
-PID_SETTLE_DELTA = 1.
-PID_SETTLE_SLOPE = .1
+PID_SETTLE_DELTA = 2.
+PID_SETTLE_SLOPE = .5
 
 class ControlPID:
     def __init__(self, heater, config):
+        self.printer = config.get_printer()
+        self.config = config
+        self.oldco = 0
         self.heater = heater
         self.heater_max_power = heater.get_max_power()
         self.Kp = config.getfloat('pid_Kp') / PID_PARAM_BASE
         self.Ki = config.getfloat('pid_Ki') / PID_PARAM_BASE
         self.Kd = config.getfloat('pid_Kd') / PID_PARAM_BASE
+        self.high_temp_value = config.getint('high_temp_value', default=280)
+        self.Kp_ht = config.getfloat('pid_Kp_high_temp',default=config.getfloat('pid_Kp')) / PID_PARAM_BASE
+        self.Ki_ht = config.getfloat('pid_Ki_high_temp',default=config.getfloat('pid_Ki')) / PID_PARAM_BASE
+        self.Kd_ht = config.getfloat('pid_Kd_high_temp',default=config.getfloat('pid_Kd')) / PID_PARAM_BASE
+        self.pid_calibrate_Kp = None
+        self.pid_calibrate_Ki = None
+        self.pid_calibrate_Kd = None
+        self.pid_calibrate_Kp_ht = None
+        self.pid_calibrate_Ki_ht = None
+        self.pid_calibrate_Kd_ht = None
         self.min_deriv_time = heater.get_smooth_time()
         self.temp_integ_max = 0.
         if self.Ki:
@@ -187,6 +363,31 @@ class ControlPID:
         self.prev_temp_time = 0.
         self.prev_temp_deriv = 0.
         self.prev_temp_integ = 0.
+        self.heating = False
+        # state 0未在加热 1加热中 2已达到目标温度
+        self.heater_bed_state = 0
+    def dynamically_modify_pid(self, target_temp):
+        if target_temp > self.high_temp_value:
+            if self.pid_calibrate_Kp_ht:
+                self.Kp = self.pid_calibrate_Kp_ht
+                self.Ki = self.pid_calibrate_Ki_ht
+                self.Kd = self.pid_calibrate_Kd_ht
+            else:
+                self.Kp = self.Kp_ht
+                self.Ki = self.Ki_ht
+                self.Kd = self.Kd_ht
+        else:
+            if self.pid_calibrate_Kp:
+                self.Kp = self.pid_calibrate_Kp
+                self.Ki = self.pid_calibrate_Ki
+                self.Kd = self.pid_calibrate_Kd
+            else:
+                self.Kp = self.config.getfloat('pid_Kp') / PID_PARAM_BASE
+                self.Ki = self.config.getfloat('pid_Ki') / PID_PARAM_BASE
+                self.Kd = self.config.getfloat('pid_Kd') / PID_PARAM_BASE
+        logging.info("dynamically_modify_pid target_temp:%s pid: Kp=%f Ki=%f Kd=%f"%(target_temp, self.Kp, self.Ki, self.Kd))
+        if self.Ki:
+            self.temp_integ_max = self.heater_max_power / self.Ki
     def temperature_update(self, read_time, temp, target_temp):
         time_diff = read_time - self.prev_temp_time
         # Calculate change of temperature
@@ -205,6 +406,18 @@ class ControlPID:
         #logging.debug("pid: %f@%.3f -> diff=%f deriv=%f err=%f integ=%f co=%d",
         #    temp, read_time, temp_diff, temp_deriv, temp_err, temp_integ, co)
         bounded_co = max(0., min(self.heater_max_power, co))
+       # self.powerpin = self.printer.lookup_object("power_pin")
+
+        # bounded_co = max(0., min(self.heater_max_power, co))
+        # if bounded_co == self.heater_max_power:
+        #     if self.oldco == 0:
+        #       #  self.powerpin.set_power_pin(0)
+        #         self.oldco = self.heater_max_power
+        #     else:
+        #         if self.oldco == self.heater_max_power:
+        #           #  self.powerpin.set_power_pin(1)
+        #
+        #         self.oldco = 0
         self.heater.set_pwm(read_time, bounded_co)
         # Store state for next measurement
         self.prev_temp = temp
@@ -212,6 +425,27 @@ class ControlPID:
         self.prev_temp_deriv = temp_deriv
         if co == bounded_co:
             self.prev_temp_integ = temp_integ
+
+        if self.heater.name == "heater_bed":
+            heater_bed = self.printer.lookup_object('heater_bed')
+            if target_temp == 0:
+                # 未在加热
+                self.heating = False
+                self.heater_bed_state = 0
+            elif target_temp + PID_SETTLE_DELTA < temp:
+                # 已超目标温度
+                self.heating = False
+                self.heater_bed_state = 2
+            elif target_temp and self.check_busy(self.printer.get_reactor().monotonic(), temp, target_temp) == True:
+                # 加热中
+                self.heating = True
+                self.heater_bed_state = 1
+            else:
+                # 已达到目标温度
+                self.heating = False
+                self.heater_bed_state = 2
+            heater_bed.heater_bed_state = self.heater_bed_state
+            heater_bed.last_pwm_value = bounded_co
     def check_busy(self, eventtime, smoothed_temp, target_temp):
         temp_diff = target_temp - smoothed_temp
         return (abs(temp_diff) > PID_SETTLE_DELTA
@@ -241,6 +475,20 @@ class PrinterHeaters:
         gcode.register_command("M105", self.cmd_M105, when_not_ready=True)
         gcode.register_command("TEMPERATURE_WAIT", self.cmd_TEMPERATURE_WAIT,
                                desc=self.cmd_TEMPERATURE_WAIT_help)
+        # Register webhooks
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("breakheater", self._handle_breakheater)
+        self.can_break=False
+        self.can_break_flag = 0
+        self.extruder_temperature_wait = False
+        self.bed_temperature_wait = False
+    def _handle_breakheater(self,web_request):
+        reactor = self.printer.get_reactor()
+        for heater in self.heaters.values():
+            eventtime = reactor.monotonic()
+            if heater.check_busy(eventtime):
+                self.can_break = True
+
     def load_config(self, config):
         self.have_load_sensors = True
         # Load default temperature sensors
@@ -295,10 +543,16 @@ class PrinterHeaters:
         self.gcode_id_to_sensor[gcode_id] = psensor
     def get_status(self, eventtime):
         return {'available_heaters': self.available_heaters,
-                'available_sensors': self.available_sensors}
+                'available_sensors': self.available_sensors,
+                'extruder_temperature_wait': self.extruder_temperature_wait,
+                'bed_temperature_wait': self.bed_temperature_wait}
     def turn_off_all_heaters(self, print_time=0.):
         for heater in self.heaters.values():
             heater.set_temp(0.)
+            # now = self.printer.get_reactor().monotonic()
+            # heater.set_pwm(now, 0.0)
+            # self.target_temp = 0.0
+
     cmd_TURN_OFF_HEATERS_help = "Turn off all heaters"
     def cmd_TURN_OFF_HEATERS(self, gcmd):
         self.turn_off_all_heaters()
@@ -330,10 +584,31 @@ class PrinterHeaters:
         gcode = self.printer.lookup_object("gcode")
         reactor = self.printer.get_reactor()
         eventtime = reactor.monotonic()
-        while not self.printer.is_shutdown() and heater.check_busy(eventtime):
+        self.can_break_flag = 1
+        self.can_break = False
+        if "heater_bed" in heater.name:
+            self.bed_temperature_wait = True
+        else:
+            self.extruder_temperature_wait = True
+        while not self.printer.is_shutdown() and heater.check_busy(eventtime) :
+            if self.can_break:
+                self.can_break_flag = 2
+                self.can_break = False
+                # toolhead._handle_shutdown()
+                #toolhead.move_queue.reset()
+                # self.turn_off_all_heaters()
+                #gcode.run_script("G28")
+
+                break
             print_time = toolhead.get_last_move_time()
             gcode.respond_raw(self._get_temp(eventtime))
             eventtime = reactor.pause(eventtime + 1.)
+        if self.can_break_flag != 2:
+            self.can_break_flag = 3
+        if "heater_bed" in heater.name:
+            self.bed_temperature_wait = False
+        else:
+            self.extruder_temperature_wait = False
     def set_temperature(self, heater, temp, wait=False):
         toolhead = self.printer.lookup_object('toolhead')
         toolhead.register_lookahead_callback((lambda pt: None))
@@ -359,7 +634,7 @@ class PrinterHeaters:
         toolhead = self.printer.lookup_object("toolhead")
         reactor = self.printer.get_reactor()
         eventtime = reactor.monotonic()
-        while not self.printer.is_shutdown():
+        while not self.printer.is_shutdown() and not self.can_break:
             temp, target = sensor.get_temp(eventtime)
             if temp >= min_temp and temp <= max_temp:
                 return
--- a/klippy/extras/homing.py
+++ b/klippy/extras/homing.py
@@ -3,7 +3,8 @@
 # Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, math
+import logging, math, json, os
+from extras.z_align import MOTOR_PROTECT_ERROR
 
 HOMING_START_DELAY = 0.001
 ENDSTOP_SAMPLE_TIME = .000015
@@ -41,6 +42,9 @@ class HomingMove:
         self.endstops = endstops
         if toolhead is None:
             toolhead = printer.lookup_object('toolhead')
+
+        self.prtouch_v3 = printer.lookup_object('prtouch_v3')
+        self.prtouch_v3.z_full_movement_flag = False
         self.toolhead = toolhead
         self.stepper_positions = []
     def get_mcu_endstops(self):
@@ -65,6 +69,16 @@ class HomingMove:
             kin_spos[sname] += offsets.get(sname, 0) * stepper.get_step_dist()
         thpos = self.toolhead.get_position()
         return list(kin.calc_position(kin_spos))[:3] + thpos[3:]
+    def handle_force_stop(self):
+        # 拉高pa9 en引脚, 清除运动队列, 查询保护码, 设置xy电机到错误码输出模式
+        # self.printer.lookup_object('motor_control').force_stop()
+        toolhead = self.printer.lookup_object('toolhead')
+        toolhead._handle_shutdown()
+        toolhead.reactor.pause(toolhead.reactor.monotonic() + 1.0)
+        gcode = self.printer.lookup_object('gcode')
+        gcode.run_script_from_command("MOTOR_CHECK_PROTECTION_AFTER_HOME DATA=11")
+        gcode.run_script_from_command("MOTOR_STALL_MODE DATA=2")
+        toolhead.can_pause = True
     def homing_move(self, movepos, speed, probe_pos=False,
                     triggered=True, check_triggered=True):
         # Notify start of homing/probing move
@@ -74,9 +88,11 @@ class HomingMove:
         kin = self.toolhead.get_kinematics()
         kin_spos = {s.get_name(): s.get_commanded_position()
                     for s in kin.get_steppers()}
+        
         self.stepper_positions = [ StepperPosition(s, name)
                                    for es, name in self.endstops
                                    for s in es.get_steppers() ]
+
         # Start endstop checking
         print_time = self.toolhead.get_last_move_time()
         endstop_triggers = []
@@ -94,6 +110,8 @@ class HomingMove:
             self.toolhead.drip_move(movepos, speed, all_endstop_trigger)
         except self.printer.command_error as e:
             error = """{"code":"key20", "msg":"Error during homing move: %s", "values": [%s]}""" % (str(e),str(e))
+            logging.info("No trigger on %s after full movement, set MOTOR_STALL_MODE DATA=2"%name)
+            self.handle_force_stop()
         # Wait for endstops to trigger
         trigger_times = {}
         move_end_print_time = self.toolhead.get_last_move_time()
@@ -103,8 +121,19 @@ class HomingMove:
                 trigger_times[name] = trigger_time
             elif trigger_time < 0. and error is None:
                 error = """{"code":"key21", "msg":"Communication timeout during homing %s", "values": ["%s"]}""" % (name, name)
+                logging.info("Communication timeout during homing %s, set MOTOR_STALL_MODE DATA=2"%name)
+                self.handle_force_stop()
             elif check_triggered and error is None:
                 error = """{"code":"key22", "msg":"No trigger on %s after full movement", "values": ["%s"]}""" % (name, name)
+                # z轴误触发后,对x、y电机进行切换为错误码输出模式
+                if name == "z":
+                    error = None
+                    self.prtouch_v3.z_full_movement_flag = True
+                    logging.info("No trigger on z after full movement, set MOTOR_STALL_MODE DATA=2")
+                    gcode = self.printer.lookup_object('gcode')
+                    gcode.run_script_from_command("MOTOR_STALL_MODE DATA=2")
+                logging.info("No trigger on %s after full movement, set MOTOR_STALL_MODE DATA=2"%name)
+                self.handle_force_stop()
         # Determine stepper halt positions
         self.toolhead.flush_step_generation()
         for sp in self.stepper_positions:
@@ -144,7 +173,7 @@ class HomingMove:
             if sp.start_pos == sp.trig_pos:
                 return sp.endstop_name
         return None
-
+        
 # State tracking of homing requests
 class Homing:
     def __init__(self, printer):
@@ -153,6 +182,10 @@ class Homing:
         self.changed_axes = []
         self.trigger_mcu_pos = {}
         self.adjust_pos = {}
+        self.stepper_z_sensorless_flag = False
+        self.out_z_all = 0
+        self.homez_info = None
+
     def set_axes(self, axes):
         self.changed_axes = axes
     def get_axes(self):
@@ -170,6 +203,19 @@ class Homing:
         return thcoord
     def set_homed_position(self, pos):
         self.toolhead.set_position(self._fill_coord(pos))
+
+    def get_step(self,endstops):
+        self.stepper_positions = [ StepperPosition(s, name)
+                                   for es, name in endstops
+                                   for s in es.get_steppers() ]
+        for sp in self.stepper_positions:
+            if sp.stepper_name == "stepper_z":
+                kin = self.toolhead.get_kinematics()
+                halt_step_dist = {s.get_name(): s.get_step_dist()
+                                 for s in kin.get_steppers()}
+                logging.info("start_pos:%s trig_pos:%s halt_step_dist:%s" % (sp.start_pos,sp.trig_pos,halt_step_dist[sp.stepper_name]))
+                return [sp.start_pos, halt_step_dist[sp.stepper_name]]
+        return None
     def home_rails(self, rails, forcepos, movepos):
         # Notify of upcoming homing operation
         self.printer.send_event("homing:home_rails_begin", self, rails)
@@ -181,8 +227,17 @@ class Homing:
         # Perform first home
         endstops = [es for rail in rails for es in rail.get_endstops()]
         hi = rails[0].get_homing_info()
+        # 获取归零开始时的z电机step
+        _homez_info = self.get_step(endstops)
+        if _homez_info is not None:
+            # 记录start_pos halt_pos step_dist数据
+            self.homez_info = _homez_info
         hmove = HomingMove(self.printer, endstops)
-        hmove.homing_move(homepos, hi.speed)
+        if self.stepper_z_sensorless_flag:
+            hmove.homing_move(homepos, hi.speed*4, False, True, False)
+        else:
+            hmove.homing_move(homepos, hi.speed)      
+
         # Perform second home
         if hi.retract_dist:
             # Retract
@@ -200,7 +255,20 @@ class Homing:
             self.toolhead.set_position(startpos)
             hmove = HomingMove(self.printer, endstops)
             hmove.homing_move(homepos, hi.second_homing_speed)
-            if hmove.check_no_movement() is not None:
+
+            if hmove.check_no_movement() is not None and rails[0].get_name() == "stepper_z":
+                hmove.prtouch_v3.z_full_movement_flag = True
+                self.printer.send_event("homing:homing_move_end", hmove)
+
+
+            # 获取停止时后的z电机step
+            _homez_info = self.get_step(endstops)
+            if _homez_info is not None:
+                # 只更新halt_pos数据
+                self.out_z_all = abs(self.homez_info[0] - _homez_info[0]) * self.homez_info[1]
+            if hmove.check_no_movement() is not None and rails[0].get_name() != "stepper_z":
+                logging.info("hmove.check_no_movement %s, set MOTOR_STALL_MODE DATA=2" % hmove.check_no_movement())
+                hmove.handle_force_stop()
                 raise self.printer.command_error(
                     """{"code":"key23", "msg":"Endstop %s still triggered after retract", "values": ["%s"]}"""
                     % (hmove.check_no_movement(), hmove.check_no_movement()))
@@ -224,10 +292,19 @@ class Homing:
 
 class PrinterHoming:
     def __init__(self, config):
+        self.config = config
         self.printer = config.get_printer()
         # Register g-code commands
         gcode = self.printer.lookup_object('gcode')
+        gcode.register_command('RECOVERY_Z_ADJUSTMENT', self.cmd_RECOVERY_Z_ADJUSTMENT)
         gcode.register_command('G28', self.cmd_G28)
+        gcode.register_command('STEPPER_Z_SENEORLESS', self.cmd_STEPPER_Z_SENEORLESS)
+        self.probe_type = ""
+        if config.has_section('prtouch_v2'):
+            self.probe_type = "prtouch_v2"
+        elif config.has_section('bltouch'):
+            self.probe_type = "bltouch"
+        self.z_move = 0
     def manual_home(self, toolhead, endstops, pos, speed,
                     triggered, check_triggered):
         hmove = HomingMove(self.printer, endstops, toolhead)
@@ -244,7 +321,10 @@ class PrinterHoming:
         endstops = [(mcu_probe, "probe")]
         hmove = HomingMove(self.printer, endstops)
         try:
-            epos = hmove.homing_move(pos, speed, probe_pos=True)
+            if self.probe_type == "prtouch_v2":
+                epos = self.printer.lookup_object('probe').mcu_probe.run_G29_Z()
+            else:
+                epos = hmove.homing_move(pos, speed, probe_pos=True)
         except self.printer.command_error:
             if self.printer.is_shutdown():
                 raise self.printer.command_error(
@@ -255,7 +335,38 @@ class PrinterHoming:
         #     raise self.printer.command_error(
         #         '{"code": "key6", "msg": "Probe triggered prior to movement"}')
         return epos
+        
+    def cmd_STEPPER_Z_SENEORLESS(self, gcmd):
+        toolhead = self.printer.lookup_object('toolhead')
+        move_dist = gcmd.get_int('MOVE_DIST', default=0, minval=0, maxval=360)
+        homing_state = Homing(self.printer)
+        homing_state.set_axes([2])
+        kin = self.printer.lookup_object('toolhead').get_kinematics()
+        gcode = self.printer.lookup_object('gcode')
+        gcode.respond_info("cmd_STEPPER_Z_SENEORLESS")
+        gcode.respond_info("move_dist {}".format(move_dist))
+        kin.home_z_with_sensorless(homing_state, move_dist)
+        # gcode = self.printer.lookup_object('gcode')
+        pos = toolhead.get_position()
+        pos[2] = move_dist - 3
+        toolhead.set_position(pos, homing_axes=[2])
+        #gcode.run_script_from_command('G4 P1000')
+        #gcode.run_script_from_command('G91')
+        #gcode.run_script_from_command('G1 Z-5 F2400')
+        #gcode.run_script_from_command('M400')
+        #gcode.run_script_from_command('G90')
+        #toolhead.manual_move([None, None, 0.], 5)
+        if hasattr(toolhead.get_kinematics(), "note_z_not_homed"):
+            toolhead.get_kinematics().note_z_not_homed()
+
+    def cmd_RECOVERY_Z_ADJUSTMENT(self, gcmd):
+        # 调用ZDOWN后再调用此处 恢复z_tilt调整值
+        self.resume_adjustment()
+
     def cmd_G28(self, gcmd):
+        # leave flush area
+        if self.printer.lookup_object('box').has_flushing_sign():
+            self.run_gcmd('LEAVE_FLUSH_AREA')
         # Move to origin
         axes = []
         for pos, axis in enumerate('XYZ'):
@@ -265,15 +376,217 @@ class PrinterHoming:
             axes = [0, 1, 2]
         homing_state = Homing(self.printer)
         homing_state.set_axes(axes)
-        kin = self.printer.lookup_object('toolhead').get_kinematics()
+        toolhead = self.printer.lookup_object('toolhead')
+        kin = toolhead.get_kinematics()
+        gcode = self.printer.lookup_object('gcode')
         try:
-            kin.home(homing_state)
-        except self.printer.command_error:
+            if self.probe_type == "prtouch_v2":
+                for a in axes:
+                    if a == 0 or a == 1:
+                        homing_state.set_axes([a])
+                        kin.home(homing_state)
+                    else:
+                        self.printer.lookup_object('probe').mcu_probe.run_G28_Z()
+            else:
+                homing_state.out_z_all = 0
+                for a in axes:
+                    if a == 0 or a == 1:
+                        homing_state.set_axes([a])
+                        kin.home(homing_state)
+                    else:
+                        if self.config.has_section("z_align"):
+                            self.run_gcmd("BED_MESH_CLEAR", wait=True)
+                            max_accel = toolhead.get_max_accel()
+                            z_align = self.printer.lookup_object('z_align')
+                            z_align.force_stop_flag = False
+                            gcode.respond_info("is_already_zodwn:%s zdown_switch_enable:%s" % (z_align.is_already_zodwn, z_align.zdown_switch_enable))
+                            # 检测到没有做过下光电归位时,强制做一次下光电归位
+                            if z_align.is_already_zodwn==False:
+                                gcode.run_script_from_command("SET_VELOCITY_LIMIT ACCEL=300")
+                                ret = self.run_G28_two_Z()
+                                if ret == MOTOR_PROTECT_ERROR:
+                                    gcode.respond_info("Z MOTOR_PROTECT_ERROR")
+                                    raise
+                                gcode.run_script_from_command("SET_VELOCITY_LIMIT ACCEL=%s" % max_accel )
+                                kin.home(homing_state)
+                                gcode.respond_info("za1:%s za2:%s z_max:%s"%(self.z_move,homing_state.out_z_all,(self.z_move+homing_state.out_z_all)))
+                                if toolhead.G29_flag == True:
+                                    gcode.respond_info("save config za1:%s za2:%s z_max:%s"%(self.z_move,homing_state.out_z_all,(self.z_move+homing_state.out_z_all)))
+                                    self.write_real_zmax(self.z_move+homing_state.out_z_all)
+                                z_align.is_already_zodwn = True
+                                gcode.run_script_from_command("SET_Z_LIMIT")
+                                continue
+                            # zdown_switch_enable==1时,强制做光电找平; zdown_switch_enable==0时,不做光电找平
+                            if z_align.zdown_switch_enable==1:
+                                z_align.zdown_switch_enable = 0
+                                gcode.run_script_from_command("SET_VELOCITY_LIMIT ACCEL=300")
+                                ret = self.run_G28_two_Z()
+                                if ret == MOTOR_PROTECT_ERROR:
+                                    gcode.respond_info("Z MOTOR_PROTECT_ERROR")
+                                    raise
+                                gcode.run_script_from_command("SET_VELOCITY_LIMIT ACCEL=%s" % max_accel )
+                                kin.home(homing_state)
+                                gcode.respond_info("za1:%s za2:%s z_max:%s"%(self.z_move,homing_state.out_z_all,(self.z_move+homing_state.out_z_all)))
+                                if toolhead.G29_flag == True:
+                                    gcode.respond_info("save config za1:%s za2:%s z_max:%s"%(self.z_move,homing_state.out_z_all,(self.z_move+homing_state.out_z_all)))
+                                    self.write_real_zmax(self.z_move+homing_state.out_z_all)
+                                z_align.is_already_zodwn = True
+                                gcode.run_script_from_command("SET_Z_LIMIT")
+                                continue
+                            curtime = self.printer.get_reactor().monotonic()
+                            gcode_move = self.printer.lookup_object('gcode_move')
+                            if 'z' in toolhead.get_status(curtime)['homed_axes'] and z_align.is_already_zodwn==True and \
+                              gcode_move.get_status(curtime)['position'][2] > 10:
+                                gcmd = 'G1 F%d Z%.3f' % (30 * 60, 10)
+                                self.run_gcmd(gcmd, wait=True)
+                            # 不做光电找平
+                            kin.home(homing_state)
+                            gcode.run_script_from_command("SET_Z_LIMIT")
+                        else:
+                            kin.home(homing_state)
+        except self.printer.command_error as err:
+            logging.exception(err)
+            self.set_stall_mode(gcode)
             if self.printer.is_shutdown():
                 raise self.printer.command_error(
                     "Homing failed due to printer shutdown")
             self.printer.lookup_object('stepper_enable').motor_off()
             raise
+        except Exception as err:
+            logging.exception(err)
+            self.set_stall_mode(gcode)
+            raise
+    def set_stall_mode(self, gcode, check_protection=True):
+        if self.config.has_section("motor_control") and self.config.getsection('motor_control').getint('switch')==1:
+            # gcode.run_script_from_command("MOTOR_CLEAR_ERR_WARN_CODE NUM=0 DATA=5") # 清除错误码
+            self.printer.lookup_object('motor_control').is_homing = False
+            raise
+            # gcode.run_script_from_command("MOTOR_STALL_MODE DATA=2") # stall 引脚模式切换为紧急保护输出模式
+            # self.printer.get_reactor().pause(self.printer.get_reactor().monotonic() + 1.0)
+            # self.printer.lookup_object('motor_control').is_homing = False
+            # if check_protection:
+            #     gcode.run_script_from_command("MOTOR_CHECK_PROTECTION_AFTER_HOME DATA=10") # 查询电机是否有错误码
+    def write_real_zmax(self, data):
+        z_align = self.printer.lookup_object('z_align')
+        max_z = self.config.getsection('stepper_z').getfloat('position_max', default=360)
+        logging.info("stepper_z position_max:%s" % max_z)
+        if data < max_z-15 or data > max_z:
+            logging.error("real zmax out of range[%s, %s]: %s" % ((max_z-15), max_z, data))
+            return
+        real_zmax_path = z_align.get_real_zmax_path()
+        with open(real_zmax_path, "w") as f:
+            logging.info("real_zmax_path write zmax:%s" % data)
+            f.write(json.dumps({"zmax": data}))
+            f.flush()
+
+    def run_G28_two_Z(self):
+        try:
+            # self.move_to_center(speed=50, wait=True)
+            gcode = self.printer.lookup_object('gcode')
+            gcmd = gcode.create_gcode_command("", "", {})
+            z_align = self.printer.lookup_object('z_align')
+            ret = z_align.cmd_ZDOWN(gcmd)
+            gcode = self.printer.lookup_object('gcode')
+            gcode.respond_info("ZDOWN ret:%s"%ret)
+            if ret == MOTOR_PROTECT_ERROR:
+                return MOTOR_PROTECT_ERROR
+            # self.resume_adjustment()
+            # self.set_max_z_pos()
+            max_z = self.config.getsection('stepper_z').getfloat('position_max')
+            # distance_ratio 向上快速运动距离的比例系数
+            distance_ratio = self.printer.lookup_object('z_align').distance_ratio
+            self.z_move = max_z*distance_ratio
+            self.move_z(speed=30, height=self.z_move) 
+            # 检测电机保护错误码是否存在
+            if self.config.has_section("motor_control") and self.config.getsection('motor_control').getint('switch')==1:
+                motor_error_code = self.printer.lookup_object('motor_control').motor_error_code
+                for i in range(1,5):
+                    if motor_error_code.get(str(i), 0):
+                        gcode.respond_info("%s motor_error_code..." % str(i))
+                        return MOTOR_PROTECT_ERROR
+        except Exception as err:
+            logging.exception(err)
+        return 0
+
+    def resume_adjustment(self):
+        z_tilt = self.printer.lookup_object('z_tilt')
+        if os.path.exists(z_tilt.stepper_adjustment_path):
+            result = {}
+            with open(z_tilt.stepper_adjustment_path, "r") as f:
+                try:
+                    result = json.loads(f.read())
+                except Exception as err:
+                    pass
+            if result:
+                self.move_z(speed=20, height=9)
+                stepper_z_adjustment = result.get("stepper_z_adjustment", 0)
+                stepper_z1_adjustment = result.get("stepper_z1_adjustment", 0)
+                # gcmd_z = "FORCE_MOVE STEPPER=stepper_z DISTANCE=%s VELOCITY=5" % (-stepper_z_adjustment)
+                # gcmd_z1 = "FORCE_MOVE STEPPER=stepper_z1 DISTANCE=%s VELOCITY=5" % (-stepper_z1_adjustment)
+                gcmd_z = "FORCE_MOVE STEPPER=stepper_z DISTANCE=%s VELOCITY=5" % stepper_z_adjustment # 热床下降 stepper_z_adjustment > 0
+                gcmd_z1 = "FORCE_MOVE STEPPER=stepper_z1 DISTANCE=%s VELOCITY=5" % stepper_z1_adjustment
+                tolerance = abs(stepper_z1_adjustment) if abs(stepper_z_adjustment) > abs(stepper_z1_adjustment) else abs(stepper_z_adjustment)
+                self.run_gcmd(gcmd_z, wait=False)
+                self.run_gcmd(gcmd_z1, wait=False)
+                # reactor = self.printer.get_reactor()
+                # reactor.pause(reactor.monotonic() + 1.0)
+                self.move_z(speed=20, height=-9)
+                # self.move_z(speed=20, height=-(9-tolerance))
+
+    def run_gcmd(self, gcmd, wait=True):
+        toolhead = self.printer.lookup_object('toolhead')
+        gcode = self.printer.lookup_object('gcode')
+        logging.info("run_gcmd:%s"%gcmd)
+        gcode.run_script_from_command(gcmd)
+        if wait:
+            toolhead.wait_moves()
+
+    def move_to_center(self, speed, wait=True):
+        toolhead = self.printer.lookup_object('toolhead')
+        now_pos = pos = toolhead.get_position()
+        min_x = self.config.getsection('stepper_x').getfloat('position_min')
+        max_x = self.config.getsection('stepper_x').getfloat('position_max')
+        min_y = self.config.getsection('stepper_y').getfloat('position_min')
+        max_y = self.config.getsection('stepper_y').getfloat('position_max')
+        home_x = min_x + (max_x - min_x) / 2
+        home_y = min_y + (max_y - min_y) / 2
+        pos[0] = home_x
+        pos[1] = home_y
+        gcmd = 'G1 F%d X%.3f Y%.3f' % (speed * 60, pos[0], pos[1])
+        self.run_gcmd(gcmd, wait=True)
+
+    def move_z(self, speed=50, wait=True, height=5):
+        toolhead = self.printer.lookup_object('toolhead')
+        now_pos = toolhead.get_position()
+        toolhead.set_position(now_pos, homing_axes=(2,))
+        logging.info("move_z now_pos:%s"%str(now_pos))
+        slow_up_pos = now_pos[2] - 4
+        now_pos[2] = now_pos[2] - height
+        gcmd = 'G1 F%d X%.3f Y%.3f Z%.3f' % (speed * 60, now_pos[0], now_pos[1], now_pos[2])
+        logging.info("move_z gcmd:%s"%gcmd)
+        self.run_gcmd("G4 P200", wait=True)
+        self.run_gcmd(gcmd, wait=True)
+
+    def set_max_z_pos(self):
+        toolhead = self.printer.lookup_object('toolhead')
+        now_pos = toolhead.get_position()
+        logging.info("before set_max_z_pos cur toolhead.set_position:%s" % str(now_pos))
+        now_pos[2] = self.config.getsection('stepper_z').getfloat('position_max')
+        toolhead.set_position(now_pos, homing_axes=(2,))
+        logging.info("after set_max_z_pos cur toolhead.set_position:%s" % str(now_pos))
+
+    # def check_endstops_z(self):
+    #     query_endstops = self.printer.load_object(self.config, 'query_endstops')
+    #     # endstops_z = query_endstops.endstops[2][0]
+    #     # endstops_z1 = query_endstops.endstops[3][0]
+    #     endstops_z_z1 = [query_endstops.endstops[2], query_endstops.endstops[3]]
+    #     print_time = self.printer.lookup_object('toolhead').get_last_move_time()
+    #     last_state = [(name, mcu_endstop.query_endstop(print_time))
+    #                     for mcu_endstop, name in endstops_z_z1]
+    #     result = [(name, ["open", "TRIGGERED"][not not t]) for name, t in last_state]
+    #     if result[0][1] == "TRIGGERED" or result[1][1] == "TRIGGERED":
+    #         return (True, result)
+    #     return (False, result)
 
 def load_config(config):
     return PrinterHoming(config)
--- a/klippy/extras/homing_override.py
+++ b/klippy/extras/homing_override.py
@@ -6,6 +6,7 @@
 
 class HomingOverride:
     def __init__(self, config):
+        self.config = config
         self.printer = config.get_printer()
         self.start_pos = [config.getfloat('set_position_' + a, None)
                           for a in 'xyz']
@@ -18,6 +19,10 @@ class HomingOverride:
         self.prev_G28 = self.gcode.register_command("G28", None)
         self.gcode.register_command("G28", self.cmd_G28)
     def cmd_G28(self, gcmd):
+        if self.config.has_section("motor_control") and self.config.getsection('motor_control').getint('switch')==1:
+            if self.printer.lookup_object('motor_control').is_ready == False:
+                self.gcode.respond_info("The motor parameters are initializing, Please try again later...")
+                return
         if self.in_script:
             # Was called recursively - invoke the real G28 command
             self.prev_G28(gcmd)
--- /dev/null
+++ b/klippy/extras/hx711s.py
@@ -0,0 +1,207 @@
+# Support for 1-wire based temperature sensors
+#
+# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from os import remove
+import time
+import mcu
+import math
+
+class HX711S:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.gcode = self.printer.lookup_object("gcode")
+        self.s_count = config.getint('count', 1, 1, 4)
+        self.base_avgs = [0, 0, 0, 0]
+        self.del_dirty = False
+        self.index_dirty = 0
+        self.start_tick = 0
+        self.need_wait = False
+        self.s_clk_pin = []
+        self.s_sdo_pin = []
+        self.all_params = []
+        self.all_vals = [[], [], [], []]
+        for i in range(self.s_count):
+            self.s_clk_pin.append(config.get('sensor%d_clk_pin' % i, None if i == 0 else self.s_clk_pin[i - 1]))
+            self.s_sdo_pin.append(config.get('sensor%d_sdo_pin' % i, None if i == 0 else self.s_sdo_pin[i - 1]))
+        self.mcu = mcu.get_printer_mcu(self.printer, config.get('use_mcu'))
+        self.oid = self.mcu.create_oid()
+        self.mcu.register_config_callback(self._build_config)
+        self.mcu.register_response(self._handle_debug_hx711s, "debug_hx711s", self.oid)
+        self.mcu.register_response(self._handle_result_hx711s, "result_hx711s", self.oid)
+        self.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.printer.register_event_handler("klippy:shutdown", self._handle_shutdown)
+        self.printer.register_event_handler("klippy:disconnect", self._handle_disconnect)
+        self.gcode.register_command('READ_HX711', self.cmd_READ_HX711, desc=self.cmd_READ_HX711_help)
+        self.pi_count = int(0)
+        self.show_msg = False
+        self.filter = None 
+        self.query_cmd = None
+        self.mcu_freq = 72000000
+        self.last_send_heart = 0.
+        self.is_shutdown = True
+        self.is_timeout = True
+        pass
+
+    def _build_config(self):
+        self.mcu.add_config_cmd("config_hx711s oid=%d hx711_count=%d" % (self.oid, self.s_count))
+        pins = self.printer.lookup_object("pins") 
+        for i in range(self.s_count):
+            clk_pin_params = pins.lookup_pin(self.s_clk_pin[i])
+            sdo_pin_params = pins.lookup_pin(self.s_sdo_pin[i])
+            self.mcu.add_config_cmd("add_hx711s oid=%d index=%d clk_pin=%s sdo_pin=%s" % (self.oid, i, clk_pin_params['pin'], sdo_pin_params['pin']))
+        # self.query_cmd = self.mcu.lookup_command("query_hx711s oid=%c times_read=%hu is_ck_con=%c", cq=None)
+        self.query_cmd = self.mcu.lookup_command("query_hx711s oid=%c times_read=%hu", cq=None)
+        self.filter = self.printer.lookup_object('filter')
+        self.mcu_freq = self.mcu.get_constant_float('CLOCK_FREQ')
+        pass
+
+    def _handle_mcu_identify(self):
+        # self.send_heart_beat_cmd = self.mcu.lookup_query_command(
+        #     "heart_beat_hx711s oid=%c",
+        #     "heart_beat_hx711s_result oid=%c",
+        #     oid=self.oid, cq=None)
+        pass
+
+        self.is_shutdown = False
+        self.is_timeout = False
+        pass
+
+    def _handle_debug_hx711s(self, params):
+        self.printer.lookup_object('prtouch').pnt_msg(str(params))
+        pass
+
+    def _handle_shutdown(self):
+        self.is_shutdown = True
+        pass
+
+    def _handle_disconnect(self):
+        self.is_timeout = True
+        pass
+
+    def _handle_result_hx711s(self, params):
+        while self.need_wait:
+            self.delay_s(0.001)
+        self.start_tick = self.start_tick if len(self.all_params) != 0 else params['nt']
+        if self.del_dirty and (params['vd'] != 0 or params['it'] > 20) and self.index_dirty == 0:
+            self.index_dirty = 1
+            return
+        self.index_dirty -= 1 if self.index_dirty == 1 else 0
+        self.all_params.append(params)
+        for i in range(self.s_count):
+            self.all_vals[i].append(params['v%d' % i] - self.base_avgs[i])
+        if self.show_msg:
+            self.gcode.respond_info('Hx711 Val=' + str(params))
+        if len(self.all_params) > self.pi_count:
+            del self.all_params[0]
+            for i in range(self.s_count):
+                del self.all_vals[i][0]
+        pass
+
+    def query_start(self, pi_count, cycle_count, del_dirty=False, show_msg=False, is_ck_con=False):
+        if self.is_shutdown or self.is_timeout:
+            pass
+        if cycle_count != 0:
+            self.pi_count = pi_count
+            self.all_params = []
+            self.all_vals = [[], [], [], []]
+            self.show_msg = show_msg
+            self.del_dirty = del_dirty
+            self.index_dirty = 0
+        # self.query_cmd.send([self.oid, cycle_count, 1 if is_ck_con else 0])
+        self.query_cmd.send([self.oid, cycle_count])
+        pass
+
+    def get_params(self):
+        self.need_wait = True
+        tmps = [x for x in self.all_params]
+        self.need_wait = False
+        return tmps, self.start_tick
+
+    def get_vals(self):
+        self.need_wait = True
+        tmps = [[], [], [], []]
+        for i in range(self.s_count):
+            tmps[i] = [x for x in self.all_vals[i]]
+        self.need_wait = False
+        return tmps
+
+    def delay_s(self, delay_s):
+        toolhead = self.printer.lookup_object("toolhead")
+        reactor = self.printer.get_reactor()
+        eventtime = reactor.monotonic()
+        if not self.printer.is_shutdown():
+            toolhead.get_last_move_time()
+            eventtime = reactor.pause(eventtime + delay_s)
+            pass
+
+    def send_heart_beat(self):
+        # if time.time() - self.last_send_heart > 0.1:
+        #     self.send_heart_beat_cmd.send([self.oid])
+        #     self.last_send_heart = time.time()
+        pass
+
+    def read_base(self, cnt, max_hold, reset_zero=True):
+        avgs = [0, 0, 0, 0]
+        rvs = [[], [], [], []]
+        for i in range(3):
+            self.base_avgs = [0, 0, 0, 0]
+            avgs = [0, 0, 0, 0]
+            self.query_start(cnt, cnt + 5, del_dirty=True, show_msg=False)
+            t_last = time.time()
+            while not (self.is_shutdown or self.is_timeout) and len(self.get_vals()[0]) < cnt and (time.time() - t_last) < cnt * 0.010 * 15:
+                self.delay_s(0.010)
+                pass
+            vals = self.get_vals()
+            if len(vals[0]) < cnt:
+                raise self.printer.command_error("""{"code":"key503", "msg":"z-Touch::read_base: Can not read z-Touch data."}""")
+                
+            for j in range(self.s_count):
+                del vals[j][0:int(len(vals[j]) / 2)]
+            for j in range(self.s_count):
+                del vals[j][vals[j].index(min(vals[j]))]
+                del vals[j][vals[j].index(min(vals[j]))]
+                del vals[j][vals[j].index(max(vals[j]))]
+                del vals[j][vals[j].index(max(vals[j]))]
+            rvs = [[], [], [], []]
+            tf = self.filter.get_tft()
+            lf = self.filter.get_lft(0.5)
+            for j in range(self.s_count):
+                vals[j] = tf.ftr_val(vals[j])
+                vals[j] = lf.ftr_val(vals[j])
+                rvs[j].append(min(vals[j]))
+                rvs[j].append(sum(vals[j]) / len(vals[j]))
+                rvs[j].append(max(vals[j]))
+                avgs[j] = sum(vals[j]) / len(vals[j])
+                self.printer.lookup_object('prtouch').pnt_msg('READ_BASE ch=%d min=%.2f avg=%.2f max=%.2f' % (j, rvs[j][-3], avgs[j], rvs[j][-1]))
+            if reset_zero:
+                self.base_avgs = avgs
+
+            sum_max = 0
+            for j in range(self.s_count):
+                sum_max += math.fabs(rvs[j][2] - rvs[j][0])
+            if sum_max < max_hold * 2:
+                break
+        return avgs, rvs
+
+    cmd_READ_HX711_help = "Read hx711s vals"
+
+    def cmd_READ_HX711(self, gcmd):
+        cnt = gcmd.get_int('C', 1, minval=1, maxval=9999) 
+        self.query_start(cnt, cnt, False, False, False)
+        self.delay_s(1.)
+        self.base_avgs = [0, 0, 0, 0]
+        vals = self.get_vals()
+        for i in range(self.s_count):
+            self.gcode.respond_info('CH%d=' % i)
+            sv = '['
+            for j in range(len(vals[i])):
+                sv += '%.2f, ' % vals[i][j]
+            self.gcode.respond_info(sv + ']')
+        self.read_base(40, 500000)
+        pass
+
+
+def load_config(config):
+    return HX711S(config)
--- a/klippy/extras/input_shaper.py
+++ b/klippy/extras/input_shaper.py
@@ -107,6 +107,9 @@ class InputShaper:
         gcode.register_command("SET_INPUT_SHAPER",
                                self.cmd_SET_INPUT_SHAPER,
                                desc=self.cmd_SET_INPUT_SHAPER_help)
+        gcode.register_command("UPDATE_INPUT_SHAPER",
+                               self.cmd_UPDATE_INPUT_SHAPER,
+                               desc=self.cmd_UPDATE_INPUT_SHAPER_help)
     def get_shapers(self):
         return self.shapers
     def connect(self):
@@ -160,6 +163,9 @@ class InputShaper:
             self._update_input_shaping()
         for shaper in self.shapers:
             shaper.report(gcmd)
+    cmd_UPDATE_INPUT_SHAPER_help = "cmd_UPDATE_INPUT_SHAPER parameters for input shaper"
+    def cmd_UPDATE_INPUT_SHAPER(self, gcmd):
+        self.connect()
 
 def load_config(config):
     return InputShaper(config)
--- /dev/null
+++ b/klippy/extras/io_remap.py
@@ -0,0 +1,58 @@
+import mcu, logging
+
+class CommandError(Exception):
+    pass
+
+"""
+[io_remap]
+src_x_pin: PA1    # 输入pin脚索引号(被映射)
+src_y_pin: PA8    # 输入pin脚索引号(被映射)
+remap_pin: PA15   # 输出pin脚索引号(映射)
+src_x_pullup: 1   # 输入pin脚的上下拉配置,1表示上拉(意味着读取到0表示触发),0表示下拉(意味着读取到1表示触发)
+src_y_pullup: 1   # 输入pin脚的上下拉配置,1表示上拉(意味着读取到0表示触发),0表示下拉(意味着读取到1表示触发)
+remap_def: 1      # 输出pin脚的默认输出电平
+filterNum: 1      # 当读取输入pin脚有效电平持续时间大于等于filterNum * periodTicks, 置输出pin脚为有效电平状态。如果输入的参数为0, 将采用默认值5
+periodTicks: 0    # 轮询输入pin脚周期, 单位ticks。如果输入的参数为0, 采用50uS对应的tick默认值
+"""
+
+class IORemap:
+    error = CommandError
+    def __init__(self, config):
+        self.config = config
+        self.printer = config.get_printer()
+        self.src_x_pin = self.config.getsection('io_remap').get('src_x_pin')
+        self.src_y_pin = self.config.getsection('io_remap').get('src_y_pin')
+        self.remap_pin = self.config.getsection('io_remap').get('remap_pin')
+        self.src_x_pullup = self.config.getsection('io_remap').getint('src_x_pullup')
+        self.src_y_pullup = self.config.getsection('io_remap').getint('src_y_pullup')
+        self.remap_def = self.config.getsection('io_remap').getint('remap_def')
+        self.filterNum = self.config.getsection('io_remap').getint('filterNum')
+        self.periodTicks = self.config.getsection('io_remap').getint('periodTicks')
+        self.mcu = mcu.get_printer_mcu(self.printer, "nozzle_mcu")
+        self.oidx = self.mcu.create_oid()
+        self.oidy = self.mcu.create_oid()
+        self.mcu.register_config_callback(self._build_config)
+        self.gcode = config.get_printer().lookup_object('gcode')
+        self.gcode.register_command("SET_IOREMAP", self.cmd_SET_IOREMAP)
+
+    def _build_config(self):       
+        self.mcu.add_config_cmd("config_ioRemap oid=%d src_pin=%s src_pullup=%d remap_pin=%s remap_def=%d"
+                                 % (self.oidx,self.src_x_pin,self.src_x_pullup,self.remap_pin,self.remap_def))
+        self.mcu.add_config_cmd("config_ioRemap oid=%d src_pin=%s src_pullup=%d remap_pin=%s remap_def=%d"
+                                 % (self.oidy,self.src_y_pin,self.src_y_pullup,self.remap_pin,self.remap_def))
+        self.gcode.respond_info("config_ioRemap oid=%s src_pin=%s src_pullup=%s remap_pin=%s remap_def=%s"%
+                                (self.oidx,self.src_x_pin,self.src_x_pullup,self.remap_pin,self.remap_def))
+        self.gcode.respond_info("config_ioRemap oid=%s src_pin=%s src_pullup=%s remap_pin=%s remap_def=%s"%
+                                (self.oidy,self.src_y_pin,self.src_y_pullup,self.remap_pin,self.remap_def)) 
+    def cmd_SET_IOREMAP(self, gcmd):
+        operation = gcmd.get_int('S', 0)
+        axes = gcmd.get_int('AXES', 0)
+        oid = self.oidx if axes==0 else self.oidy
+        operation_ioRemap = self.mcu.lookup_query_command("operation_ioRemap oid=%c operation=%c filterNum=%c periodTicks=%u",
+                                                          "query_ioRemap oid=%c sta=%c", oid=oid)
+        operation_ioRemap.send([oid, operation, self.filterNum, self.periodTicks])
+        self.gcode.respond_info("operation_ioRemap oid=%s operation=%s filterNum=%s periodTicks=%s"%(oid, operation, self.filterNum, self.periodTicks))
+
+def load_config(config):
+    return IORemap(config)
+
--- /dev/null
+++ b/klippy/extras/lis2dw.py
@@ -0,0 +1,265 @@
+# Support for reading acceleration data from an LIS2DW chip
+#
+# Copyright (C) 2023  Zhou.XianMing <zhouxm@biqu3d.com>
+# Copyright (C) 2020-2021  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging, time, collections, threading, multiprocessing, os
+from . import bus, motion_report, adxl345
+
+# LIS2DW registers
+REG_LIS2DW_WHO_AM_I_ADDR = 0x0F
+REG_LIS2DW_CTRL_REG1_ADDR = 0x20
+REG_LIS2DW_CTRL_REG2_ADDR = 0x21
+REG_LIS2DW_CTRL_REG3_ADDR = 0x22
+REG_LIS2DW_CTRL_REG6_ADDR = 0x25
+REG_LIS2DW_STATUS_REG_ADDR = 0x27
+REG_LIS2DW_OUT_XL_ADDR = 0x28
+REG_LIS2DW_OUT_XH_ADDR = 0x29
+REG_LIS2DW_OUT_YL_ADDR = 0x2A
+REG_LIS2DW_OUT_YH_ADDR = 0x2B
+REG_LIS2DW_OUT_ZL_ADDR = 0x2C
+REG_LIS2DW_OUT_ZH_ADDR = 0x2D
+REG_LIS2DW_FIFO_CTRL   = 0x2E
+REG_LIS2DW_FIFO_SAMPLES = 0x2F
+REG_MOD_READ = 0x80
+# REG_MOD_MULTI = 0x40
+
+LIS2DW_DEV_ID = 0x44
+
+FREEFALL_ACCEL = 9.80665
+SCALE = FREEFALL_ACCEL * 1.952 / 4
+
+Accel_Measurement = collections.namedtuple(
+    'Accel_Measurement', ('time', 'accel_x', 'accel_y', 'accel_z'))
+
+MIN_MSG_TIME = 0.100
+
+BYTES_PER_SAMPLE = 6
+SAMPLES_PER_BLOCK = 8
+
+# Printer class that controls LIS2DW chip
+class LIS2DW:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        adxl345.AccelCommandHelper(config, self)
+        self.query_rate = 0
+        am = {'x': (0, SCALE), 'y': (1, SCALE), 'z': (2, SCALE),
+              '-x': (0, -SCALE), '-y': (1, -SCALE), '-z': (2, -SCALE)}
+        axes_map = config.getlist('axes_map', ('x','y','z'), count=3)
+        if any([a not in am for a in axes_map]):
+            raise config.error("Invalid lis2dw axes_map parameter")
+        self.axes_map = [am[a.strip()] for a in axes_map]
+        self.data_rate = 1600
+        # Measurement storage (accessed from background thread)
+        self.lock = threading.Lock()
+        self.raw_samples = []
+        # Setup mcu sensor_lis2dw bulk query code
+        self.spi = bus.MCU_SPI_from_config(config, 3, default_speed=5000000)
+        self.mcu = mcu = self.spi.get_mcu()
+        self.oid = oid = mcu.create_oid()
+        self.query_lis2dw_cmd = self.query_lis2dw_end_cmd = None
+        self.query_lis2dw_status_cmd = None
+        mcu.add_config_cmd("config_lis2dw oid=%d spi_oid=%d"
+                           % (oid, self.spi.get_oid()))
+        mcu.add_config_cmd("query_lis2dw oid=%d clock=0 rest_ticks=0"
+                           % (oid,), on_restart=True)
+        mcu.register_config_callback(self._build_config)
+        mcu.register_response(self._handle_lis2dw_data, "lis2dw_data", oid)
+        # Clock tracking
+        self.last_sequence = self.max_query_duration = 0
+        self.last_limit_count = self.last_error_count = 0
+        self.clock_sync = adxl345.ClockSyncRegression(self.mcu, 640)
+        # API server endpoints
+        self.api_dump = motion_report.APIDumpHelper(
+            self.printer, self._api_update, self._api_startstop, 0.100)
+        self.name = config.get_name().split()[-1]
+        wh = self.printer.lookup_object('webhooks')
+        wh.register_mux_endpoint("lis2dw/dump_lis2dw", "sensor", self.name,
+                                 self._handle_dump_lis2dw)
+
+    def _build_config(self):
+        cmdqueue = self.spi.get_command_queue()
+        self.query_lis2dw_cmd = self.mcu.lookup_command(
+            "query_lis2dw oid=%c clock=%u rest_ticks=%u", cq=cmdqueue)
+        self.query_lis2dw_end_cmd = self.mcu.lookup_query_command(
+            "query_lis2dw oid=%c clock=%u rest_ticks=%u",
+            "lis2dw_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
+            " buffered=%c fifo=%c limit_count=%hu", oid=self.oid, cq=cmdqueue)
+        self.query_lis2dw_status_cmd = self.mcu.lookup_query_command(
+            "query_lis2dw_status oid=%c",
+            "lis2dw_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
+            " buffered=%c fifo=%c limit_count=%hu", oid=self.oid, cq=cmdqueue)
+    def read_reg(self, reg):
+        params = self.spi.spi_transfer([reg | REG_MOD_READ, 0x00])
+        response = bytearray(params['response'])
+        return response[1]
+    def set_reg(self, reg, val, minclock=0):
+        self.spi.spi_send([reg, val & 0xFF], minclock=minclock)
+        stored_val = self.read_reg(reg)
+        if stored_val != val:
+            raise self.printer.command_error(
+                    "Failed to set LIS2DW register [0x%x] to 0x%x: got 0x%x. "
+                    "This is generally indicative of connection problems "
+                    "(e.g. faulty wiring) or a faulty lis2dw chip." % (
+                        reg, val, stored_val))
+    # Measurement collection
+    def is_measuring(self):
+        return self.query_rate > 0
+    def _handle_lis2dw_data(self, params):
+        with self.lock:
+            self.raw_samples.append(params)
+    def _extract_samples(self, raw_samples):
+        # Load variables to optimize inner loop below
+        (x_pos, x_scale), (y_pos, y_scale), (z_pos, z_scale) = self.axes_map
+        last_sequence = self.last_sequence
+        time_base, chip_base, inv_freq = self.clock_sync.get_time_translation()
+        # Process every message in raw_samples
+        count = seq = 0
+        samples = [None] * (len(raw_samples) * SAMPLES_PER_BLOCK)
+        for params in raw_samples:
+            seq_diff = (last_sequence - params['sequence']) & 0xffff
+            seq_diff -= (seq_diff & 0x8000) << 1
+            seq = last_sequence - seq_diff
+            d = bytearray(params['data'])
+            msg_cdiff = seq * SAMPLES_PER_BLOCK - chip_base
+
+            for i in range(len(d) // BYTES_PER_SAMPLE):
+                d_xyz = d[i*BYTES_PER_SAMPLE:(i+1)*BYTES_PER_SAMPLE]
+                xlow, xhigh, ylow, yhigh, zlow, zhigh = d_xyz
+                # Merge and perform twos-complement
+
+                rx = (((xhigh << 8) | xlow)) - ((xhigh & 0x80) << 9)
+                ry = (((yhigh << 8) | ylow)) - ((yhigh & 0x80) << 9)
+                rz = (((zhigh << 8) | zlow)) - ((zhigh & 0x80) << 9)
+
+                raw_xyz = (rx, ry, rz)
+
+                x = round(raw_xyz[x_pos] * x_scale, 6)
+                y = round(raw_xyz[y_pos] * y_scale, 6)
+                z = round(raw_xyz[z_pos] * z_scale, 6)
+
+                ptime = round(time_base + (msg_cdiff + i) * inv_freq, 6)
+                samples[count] = (ptime, x, y, z)
+                count += 1
+        self.clock_sync.set_last_chip_clock(seq * SAMPLES_PER_BLOCK + i)
+        del samples[count:]
+        return samples
+    def _update_clock(self, minclock=0):
+        # Query current state
+        for retry in range(5):
+            params = self.query_lis2dw_status_cmd.send([self.oid],
+                                                        minclock=minclock)
+            fifo = params['fifo'] & 0x1f
+            if fifo <= 32:
+                break
+        else:
+            raise self.printer.command_error("Unable to query lis2dw fifo")
+        mcu_clock = self.mcu.clock32_to_clock64(params['clock'])
+        sequence = (self.last_sequence & ~0xffff) | params['next_sequence']
+        if sequence < self.last_sequence:
+            sequence += 0x10000
+        self.last_sequence = sequence
+        buffered = params['buffered']
+        limit_count = (self.last_limit_count & ~0xffff) | params['limit_count']
+        if limit_count < self.last_limit_count:
+            limit_count += 0x10000
+        self.last_limit_count = limit_count
+        duration = params['query_ticks']
+        if duration > self.max_query_duration:
+            # Skip measurement as a high query time could skew clock tracking
+            self.max_query_duration = max(2 * self.max_query_duration,
+                                          self.mcu.seconds_to_clock(.000005))
+            return
+        self.max_query_duration = 2 * duration
+        msg_count = (sequence * SAMPLES_PER_BLOCK
+                     + buffered // BYTES_PER_SAMPLE + fifo)
+        # The "chip clock" is the message counter plus .5 for average
+        # inaccuracy of query responses and plus .5 for assumed offset
+        # of lis2dw hw processing time.
+        chip_clock = msg_count + 1
+        self.clock_sync.update(mcu_clock + duration // 2, chip_clock)
+    def _start_measurements(self):
+        if self.is_measuring():
+            return
+        # In case of miswiring, testing LIS2DW device ID prevents treating
+        # noise or wrong signal as a correctly initialized device
+        dev_id = self.read_reg(REG_LIS2DW_WHO_AM_I_ADDR)
+        logging.info("lis2dw_dev_id: %x", dev_id)
+        if dev_id != LIS2DW_DEV_ID:
+            raise self.printer.command_error(
+                "Invalid lis2dw id (got %x vs %x).\n"
+                "This is generally indicative of connection problems\n"
+                "(e.g. faulty wiring) or a faulty lis2dw chip."
+                % (dev_id, LIS2DW_DEV_ID))
+        # Setup chip in requested query rate
+        # ODR/2, +-16g, low-pass filter, Low-noise abled
+        self.set_reg(REG_LIS2DW_CTRL_REG6_ADDR, 0x34)
+        # Continuous mode: If the FIFO is full
+        # the new sample overwrites the older sample.
+        self.set_reg(REG_LIS2DW_FIFO_CTRL, 0xC0)
+        # High-Performance / Low-Power mode 1600/200 Hz
+        # High-Performance Mode (14-bit resolution)
+        self.set_reg(REG_LIS2DW_CTRL_REG1_ADDR, 0x94)
+
+        # Setup samples
+        with self.lock:
+            self.raw_samples = []
+        # Start bulk reading
+        systime = self.printer.get_reactor().monotonic()
+        print_time = self.mcu.estimated_print_time(systime) + MIN_MSG_TIME
+        reqclock = self.mcu.print_time_to_clock(print_time)
+        rest_ticks = self.mcu.seconds_to_clock(4. / self.data_rate)
+        self.query_rate = self.data_rate
+        self.query_lis2dw_cmd.send([self.oid, reqclock, rest_ticks],
+                                    reqclock=reqclock)
+        logging.info("LIS2DW starting '%s' measurements", self.name)
+        # Initialize clock tracking
+        self.last_sequence = 0
+        self.last_limit_count = self.last_error_count = 0
+        self.clock_sync.reset(reqclock, 0)
+        self.max_query_duration = 1 << 31
+        self._update_clock(minclock=reqclock)
+        self.max_query_duration = 1 << 31
+    def _finish_measurements(self):
+        if not self.is_measuring():
+            return
+        # Halt bulk reading
+        params = self.query_lis2dw_end_cmd.send([self.oid, 0, 0])
+        self.query_rate = 0
+        with self.lock:
+            self.raw_samples = []
+        logging.info("LIS2DW finished '%s' measurements", self.name)
+        self.set_reg(REG_LIS2DW_FIFO_CTRL, 0x00)
+    # API interface
+    def _api_update(self, eventtime):
+        self._update_clock()
+        with self.lock:
+            raw_samples = self.raw_samples
+            self.raw_samples = []
+        if not raw_samples:
+            return {}
+        samples = self._extract_samples(raw_samples)
+        if not samples:
+            return {}
+        return {'data': samples, 'errors': self.last_error_count,
+                'overflows': self.last_limit_count}
+    def _api_startstop(self, is_start):
+        if is_start:
+            self._start_measurements()
+        else:
+            self._finish_measurements()
+    def _handle_dump_lis2dw(self, web_request):
+        self.api_dump.add_client(web_request)
+        hdr = ('time', 'x_acceleration', 'y_acceleration', 'z_acceleration')
+        web_request.send({'header': hdr})
+    def start_internal_client(self):
+        cconn = self.api_dump.add_internal_client()
+        return adxl345.AccelQueryHelper(self.printer, cconn)
+
+
+def load_config(config):
+    return LIS2DW(config)
+
+def load_config_prefix(config):
+    return LIS2DW(config)
--- /dev/null
+++ b/klippy/extras/load_ai.py
@@ -0,0 +1,633 @@
+import logging
+import http.client
+from email.mime.base import MIMEBase
+from email.encoders import encode_base64
+import os
+import subprocess
+import json
+import re
+import copy
+import threading
+from subprocess import check_output
+from extras.base_info import base_dir
+    
+class LoadAI:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
+        self.flowdetect_img_dir = os.path.join(base_dir, "ai_image/flowdetect_img")
+        self.user_print_refer_path = os.path.join(base_dir, "creality/userdata/config/user_print_refer.json")
+        self.pic_dir = config.get('path', self.flowdetect_img_dir)
+        self.gcode = self.printer.lookup_object('gcode')
+        self.toolhead = None
+        self.box_action = None
+        self.printer.register_event_handler('klippy:ready', self.find_objs)
+        self.gcode.register_command(
+            "LOAD_AI_T_CMD_TEST", self.cmd_LOAD_AI_T_CMD_TEST)
+        self.gcode.register_command(
+            "LOAD_AI_NOZZLE_CAM_POWER_ON", self.cmd_LOAD_AI_NOZZLE_CAM_POWER_ON)
+        self.gcode.register_command(
+            "LOAD_AI_NOZZLE_CAM_POWER_OFF", self.cmd_LOAD_AI_NOZZLE_CAM_POWER_OFF)
+        self.gcode.register_command(
+            "LOAD_AI_SET_AI_CONTROL_PREFER", self.cmd_LOAD_AI_SET_AI_CONTROL_PREFER)
+        self.gcode.register_command(
+            "LOAD_AI_DEAL", self.cmd_LOAD_AI_DEAL)
+        self.gcode.register_command(
+            "LOAD_AI_DETECT_WASTE", self.cmd_LOAD_AI_DETECT_WASTE)
+        self.gcode.register_command(
+            "LOAD_AI_GET_STATUS", self.cmd_LOAD_AI_GET_STATUS)
+        # ai_control_values = self.extract_ai_control_prefer_values(self.user_print_refer_path, ["switch", "wasteSwitch"])
+        # self.ai_switch = ai_control_values.get("switch") if ai_control_values else None
+        # self.ai_waste_switch = ai_control_values.get("wasteSwitch") if ai_control_values else None
+        # self.cx_ai_engine_status = {
+        #     "ai_switch": self.ai_switch,
+        #     "ai_waste_switch": self.ai_waste_switch,
+        #     "command_type": "",
+        #     "command": "",
+        #     "command_description": "",
+        #     "stderr": "",
+        #     "ai_results": "",
+        #     "max_re_prob": 0.0,
+        #     "normalized_total_area": 0.0,
+        #     "output_width": 0,
+        #     "output_height": 0
+        # }
+        self.cx_ai_engine_status = {}
+        self.ai_switch = 0
+        self.ai_waste_switch = 0
+        self.result = ""
+        self.stderr = ""
+        self.t_command_count = 2
+
+    def find_objs(self):
+        self.toolhead = self.printer.lookup_object('toolhead')
+        self.box_action = self.printer.lookup_object('box').box_action
+
+    def extract_ai_control_prefer_values(self, json_file, keys):
+        # 读取 JSON 文件内容
+        try:
+            with open(json_file, 'r') as file:
+                data = json.load(file)
+        except Exception as e:
+            logging.error(f"Error opening or reading the JSON file: {e}")
+            return None
+
+        # 查找 ai_control 中的指定键值
+        values = {}
+        for key in keys:
+            if 'ai_control' in data and key in data['ai_control']:
+                values[key] = data['ai_control'][key]
+            else:
+                logging.warning(f"Key '{key}' not found in 'ai_control'")
+                values[key] = None
+
+        return values
+
+    def nozzle_cam_power_on(self):
+        try:
+            logging.info("nozzle_cam_power.sh on")
+            result_capture = subprocess.run(['nozzle_cam_power.sh', 'on'], capture_output=True, text=True)
+            # 打印 ai_capture 的输出
+            logging.info(result_capture.stdout)
+            logging.info(result_capture.stderr)
+
+        except Exception as e:
+            logging.info(f"Error: {e}")
+
+    def nozzle_cam_power_off(self):
+        try:
+            logging.info("nozzle_cam_power.sh off")
+            result_capture = subprocess.run(['nozzle_cam_power.sh', 'off'], capture_output=True, text=True)
+            # 打印 ai_capture 的输出
+            logging.info(result_capture.stdout)
+            logging.info(result_capture.stderr)
+
+        except Exception as e:
+            logging.info(f"Error: {e}")
+
+    def ai_capture(self):
+        try:
+            logging.info("ai_capture 1")
+            # 运行 ai_capture 命令并捕获输出
+            result_capture = subprocess.run(['ai_capture', '1'], capture_output=True, text=True)
+
+            # 打印 ai_capture 的输出（可选）
+            logging.info(result_capture.stdout)
+            logging.info(result_capture.stderr)
+
+            return result_capture.stdout  # 返回标准输出
+        except Exception as e:
+            logging.info(f"Error: {e}")
+            return None
+    
+    def remove_files(self, file_path):
+        command = 'rm -rf ' + file_path
+        try:
+            # Execute the command
+            subprocess.run(command, shell=True, check=True)
+            print("Files removed successfully.")
+        except subprocess.CalledProcessError as e:
+            print(f"Error occurred: {e}")
+
+    def calculate_overlap_area(self, rectangles):
+        """使用扫描线算法计算矩形的重叠区域总面积"""
+        try:
+            # 事件定义为 (x, opening/closing, y1, y2)
+            OPEN, CLOSE = 1, -1
+            events = []
+
+            # 为所有矩形生成事件
+            for (x1, y1, x2, y2) in rectangles:
+                events.append((x1, OPEN, y1, y2))
+                events.append((x2, CLOSE, y1, y2))
+
+            # 按 x 坐标对事件进行排序
+            events.sort()
+
+            # 使用扫描线计算区域面积
+            def calc_area(active_y_intervals):
+                """计算当前活动的 y 区间覆盖的 y 长度"""
+                total = 0
+                current_y = -1
+                for (y1, y2) in active_y_intervals:
+                    current_y = max(current_y, y1)
+                    total += max(0, y2 - current_y)
+                    current_y = max(current_y, y2)
+                return total
+
+            active_intervals = []
+            last_x = 0
+            total_area = 0
+
+            for x, typ, y1, y2 in events:
+                logging.info(f"Processing event: x={x}, typ={typ}, y1={y1}, y2={y2}")
+
+                # 计算 last_x 和当前 x 之间区域的面积
+                area = calc_area(active_intervals) * (x - last_x)
+                logging.info(f"Area between x={last_x} and x={x}: {area}")
+                total_area += area
+                last_x = x
+
+                if typ == OPEN:
+                    active_intervals.append((y1, y2))
+                    active_intervals.sort()
+                    logging.info(f"Added interval: {(y1, y2)}, active_intervals={active_intervals}")
+                elif typ == CLOSE:
+                    try:
+                        active_intervals.remove((y1, y2))
+                        logging.info(f"Removed interval: {(y1, y2)}, active_intervals={active_intervals}")
+                    except ValueError:
+                        logging.warning(f"Warning: Interval {(y1, y2)} not found in {active_intervals}")
+
+            return total_area
+
+        except Exception as e:
+            logging.error(f"An error occurred in calculate_overlap_area: {e}")
+            logging.exception("Exception details:")
+            return 0
+
+    def process_waste_ai_detect_result(self, result_stdout_str):
+        cnt_pattern = r"ai detection completed, cnt = (\d+)"
+        result_pattern = r"(\d+)\s+(\d+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)"
+        output_size_pattern = r"output width:\s+(\d+),\s+height:\s+(\d+)"
+        
+        # 获取AI识别个数
+        cnt_match = re.search(cnt_pattern, result_stdout_str)
+        if cnt_match:
+            ai_size_int = int(cnt_match.group(1))
+            ai_results = []
+
+            logging.info("ai_size_int:%d", ai_size_int)
+
+            # 提取输出图片的宽度和高度
+            output_size_match = re.search(output_size_pattern, result_stdout_str)
+            if output_size_match:
+                output_width = int(output_size_match.group(1))
+                output_height = int(output_size_match.group(2))
+            else:
+                output_width = 0
+                output_height = 0
+
+            # 提取检测结果
+            data_start = result_stdout_str.split("num / re_label / re_prob / re_obj_rect_x / re_obj_rect_y / re_obj_rect_width / re_obj_rect_height")[-1]
+            data_start = data_start.strip().splitlines()
+
+            rectangles = []
+            max_re_prob = 0
+
+            for line in data_start:
+                match = re.match(result_pattern, line)
+                if match:
+                    ai_result = {
+                        "num": int(match.group(1)),
+                        "re_label": int(match.group(2)),
+                        "re_prob": float(match.group(3)),
+                        "re_obj_rect_x": float(match.group(4)),
+                        "re_obj_rect_y": float(match.group(5)),
+                        "re_obj_rect_width": float(match.group(6)),
+                        "re_obj_rect_height": float(match.group(7))
+                    }
+
+                    # 更新最大 re_prob 值
+                    if ai_result["re_prob"] > max_re_prob:
+                        max_re_prob = ai_result["re_prob"]
+
+                    # 将矩形的坐标转换为 (x1, y1, x2, y2) 格式，并添加到列表中
+                    rectangles.append((
+                        ai_result["re_obj_rect_x"],
+                        ai_result["re_obj_rect_y"],
+                        ai_result["re_obj_rect_x"] + ai_result["re_obj_rect_width"],
+                        ai_result["re_obj_rect_y"] + ai_result["re_obj_rect_height"]
+                    ))
+                    
+                     # 移除不需要的键
+                    del ai_result["re_obj_rect_x"]
+                    del ai_result["re_obj_rect_y"]
+                    del ai_result["re_obj_rect_width"]
+                    del ai_result["re_obj_rect_height"]
+
+                    re_prob = ai_result["re_prob"]
+                    # ai_results.append(re_prob)
+                    ai_results.append(ai_result)
+            
+            ai_results = json.dumps(ai_results)
+            # 计算所有矩形的重叠面积
+            total_area = self.calculate_overlap_area(rectangles)
+            # 面积归一化
+            if output_width and output_height:
+                normalized_total_area = total_area / (output_width * output_height)
+                logging.info("Total Area: %f, Overlap Normalized Total Area: %f", total_area, normalized_total_area)
+            else:
+                logging.warning("Output dimensions are not available. Cannot normalize total area.")
+                normalized_total_area = 0
+            
+            # 面积归一化，最大面积为1
+            result_dict = {
+                "ai_results": ai_results,
+                "max_re_prob": max_re_prob if normalized_total_area > 0.35 else 0.0,
+                "normalized_total_area": normalized_total_area,
+                "output_width": output_width,
+                "output_height": output_height
+            }
+
+            return result_dict
+
+        return None
+
+    def execute_toolhead_ai_waste_management(self):
+        logging.info(f"execute_toolhead_ai_waste_management start: ai_switch={self.ai_switch}, ai_waste_switch={self.ai_waste_switch}, t_command_count={self.t_command_count}")
+        self.gcode.respond_info("ai_switch = %d, ai_waste_switch = %d \n" % (self.ai_switch, self.ai_waste_switch))
+        if self.t_command_count < 2:
+            self.t_command_count += 1
+            return
+        # T指令达到2次后检测
+        self.t_command_count = 0  # 重置计数器
+        if int(self.ai_waste_switch) == 1:  # AI检测开启
+            self.nozzle_cam_power_on()  # 进料前给喷头上电 LOAD_AI_NOZZLE_CAM_POWER_ON
+            self.box_action.go_to_extrude_pos() # BOX_GO_TO_EXTRUDE_POS
+            self.toolhead.wait_moves() # M400
+            self.gcode.run_script_from_command("G91")
+            self.gcode.run_script_from_command("G1 X-2 F12000")
+            self.toolhead.wait_moves() # M400
+            self.gcode.run_script_from_command("G1 X9 F12000")
+            self.toolhead.wait_moves() # M400
+            self.reactor.pause(self.reactor.monotonic() + 2)
+            self.gcode.respond_info("WILL LOAD_AI_DEAL")
+            # LOAD_AI_DEAL
+            self.gcode.run_script_from_command("LOAD_AI_DETECT_WASTE")  # 废料槽检测
+            self.nozzle_cam_power_off()  # 关灯 LOAD_AI_NOZZLE_CAM_POWER_OFF
+            self.gcode.run_script_from_command("G1 X-7")
+            self.toolhead.wait_moves() # M400
+            self.gcode.run_script_from_command("G90")
+            self.gcode.run_script_from_command("BOX_NOZZLE_CLEAN")  # 擦嘴
+            self.box_action.move_to_safe_pos()  # 去安全位置 BOX_MOVE_TO_SAFE_POS
+
+        logging.info(f"execute_toolhead_ai_waste_management end!!!")
+
+    def cmd_LOAD_AI_T_CMD_TEST(self, gcmd):
+        """
+        根据指定的温度和T编号测试T指令换料擦嘴流程
+        示例：LOAD_AI_T_CMD_TEST TEMP=220 TCMD_NUM=0
+        """
+        self.t_command_count = 2 # 立即触发废料槽检测
+        logging.info("LOAD_AI_T_CMD_TEST gcmd: %s"% gcmd.get_command_parameters())
+        temp = gcmd.get_int("TEMP", minval=180, maxval=300, default=220)
+        tcmd_num = gcmd.get_int("TCMD_NUM", minval=0, maxval=16, default=0)
+        self.gcode.run_script_from_command("BOX_GO_TO_EXTRUDE_POS")
+        self.gcode.run_script_from_command(f"M109 S{temp}")
+        self.gcode.run_script_from_command(f"T{tcmd_num}")
+        self.gcode.run_script_from_command("BOX_GO_TO_EXTRUDE_POS")
+        self.gcode.run_script_from_command("M106 P0 S255")
+        self.gcode.run_script_from_command("M106 P2 S255")
+        self.gcode.run_script_from_command("M109 S140")
+        self.gcode.run_script_from_command("M106 P0 S0")
+        self.gcode.run_script_from_command("M106 P2 S0")
+        self.gcode.run_script_from_command("BOX_NOZZLE_CLEAN")
+        self.gcode.run_script_from_command("M109 S0")
+        self.gcode.run_script_from_command("G90")
+        self.gcode.run_script_from_command("G1 X150 Y150 F7800")
+
+    def cmd_LOAD_AI_NOZZLE_CAM_POWER_ON(self, gcmd):
+        self.nozzle_cam_power_on()
+        
+    def cmd_LOAD_AI_NOZZLE_CAM_POWER_OFF(self, gcmd):
+        self.nozzle_cam_power_off()
+
+    def cmd_LOAD_AI_SET_AI_CONTROL_PREFER(self, gcmd):
+        logging.info("gcmd: %s"% gcmd.get_command_parameters())
+        self.ai_switch = gcmd.get_int("SWITCH", minval=0, maxval=1, default=self.ai_switch)
+        self.ai_waste_switch = gcmd.get_int("WASTE_SWITCH", minval=0, maxval=1, default=self.ai_waste_switch)
+        logging.info("ai_switch: %d, ai_waste_switch: %d" % (self.ai_switch, self.ai_waste_switch))
+        # ai_control_values = self.extract_ai_control_prefer_values(self.user_print_refer_path, ["switch", "wasteSwitch"])
+        # self.ai_switch = ai_control_values.get("switch") if ai_control_values else None
+        # self.ai_waste_switch = ai_control_values.get("wasteSwitch") if ai_control_values else None
+        self.cx_ai_engine_status = {
+            "ai_switch": self.ai_switch,
+            "ai_waste_switch": self.ai_waste_switch,
+            "command_type": "",
+            "command": "",
+            "command_description": "",
+            "stderr": "",
+            "ai_results": "",
+            "max_re_prob": 0.0,
+            "normalized_total_area": 0.0,
+            "output_width": 0,
+            "output_height": 0
+        }
+        logging.info("LOAD_AI_SET_AI_CONTROL_PREFER:%s" % self.cx_ai_engine_status)
+
+    def cmd_LOAD_AI_DEAL(self, gcmd):
+        # 加载AI上传图片
+        try:
+            # ip = self.get_ip()
+            # if not ip:
+            #     self.gcode.respond_info("LOAD_AI_DEAL net error")
+            #     return
+            # self.nozzle_cam_power_on()
+            # self.reactor.pause(self.reactor.monotonic() + 1)
+            self.ai_capture()
+            self.reactor.pause(self.reactor.monotonic() + 2)
+            filename = self.find_latest_photo()
+            if not filename or not os.path.exists(filename):
+                # 关灯
+                # self.nozzle_cam_power_off()
+                self.gcode.respond_info("LOAD_AI_DEAL photo error, filename is %s" % filename)
+                return
+            files = {'file': filename}
+            response = self.send_post_request(files)
+            logging.info("LOAD_AI_DEAL:%s" % response)
+            self.gcode.respond_info("LOAD_AI_DEAL:%s" % response)
+            logging.info("files:%s",files)
+            self.remove_files(filename)
+        except Exception as e:
+            logging.exception(e)
+        # 关灯
+        # self.nozzle_cam_power_off()
+    def ai_engine_capture(self, cmd):
+        logging.info(f"Executing command: {cmd}")
+        try:
+            # 运行命令，捕获标准输出和标准错误
+            process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
+            self.result, self.stderr = process.communicate()
+
+            # 检查返回码
+            if process.returncode != 0:
+                logging.error(f"Command '{cmd}' failed with return code {process.returncode}")
+                if self.stderr:
+                    logging.error(f"Error output: {self.stderr.strip()}")
+                else:
+                    logging.error("No error output captured.")
+
+            logging.info(f"Command '{cmd}' returned output: {self.result.strip()}")
+        except subprocess.CalledProcessError as e:
+            logging.error(f"Command '{e.cmd}' returned non-zero exit status {e.returncode}")
+            logging.error(f"Error output: {e.stderr.strip() if e.stderr else 'No error output captured.'}")
+        except Exception as e:
+            logging.error(f"An unexpected error occurred: {str(e)}")
+
+    def execute_ai_waste_detection(self):
+        # ai_control_values = self.extract_ai_control_prefer_values(self.user_print_refer_path, ["switch", "wasteSwitch"])
+        # self.ai_switch = ai_control_values.get("switch") if ai_control_values else None
+        # self.ai_waste_switch = ai_control_values.get("wasteSwitch") if ai_control_values else None
+        # # self.gcode.respond_info(f"switch: {ai_switch}")
+        # if ai_switch != 1:
+        #     # self.gcode.respond_info(f"switch: {ai_switch}")
+        #     return
+        cmd = f"ai_engine 1 5 --user_data_dir={base_dir}"
+        json_output = {
+            "ai_switch": self.ai_switch,
+            "ai_waste_switch": self.ai_waste_switch,
+            "command_type": "ai_engine",
+            "command": cmd,
+            "command_description": "waste",
+            "stderr": "",
+            "ai_results": [],
+            "max_re_prob": 0.0,
+            "normalized_total_area": 0.0,
+            "output_width": 0,
+            "output_height": 0
+        }
+
+        try:
+            self.result = {}
+            self.stderr = ""
+            # 启动后台线程执行命令
+            background_thread = threading.Thread(target=self.ai_engine_capture, args=(cmd,))
+            background_thread.start()
+
+            # 等待结果
+            for _ in range(100):
+                if self.result:
+                    break
+                self.reactor.pause(self.reactor.monotonic() + 0.1)
+            else:
+                logging.info("run cmd_LOAD_AI_DETECT_WASTE failed: timeout")
+                return
+            
+            # 处理结果
+            if self.stderr:
+                json_output["stderr"] = self.stderr
+            else:
+                ai_results = self.process_waste_ai_detect_result(self.result)
+                if ai_results is not None:
+                    json_output["ai_results"] = ai_results["ai_results"]
+                    json_output["max_re_prob"] = ai_results["max_re_prob"]
+                    json_output["normalized_total_area"] = ai_results["normalized_total_area"]
+                    json_output["output_width"] = ai_results["output_width"]
+                    json_output["output_height"] = ai_results["output_height"]
+
+             # 更新状态并记录信息
+            self.cx_ai_engine_status = copy.deepcopy(json_output)
+            json_output["stdout"] = self.result
+            json_output_str = json.dumps(json_output, indent=4)
+            logging.info(json_output_str)
+
+            # 打印 ai_capture 的输出（可选）
+            # self.gcode.respond_info(json_output_str)
+            return self.result  # 返回标准输出
+        except Exception as e:
+            json_output["stderr"] = str(e)
+            self.cx_ai_engine_status = json_output
+            json_output_str = json.dumps(json_output, indent=4)
+            logging.info(json_output_str)
+            # self.gcode.respond_info(json_output_str)
+            return None
+
+    # AI 废料槽检测
+    def cmd_LOAD_AI_DETECT_WASTE(self,gcmd):  
+        return self.execute_ai_waste_detection()
+
+    def create_multipart_form_data(self, files):
+        """
+        创建并返回multipart/form-data的字节串，用于HTTP POST请求体。
+        """
+        boundary = '---------------------------' + os.urandom(16).hex()
+        body = []
+
+        for name, filepath in files.items():
+            with open(filepath, 'rb') as f:
+                part = MIMEBase('application', 'octet-stream')
+                part.set_payload(f.read())
+                encode_base64(part)
+
+                # 添加头部信息（作为字节串列表）
+                # waste_ip_时间戳
+                # upload_new_filename = "waste_" + ip + "_" + os.path.basename(filepath)
+                part_headers = [
+                    f'Content-Disposition: form-data; name="{name}"; filename="{os.path.basename(filepath)}"',
+                    # f'Content-Disposition: form-data; name="{name}"; filename="{upload_new_filename}"',
+                    f'Content-Type: {part.get_content_type()}',
+                    f'Content-Transfer-Encoding: base64'
+                ]
+                headers_bytes = [header.encode('utf-8') + b'\r\n' for header in part_headers]
+
+                # 添加到body中
+                body.append(f'--{boundary}\r\n'.encode('utf-8'))
+                body.extend(headers_bytes)
+                body.append(b'\r\n')
+                # 添加base64编码的内容（已经是字节串）
+                body.append(part.get_payload(decode=True))
+                body.append(b'\r\n')
+
+                # 添加最后的边界（带有两个破折号）
+        body.append(f'--{boundary}--\r\n'.encode('utf-8'))
+
+        # 将所有部分连接成一个字节串
+        return b''.join(body), boundary
+
+    def send_post_request(self, files):
+        # 假设URL格式是 http://hostname/path
+        # hostname, path = url.split('/', 2)[2], '/' + '/'.join(url.split('/')[3:])
+        hostname, path = "http://172.23.88.101:38765", "upload/"
+        # 创建multipart/form-data体和边界
+        body, boundary = self.create_multipart_form_data(files)
+
+        # 创建HTTP连接并发送请求
+        conn = http.client.HTTPConnection("172.23.88.101", 38765)
+        headers = {
+            'Content-Type': f'multipart/form-data; boundary={boundary}',
+            'Content-Length': str(len(body))  # 设置内容长度
+        }
+        conn.request('POST', path, body, headers)
+
+        # 获取响应
+        response = conn.getresponse()
+        print(f'Status: {response.status}, Reason: {response.reason}')
+        resp_text = response.read().decode('utf-8')
+        print(resp_text)  # 假设响应是文本
+
+        # 关闭连接
+        conn.close()
+        return resp_text
+
+    def find_latest_photo(self):
+        """
+        查找指定目录中最新的照片文件。
+
+        :param directory: 包含照片的目录路径
+        :return: 最新照片文件的完整路径，如果没有找到照片则返回None
+        """
+        latest_photo_path = None
+        latest_photo_mtime = None
+
+        # 遍历目录中的所有文件和文件夹
+        for root, dirs, files in os.walk(self.pic_dir):
+            for file in files:
+                # 检查文件扩展名，以确定它是否是图片
+                if file.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp')):
+                    file_path = os.path.join(root, file)
+                    mtime = os.path.getmtime(file_path)
+
+                    # 如果这是第一个找到的图片，或者比当前已知的最新图片更新
+                    if latest_photo_mtime is None or mtime > latest_photo_mtime:
+                        latest_photo_path = file_path
+                        latest_photo_mtime = mtime
+
+        return latest_photo_path
+    
+    def cmd_LOAD_AI_GET_STATUS(self,gcmd):  
+        # 测试数据初始化
+        detection_results = [
+            [0, 0, 0.931467, 1.0, 0.0, 4.0, 4.0],
+            [1, 0, 0.831467, 3.0, 1.0, 3.0, 4.0],
+            [2, 0, 0.731467, 0.0, 3.0, 7.0, 3.0]
+        ]
+        cnt = len(detection_results)
+        # 将数据转换回字符串格式
+        detection_results_str = "\n".join(
+            "\t".join(map(str, result)) for result in detection_results
+        )
+        
+        # 接口功能测试
+        self.cx_ai_engine_status = {
+            "ai_switch": 1,
+            "ai_waste_switch": 1,
+            "command_type": "ai_engine",
+            "command": f"ai_engine 1 5 --user_data_dir={base_dir}",
+            "command_description": "waste",
+            "stderr": "",
+            "ai_results": (
+                "cam_type=1\n"
+                "mode=5\n"
+                "debug=0\n"
+                f"user_data_dir={base_dir}\n"
+                "gcode_path=\n"
+                "z_height=0.000000\n"
+                "ParseParamFile model_str_=F008\n"
+                "ParseParamFile sys_version_=1.1.0.15\n"
+                "the pid is alive...!\n"
+                "flag = 0\n"
+                f"input = {base_dir}/ai_image/sub_capture.bmp\n"
+                "AI_upload_mode = 1\n"
+                "{\"reqId\":\"1722419562737\",\"dn\":\"00000000000000\",\"code\":\"key609\",\"data\":\"0.000000|1722419562.736825|/usr/data/ai_image/ai_property/F008-waste-2024_7_31_17_52_42.jpg\\n\"}\n"
+                "output width: 1600, height: 1200\n"
+                f"output = {base_dir}/ai_image/sub_processed_ai_waste_mode.jpg\n"
+                f"ai detection completed, cnt = {cnt}\n"
+                "num / re_label / re_prob / re_obj_rect_x / re_obj_rect_y / re_obj_rect_width / re_obj_rect_height\n"
+                f"{detection_results_str}"
+            ),
+            "max_re_prob": 0.0,
+            "normalized_total_area": 0.0,
+            "output_width": 0,
+            "output_height": 0
+        }
+        result_stdout = self.cx_ai_engine_status["ai_results"]
+        ai_results = self.process_waste_ai_detect_result(result_stdout)
+        if ai_results is not None:
+            self.cx_ai_engine_status["ai_results"] = ai_results["ai_results"]
+            self.cx_ai_engine_status["max_re_prob"] = ai_results["max_re_prob"]
+            self.cx_ai_engine_status["normalized_total_area"] = ai_results["normalized_total_area"]
+            self.cx_ai_engine_status["output_width"] = ai_results["output_width"]
+            self.cx_ai_engine_status["output_height"] = ai_results["output_height"]
+        json_output_str = json.dumps(self.cx_ai_engine_status, indent=4)  
+        logging.info(json_output_str)
+        
+    def get_status(self, eventtime):
+        # ai_control_values = self.extract_ai_control_prefer_values(self.user_print_refer_path, ["switch", "wasteSwitch"])
+        # self.ai_switch = ai_control_values.get("switch") if ai_control_values else None
+        # self.ai_waste_switch = ai_control_values.get("wasteSwitch") if ai_control_values else None
+        # self.cx_ai_engine_status["ai_switch"] = self.ai_switch
+        return self.cx_ai_engine_status
+
+def load_config(config):
+    return LoadAI(config)
\ No newline at end of file
--- /dev/null
+++ b/klippy/extras/metadata.py
@@ -0,0 +1,1261 @@
+#!/usr/bin/env python3
+# GCode metadata extraction utility
+#
+# Copyright (C) 2020 Eric Callahan <arksine.code@gmail.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+
+from __future__ import annotations
+import json
+import argparse
+import re
+import os
+import sys
+import base64
+import traceback
+import tempfile
+import zipfile
+import shutil
+import uuid
+from PIL import Image
+
+# Annotation imports
+from typing import (
+    TYPE_CHECKING,
+    Any,
+    Optional,
+    Dict,
+    List,
+    Tuple,
+    Type,
+)
+if TYPE_CHECKING:
+    pass
+
+UFP_MODEL_PATH = "/3D/model.gcode"
+UFP_THUMB_PATH = "/Metadata/thumbnail.png"
+
+def log_to_stderr(msg: str) -> None:
+    sys.stderr.write(f"{msg}\n")
+    sys.stderr.flush()
+
+# regex helpers
+def _regex_find_floats(pattern: str,
+                       data: str,
+                       strict: bool = False
+                       ) -> List[float]:
+    # If strict is enabled, pattern requires a floating point
+    # value, otherwise it can be an integer value
+    fptrn = r'\d+\.\d*' if strict else r'\d+\.?\d*'
+    matches = re.findall(pattern, data)
+    if matches:
+        # return the maximum height value found
+        try:
+            return [float(h) for h in re.findall(
+                    fptrn, " ".join(matches))]
+        except Exception:
+            pass
+    return []
+
+def _regex_find_ints(pattern: str, data: str) -> List[int]:
+    matches = re.findall(pattern, data)
+    if matches:
+        # return the maximum height value found
+        try:
+            return [int(h) for h in re.findall(
+                    r'\d+', " ".join(matches))]
+        except Exception:
+            pass
+    return []
+
+def _regex_find_first(pattern: str, data: str) -> Optional[float]:
+    match = re.search(pattern, data)
+    val: Optional[float] = None
+    if match:
+        try:
+            val = float(match.group(1))
+        except Exception:
+            return None
+    return val
+
+def _regex_find_int(pattern: str, data: str) -> Optional[int]:
+    match = re.search(pattern, data)
+    val: Optional[int] = None
+    if match:
+        try:
+            val = int(match.group(1))
+        except Exception:
+            return None
+    return val
+
+def _regex_find_string(pattern: str, data: str) -> Optional[str]:
+    match = re.search(pattern, data)
+    if match:
+        return match.group(1).strip('"')
+    return None
+
+def get_print_file_metadata(file_path):
+    result = {}
+    count = 3000
+    try:
+        with open(file_path, "r") as f:
+            while count:
+                count -= 1
+                line = f.readline() 
+                if not line.startswith(";"):
+                    continue
+                if re.findall(r";MINX:(.*)\n", line):  
+                    result["MINX"] = float(re.findall(r";MINX:(.*)\n", line)[0].strip())
+                if re.findall(r";MINY:(.*)\n", line):  
+                    result["MINY"] = float(re.findall(r";MINY:(.*)\n", line)[0].strip()) 
+                if re.findall(r";MINZ:(.*)\n", line):  
+                    result["MINZ"] = float(re.findall(r";MINZ:(.*)\n", line)[0].strip())
+                if re.findall(r";MAXX:(.*)\n", line):  
+                    result["MAXX"] = float(re.findall(r";MAXX:(.*)\n", line)[0].strip()) 
+                if re.findall(r";MAXY:(.*)\n", line):  
+                    result["MAXY"] = float(re.findall(r";MAXY:(.*)\n", line)[0].strip())
+                if re.findall(r";MAXZ:(.*)\n", line):  
+                    result["MAXZ"] = float(re.findall(r";MAXZ:(.*)\n", line)[0].strip())
+                if re.findall(r";Machine Height:(.*)\n", line):  
+                    result["MachineHeight"] = float(re.findall(r";Machine Height:(.*)\n", line)[0].strip())
+                if re.findall(r";Machine Width:(.*)\n", line):  
+                    result["MachineWidth"] = float(re.findall(r";Machine Width:(.*)\n", line)[0].strip())
+                if re.findall(r";Machine Depth:(.*)\n", line):  
+                    result["MachineDepth"] = float(re.findall(r";Machine Depth:(.*)\n", line)[0].strip())
+                if re.findall(r";Material Name:(.*)\n", line):  
+                    result["MaterialName"] = str(re.findall(r";Material Name:(.*)\n", line)[0].strip())
+                if re.findall(r";Material Type:(.*)\n", line):  
+                    result["MaterialType"] = str(re.findall(r";Material Type:(.*)\n", line)[0].strip())
+    except Exception as err:
+        print(err)
+        return None
+    return result
+
+# Slicer parsing implementations
+class BaseSlicer(object):
+    def __init__(self, file_path: str) -> None:
+        self.path = file_path
+        self.header_data: str = ""
+        self.footer_data: str = ""
+        self.layer_height: Optional[float] = None
+        self.has_m486_objects: bool = False
+
+    def set_data(self,
+                 header_data: str,
+                 footer_data: str,
+                 fsize: int) -> None:
+        self.header_data = header_data
+        self.footer_data = footer_data
+        self.size: int = fsize
+
+    def _parse_min_float(self,
+                         pattern: str,
+                         data: str,
+                         strict: bool = False
+                         ) -> Optional[float]:
+        result = _regex_find_floats(pattern, data, strict)
+        if result:
+            return min(result)
+        else:
+            return None
+
+    def _parse_max_float(self,
+                         pattern: str,
+                         data: str,
+                         strict: bool = False
+                         ) -> Optional[float]:
+        result = _regex_find_floats(pattern, data, strict)
+        if result:
+            return max(result)
+        else:
+            return None
+
+    def _check_has_objects(self,
+                           data: str,
+                           pattern: Optional[str] = None
+                           ) -> bool:
+        match = re.search(
+            r"\n((DEFINE_OBJECT)|(EXCLUDE_OBJECT_DEFINE)) NAME=",
+            data
+        )
+        if match is not None:
+            # Objects already processed
+            fname = os.path.basename(self.path)
+            log_to_stderr(
+                f"File '{fname}' currently supports cancellation, "
+                "processing aborted"
+            )
+            if match.group(1).startswith("DEFINE_OBJECT"):
+                log_to_stderr(
+                    "Legacy object processing detected.  This is not "
+                    "compatible with official versions of Klipper."
+                )
+            return False
+        # Always check M486
+        patterns = [r"\nM486"]
+        if pattern is not None:
+            patterns.append(pattern)
+        for regex in patterns:
+            if re.search(regex, data) is not None:
+                self.has_m486_objects = regex == r"\nM486"
+                return True
+        return False
+
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(self.header_data)
+
+    def parse_gcode_start_byte(self) -> Optional[int]:
+        m = re.search(r"\n[MG]\d+\s.*\n", self.header_data)
+        if m is None:
+            return None
+        return m.start()
+
+    def parse_gcode_end_byte(self) -> Optional[int]:
+        rev_data = self.footer_data[::-1]
+        m = re.search(r"\n.*\s\d+[MG]\n", rev_data)
+        if m is None:
+            return None
+        return self.size - m.start()
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return None
+
+    def parse_model_info(self):
+        return None
+
+    def parse_layer_height(self) -> Optional[float]:
+        return None
+
+    def parse_object_height(self) -> Optional[float]:
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        return None
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return None
+
+    def parse_filament_name(self) -> Optional[str]:
+        return None
+
+    def parse_filament_type(self) -> Optional[str]:
+        return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return None
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return None
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return None
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return None
+
+    def parse_layer_count(self) -> Optional[int]:
+        return None
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return None
+
+    def parse_flush_para(self) -> Optional[Dict[str, Any]]:
+        return None
+
+    def parse_default_filament_colour(self) -> Optional[Tuple[Any, ...]]:
+        return None
+
+class UnknownSlicer(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        return {'slicer': "Unknown"}
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return self._parse_min_float(r"G1\sZ\d+\.\d*", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(r"G1\sZ\d+\.\d*", self.footer_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M109 S(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M190 S(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M191 S(\d+\.?\d*)", self.header_data)
+
+
+class PrusaSlicer(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        aliases = {
+            'PrusaSlicer': r"PrusaSlicer\s(.*)\son",
+            'SuperSlicer': r"SuperSlicer\s(.*)\son",
+            'OrcaSlicer': r"OrcaSlicer\s(.*)\son",
+            'SliCR-3D': r"SliCR-3D\s(.*)\son",
+            'BambuStudio': r"BambuStudio[^ ]*\s(.*)\n",
+            'A3dp-Slicer': r"A3dp-Slicer\s(.*)\son",
+        }
+        for name, expr in aliases.items():
+            match = re.search(expr, data)
+            if match:
+                return {
+                    'slicer': name,
+                    'slicer_version': match.group(1)
+                }
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(
+            self.header_data, r"\n; printing object")
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        # Check percentage
+        pct = _regex_find_first(
+            r"; first_layer_height = (\d+)%", self.footer_data)
+        if pct is not None:
+            if self.layer_height is None:
+                # Failed to parse the original layer height, so it is not
+                # possible to calculate a percentage
+                return None
+            return round(pct / 100. * self.layer_height, 6)
+        return _regex_find_first(
+            r"; first_layer_height = (\d+\.?\d*)", self.footer_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r"; layer_height = (\d+\.?\d*)", self.footer_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        matches = re.findall(
+            r";BEFORE_LAYER_CHANGE\n(?:.*\n)?;(\d+\.?\d*)", self.footer_data)
+        if matches:
+            try:
+                matches = [float(m) for m in matches]
+            except Exception:
+                pass
+            else:
+                return max(matches)
+        return self._parse_max_float(r"G1\sZ\d+\.\d*\sF", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"filament\sused\s\[mm\]\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"total\sfilament\sused\s\[g\]\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_type\s=\s(.*)", self.footer_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_settings_id\s=\s(.*)", self.footer_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        time_match = re.search(
+            r';\sestimated\sprinting\stime.*', self.footer_data)
+        if not time_match:
+            return None
+        total_time = 0
+        time_group = time_match.group()
+        time_patterns = [(r"(\d+)d", 24*60*60), (r"(\d+)h", 60*60),
+                         (r"(\d+)m", 60), (r"(\d+)s", 1)]
+        try:
+            for pattern, multiplier in time_patterns:
+                t = re.search(pattern, time_group)
+                if t:
+                    total_time += int(t.group(1)) * multiplier
+        except Exception:
+            return None
+        return round(total_time, 2)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; first_layer_temperature = (\d+\.?\d*)", self.footer_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; first_layer_bed_temperature = (\d+\.?\d*)", self.footer_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; chamber_temperature = (\d+\.?\d*)", self.footer_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\snozzle_diameter\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        return _regex_find_int(
+            r"; total layers count = (\d+)", self.footer_data)
+
+    def parse_flush_para(self) -> Optional[Dict[str, List[int]]]:
+        flush_multiplier = None
+        flush_volumes_matrix = None
+        # Search for flush_multiplier value
+        flush_multiplier_match = re.search(r'flush_multiplier\s*=\s*([\d.]+)', self.footer_data)
+        if flush_multiplier_match:
+            flush_multiplier = float(flush_multiplier_match.group(1))
+        # Search for flush_volumes_matrix value
+        flush_volumes_matrix_match = re.search(r'flush_volumes_matrix\s*=\s*([^;]+)', self.footer_data)
+        if flush_volumes_matrix_match:
+            flush_volumes_matrix = [int(x) for x in flush_volumes_matrix_match.group(1).strip().split(',')]
+        # return
+        if flush_multiplier is not None or flush_volumes_matrix is not None:
+            return {'flush_multiplier': flush_multiplier, 'flush_volumes_matrix': flush_volumes_matrix}
+        else:
+            return None
+
+class Slic3rPE(PrusaSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Slic3r\sPrusa\sEdition\s(.*)\son", data)
+        if match:
+            return {
+                'slicer': "Slic3r PE",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"filament\sused\s=\s(\d+\.\d+)mm", self.footer_data)
+
+
+class Slic3r(Slic3rPE):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Slic3r\s(\d.*)\son", data)
+        if match:
+            return {
+                'slicer': "Slic3r",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_first(
+            r";\sfilament\_length\_m\s=\s(\d+\.\d*)", self.footer_data)
+        if filament is not None:
+            filament *= 1000
+        return filament
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sfilament\smass\_g\s=\s(\d+\.\d*)", self.footer_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return None
+
+class Cura(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Cura_SteamEngine\s(.*)", data)
+        if match:
+            return {
+                'slicer': "Cura",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(
+            self.header_data, r"\n;MESH:")
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(r";MINZ:(\d+\.?\d*)", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";Layer\sheight:\s(\d+\.?\d*)", self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return _regex_find_first(r";MAXZ:(\d+\.?\d*)", self.header_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_first(
+            r";Filament\sused:\s(\d+\.?\d*)m", self.header_data)
+        if filament is not None:
+            filament *= 1000
+        return filament
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Filament\sweight\s=\s.(\d+\.\d+).", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\stype\s=\s(.*)", self.header_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\sname\s=\s(.*)", self.header_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return self._parse_max_float(r";TIME:.*", self.header_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M109 S(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M190 S(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M191 S(\d+\.?\d*)", self.header_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        return _regex_find_int(
+            r";LAYER_COUNT\:(\d+)", self.header_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Nozzle\sdiameter\s=\s(\d+\.\d*)", self.header_data)
+
+class Simplify3D(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"Simplify3D\(R\)\sVersion\s(.*)", data)
+        if match:
+            self._version = match.group(1)
+            self._is_v5 = self._version.startswith("5")
+            return {
+                'slicer': "Simplify3D",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return self._parse_min_float(r"G1\sZ\d+\.\d*", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";\s+layerHeight,(\d+\.?\d*)", self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(r"G1\sZ\d+\.\d*", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+(?:Filament\slength|Material\sLength):\s(\d+\.?\d*)\smm",
+            self.footer_data
+        )
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+(?:Plastic\sweight|Material\sWeight):\s(\d+\.?\d*)\sg",
+            self.footer_data
+        )
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\s+printMaterial,(.*)", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\s+makerBotModelMaterial,(.*)", self.footer_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        time_match = re.search(
+            r';\s+Build (t|T)ime:.*', self.footer_data)
+        if not time_match:
+            return None
+        total_time = 0
+        time_group = time_match.group()
+        time_patterns = [(r"(\d+)\shours?", 60*60), (r"(\d+)\smin", 60),
+                         (r"(\d+)\ssec", 1)]
+        try:
+            for pattern, multiplier in time_patterns:
+                t = re.search(pattern, time_group)
+                if t:
+                    total_time += int(t.group(1)) * multiplier
+        except Exception:
+            return None
+        return round(total_time, 2)
+
+    def _get_temp_items(self, pattern: str) -> List[str]:
+        match = re.search(pattern, self.header_data)
+        if match is None:
+            return []
+        return match.group().split(",")[1:]
+
+    def _get_first_layer_temp(self, heater: str) -> Optional[float]:
+        heaters = self._get_temp_items(r"temperatureName.*")
+        temps = self._get_temp_items(r"temperatureSetpointTemperatures.*")
+        for h, temp in zip(heaters, temps):
+            if h == heater:
+                try:
+                    return float(temp)
+                except Exception:
+                    return None
+        return None
+
+    def _get_first_layer_temp_v5(self, heater_type: str) -> Optional[float]:
+        pattern = (
+            r";\s+temperatureController,.+?"
+            r";\s+temperatureType,"f"{heater_type}"r".+?"
+            r";\s+temperatureSetpoints,\d+\|(\d+)"
+        )
+        match = re.search(pattern, self.header_data, re.MULTILINE | re.DOTALL)
+        if match is not None:
+            try:
+                return float(match.group(1))
+            except Exception:
+                return None
+        return None
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        if self._is_v5:
+            return self._get_first_layer_temp_v5("extruder")
+        else:
+            return self._get_first_layer_temp("Extruder 1")
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        if self._is_v5:
+            return self._get_first_layer_temp_v5("platform")
+        else:
+            return self._get_first_layer_temp("Heated Bed")
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+(?:extruderDiameter|nozzleDiameter),(\d+\.\d*)",
+            self.header_data
+        )
+
+class KISSlicer(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, Any]]:
+        match = re.search(r";\sKISSlicer", data)
+        if match:
+            ident = {'slicer': "KISSlicer"}
+            vmatch = re.search(r";\sversion\s(.*)", data)
+            if vmatch:
+                version = vmatch.group(1).replace(" ", "-")
+                ident['slicer_version'] = version
+            return ident
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\s+first_layer_thickness_mm\s=\s(\d+\.?\d*)", self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";\s+max_layer_thickness_mm\s=\s(\d+\.?\d*)", self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(
+            r";\sEND_LAYER_OBJECT\sz.*", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_floats(
+            r";\s+Ext\s.*mm", self.footer_data, strict=True)
+        if filament:
+            return sum(filament)
+        return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        time = _regex_find_first(
+            r";\sCalculated.*Build\sTime:\s(\d+\.?\d*)\sminutes",
+            self.footer_data)
+        if time is not None:
+            time *= 60
+            return round(time, 2)
+        return None
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; first_layer_C = (\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; bed_C = (\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; chamber_C = (\d+\.?\d*)", self.header_data)
+
+
+class IdeaMaker(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        match = re.search(r"\sideaMaker\s(.*),", data)
+        if match:
+            return {
+                'slicer': "IdeaMaker",
+                'slicer_version': match.group(1)
+            }
+        return None
+
+    def has_objects(self) -> bool:
+        return self._check_has_objects(
+            self.header_data, r"\n;PRINTING:")
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        layer_info = _regex_find_floats(
+            r";LAYER:0\s*.*\s*;HEIGHT.*", self.header_data)
+        if len(layer_info) >= 3:
+            return layer_info[2]
+        return None
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        layer_info = _regex_find_floats(
+            r";LAYER:1\s*.*\s*;HEIGHT.*", self.header_data)
+        if len(layer_info) >= 3:
+            self.layer_height = layer_info[2]
+            return self.layer_height
+        return None
+
+    def parse_object_height(self) -> Optional[float]:
+        bounds = _regex_find_floats(
+            r";Bounding Box:.*", self.header_data)
+        if len(bounds) >= 6:
+            return bounds[5]
+        return None
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament = _regex_find_floats(
+            r";Material.\d\sUsed:.*", self.footer_data, strict=True)
+        if filament:
+            return sum(filament)
+        return None
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\stype\s=\s(.*)", self.header_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Filament\sname\s=\s(.*)", self.header_data)
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        pi = 3.141592653589793
+        length = _regex_find_floats(
+            r";Material.\d\sUsed:.*", self.footer_data, strict=True)
+        diameter = _regex_find_floats(
+            r";Filament\sDiameter\s.\d:.*", self.header_data, strict=True)
+        density = _regex_find_floats(
+            r";Filament\sDensity\s.\d:.*", self.header_data, strict=True)
+        if len(length) == len(density) == len(diameter):
+            # calc individual weight for each filament with m=pi/4*d²*l*rho
+            weights = [(pi/4 * diameter[i]**2 * length[i] * density[i]/10**6)
+                       for i in range(len(length))]
+            return sum(weights)
+        return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Print\sTime:\s(\d+\.?\d*)", self.footer_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M109 T0 S(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M190 S(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"M191 S(\d+\.?\d*)", self.header_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Dimension:(?:\s\d+\.\d+){3}\s(\d+\.\d+)", self.header_data)
+
+class IceSL(BaseSlicer):
+    def check_identity(self, data) -> Optional[Dict[str, Any]]:
+        match = re.search(r"<IceSL\s(.*)>", data)
+        if match:
+            version = match.group(1) if match.group(1)[0].isdigit() else "-"
+            return {
+                'slicer': "IceSL",
+                'slicer_version': version
+            }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sz_layer_height_first_layer_mm\s:\s+(\d+\.\d+)",
+            self.header_data)
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r";\sz_layer_height_mm\s:\s+(\d+\.\d+)",
+            self.header_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sprint_height_mm\s:\s+(\d+\.\d+)", self.header_data)
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sextruder_temp_degree_c_0\s:\s+(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sbed_temp_degree_c\s:\s+(\d+\.?\d*)", self.header_data)
+
+    def parse_chamber_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\schamber_temp_degree_c\s:\s+(\d+\.?\d*)", self.header_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sfilament_used_mm\s:\s+(\d+\.\d+)", self.header_data)
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sfilament_used_g\s:\s+(\d+\.\d+)", self.header_data)
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_name\s:\s+(.*)", self.header_data)
+
+    def parse_filament_type(self) -> Optional[str]:
+        return _regex_find_string(
+            r";\sfilament_type\s:\s+(.*)", self.header_data)
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\sestimated_print_time_s\s:\s+(\d*\.*\d*)", self.header_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        return _regex_find_int(
+            r";\slayer_count\s:\s+(\d+)", self.header_data)
+
+    def parse_nozzle_diameter(self) -> Optional[float]:
+        return _regex_find_first(
+            r";\snozzle_diameter_mm_0\s:\s+(\d+\.\d+)", self.header_data)
+
+class KiriMoto(BaseSlicer):
+    def check_identity(self, data) -> Optional[Dict[str, Any]]:
+        variants: Dict[str, str] = {
+            "Kiri:Moto": r"; Generated by Kiri:Moto (\d.+)",
+            "SimplyPrint": r"; Generated by Kiri:Moto \(SimplyPrint\) (.+)"
+        }
+        for name, pattern in variants.items():
+            match = re.search(pattern, data)
+            if match:
+                return {
+                    "slicer": name,
+                    "slicer_version": match.group(1)
+                }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; firstSliceHeight = (\d+\.\d+)", self.header_data
+        )
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        self.layer_height = _regex_find_first(
+            r"; sliceHeight = (\d+\.\d+)", self.header_data
+        )
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        return self._parse_max_float(
+            r"G1 Z\d+\.\d+ (?:; z-hop end|F\d+\n)",
+            self.footer_data, strict=True
+        )
+
+    def parse_layer_count(self) -> Optional[int]:
+        matches = re.findall(
+            r";; --- layer (\d+) \(.+", self.footer_data
+        )
+        if not matches:
+            return None
+        try:
+            return int(matches[-1]) + 1
+        except Exception:
+            return None
+
+    def parse_estimated_time(self) -> Optional[float]:
+        return _regex_find_int(r"; --- print time: (\d+)s", self.footer_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; --- filament used: (\d+\.?\d*) mm", self.footer_data
+        )
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; firstLayerNozzleTemp = (\d+\.?\d*)", self.header_data
+        )
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r"; firstLayerBedTemp = (\d+\.?\d*)", self.header_data
+        )
+
+class Creality(BaseSlicer):
+    def check_identity(self, data: str) -> Optional[Dict[str, str]]:
+        aliases = {
+            'Creative3D': r"Creative3D",
+            'Creality': r"Creality"
+        }
+        pattern = r'Version : V([\d\.]+)'
+        match_version = re.search(pattern, data)
+        if not match_version:
+            match_version = re.search(r'Creality_Print V([\d\.]+)', data)
+        slicer_version = match_version.group(1) if match_version else "1.0"
+        for name, expr in aliases.items():
+            match = re.search(expr, data)
+            if match:
+                return {
+                    'slicer': name,
+                    'slicer_version': slicer_version
+                }
+        return None
+
+    def parse_first_layer_height(self) -> Optional[float]:
+        first_layer_height = _regex_find_first(r";MINZ:(\d+\.?\d*)", self.header_data)
+        if not first_layer_height:
+            first_layer_height = _regex_find_first(r";MINZ:(\d+\.?\d*)", self.footer_data)
+        return first_layer_height
+
+    def parse_model_info(self):
+        return get_print_file_metadata(self.path)
+
+    def parse_layer_height(self) -> Optional[float]:
+        pattern = r";Layer height:\s*(\d+\.?\d*)"
+        self.layer_height = _regex_find_first(pattern, self.header_data)
+        if not self.layer_height:
+            self.layer_height = _regex_find_first(r"; layer_height = (\d+\.\d*)", self.footer_data)
+        return self.layer_height
+
+    def parse_object_height(self) -> Optional[float]:
+        matches = re.findall(
+            r";MAXZ:(\d+\.?\d*)", self.header_data)
+        if matches:
+            try:
+                matches = [float(m) for m in matches]
+            except Exception:
+                pass
+            else:
+                return max(matches)
+        else:
+            max_z_height = _regex_find_first(r"; max_z_height: (\d+\.\d*)", self.header_data)
+            if max_z_height:
+                return max_z_height
+        return self._parse_max_float(r"G1\sZ\d+\.\d*\sF", self.footer_data)
+
+    def parse_layer_count(self) -> Optional[int]:
+        layer_count = _regex_find_int(r";LAYER_COUNT\:(\d+)", self.header_data)
+        if not layer_count:
+            layer_count = _regex_find_int(r"; total layer number: (\d+)", self.header_data)
+        return layer_count
+
+    def parse_filament_type(self) -> Optional[str]:
+        result = ""
+        filament_type = _regex_find_string(r";Material Type:(\S+)", self.header_data)
+        if not filament_type:
+            filament_type = _regex_find_string(r"; default_filament_type = (\S+)", self.footer_data)
+        if not filament_type:
+            filament_type = _regex_find_string(r"; filament_type = (\S+)", self.footer_data)
+        if filament_type:
+            result = filament_type.strip(";")
+        return result
+
+    def parse_filament_name(self) -> Optional[str]:
+        return _regex_find_string(
+            r";Material Name:(.+)", self.header_data)
+
+    def parse_filament_total(self) -> Optional[float]:
+        filament_total = _regex_find_first(
+            r";Filament used:(\d+\.?\d*)m", self.header_data)
+        if filament_total:
+            filament_total = filament_total * 1000
+        return filament_total
+
+    def parse_filament_weight_total(self) -> Optional[float]:
+        filament_weight_total = _regex_find_first(
+            r";Filament Weight:(\d+\.?\d*)", self.header_data)
+        if filament_weight_total:
+            filament_weight_total = filament_weight_total * 5.88
+        return filament_weight_total
+
+    def parse_estimated_time(self) -> Optional[float]:
+        total_time = _regex_find_first(
+            r";TIME:(\d+)", self.header_data)
+        return total_time
+
+    def parse_first_layer_extr_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Print Temperature:(\d+\.?\d*)", self.header_data)
+
+    def parse_first_layer_bed_temp(self) -> Optional[float]:
+        return _regex_find_first(
+            r";Bed Temperature:(\d+\.?\d*)", self.header_data)
+
+    def parse_flush_para(self) -> Optional[Dict[str, List[int]]]:
+        flush_multiplier = None
+        flush_volumes_matrix = None
+        # Search for flush_multiplier value
+        flush_multiplier_match = re.search(r'flush_multiplier\s*=\s*([\d.]+)', self.header_data)
+        if not flush_multiplier_match:
+            flush_multiplier_match = re.search(r'flush_multiplier\s*=\s*([\d.]+)', self.footer_data)
+        if flush_multiplier_match:
+            flush_multiplier = float(flush_multiplier_match.group(1))
+        # Search for flush_volumes_matrix value
+        flush_volumes_matrix_match = re.search(r'flush_volumes_matrix\s*=\s*([^;]+)', self.header_data)
+        if not flush_volumes_matrix_match:
+            flush_volumes_matrix_match = re.search(r'flush_volumes_matrix\s*=\s*([^;]+)', self.footer_data)
+        if flush_volumes_matrix_match:
+            flush_volumes_matrix = [int(float(x)) for x in flush_volumes_matrix_match.group(1).strip().split(',')]
+        # return
+        if flush_multiplier is not None or flush_volumes_matrix is not None:
+            return {'flush_multiplier': flush_multiplier, 'flush_volumes_matrix': flush_volumes_matrix}
+        else:
+            return None
+
+    def parse_default_filament_colour(self) -> Optional[Tuple[Any, ...]]:
+        default_filament_colour = []
+        default_filament_colour_match = re.search(r'default_filament_colour = (\S+)', self.header_data)
+        if not default_filament_colour_match:
+            default_filament_colour_match = re.search(r'default_filament_colour = (\S+)', self.footer_data)
+        if default_filament_colour_match:
+            default_filament_colour = default_filament_colour_match.group(1).split(';')
+        return default_filament_colour
+
+READ_SIZE = 512 * 1024
+SUPPORTED_SLICERS: List[Type[BaseSlicer]] = [
+    PrusaSlicer, Slic3rPE, Slic3r, Cura, Simplify3D,
+    KISSlicer, IdeaMaker, IceSL, KiriMoto, Creality
+]
+SUPPORTED_DATA = [
+    'gcode_start_byte',
+    'gcode_end_byte',
+    'layer_count',
+    'object_height',
+    'estimated_time',
+    'nozzle_diameter',
+    'layer_height',
+    'first_layer_height',
+    'first_layer_extr_temp',
+    'first_layer_bed_temp',
+    'chamber_temp',
+    'filament_name',
+    'filament_type',
+    'filament_total',
+    'filament_weight_total',
+    'flush_para',
+    'model_info',
+    'default_filament_colour']
+
+def process_objects(file_path: str, slicer: BaseSlicer, name: str) -> bool:
+    try:
+        from preprocess_cancellation import (
+            preprocess_slicer,
+            preprocess_cura,
+            preprocess_ideamaker,
+            preprocess_m486
+        )
+    except ImportError:
+        log_to_stderr("Module 'preprocess-cancellation' failed to load")
+        return False
+    fname = os.path.basename(file_path)
+    log_to_stderr(
+        f"Performing Object Processing on file: {fname}, "
+        f"sliced by {name}"
+    )
+    with tempfile.TemporaryDirectory() as tmp_dir_name:
+        tmp_file = os.path.join(tmp_dir_name, fname)
+        with open(file_path, 'r') as in_file:
+            with open(tmp_file, 'w') as out_file:
+                try:
+                    if slicer.has_m486_objects:
+                        processor = preprocess_m486
+                    elif isinstance(slicer, PrusaSlicer):
+                        processor = preprocess_slicer
+                    elif isinstance(slicer, Cura):
+                        processor = preprocess_cura
+                    elif isinstance(slicer, IdeaMaker):
+                        processor = preprocess_ideamaker
+                    else:
+                        log_to_stderr(
+                            f"Object Processing Failed, slicer {name}"
+                            "not supported"
+                        )
+                        return False
+                    for line in processor(in_file):
+                        out_file.write(line)
+                except Exception as e:
+                    log_to_stderr(f"Object processing failed: {e}")
+                    return False
+        if os.path.islink(file_path):
+            file_path = os.path.realpath(file_path)
+        shutil.move(tmp_file, file_path)
+    return True
+
+def get_slicer(file_path: str) -> Tuple[BaseSlicer, Dict[str, str]]:
+    header_data = footer_data = ""
+    slicer: Optional[BaseSlicer] = None
+    size = os.path.getsize(file_path)
+    with open(file_path, 'r') as f:
+        # read the default size, which should be enough to
+        # identify the slicer
+        header_data = f.read(READ_SIZE)
+        for impl in SUPPORTED_SLICERS:
+            slicer = impl(file_path)
+            ident = slicer.check_identity(header_data)
+            if ident is not None:
+                break
+        else:
+            slicer = UnknownSlicer(file_path)
+            ident = slicer.check_identity(header_data)
+        if size > READ_SIZE * 2:
+            f.seek(size - READ_SIZE)
+            footer_data = f.read()
+        elif size > READ_SIZE:
+            remaining = size - READ_SIZE
+            footer_data = header_data[remaining - READ_SIZE:] + f.read()
+        else:
+            footer_data = header_data
+        slicer.set_data(header_data, footer_data, size)
+    if ident is None:
+        ident = {"slicer": "unknown"}
+    return slicer, ident
+
+def extract_metadata(
+    file_path: str, check_objects: bool
+) -> Dict[str, Any]:
+    metadata: Dict[str, Any] = {}
+    slicer, ident = get_slicer(file_path)
+    if check_objects and slicer.has_objects():
+        name = ident.get("slicer", "unknown")
+        if process_objects(file_path, slicer, name):
+            slicer, ident = get_slicer(file_path)
+    metadata['size'] = os.path.getsize(file_path)
+    metadata['modified'] = os.path.getmtime(file_path)
+    metadata['uuid'] = str(uuid.uuid4())
+    metadata.update(ident)
+    for key in SUPPORTED_DATA:
+        func = getattr(slicer, "parse_" + key)
+        result = func()
+        if result is not None:
+            metadata[key] = result
+    if metadata.get("filament_type"):
+        metadata["model_info"]["MaterialType"] = metadata.get("filament_type")
+    if metadata.get("filament_name"):
+        metadata["model_info"]["MaterialName"] = metadata.get("filament_name")
+    return metadata
+
+def extract_ufp(ufp_path: str, dest_path: str) -> None:
+    if not os.path.isfile(ufp_path):
+        log_to_stderr(f"UFP file Not Found: {ufp_path}")
+        sys.exit(-1)
+    thumb_name = os.path.splitext(
+        os.path.basename(dest_path))[0] + ".png"
+    dest_thumb_dir = os.path.join(os.path.dirname(dest_path), ".thumbs")
+    dest_thumb_path = os.path.join(dest_thumb_dir, thumb_name)
+    try:
+        with tempfile.TemporaryDirectory() as tmp_dir_name:
+            tmp_thumb_path = ""
+            with zipfile.ZipFile(ufp_path) as zf:
+                tmp_model_path = zf.extract(
+                    UFP_MODEL_PATH, path=tmp_dir_name)
+                if UFP_THUMB_PATH in zf.namelist():
+                    tmp_thumb_path = zf.extract(
+                        UFP_THUMB_PATH, path=tmp_dir_name)
+            if os.path.islink(dest_path):
+                dest_path = os.path.realpath(dest_path)
+            shutil.move(tmp_model_path, dest_path)
+            if tmp_thumb_path:
+                if not os.path.exists(dest_thumb_dir):
+                    os.mkdir(dest_thumb_dir)
+                shutil.move(tmp_thumb_path, dest_thumb_path)
+    except Exception:
+        log_to_stderr(traceback.format_exc())
+        sys.exit(-1)
+    try:
+        os.remove(ufp_path)
+    except Exception:
+        log_to_stderr(f"Error removing ufp file: {ufp_path}")
+
+def main(path: str,
+         filename: str,
+         ufp: Optional[str],
+         check_objects: bool
+         ) -> None:
+    file_path = os.path.join(path, filename)
+    if ufp is not None:
+        extract_ufp(ufp, file_path)
+    metadata: Dict[str, Any] = {}
+    if not os.path.isfile(file_path):
+        log_to_stderr(f"File Not Found: {file_path}")
+        sys.exit(-1)
+    try:
+        metadata = extract_metadata(file_path, check_objects)
+    except Exception:
+        log_to_stderr(traceback.format_exc())
+        sys.exit(-1)
+    fd = sys.stdout.fileno()
+    data = json.dumps(
+        {'file': filename, 'metadata': metadata}).encode()
+    while data:
+        try:
+            ret = os.write(fd, data)
+        except OSError:
+            continue
+        data = data[ret:]
+
+
+if __name__ == "__main__":
+    # Parse start arguments
+    parser = argparse.ArgumentParser(
+        description="GCode Metadata Extraction Utility")
+    parser.add_argument(
+        "-f", "--filename", metavar='<filename>',
+        help="name gcode file to parse")
+    parser.add_argument(
+        "-p", "--path", default=os.path.abspath(os.path.dirname(__file__)),
+        metavar='<path>',
+        help="optional absolute path for file"
+    )
+    parser.add_argument(
+        "-u", "--ufp", metavar="<ufp file>", default=None,
+        help="optional path of ufp file to extract"
+    )
+    parser.add_argument(
+        "-o", "--check-objects", dest='check_objects', action='store_true',
+        help="process gcode file for exclude opbject functionality")
+    args = parser.parse_args()
+    check_objects = args.check_objects
+    enabled_msg = "enabled" if check_objects else "disabled"
+    log_to_stderr(f"Object Processing is {enabled_msg}")
+    main(args.path, args.filename, args.ufp, check_objects)
--- /dev/null
+++ b/klippy/extras/motor_control.py
@@ -0,0 +1,4 @@
+from . import motor_control_wrapper
+
+def load_config(config):
+    return(motor_control_wrapper.Motor_Control(config))
--- a/klippy/extras/output_pin.py
+++ b/klippy/extras/output_pin.py
@@ -7,9 +7,10 @@
 PIN_MIN_TIME = 0.100
 RESEND_HOST_TIME = 0.300 + PIN_MIN_TIME
 MAX_SCHEDULE_TIME = 5.0
-
+import logging
 class PrinterOutputPin:
     def __init__(self, config):
+        self.config = config
         self.printer = config.get_printer()
         ppins = self.printer.lookup_object('pins')
         self.is_pwm = config.getboolean('pwm', False)
@@ -50,13 +51,52 @@ class PrinterOutputPin:
                 'shutdown_value', 0., minval=0., maxval=self.scale) / self.scale
             self.mcu_pin.setup_start_value(self.last_value, self.shutdown_value)
             pin_name = config.get_name().split()[1]
+
             gcode = self.printer.lookup_object('gcode')
             gcode.register_mux_command("SET_PIN", "PIN", pin_name,
                                        self.cmd_SET_PIN,
                                        desc=self.cmd_SET_PIN_help)
+            self.heaters = self.printer.load_object(config,"heaters")
+
+            # if pin_name == "power":
+            #     self.power_timer = self.reactor.register_timer(
+            #         self.checkpwm, self.reactor.NOW+10)
+            #     self.ispweron = False
+    def set_poewon(self,value):
+
+        value /= self.scale
+        cycle_time = self.default_cycle_time
+
+        toolhead = self.printer.lookup_object('toolhead')
+        toolhead.register_lookahead_callback(
+            lambda print_time: self._set_pin(print_time, value, cycle_time))
+
+
+        # toolhead = self.printer.lookup_object('toolhead')
+        # toolhead.register_lookahead_callback(
+        #     lambda print_time: self._set_pin(print_time, value, 0))
+    def checkpwm(self, eventtime):
+        systime = self.reactor.monotonic()
+        for heater in self.heaters.heaters.values():
+
+            eventtime = self.reactor.monotonic()
+            if heater.name == "heater_bed" :
+                if heater.check_busy(eventtime) :
+                    if self.ispweron == False and heater.target_temp != 0:
+                        self.set_poewon(0)
+                        self.ispweron = True
+
+                else:
+                    if self.ispweron == True:
+                        self.ispweron = False
+                        self.set_poewon(1)
+                        return systime + 10
+        return systime + 3
     def get_status(self, eventtime):
         return {'value': self.last_value}
     def _set_pin(self, print_time, value, cycle_time, is_resend=False):
+
+
         if value == self.last_value and cycle_time == self.last_cycle_time:
             if not is_resend:
                 return
@@ -65,14 +105,19 @@ class PrinterOutputPin:
             self.mcu_pin.set_pwm(print_time, value, cycle_time)
         else:
             self.mcu_pin.set_digital(print_time, value)
+            pin_name = self.config.get_name().split()[1]
+            if pin_name.startswith("motor_"):
+                logging.info("_set_pin pin_name=%s value=%s" % (pin_name, value))
         self.last_value = value
         self.last_cycle_time = cycle_time
         self.last_print_time = print_time
         if self.resend_interval and self.resend_timer is None:
             self.resend_timer = self.reactor.register_timer(
                 self._resend_current_val, self.reactor.NOW)
+
     cmd_SET_PIN_help = "Set the value of an output pin"
     def cmd_SET_PIN(self, gcmd):
+
         value = gcmd.get_float('VALUE', minval=0., maxval=self.scale)
         value /= self.scale
         cycle_time = gcmd.get_float('CYCLE_TIME', self.default_cycle_time,
@@ -80,8 +125,11 @@ class PrinterOutputPin:
         if not self.is_pwm and value not in [0., 1.]:
             raise gcmd.error("Invalid pin value")
         toolhead = self.printer.lookup_object('toolhead')
-        toolhead.register_lookahead_callback(
-            lambda print_time: self._set_pin(print_time, value, cycle_time))
+        systime = self.reactor.monotonic()
+        print_time=self.mcu_pin.get_mcu().estimated_print_time(systime)
+        self._set_pin(print_time+0.1, value, cycle_time)
+        # toolhead.register_lookahead_callback(
+        #     lambda print_time: self._set_pin(print_time, value, cycle_time))
 
     def _resend_current_val(self, eventtime):
         if self.last_value == self.shutdown_value:
--- a/klippy/extras/pause_resume.py
+++ b/klippy/extras/pause_resume.py
@@ -3,16 +3,20 @@
 # Copyright (C) 2019  Eric Callahan <arksine.code@gmail.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
+import os, json, logging
+from .tool import reportInformation
 
 class PauseResume:
     def __init__(self, config):
         self.printer = config.get_printer()
+        self.reactor = self.printer.get_reactor()
         self.gcode = self.printer.lookup_object('gcode')
         self.recover_velocity = config.getfloat('recover_velocity', 50.)
         self.v_sd = None
         self.is_paused = False
         self.sd_paused = False
         self.pause_command_sent = False
+        self.config = config
         self.printer.register_event_handler("klippy:connect",
                                             self.handle_connect)
         self.gcode.register_command("PAUSE", self.cmd_PAUSE,
@@ -24,14 +28,114 @@ class PauseResume:
         self.gcode.register_command("CANCEL_PRINT", self.cmd_CANCEL_PRINT,
                                     desc=self.cmd_CANCEL_PRINT_help)
         webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("pause_resume/cancel_continue_print",
+                                   self._handle_cancel_continue_print_request)
+        webhooks.register_endpoint("pause_resume/check_continue_print_state",
+                                   self._check_power_loss_state_request)
+        webhooks.register_endpoint("pause_resume/set_print_first_layer",
+                                   self._set_print_first_layer_request)
         webhooks.register_endpoint("pause_resume/cancel",
                                    self._handle_cancel_request)
         webhooks.register_endpoint("pause_resume/pause",
                                    self._handle_pause_request)
         webhooks.register_endpoint("pause_resume/resume",
                                    self._handle_resume_request)
+        webhooks.register_endpoint("getBootLoaderVersion",
+                                   self._getBootLoaderVersion)
+        self._setBootLoaderStateCmdOid = None
+        self.pause_start = False
+        self.motor_cancel_print_start = False
+        self.resume_err = False
     def handle_connect(self):
         self.v_sd = self.printer.lookup_object('virtual_sdcard', None)
+        
+    def _getBootLoaderVersion(self, web_request):
+        mcu = self.printer.lookup_object('mcu')
+        result = mcu.get_constants().get('software_version', '')
+        web_request.send({'software_version': result})
+        return {"software_version": result}
+    
+    def _setBootLoaderState(self, web_request):
+        mcu = self.printer.lookup_object('mcu')
+        oid = mcu.create_oid() if not self._setBootLoaderStateCmdOid else self._setBootLoaderStateCmdOid
+        self._setBootLoaderStateCmdOid = oid
+        mcu.add_config_cmd("config_usrboot oid=%d" % (oid,))
+        # sendf("usrboot_ack oid=%c enter_boot_status=%c",args[0],status)
+        result = mcu.lookup_query_command("jump_to_usrboot_query oid=%c", "usrboot_ack oid=%c enter_boot_status=%c", oid=oid).send()
+        return {"result": result}
+
+    def _set_print_first_layer_request(self, web_request): 
+        self.v_sd.first_layer_stop = False
+        self.v_sd.print_first_layer = False
+        response = {"state": "success"}
+        web_request.send(response)
+        return response
+
+    def _check_power_loss_state_request(self, web_request): 
+        from subprocess import call
+        response = {"file_state": False, "eeprom_state": False}
+        if os.path.exists(self.v_sd.print_file_name_path):
+            try:
+                with open(self.v_sd.print_file_name_path, "r") as f:
+                    data = f.read()
+                    logging.info("[print_file_name_path] POWER_LOSS_DATA: \n %s", data)
+                    if len(data) == 0:
+                        logging.error("%s f.read()==None read fail!!!" % self.v_sd.print_file_name_path)
+                    response["file_state"] = True if json.loads(data) else False
+            except Exception as err:
+                os.remove(self.v_sd.print_file_name_path)
+                bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+                if bl24c16f:
+                    self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+                logging.exception(err)
+        power_loss_switch = False
+        if os.path.exists(self.v_sd.user_print_refer_path):
+            with open(self.v_sd.user_print_refer_path, "r") as f:
+                data = json.loads(f.read())
+                logging.info("[user_print_refer_path] POWER_LOSS_DATA: \n %s", data)
+                power_loss_switch = data.get("power_loss", {}).get("switch", False)
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+        eepromState = bl24c16f.checkEepromFirstEnable() if power_loss_switch and bl24c16f else True
+        self.gcode.run_script('EEPROM_DEBUG_READ ADDR=0 SIZE=56')
+        logging.info("power_loss_switch is %s, bl24c16f is %s, eepromState is %s", power_loss_switch, bl24c16f, eepromState)
+        if not eepromState:
+            response["eeprom_state"] = True
+        print_stats = self.printer.lookup_object('print_stats', None)
+        logging.info("print_stats.state is %s", print_stats.state)
+        if response["file_state"] == True and response["eeprom_state"] == True and print_stats and print_stats.state == "standby":
+            print_stats.power_loss = 1
+        if print_stats and print_stats.state != "standby":
+            response["file_state"] = False
+            response["eeprom_state"] = False
+            logging.info("current printer state:%s" % print_stats.state)
+        if os.path.exists(self.gcode.exclude_object_info) and (response["file_state"]==False or response["eeprom_state"]==False):
+            os.remove(self.gcode.exclude_object_info)
+        web_request.send(response)
+        return response
+    
+    def _handle_cancel_continue_print_request(self, web_request):
+        self.printer.send_event("v_sd:cancel_power_loss_update_filament_used")
+        reactor = self.printer.get_reactor()
+        reactor.pause(reactor.monotonic()+0.2)
+        from subprocess import call
+        if os.path.exists(self.v_sd.print_file_name_path):
+            os.remove(self.v_sd.print_file_name_path)
+        if os.path.exists(self.gcode.exclude_object_info):
+            os.remove(self.gcode.exclude_object_info)
+        call("sync", shell=True)
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+        power_loss_switch = False
+        if os.path.exists(self.v_sd.user_print_refer_path):
+            with open(self.v_sd.user_print_refer_path, "r") as f:
+                data = json.loads(f.read())
+                power_loss_switch = data.get("power_loss", {}).get("switch", False)
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+        if power_loss_switch and bl24c16f:
+            self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+            self.gcode.respond_info("cancel_continue_print:success")
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats:
+            print_stats.power_loss = 0
     def _handle_cancel_request(self, web_request):
         self.gcode.run_script("CANCEL_PRINT")
     def _handle_pause_request(self, web_request):
@@ -40,7 +144,8 @@ class PauseResume:
         self.gcode.run_script("RESUME")
     def get_status(self, eventtime):
         return {
-            'is_paused': self.is_paused
+            'is_paused': self.is_paused,
+            'resume_err': self.resume_err
         }
     def is_sd_active(self):
         return self.v_sd is not None and self.v_sd.is_active()
@@ -65,9 +170,11 @@ class PauseResume:
         self.send_pause_command()
         self.gcode.run_script_from_command("SAVE_GCODE_STATE NAME=PAUSE_STATE")
         self.is_paused = True
+        reportInformation("key601")
     def send_resume_command(self):
         if self.sd_paused:
             # Printing from virtual sd, run pause command
+            self.v_sd.do_resume_status = True
             self.v_sd.do_resume()
             self.sd_paused = False
         else:
@@ -78,12 +185,26 @@ class PauseResume:
         if not self.is_paused:
             gcmd.respond_info("""{"code": "key16", "msg": "Print is not paused, resume aborted"}""")
             return
+        if self.resume_err == True:
+            logging.info("resume_err is True")
+            self.reactor.pause(self.reactor.monotonic() + 0.5)
+            self.resume_err = False
+            return
         velocity = gcmd.get_float('VELOCITY', self.recover_velocity)
         self.gcode.run_script_from_command(
             "RESTORE_GCODE_STATE NAME=PAUSE_STATE MOVE=1 MOVE_SPEED=%.4f"
             % (velocity))
         self.send_resume_command()
         self.is_paused = False
+        result = {}
+        if os.path.exists(self.v_sd.print_file_name_path):
+            with open(self.v_sd.print_file_name_path, "r") as f:
+                result = (json.loads(f.read()))
+                result["variable_z_safe_pause"] = 0
+            with open(self.v_sd.print_file_name_path, "w") as f:
+                f.write(json.dumps(result))
+                f.flush()
+        reportInformation("key602")
     cmd_CLEAR_PAUSE_help = (
         "Clears the current paused state without resuming the print")
     def cmd_CLEAR_PAUSE(self, gcmd):
@@ -95,6 +216,7 @@ class PauseResume:
         else:
             gcmd.respond_info("action:cancel")
         self.cmd_CLEAR_PAUSE(gcmd)
+        reportInformation("key603")
 
 def load_config(config):
     return PauseResume(config)
--- /dev/null
+++ b/klippy/extras/photograph.py
@@ -0,0 +1,14 @@
+import logging
+from subprocess import check_output
+
+def main():
+    try:
+        capture_shell = "capture 0"
+        logging.info(capture_shell)
+        capture_ret = check_output(capture_shell, shell=True).decode("utf-8")
+        logging.info("capture 0 return:#%s#" % str(capture_ret))
+    except Exception as err:
+        logging.error(err)
+
+if __name__ == "__main__":
+    main()
--- a/klippy/extras/pid_calibrate.py
+++ b/klippy/extras/pid_calibrate.py
@@ -8,6 +8,7 @@ from . import heaters
 
 class PIDCalibrate:
     def __init__(self, config):
+        self.config = config
         self.printer = config.get_printer()
         gcode = self.printer.lookup_object('gcode')
         gcode.register_command('PID_CALIBRATE', self.cmd_PID_CALIBRATE,
@@ -43,11 +44,27 @@ class PIDCalibrate:
             "The SAVE_CONFIG command will update the printer config file\n"
             "with these parameters and restart the printer." % (Kp, Ki, Kd))
         # Store results for SAVE_CONFIG
+        Kp_name = 'pid_Kp'
+        Ki_name = 'pid_Ki'
+        Kd_name = 'pid_Kd'
+        PID_PARAM_BASE = 255.
+        high_temp_value = self.config.getsection('extruder').getint('high_temp_value', default=280)
+        if heater_name == 'extruder' and target > high_temp_value:
+            Kp_name = 'pid_Kp_high_temp'
+            Ki_name = 'pid_Ki_high_temp'
+            Kd_name = 'pid_Kd_high_temp'
+            heater.control.pid_calibrate_Kp_ht = float("%.3f" % Kp) / PID_PARAM_BASE
+            heater.control.pid_calibrate_Ki_ht = float("%.3f" % Ki) / PID_PARAM_BASE
+            heater.control.pid_calibrate_Kd_ht = float("%.3f" % Kd) / PID_PARAM_BASE
+        elif heater_name == 'extruder' and target <= high_temp_value:
+            heater.control.pid_calibrate_Kp = float("%.3f" % Kp) / PID_PARAM_BASE
+            heater.control.pid_calibrate_Ki = float("%.3f" % Ki) / PID_PARAM_BASE
+            heater.control.pid_calibrate_Kd = float("%.3f" % Kd) / PID_PARAM_BASE
         configfile = self.printer.lookup_object('configfile')
         configfile.set(heater_name, 'control', 'pid')
-        configfile.set(heater_name, 'pid_Kp', "%.3f" % (Kp,))
-        configfile.set(heater_name, 'pid_Ki', "%.3f" % (Ki,))
-        configfile.set(heater_name, 'pid_Kd', "%.3f" % (Kd,))
+        configfile.set(heater_name, Kp_name, "%.3f" % (Kp,))
+        configfile.set(heater_name, Ki_name, "%.3f" % (Ki,))
+        configfile.set(heater_name, Kd_name, "%.3f" % (Kd,))
 
 TUNE_PID_DELTA = 5.0
 
--- a/klippy/extras/print_stats.py
+++ b/klippy/extras/print_stats.py
@@ -3,7 +3,8 @@
 # Copyright (C) 2020  Eric Callahan <arksine.code@gmail.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-
+import os, json, logging
+from .base_info import base_dir
 class PrintStats:
     def __init__(self, config):
         printer = config.get_printer()
@@ -15,6 +16,20 @@ class PrintStats:
         self.gcode.register_command(
             "SET_PRINT_STATS_INFO", self.cmd_SET_PRINT_STATS_INFO,
             desc=self.cmd_SET_PRINT_STATS_INFO_help)
+        # G28 down 12mm flag
+        self.power_loss = 0
+        self.print_duration = 0
+        self.z_pos_filepath = os.path.join(base_dir, "creality/userdata/config/z_pos.json")
+        self.z_pos = self.get_z_pos()
+    def get_z_pos(self):
+        z_pos = 0
+        if os.path.exists(self.z_pos_filepath):
+            try:
+                with open(self.z_pos_filepath, "r") as f:
+                    z_pos = float(json.loads(f.read()).get("z_pos", 0))
+            except Exception as err:
+                logging.error(err)
+        return z_pos
     def _update_filament_usage(self, eventtime):
         gc_status = self.gcode_move.get_status(eventtime)
         cur_epos = gc_status['position'].e
@@ -24,17 +39,35 @@ class PrintStats:
     def set_current_file(self, filename):
         self.reset()
         self.filename = filename
-    def note_start(self):
+    def note_start(self, info_path=""):
         curtime = self.reactor.monotonic()
+        # if self.print_start_time is None:
+        #     self.print_start_time = curtime
+        # elif self.last_pause_time is not None:
+        #     # Update pause time duration
+        #     pause_duration = curtime - self.last_pause_time
+        #     self.prev_pause_duration += pause_duration
+        #     self.last_pause_time = None
+        # Reset last e-position
+        gc_status = self.gcode_move.get_status(curtime)
+        ret = {}
+        if info_path and os.path.exists(info_path):
+            try:
+                with open(info_path, "r") as f:
+                    ret = json.loads(f.read())
+                    self.filament_used = ret.get("filament_used", 0)
+            except Exception as err:
+                pass
         if self.print_start_time is None:
-            self.print_start_time = curtime
+            if info_path and ret and ret.get("last_print_duration"):
+                self.print_start_time = curtime - int(ret.get("last_print_duration", 0))
+            else:
+                self.print_start_time = curtime
         elif self.last_pause_time is not None:
             # Update pause time duration
             pause_duration = curtime - self.last_pause_time
             self.prev_pause_duration += pause_duration
             self.last_pause_time = None
-        # Reset last e-position
-        gc_status = self.gcode_move.get_status(curtime)
         self.last_epos = gc_status['position'].e
         self.state = "printing"
         self.error_message = ""
@@ -105,6 +138,7 @@ class PrintStats:
                 # Track duration prior to extrusion
                 self.init_duration = self.total_duration - time_paused
         print_duration = self.total_duration - self.init_duration - time_paused
+        self.print_duration = print_duration
         return {
             'filename': self.filename,
             'total_duration': self.total_duration,
@@ -113,8 +147,12 @@ class PrintStats:
             'state': self.state,
             'message': self.error_message,
             'info': {'total_layer': self.info_total_layer,
-                     'current_layer': self.info_current_layer}
+                     'current_layer': self.info_current_layer},
+            'power_loss': self.power_loss,
+            'z_pos': self.z_pos,
         }
+    def stats(self, eventtime):
+        return False, 'print_stats: %s' % self.state
 
 def load_config(config):
     return PrintStats(config)
--- a/klippy/extras/probe.py
+++ b/klippy/extras/probe.py
@@ -23,6 +23,8 @@ class PrinterProbe:
         self.x_offset = config.getfloat('x_offset', 0.)
         self.y_offset = config.getfloat('y_offset', 0.)
         self.z_offset = config.getfloat('z_offset')
+        self.z_offset_calibrate = 0
+        self.z_offset_change_flag = False
         self.probe_calibrate_z = 0.
         self.multi_probe_pending = False
         self.last_state = False
@@ -127,6 +129,17 @@ class PrinterProbe:
             if "Timeout during endstop homing" in reason:
                 reason += HINT_TIMEOUT
             raise self.printer.command_error(reason)
+        # get z compensation from axis_twist_compensation
+        axis_twist_compensation = self.printer.lookup_object(
+            'axis_twist_compensation', None)
+        z_compensation = 0
+        if axis_twist_compensation is not None:
+            z_compensation = (
+                axis_twist_compensation.get_z_compensation_value(pos))
+        # add z compensation to probe position
+        self.gcode.respond_info("probe at %.3f,%.3f is z=%.6f z_compensation=%.6f"
+                                % (epos[0], epos[1], epos[2],z_compensation))
+        epos[2] += z_compensation
         self.gcode.respond_info("probe at %.3f,%.3f is z=%.6f"
                                 % (epos[0], epos[1], epos[2]))
         return epos[:3]
@@ -196,7 +209,8 @@ class PrinterProbe:
         gcmd.respond_info("probe: %s" % (["open", "TRIGGERED"][not not res],))
     def get_status(self, eventtime):
         return {'last_query': self.last_state,
-                'last_z_result': self.last_z_result}
+                'last_z_result': self.last_z_result,
+                'z_offset': self.z_offset_calibrate if self.z_offset_change_flag else self.z_offset}
     cmd_PROBE_ACCURACY_help = "Probe Z-height accuracy at current XY position"
     def cmd_PROBE_ACCURACY(self, gcmd):
         speed = gcmd.get_float("PROBE_SPEED", self.speed, above=0.)
@@ -239,6 +253,7 @@ class PrinterProbe:
             "probe accuracy results: maximum %.6f, minimum %.6f, range %.6f, "
             "average %.6f, median %.6f, standard deviation %.6f" % (
             max_value, min_value, range_value, avg_value, median, sigma))
+        return max_value, min_value, range_value, avg_value, median, sigma,positions
     def probe_calibrate_finalize(self, kin_pos):
         if kin_pos is None:
             return
@@ -269,18 +284,37 @@ class PrinterProbe:
     def cmd_Z_OFFSET_APPLY_PROBE(self,gcmd):
         offset = self.gcode_move.get_status()['homing_origin'].z
         configfile = self.printer.lookup_object('configfile')
-        if offset == 0:
-            self.gcode.respond_info("Nothing to do: Z Offset is 0")
-        else:
-            new_calibrate = self.z_offset - offset
-            self.gcode.respond_info(
-                "%s: z_offset: %.3f\n"
-                "The SAVE_CONFIG command will update the printer config file\n"
-                "with the above and restart the printer."
-                % (self.name, new_calibrate))
-            configfile.set(self.name, 'z_offset', "%.3f" % (new_calibrate,))
+        # if offset == 0:
+        #     self.gcode.respond_info("Nothing to do: Z Offset is 0")
+        # else:
+        new_calibrate = self.z_offset - offset
+        self.gcode.respond_info(
+            "%s: z_offset: %.3f\n"
+            "The SAVE_CONFIG command will update the printer config file\n"
+            "with the above and restart the printer."
+            % (self.name, new_calibrate))
+        configfile.set(self.name, 'z_offset', "%.3f" % (new_calibrate,))
+        self.z_offset_calibrate = new_calibrate
+        self.z_offset_change_flag = True
+        self.record_gcode_offset_when_printing()
     cmd_Z_OFFSET_APPLY_PROBE_help = "Adjust the probe's z_offset"
 
+    def record_gcode_offset_when_printing(self):
+        import os, json
+        try:
+            configfile = self.printer.lookup_object('configfile')
+            print_stats = self.printer.load_object(configfile, 'print_stats')
+            v_sd = self.printer.lookup_object('virtual_sdcard')
+            if print_stats and print_stats.state == "printing" and os.path.exists(v_sd.print_file_name_path) and self.z_offset_change_flag:
+                with open(v_sd.print_file_name_path, "r") as f:
+                    result = (json.loads(f.read()))
+                    result["SET_GCODE_OFFSET"] = self.z_offset_calibrate
+                with open(v_sd.print_file_name_path, "w") as f:
+                    f.write(json.dumps(result))
+                    f.flush()
+        except Exception as err:
+            logging.error("record_gcode_offset_when_printing error: %s" % err)
+
 # Endstop wrapper that enables probe specific features
 class ProbeEndstopWrapper:
     def __init__(self, config):
@@ -369,6 +403,11 @@ class ProbePointsHelper:
         self.lift_speed = self.speed
         self.probe_offsets = (0., 0., 0.)
         self.results = []
+        self.probe_type = ""
+        if config.has_section('prtouch_v2'):
+            self.probe_type = "prtouch_v2"
+        elif config.has_section('bltouch'):
+            self.probe_type = "bltouch"
     def minimum_points(self,n):
         if len(self.probe_points) < n:
             raise self.printer.config_error(
@@ -387,7 +426,8 @@ class ProbePointsHelper:
         if not self.results:
             # Use full speed to first probe position
             speed = self.speed
-        toolhead.manual_move([None, None, self.horizontal_move_z], speed)
+        if self.probe_type != "prtouch_v2":
+            toolhead.manual_move([None, None, self.horizontal_move_z], speed)
         # Check if done probing
         if len(self.results) >= len(self.probe_points):
             toolhead.get_last_move_time()
@@ -400,7 +440,10 @@ class ProbePointsHelper:
         if self.use_offsets:
             nextpos[0] -= self.probe_offsets[0]
             nextpos[1] -= self.probe_offsets[1]
-        toolhead.manual_move(nextpos, self.speed)
+        if self.probe_type == "prtouch_v2":
+            self.printer.lookup_object('probe').mcu_probe.run_to_next(nextpos)
+        else:
+            toolhead.manual_move(nextpos, self.speed)
         return False
     def start_probe(self, gcmd):
         manual_probe.verify_no_manual_probe(self.printer)
@@ -420,8 +463,18 @@ class ProbePointsHelper:
         if self.horizontal_move_z < self.probe_offsets[2]:
             raise gcmd.error("""{"code": "key15", "msg": "horizontal_move_z can't be less than probe's z_offset"}""")
         probe.multi_probe_begin()
+        # gcode = self.printer.lookup_object('gcode')
+        # g28_gcmd = gcode.create_gcode_command("G28", "G28", {'X': '0', 'Y': '0', 'Z': '0'})
+        # self.safe_z_home = self.printer.lookup_object('safe_z_home')
+        # self.safe_z_home.cmd_G28(g28_gcmd)
         while 1:
             done = self._move_next()
+
+            # 增加等待时间，用于倾斜校准等待一小段时间，避免干扰
+            wait_time = gcmd.get_float('WAITTIME', default = 0)
+            if wait_time != 0:
+                logging.info("Z_TILT_ADJUST wait_time: %s" % wait_time)
+                self.printer.get_reactor().pause(self.printer.get_reactor().monotonic() + wait_time)
             if done:
                 break
             pos = probe.run_probe(gcmd)
--- /dev/null
+++ b/klippy/extras/prtouch.py
@@ -0,0 +1,819 @@
+# Support for button detection and callbacks
+#
+# Copyright (C) 2022-12-09  CC <wangyulong878@sina.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging
+import math
+import random
+from . import probe
+import mcu
+import time
+import socket
+
+class PRTouchCFG:
+    def __init__(self, config):
+        self.base_count = config.getint('base_count', default=40, minval=10, maxval=100)
+        self.pi_count = config.getint('pi_count', default=32, minval=16, maxval=128)
+        self.min_hold = config.getint('min_hold', default=3000, minval=100, maxval=50000)
+        self.max_hold = config.getint('max_hold', default=50000, minval=100, maxval=100000)
+        self.hot_min_temp = config.getfloat('s_hot_min_temp', default=140, minval=80, maxval=200)
+        self.hot_max_temp = config.getfloat('s_hot_max_temp', default=200, minval=180, maxval=300)
+        self.bed_max_temp = config.getfloat('s_bed_max_temp', default=60, minval=45, maxval=100)
+        self.pa_fil_len_mm = config.getint('pa_fil_len_mm', default=2, minval=2, maxval=100)
+        self.pa_fil_dis_mm = config.getint('pa_fil_dis_mm', default=30, minval=2, maxval=100)
+        self.pa_clr_dis_mm = config.getint('pa_clr_dis_mm', default=20, minval=2, maxval=100)
+        self.pa_clr_down_mm = config.getfloat('pa_clr_down_mm', default=-0.1, minval=-1, maxval=1)
+        self.clr_noz_start_x = config.getfloat('clr_noz_start_x', default=0, minval=0, maxval=1000)
+        self.clr_noz_start_y = config.getfloat('clr_noz_start_y', default=0, minval=0, maxval=1000)
+        self.clr_noz_len_x = config.getfloat('clr_noz_len_x', default=0, minval=self.pa_clr_dis_mm + 6, maxval=1000)
+        self.clr_noz_len_y = config.getfloat('clr_noz_len_y', default=0, minval=0, maxval=1000)
+        self.bed_max_err = config.getint('bed_max_err', default=2, minval=2, maxval=10)
+        self.max_z = config.getsection('stepper_z').getfloat('position_max', default=300, minval=100, maxval=500)
+        self.g29_xy_speed = config.getfloat('g29_xy_speed', default=150, minval=10, maxval=1000)
+        self.fix_z_offset = config.getfloat('fix_z_offset', default=0.0, minval=-1, maxval=1)
+        self.max_dis_bef_g28 = config.getfloat('max_dis_bef_g28', default=10, minval=0, maxval=50)
+        self.dead_zone_bef_g28 = config.getfloat('dead_zone_bef_g28', default=self.max_dis_bef_g28 / 2, minval=0, maxval=50) 
+        self.g28_sta0_speed = config.getfloat('g28_sta0_speed', default=2.0, minval=0.1, maxval=10)
+        self.g28_sta1_speed = config.getfloat('g28_sta1_speed', default=2.5, minval=0.1, maxval=10)
+        self.g29_rdy_speed = config.getfloat('g29_rdy_speed', default=2.5, minval=0.1, maxval=10)
+        self.g29_speed = config.getfloat('g29_speed', default=2.0, minval=0.1, maxval=10)
+        self.show_msg = config.getboolean('show_msg', default=False)
+        self.best_above_z = config.getfloat('best_above_z', default=1.5, minval=0.5, maxval=10)
+        self.g28_wait_cool_down = config.getboolean('g28_wait_cool_down', default=False)
+        self.shake_cnt = config.getint('shake_cnt', default=4, minval=1, maxval=512)
+        self.shake_range = config.getint('shake_range', default=0.5, minval=0.1, maxval=2)
+        self.shake_max_velocity = config.getfloat('shake_max_velocity', default=100, minval=1, maxval=5000)
+        self.shake_max_accel = config.getfloat('shake_max_accel', default=1000, minval=1, maxval=50000)
+        self.g28_sta0_min_hold = config.getint('g28_sta0_min_hold', default=self.min_hold * 2, minval=100, maxval=100000)
+        self.need_measure_gap = config.getboolean('need_measure_gap', default=True)
+        self.gap_dis_range = config.getfloat('gap_dis_range', default=0.6, minval=0.2, maxval=2)
+        self.z_gap_00 = config.getfloat('z_gap_00', default=0, minval=-1, maxval=1)
+        self.z_gap_01 = config.getfloat('z_gap_01', default=0, minval=-1, maxval=1)
+        self.z_gap_10 = config.getfloat('z_gap_10', default=0, minval=-1, maxval=1)
+        self.z_gap_11 = config.getfloat('z_gap_11', default=0, minval=-1, maxval=1)
+        self.check_bed_mesh_max_err = config.getfloat('check_bed_mesh_max_err', default=0.2, minval=0.01, maxval=1)
+        self.tri_wave_ip    = config.get('tri_wave_ip', None)
+        self.self_z_offset = config.getfloat('self_z_offset', default=0.0, minval=-2, maxval=2)
+
+        self.stored_profs = config.get_prefix_sections('prtouch')
+        self.stored_profs = self.stored_profs[1] if (len(self.stored_profs) == 2 and self.need_measure_gap) else None
+        pass
+
+
+class PRTouchVAL:
+    def __init__(self, config):
+        self.out_index = 0
+        self.out_val_mm = 0.
+        self.rdy_pos = [[0., 0., 0.] * 4]
+        self.gap_pos = None
+        self.g29_cnt = int(0)
+        self.re_probe_cnt = 0
+        self.home_xy = None
+        self.jump_probe_ready = False
+        pass
+
+
+class PRTouchOBJ:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.toolhead = None
+        self.hx711s = None
+        self.pheaters = None
+        self.heater_hot = None
+        self.heater_bed = None
+        self.bed_mesh = None
+        self.mcu = None
+        self.dirzctl = None
+        self.kin = None
+        self.gcode = self.printer.lookup_object('gcode')
+        pass
+
+    def find_objs(self):
+        self.toolhead = self.printer.lookup_object('toolhead')
+        self.hx711s = self.printer.lookup_object('hx711s')
+        self.pheaters = self.printer.lookup_object('heaters')
+        self.heater_hot = self.printer.lookup_object('extruder').heater
+        self.heater_bed = self.printer.lookup_object('heater_bed').heater
+        self.bed_mesh = self.printer.lookup_object('bed_mesh')
+        self.dirzctl = self.printer.lookup_object('dirzctl')
+        self.mcu = self.hx711s.mcu
+        self.filter = self.printer.lookup_object('filter')
+        self.kin = self.toolhead.get_kinematics()
+        pass
+
+
+class PRTouchEndstopWrapper:
+    def __init__(self, config):
+        self.cfg = PRTouchCFG(config)
+        self.val = PRTouchVAL(config)
+        self.obj = PRTouchOBJ(config)
+
+        self.obj.printer.register_event_handler('klippy:mcu_identify', self._handle_mcu_identify)
+        self.obj.gcode.register_command('PRTOUCH_TEST', self.cmd_PRTOUCH_TEST, desc=self.cmd_PRTOUCH_TEST_help)
+        self.obj.gcode.register_command('PRTOUCH_READY', self.cmd_PRTOUCH_READY, desc=self.cmd_PRTOUCH_READY_help)
+        self.obj.gcode.register_command('NOZZLE_CLEAR', self.cmd_NOZZLE_CLEAR, desc=self.cmd_NOZZLE_CLEAR_help)
+        self.obj.gcode.register_command('CHECK_BED_MESH', self.cmd_CHECK_BED_MESH, desc=self.cmd_CHECK_BED_MESH_help)
+        self.obj.gcode.register_command('MEASURE_GAP_TEST', self.cmd_MEASURE_GAP_TEST, desc=self.cmd_MEASURE_GAP_TEST_help)
+        pass
+
+    def _handle_mcu_identify(self):
+        self.obj.find_objs()
+        min_x, min_y = self.obj.bed_mesh.bmc.mesh_min
+        max_x, max_y = self.obj.bed_mesh.bmc.mesh_max
+        self.val.rdy_pos = [[min_x, min_y, self.cfg.bed_max_err + 1.],
+                            [min_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, min_y, self.cfg.bed_max_err + 1.]]
+        self.val.gap_pos = [[min_x + 1., min_y + 1., self.cfg.z_gap_00], # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_00', default=self.cfg.z_gap_00, minval=0, maxval=1)],
+                            [min_x + 1., max_y - 1., self.cfg.z_gap_01], # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_01', default=self.cfg.z_gap_01, minval=0, maxval=1)],
+                            [max_x - 1., max_y - 1., self.cfg.z_gap_11], # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_11', default=self.cfg.z_gap_11, minval=0, maxval=1)],
+                            [max_x - 1., min_y + 1., self.cfg.z_gap_10]] # if self.cfg.stored_profs is None else self.cfg.stored_profs.getfloat('z_gap_10', default=self.cfg.z_gap_10, minval=0, maxval=1)]]
+        if self.cfg.clr_noz_start_x <= 0 or self.cfg.clr_noz_start_y <= 0 or self.cfg.clr_noz_len_x <= 0 or self.cfg.clr_noz_len_y <= 0:
+            self.cfg.clr_noz_start_x = (max_x - min_x) * 1 / 3 + min_x
+            self.cfg.clr_noz_start_y = max_y - 6
+            self.cfg.clr_noz_len_x = (max_x - min_x) * 1 / 3
+            self.cfg.clr_noz_len_y = 5
+        self.val.home_xy = [(max_x - min_x) / 2 + min_x, (max_y - min_y) / 2 + min_y]
+        pass
+
+    def get_mcu(self):
+        return self.obj.mcu
+
+    def multi_probe_begin(self):
+        pass
+
+    def multi_probe_end(self):
+        pass
+
+    def probe_prepare(self, hmove):
+        pass
+
+    def home_start(self, print_time, sample_time, sample_count, rest_time,
+                   triggered=True):
+        return True
+
+    def add_stepper(self, stepper):
+        pass
+
+    def get_steppers(self):
+        return self.obj.dirzctl.steppers
+
+    def ck_sys_sta(self):
+        return not self.obj.hx711s.is_shutdown and not self.obj.hx711s.is_timeout and  not self.obj.dirzctl.is_shutdown and not self.obj.dirzctl.is_timeout
+
+    def _ck_g28ed(self, is_precision=True):
+        for i in range(3):
+            if self.obj.kin.limits[i][0] > self.obj.kin.limits[i][1]:
+                self.obj.gcode.run_script_from_command('G28')
+                break
+        pass
+
+    def _move(self, pos, speed, wait=True):
+        if not self.obj.hx711s.is_shutdown and not self.obj.hx711s.is_timeout and  not self.obj.dirzctl.is_shutdown and not self.obj.dirzctl.is_timeout:
+            # self.obj.toolhead.manual_move(pos, speed)
+            self.obj.gcode.run_script_from_command('G1 F%d X%.3f Y%.3f Z%.3f' % (speed * 60, pos[0], pos[1], pos[2]) if len(pos) >= 3 else 'G1 F%d X%.3f Y%.3f' % (speed * 60, pos[0], pos[1]))
+            if wait:
+                self.obj.toolhead.wait_moves()
+            pass
+
+    def _check_index(self, index):
+        if (index <= self.cfg.pi_count - 3) and (index >= self.cfg.pi_count * 2 / 3):
+            return True
+        return False
+
+    def _get_linear2(self, p1, p2, po, is_base_x):
+        if (math.fabs(p1[0] - p2[0]) < 0.001 and is_base_x) or (math.fabs(p1[1] - p2[1]) < 0.001 and not is_base_x):
+            return po
+        a = (p2[2] - p1[2]) / ((p2[0] - p1[0]) if is_base_x else (p2[1] - p1[1]))
+        b = p1[2] - (p1[0] if is_base_x else p1[1]) * a
+        po[2] = a * (po[0] if is_base_x else po[1]) + b
+        return po
+
+    def _pnt_tri_msg(self, index, msg,  ary):
+        if self.cfg.show_msg:
+            self.pnt_msg('TRI SUCCESS BY: ' + msg)
+            self.pnt_array('TRI CH=%d ARY=' % index, ary)
+        pass
+
+    def _check_trigger(self, arg_index, fit_vals, unfit_vals, min_hold, max_hold):
+        all_params, tick = self.obj.dirzctl.get_params()
+        if len(all_params) == 2:
+            self._pnt_tri_msg(arg_index, 'Tri by Dirzctl run over!', fit_vals)
+            return True
+        fit_vals_t = [x for x in fit_vals]
+        self.val.out_index = self.cfg.pi_count - 1
+        if len(fit_vals) >= (self.cfg.pi_count / 2) and math.fabs(fit_vals[-1]) >= max_hold and \
+                math.fabs(fit_vals[-2]) >= max_hold and math.fabs(fit_vals[-3]) >= max_hold:
+            self._pnt_tri_msg(arg_index, 'Tri by out max_hold!', fit_vals)
+            return True
+        if len(fit_vals) != self.cfg.pi_count:
+            return False           
+        for i in range(1, self.cfg.pi_count - 1):
+            if fit_vals_t[i] >= max_hold and fit_vals_t[i - 1] < (max_hold / 2) and fit_vals_t[i + 1] < (max_hold / 2):
+                fit_vals_t[i] = fit_vals_t[i - 1]
+        
+        vals_p = [x for x in fit_vals_t]
+        max_val = max(vals_p)
+        min_val = min(vals_p)
+        max_val += 1 if (max_val - min_val) == 0 else 0
+        for i in range(len(vals_p)):
+            vals_p[i] = (vals_p[i] - min_val) / (max_val - min_val)
+        angle = math.atan((vals_p[-1] - vals_p[0]) / len(vals_p))
+        sin_angle = math.sin(-angle)
+        cos_angle = math.cos(-angle)
+        for i in range(len(vals_p)):
+            vals_p[i] = (i - 0) * sin_angle + (vals_p[i] - 0) * cos_angle + 0
+        self.val.out_index = vals_p.index(min(vals_p))
+        if(self.val.out_index > 0):
+            for i in range(self.val.out_index, self.cfg.pi_count):
+                fit_vals_t[self.val.out_index] = fit_vals_t[self.val.out_index] * (self.obj.filter.lft_k1_oft / 2) + fit_vals_t[self.val.out_index - 1] * (1 - (self.obj.filter.lft_k1_oft / 2))
+        vals_p = [x for x in fit_vals_t]
+
+        if not (fit_vals_t[-1] > fit_vals_t[-2] > fit_vals_t[-3]):
+            return False
+        max_val = max(fit_vals_t[0:(self.cfg.pi_count - 3)])
+        if not ((fit_vals_t[-1] > max_val) and (fit_vals_t[-2] > max_val) and (fit_vals_t[-3] > max_val)):
+            return False
+        max_val = max(fit_vals_t)
+        min_val = min(fit_vals_t)
+        for i in range(0, self.cfg.pi_count):
+            fit_vals_t[i] = (fit_vals_t[i] - min_val) / (max_val - min_val)
+        for i in range(0, self.cfg.pi_count - 1):
+            if (fit_vals_t[-1] - fit_vals_t[i]) / ((self.cfg.pi_count - i) * 1. / self.cfg.pi_count) < 0.8:
+                return False
+        if fit_vals[-1] < min_hold or fit_vals[-2] < (min_hold / 2) or fit_vals[-3] < (min_hold / 3):
+            return False
+        self._pnt_tri_msg(arg_index, 'Tri by fit all rule!', vals_p)
+        return True
+
+    def _set_hot_temps(self, temp, fan_spd, wait=False, err=5):
+        self.obj.pheaters.set_temperature(self.obj.heater_hot, temp, False)
+        self.obj.gcode.run_script_from_command('M106 P0 S%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('M106 P1 S%d' % (fan_spd))
+        self.obj.gcode.run_script_from_command('M106 P2 S%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan0 VALUE=%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan1 VALUE=%d' % (fan_spd))
+        # self.obj.gcode.run_script_from_command('SET_PIN PIN=fan2 VALUE=%d' % (fan_spd))
+        if wait:
+            while self.ck_sys_sta() and abs(self.obj.heater_hot.target_temp - self.obj.heater_hot.smoothed_temp) > err and self.obj.heater_hot.target_temp > 0:
+                self.obj.hx711s.delay_s(0.100) 
+        pass
+
+    def _set_bed_temps(self, temp, wait=False, err=5):
+        self.obj.pheaters.set_temperature(self.obj.heater_bed, temp, False)           
+        if wait:
+            while self.ck_sys_sta() and abs(self.obj.heater_bed.target_temp - self.obj.heater_bed.smoothed_temp) > err and self.obj.heater_bed.target_temp > 0:
+                self.obj.hx711s.delay_s(0.100)          
+        pass
+
+    def pnt_msg(self, msg):
+        logging.info(msg)
+        if self.cfg.show_msg:
+            self.obj.gcode.respond_info(msg)
+        pass
+
+    def pnt_array(self, title, ary, lent=32):
+        logging.info('[%s] %s' , title, str(ary))
+        if self.cfg.show_msg:
+            st = title + ' ['
+            for i in range(len(ary) - lent, len(ary)):
+                st = st + "%.2f, " % (ary[i])
+            self.pnt_msg(st + ']')
+        pass
+
+    def _probe_times(self, max_times, rdy_pos, speed_mm, min_dis_mm, max_z_err, min_hold, max_hold):
+        o_mm = 0
+        rdy_pos_z = rdy_pos[2]
+        now_pos = self.obj.toolhead.get_position()
+        self._move(now_pos[:2] + [rdy_pos[2]], self.cfg.g29_rdy_speed)        
+        self._move(rdy_pos, self.cfg.g29_xy_speed)
+        for i in range(max_times):
+            o_index0, o_mm0, deal_sta = self.probe_by_step(rdy_pos[:2] + [rdy_pos_z], speed_mm, min_dis_mm, min_hold, max_hold, True)
+            if not deal_sta and rdy_pos_z == rdy_pos[2]:
+                rdy_pos_z += 2
+                continue
+            o_index1, o_mm1, deal_sta = self.probe_by_step(rdy_pos[:2] + [rdy_pos_z], speed_mm, min_dis_mm, min_hold, max_hold, True)
+            o_mm = (o_mm0 + o_mm1) / 2
+            if math.fabs(o_mm0 - o_mm1) <= max_z_err or not self.ck_sys_sta():
+                break
+            self.val.re_probe_cnt += 1
+            self.pnt_msg('***_probe_times must be reprobe= o_mm0=%.2f, o_mm1=%.2f' % (o_mm0, o_mm1))
+        return o_mm
+    
+    def send_wave_tri(self, ch, ary):
+        if self.cfg.tri_wave_ip is None:
+            return
+        msg = '%d' % ch
+        for i in range(len(ary)):
+            msg += ',%d' % ary[i]
+        ss = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        ss.sendto(msg.encode(), (str(self.cfg.tri_wave_ip), 21021))
+        ss.close()    
+
+    def get_best_rdy_z(self, rdy_x, rdy_y, base_pos=None):
+        if not base_pos:
+            base_pos = self.val.rdy_pos
+        p_left = [base_pos[0][0], rdy_y, 0]
+        p_right = [base_pos[2][0], rdy_y, 0]
+        p_mid = [rdy_x, rdy_y, 0]
+        p_left = self._get_linear2(base_pos[0], base_pos[1], p_left, False)
+        p_right = self._get_linear2(base_pos[2], base_pos[3], p_right, False)
+        p_mid = self._get_linear2(p_left, p_right, p_mid, True)
+        self.pnt_msg("Get best rdy z: Src=%s, x=%.2f, y=%.2f, cal_z=%.2f" % (('RDY' if base_pos == self.val.rdy_pos else 'GAP'), rdy_x, rdy_y, p_mid[2]))
+        return p_mid[2] if p_mid[2] < self.cfg.bed_max_err else self.cfg.bed_max_err
+                
+    def shake_motor(self, cnt):
+        max_velocity = self.obj.toolhead.max_velocity
+        max_accel = self.obj.toolhead.max_accel
+        max_z_velocity = self.obj.toolhead.kin.max_z_velocity
+        max_z_accel = self.obj.toolhead.kin.max_z_accel
+
+        self.obj.toolhead.max_velocity = self.cfg.shake_max_velocity
+        self.obj.toolhead.max_accel = self.cfg.shake_max_accel
+        self.obj.toolhead.kin.max_z_velocity = self.cfg.shake_max_velocity
+        self.obj.toolhead.kin.max_z_accel = self.cfg.shake_max_accel
+
+        now_pos = self.obj.toolhead.get_position()
+        for i in range(int(cnt / 2)):
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] - self.cfg.shake_range, now_pos[1] - self.cfg.shake_range, now_pos[2] - self.cfg.shake_range / 2))
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] + self.cfg.shake_range, now_pos[1] - self.cfg.shake_range, now_pos[2] + self.cfg.shake_range / 2))
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] + self.cfg.shake_range, now_pos[1] + self.cfg.shake_range, now_pos[2] - self.cfg.shake_range / 2))
+            self.obj.gcode.run_script_from_command('G1 X%.2f Y%.2f Z%.2f F600' % (now_pos[0] - self.cfg.shake_range, now_pos[1] + self.cfg.shake_range, now_pos[2] + self.cfg.shake_range / 2))
+            while len(self.obj.toolhead.move_queue.queue) >= 4 and self.ck_sys_sta():
+                self.obj.hx711s.delay_s(0.010)
+        self._move(now_pos, self.cfg.g29_xy_speed)
+
+        self.obj.toolhead.max_velocity = max_velocity
+        self.obj.toolhead.max_accel = max_accel
+        self.obj.toolhead.kin.max_z_velocity = max_z_velocity
+        self.obj.toolhead.kin.max_z_accel = max_z_accel
+        pass
+
+    def clear_nozzle(self, hot_min_temp, hot_max_temp, bed_max_temp, min_hold, max_hold):
+        min_x, min_y = self.cfg.clr_noz_start_x, self.cfg.clr_noz_start_y
+        max_x, max_y = self.cfg.clr_noz_start_x + self.cfg.clr_noz_len_x, self.cfg.clr_noz_start_y + self.cfg.clr_noz_len_y
+        self._set_bed_temps(temp=bed_max_temp, wait=False)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False, err=10)
+        self._ck_g28ed(False)
+        random.seed(time.time())  
+        cur_pos = self.obj.toolhead.get_position()
+        src_pos = [min_x + random.uniform(0, self.cfg.clr_noz_len_x - self.cfg.pa_clr_dis_mm - 5), 
+                   min_y + random.uniform(0, self.cfg.clr_noz_len_y), self.cfg.bed_max_err + 1, cur_pos[3]]
+        end_pos = [src_pos[0] + self.cfg.pa_clr_dis_mm, src_pos[1], src_pos[2], src_pos[3]]
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=True, err=10)   
+        src_pos[2] = self._probe_times(3, [src_pos[0] - 5, src_pos[1], src_pos[2]], self.cfg.g29_speed, 10, 0.2, min_hold * 2, max_hold)
+        self._set_hot_temps(temp=hot_min_temp + 40, fan_spd=0, wait=False, err=10)
+        end_pos[2] = self._probe_times(3, [end_pos[0] - 5, end_pos[1], end_pos[2]], self.cfg.g29_speed, 10, 0.2, min_hold * 2, max_hold)     
+        self._move(src_pos[:2] + [self.cfg.bed_max_err + 1], self.cfg.g29_xy_speed) 
+        self._move(src_pos[:2] + [src_pos[2] + 0.2], self.cfg.g29_rdy_speed) 
+        self._set_hot_temps(temp=hot_max_temp, fan_spd=0, wait=True, err=10)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False)
+        self._move(end_pos[:2] + [end_pos[2] + self.cfg.pa_clr_down_mm], self.cfg.g29_speed)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=255, wait=True, err=5)
+        self._move([end_pos[0] + 10, end_pos[1], end_pos[2] + 10], self.cfg.g29_speed)
+        self._set_hot_temps(temp=hot_min_temp, fan_spd=0, wait=False) 
+        self._set_bed_temps(temp=bed_max_temp, wait=True, err=5)
+
+        self._move(self.val.home_xy + [10], self.cfg.g29_xy_speed)
+        # self.obj.gcode.run_script_from_command('G28 Z')
+        pass
+
+    def measure_gap(self, zero_z):
+        min_dis_mm = self.cfg.gap_dis_range
+        speed_mm = self.cfg.gap_dis_range
+        p0_vals = None
+        p1_vals = None
+
+        rd_cnt = int(2 * 80 * (min_dis_mm / speed_mm))            
+        step_cnt = int(min_dis_mm / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        step_us = int(((min_dis_mm / speed_mm) * 1000 * 1000) / step_cnt)
+
+        now_pos = self.obj.toolhead.get_position()  
+        self._move(now_pos[:2] + [zero_z + min_dis_mm / 2, now_pos[3]], self.cfg.g29_rdy_speed)
+        self.obj.hx711s.read_base(int(self.cfg.base_count / 2), self.cfg.max_hold)
+
+        self.obj.hx711s.query_start(rd_cnt, rd_cnt, del_dirty=False, show_msg=False)       
+        self.obj.dirzctl.check_and_run(0, int(step_us), int(step_cnt), wait_finish=True)
+        p0_valss = self.obj.hx711s.get_vals()
+
+        self.obj.hx711s.query_start(rd_cnt, rd_cnt, del_dirty=False, show_msg=False)       
+        self.obj.dirzctl.check_and_run(1, int(step_us), int(step_cnt), wait_finish=True)
+        p1_valss = self.obj.hx711s.get_vals()
+
+        self.obj.hx711s.query_start(rd_cnt, int(0), del_dirty=False, show_msg=False)
+        if len(p0_valss[0]) == 0 or len(p1_valss[0]) == 0:
+            self.pnt_msg('measure_gap: Error! Cannot recv datas from hx711s!!!.')
+            return 0
+        
+        self.pnt_msg('---------------------------------')
+        for i in range(int(self.obj.hx711s.s_count)):
+            self.pnt_array('p0_%d_valss = ' % i, p0_valss[i], len(p0_valss[i]))
+        self.pnt_msg('---------------------------------')
+        for i in range(int(self.obj.hx711s.s_count)):
+            self.pnt_array('p1_%d_valss = ' % i, p1_valss[i], len(p1_valss[i]))
+        self.pnt_msg('---------------------------------')
+
+        p0_diss = []
+        p1_diss = []
+        gaps = []
+        for gap_index in range(int(self.obj.hx711s.s_count)):
+            p0_vals = p0_valss[gap_index]
+            p1_vals = p1_valss[gap_index]
+
+            if p0_vals[0] > p0_vals[-1]:
+                p0_vals = [item * -1 for item in p0_vals]
+
+            if p1_vals[0] < p1_vals[-1]:
+                p1_vals = [item * -1 for item in p1_vals]
+
+            max_val = max(p0_vals)
+            min_val = min(p0_vals)
+            for i in range(len(p0_vals)):
+                p0_vals[i] = (p0_vals[i] - min_val) / (max_val - min_val)
+            angle = math.atan((p0_vals[-1] - p0_vals[0]) / len(p0_vals))
+            sin_angle = math.sin(-angle)
+            cos_angle = math.cos(-angle)
+            for i in range(len(p0_vals)):
+                p0_vals[i] = (i - 0) * sin_angle + (p0_vals[i] - 0) * cos_angle + 0
+            p0_out_index = p0_vals.index(min(p0_vals))
+            p0_dis = (len(p0_vals) - p0_out_index) * 0.012 * speed_mm
+            p0_diss.append(p0_dis)
+
+            p1_vals = p1_vals[::-1]
+            max_val = max(p1_vals)
+            min_val = min(p1_vals)
+            for i in range(len(p1_vals)):
+                p1_vals[i] = (p1_vals[i] - min_val) / (max_val - min_val)
+            angle = math.atan((p1_vals[-1] - p1_vals[0]) / len(p1_vals))
+            sin_angle = math.sin(-angle)
+            cos_angle = math.cos(-angle)
+            for i in range(len(p1_vals)):
+                p1_vals[i] = (i - 0) * sin_angle + (p1_vals[i] - 0) * cos_angle + 0
+            p1_out_index = p1_vals.index(min(p1_vals))
+            p1_dis = (len(p1_vals) - p1_out_index) * 0.012 * speed_mm
+            p1_diss.append(p1_dis)
+
+            gaps.append(p1_dis - p0_dis)
+            pass
+
+        self.pnt_array('measure_gap: p0_diss = ', p0_diss, len(p0_diss))
+        self.pnt_array('measure_gap: p1_diss = ', p1_diss, len(p1_diss))
+        self.pnt_array('measure_gap: gaps = ', gaps, len(gaps))      
+
+        v_cnt = int(0)
+        v_gap = 0.
+        for i in range(int(self.obj.hx711s.s_count)):
+            if not ((0 < p0_diss[i] < min_dis_mm) and (0 < p1_diss[i] < min_dis_mm) and (0 <= gaps[i] < 0.2)):
+                continue
+            v_cnt += 1
+            v_gap += (gaps[i] if gaps[i] <= 0.1 else 0.1)
+            pass
+
+        v_gap = (0 if v_cnt == 0 else (v_gap / v_cnt))
+
+
+        self.pnt_msg('measure_gap: v_cnt=%d v_gap = %.2f' % (v_cnt, v_gap)) 
+
+        return v_gap
+
+    def _gap_times(self, max_times, zero_pos):
+        gaps = []
+        now_pos = self.obj.toolhead.get_position()          
+        for i in range(max_times):
+            self._move(now_pos[:2] + [zero_pos + 2, now_pos[3]], self.cfg.g29_rdy_speed)
+            self.shake_motor(int(self.cfg.shake_cnt / 2))
+            gaps.append(self.measure_gap(zero_pos))
+        gaps.sort()
+        self.pnt_array('Gap measure vals = ', gaps, len(gaps))
+        now_pos = self.obj.toolhead.get_position()  
+        self._move(now_pos[:2] + [self.cfg.bed_max_err + 1., now_pos[3]], self.cfg.g29_rdy_speed)
+        return gaps[int((max_times + 1) / 2)]
+
+    def probe_ready(self):
+        if self.val.jump_probe_ready:
+            self.val.jump_probe_ready = False
+            return False
+        self._ck_g28ed()
+        min_x, min_y = self.obj.bed_mesh.bmc.mesh_min
+        max_x, max_y = self.obj.bed_mesh.bmc.mesh_max
+        random.seed(time.time()) 
+        self.val.rdy_pos = [[min_x, min_y, self.cfg.bed_max_err + 1.],
+                            [min_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, max_y, self.cfg.bed_max_err + 1.],
+                            [max_x, min_y, self.cfg.bed_max_err + 1.]]
+        mesh = self.obj.bed_mesh.get_mesh()
+        self.obj.bed_mesh.set_mesh(None)
+        for i in range(4):
+            self.val.rdy_pos[i][2] = self._probe_times(3, self.val.rdy_pos[i], self.cfg.g29_speed, 10, 0.2, self.cfg.min_hold, self.cfg.max_hold)
+            # if self.cfg.need_measure_gap:
+            #     self.val.gap_pos[i] = [x for x in self.val.rdy_pos[i]]
+            #     self.val.gap_pos[i][2] = self._gap_times(3, self.val.rdy_pos[i][2])
+            # else:
+            #     self.val.gap_pos[i][2] = 0
+            pass
+        if self.cfg.need_measure_gap:        
+            configfile = self.obj.printer.lookup_object('configfile')
+            configfile.set('prtouch default', 'z_gap_00', self.val.gap_pos[0][2])
+            configfile.set('prtouch default', 'z_gap_01', self.val.gap_pos[1][2])
+            configfile.set('prtouch default', 'z_gap_11', self.val.gap_pos[2][2])
+            configfile.set('prtouch default', 'z_gap_10', self.val.gap_pos[3][2])
+        self.pnt_msg("RDY_POS = [00=%.2f, 01=%.2f, 11=%.2f, 10=%.2f]" % (self.val.rdy_pos[0][2], self.val.rdy_pos[1][2], self.val.rdy_pos[2][2], self.val.rdy_pos[3][2]))
+        self.pnt_msg("GAP_POS = [00=%.2f, 01=%.2f, 11=%.2f, 10=%.2f]" % (self.val.gap_pos[0][2], self.val.gap_pos[1][2], self.val.gap_pos[2][2], self.val.gap_pos[3][2]))
+        self.obj.bed_mesh.set_mesh(mesh)
+        pass
+
+    def check_bed_mesh(self, auto_g29=True):
+        min_x, min_y = self.obj.bed_mesh.bmc.mesh_min
+        max_x, max_y = self.obj.bed_mesh.bmc.mesh_max
+        self.val.rdy_pos = [[min_x + random.uniform(2.0, +5.0), min_y + random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.],
+                            [min_x + random.uniform(2.0, +5.0), max_y - random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.],
+                            [max_x - random.uniform(2.0, +5.0), max_y - random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.],
+                            [max_x - random.uniform(2.0, +5.0), min_y + random.uniform(2.0, +5.0), self.cfg.bed_max_err + 1.]]
+        err_cnt = int(0)
+        self.val.jump_probe_ready = True
+        mesh = self.obj.bed_mesh.get_mesh()
+        if mesh is None:
+            if auto_g29:
+                self.pnt_msg("The bed_mesh data is invalid and cannot be verified.")
+                self._ck_g28ed()   
+                self.obj.gcode.run_script_from_command('BED_MESH_CALIBRATE')
+                self.obj.gcode.run_script_from_command('CXSAVE_CONFIG')
+            else:
+                #raise self.obj.printer.command_error("The bed_mesh data is invalid and cannot be verified.")
+                raise self.obj.printer.command_error("""{"code":"key504", "msg":"The bed_mesh data is invalid and cannot be verified."}""")
+            return
+
+        self.obj.bed_mesh.set_mesh(None)
+        self._ck_g28ed()        
+        self._move([self.val.home_xy[0], self.val.home_xy[1], self.cfg.bed_max_err + 1.0, self.obj.toolhead.get_position()[3]], self.cfg.g29_xy_speed)     
+        for i in range(4):
+            self.val.rdy_pos[i][2] = self._probe_times(3, self.val.rdy_pos[i], self.cfg.g29_speed, 10, self.cfg.check_bed_mesh_max_err * 2, self.cfg.min_hold, self.cfg.max_hold) + self.cfg.fix_z_offset
+            self.val.rdy_pos[i][2] += self.get_best_rdy_z(self.val.rdy_pos[i][0], self.val.rdy_pos[i][1], self.val.gap_pos) if self.cfg.need_measure_gap else 0
+            pass       
+        self.obj.bed_mesh.set_mesh(mesh)
+        errs = []
+        for i in range(4):
+            mesh_z = self.obj.bed_mesh.z_mesh.calc_z(self.val.rdy_pos[i][0], self.val.rdy_pos[i][1])
+            errs.append(abs(self.val.rdy_pos[i][2] - mesh_z))
+            err_cnt += (1 if errs[i] > self.cfg.check_bed_mesh_max_err else 0)
+            self.pnt_msg('P%d = [x=%.2f, y=%.2f, mest_z=%.2f, probe_z=%.2f, err_z=%.2f]' % (i, self.val.rdy_pos[i][0], self.val.rdy_pos[i][1], mesh_z, self.val.rdy_pos[i][2], errs[i]))        
+        if err_cnt >= 2:
+            if auto_g29:
+                self.pnt_array("check_bed_mesh: Due to the great change of the hot bed, it needs to be re-leveled. errs = ", errs, len(errs))
+                self.val.g29_cnt = 0
+                self.obj.gcode.run_script_from_command('BED_MESH_CALIBRATE')
+                self.obj.gcode.run_script_from_command('CXSAVE_CONFIG')
+            else:
+                # raise self.obj.printer.command_error("check_bed_mesh: Due to the large change of the hot bed, it can not print normally!! Errs = [%.2f, %.2f, %.2f, %.2f]" \
+                #                                         % (errs[0], errs[1], errs[2], errs[3]))
+                raise self.obj.printer.command_error("""{"code":"key501", "msg":"check_bed_mesh: Due to the large change of the hot bed, it can not print normally. Errs = [%.2f, %.2f, %.2f, %.2f]"}""" \
+                                                        % (errs[0], errs[1], errs[2], errs[3]))
+                                                        
+        else:
+            self.pnt_array("check_bed_mesh: Errs = ", errs, len(errs))
+        pass
+
+    def raise_z_bef_g28(self):
+        if self.obj.kin.limits[2][0] <= self.obj.kin.limits[2][1] and self.obj.toolhead.get_position()[2] < 5:
+            self.obj.toolhead.manual_move(self.obj.toolhead.get_position()[:2] + [5], 5)
+            self.obj.toolhead.wait_moves()
+            pass
+
+    def _cal_min_z(self, start_z, hx711_vals):
+        hx711_params, hx711_start_tick = self.obj.hx711s.get_params()
+        dirzctl_params, dirzctl_start_tick = self.obj.dirzctl.get_params()
+        if dirzctl_params is None or len(dirzctl_params) != 2:     
+            raise self.obj.printer.command_error("""{"code":"key502", "msg":"probe_by_step: Can not recv stepper-z status."}""")
+        if len(hx711_vals) < self.cfg.pi_count or len(hx711_params) < self.cfg.pi_count:
+            up_all_cnt = dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1
+            return up_all_cnt, up_all_cnt, False
+        del hx711_params[0:(len(hx711_params) - self.cfg.pi_count)]
+
+        vals_p = [x for x in hx711_vals]
+        max_val = max(vals_p)
+        min_val = min(vals_p)
+        for i in range(len(vals_p)):
+            vals_p[i] = (vals_p[i] - min_val) / (max_val - min_val)
+        angle = math.atan((vals_p[-1] - vals_p[0]) / len(vals_p))
+        sin_angle = math.sin(-angle)
+        cos_angle = math.cos(-angle)
+        for i in range(len(vals_p)):
+            vals_p[i] = (i - 0) * sin_angle + (vals_p[i] - 0) * cos_angle + 0
+        self.val.out_index = vals_p.index(min(vals_p))
+
+        dirzctl_params[0]['tick'] = (dirzctl_params[0]['tick'] - dirzctl_start_tick) / self.obj.dirzctl.mcu_freq
+        dirzctl_params[1]['tick'] = ((4294967296 if dirzctl_params[1]['tick'] < dirzctl_start_tick else 0) + dirzctl_params[1]['tick'] - dirzctl_start_tick) / self.obj.dirzctl.mcu_freq
+        dirzctl_params[0]['z'] = start_z
+        dirzctl_params[1]['z'] = start_z - (dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1) * (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base)
+        tick_p = ((4294967296 if hx711_params[self.val.out_index]['nt'] < hx711_start_tick else 0) + hx711_params[self.val.out_index]['nt'] - hx711_start_tick) / self.obj.hx711s.mcu_freq
+        self.val.out_val_mm = self._get_linear2([dirzctl_params[0]['tick'], 0, dirzctl_params[0]['z']], [dirzctl_params[1]['tick'], 0, dirzctl_params[1]['z']], [tick_p, 0, 0], True)[2]
+        self.pnt_msg('call_min_z, re_probe_cnt=%d, out_index=%d, out_val_mm=%.2f' % (self.val.re_probe_cnt, self.val.out_index, self.val.out_val_mm))
+        up_min_cnt = int((self.val.out_val_mm - dirzctl_params[1]['z']) / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        up_all_cnt = dirzctl_params[0]['step'] - dirzctl_params[1]['step'] + 1
+        limt_up_cnt = int(10 / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        up_min_cnt = up_min_cnt if up_min_cnt < limt_up_cnt else limt_up_cnt  
+        up_all_cnt = up_all_cnt if up_all_cnt < limt_up_cnt else limt_up_cnt
+        return (up_min_cnt if up_min_cnt >= 0 else 0), up_all_cnt, True
+
+    def probe_by_step(self, rdy_pos, speed_mm, min_dis_mm, min_hold, max_hold, up_after=True):
+        self.obj.hx711s.read_base(int(self.cfg.base_count / 2), max_hold)
+        step_cnt = int(min_dis_mm / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+        step_us = int(((min_dis_mm / speed_mm) * 1000 * 1000) / step_cnt)
+        self.obj.hx711s.query_start(self.cfg.pi_count * 2, int(65535), del_dirty=True, show_msg=False, is_ck_con=True)        
+        self.obj.dirzctl.check_and_run(0, int(step_us), int(step_cnt), wait_finish=False, is_ck_con=True)
+        self.obj.hx711s.delay_s(0.015)
+        self.pnt_msg('*********************************************************')
+        self.pnt_msg('PROBE_BY_STEP x=%.2f y=%.2f z=%.2f speed_mm=%.2f step_us=%d step_cnt=%d' % (rdy_pos[0], rdy_pos[1], rdy_pos[2], speed_mm, step_us, step_cnt))
+        while self.ck_sys_sta():
+            self.obj.hx711s.send_heart_beat()
+            self.obj.dirzctl.send_heart_beat()
+            all_valss = self.obj.hx711s.get_vals()
+            if all_valss is None or len(all_valss[0]) == 0:
+                self.obj.hx711s.delay_s(0.005)
+                continue
+            unfit_vals, tmp_unfit_vals = self.obj.filter.cal_offset_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.lft_k1_oft, self.cfg.pi_count)
+            fit_vals, tmp_fit_vals = self.obj.filter.cal_filter_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.hft_hz, self.obj.filter.lft_k1, self.cfg.pi_count)
+            
+            for i in range(self.obj.hx711s.s_count):
+                if not self._check_trigger(i, tmp_fit_vals[i], tmp_unfit_vals[i], min_hold, max_hold):
+                    continue
+                self.obj.dirzctl.check_and_run(0, 0, 0, wait_finish=False)
+                self.obj.hx711s.query_start(self.cfg.pi_count * 2, int(0), del_dirty=False, show_msg=False)
+                self.obj.hx711s.delay_s(0.015)
+                for j in range(int(self.obj.hx711s.s_count)):
+                    self.pnt_array('TRIGGER_USE_CH=%d, FIT_VALS=' % (j), tmp_fit_vals[j], 16)
+                self.obj.hx711s.delay_s(0.2)
+                all_valss = self.obj.hx711s.get_vals()
+                self.pnt_array('WAIT_AND_CAL_CH=%d, ARY=' % (i), all_valss[i])
+                hx711_vals, tmp_hx711_vs = self.obj.filter.cal_filter_by_vals(self.obj.hx711s.s_count, all_valss, self.obj.filter.hft_hz, self.obj.filter.lft_k1_cal, self.cfg.pi_count)
+                self.pnt_array('WAIT_AND_CAL_CH=%d, ARY=' % (i), tmp_hx711_vs[i])
+                for m in range(self.obj.hx711s.s_count):
+                    self.send_wave_tri(m, tmp_hx711_vs[m])
+                up_min_cnt, up_all_cnt, deal_sta = self._cal_min_z(rdy_pos[2], tmp_hx711_vs[i])
+                if up_after:
+                    self.obj.dirzctl.check_and_run(1, int(step_us / 2), int(up_all_cnt))
+                return self.val.out_index, self.val.out_val_mm, deal_sta
+            self.obj.hx711s.delay_s(0.005)
+        return self.val.out_index, self.val.out_val_mm, True
+
+    def run_G28_Z(self):
+        self.pnt_msg('***run_G28_Z*** Start...')
+        self.val.re_probe_cnt = 0
+        self.val.g29_cnt = 0
+        self.obj.toolhead.wait_moves()
+        target_temp = self.obj.heater_hot.target_temp
+        now_pos = self.obj.toolhead.get_position()
+        self.val.home_xy = [now_pos[0], now_pos[1]]
+        now_pos[2] = 2
+        random.seed(int(time.time()))  
+        now_pos_sta0 = [now_pos[0] + (1 if (int(time.time() * 1000) % 2 == 0) else -1) * random.uniform(10, 20),
+                        now_pos[1] + (1 if (int(time.time() * 100) % 2 == 0) else -1) * random.uniform(10, 20),
+                        now_pos[2], now_pos[3]]
+        mesh = self.obj.bed_mesh.get_mesh()
+        self.obj.bed_mesh.set_mesh(None)                
+        self.obj.toolhead.set_position(now_pos, homing_axes=[2])
+        self._move(now_pos_sta0, 20)
+        if self.cfg.g28_wait_cool_down and self.obj.heater_hot.smoothed_temp > (self.cfg.hot_min_temp + 5):
+            self.pnt_msg('G28_Z: Wait for Nozzle to cool down[%.2f -> %.2f]...' % (target_temp, self.cfg.hot_min_temp))
+            self._set_hot_temps(temp=self.cfg.hot_min_temp, fan_spd=255, wait=True, err=5) 
+            self._set_hot_temps(temp=self.cfg.hot_min_temp, fan_spd=0, wait=False, err=5) 
+        if self.cfg.max_dis_bef_g28 != 0:
+            step_cnt = int(self.cfg.max_dis_bef_g28 / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+            step_us = int(((self.cfg.max_dis_bef_g28 / self.cfg.g28_sta0_speed) * 1000 * 1000) / step_cnt)
+            self.obj.dirzctl.check_and_run(1, step_us, step_cnt)
+        if self.cfg.dead_zone_bef_g28 != 0:
+            step_cnt = int(self.cfg.dead_zone_bef_g28 / (self.obj.dirzctl.steppers[0].get_step_dist() * self.obj.dirzctl.step_base))
+            step_us = int(((self.cfg.dead_zone_bef_g28 / self.cfg.g28_sta0_speed) * 1000 * 1000) / step_cnt)
+            self.obj.dirzctl.check_and_run(0, step_us, step_cnt)
+        is_uped = False
+        for i in range(10):
+            self.obj.toolhead.set_position(now_pos_sta0[:2] + [(2 if i == 0 else 0), now_pos_sta0[3]], homing_axes=[2])
+            self._move(now_pos_sta0[:3], self.cfg.g29_rdy_speed)
+            out_index, out_mm, deal_sta = self.probe_by_step(now_pos_sta0, self.cfg.g28_sta0_speed, self.cfg.max_z, self.cfg.g28_sta0_min_hold, self.cfg.max_hold, up_after=False)
+            if not deal_sta and not is_uped:
+                is_uped = True
+                self.obj.toolhead.set_position(now_pos_sta0[:2] + [0, now_pos_sta0[3]], homing_axes=[2])
+                self._move(now_pos_sta0[:2] + [5, now_pos_sta0[3]], self.cfg.g29_rdy_speed)
+                pass
+            if (-1 < out_mm < 1 and deal_sta) or not self.ck_sys_sta():
+                break
+        self.obj.toolhead.set_position(now_pos_sta0[:2] + [-0.5, now_pos[3]], homing_axes=[2])
+        self._move(now_pos_sta0[:2] + [2, now_pos[3]], self.cfg.g29_rdy_speed)
+
+        now_pos = [now_pos[0] + random.uniform(-1.0, +1.0), now_pos[1] + random.uniform(-1.0, +1.0), 2, now_pos[3]]
+        self._move(now_pos, 30)
+        self.shake_motor(int(self.cfg.shake_cnt * 2))
+        out_mms = []
+        for i in range(5):
+            o_index0, o_mm0, deal_sta = self.probe_by_step(now_pos, self.cfg.g28_sta1_speed, self.cfg.max_z, self.cfg.min_hold, self.cfg.max_hold, True)
+            out_mms.append(o_mm0)
+        out_mms.sort()
+        self.pnt_array('G28_ZS = ', out_mms, len(out_mms))
+        if math.fabs(out_mms[3] - out_mms[1]) > 5.0:
+             raise self.obj.printer.command_error("""{"code":"key504", "msg":"run_G28_Z: Homing Z failure, During zeroing, please place the machine on a stable platform and do not touch the hot bed."}""")
+        self.obj.toolhead.set_position(now_pos[:2] + [now_pos[2] - out_mms[2] - self.cfg.self_z_offset, now_pos[3]], homing_axes=[2])
+
+        self.obj.bed_mesh.set_mesh(mesh)
+
+        # self.obj.gcode.run_script_from_command('G1 F300 Z10')
+        self._move(now_pos[:2] + [10, now_pos[3]], self.cfg.g29_rdy_speed)
+
+        if self.cfg.g28_wait_cool_down:
+            self.pnt_msg('G28_Z: Wait for Nozzle to recovery[%.2f -> %.2f]...' % (self.cfg.hot_min_temp, target_temp))
+            self._set_hot_temps(temp=target_temp, fan_spd=0, wait=True if target_temp > self.cfg.hot_min_temp else False, err=5)
+        pass
+
+    def run_G29_Z(self):
+        x_cnt = self.obj.bed_mesh.bmc.mesh_config['x_count']
+        y_cnt = self.obj.bed_mesh.bmc.mesh_config['y_count']
+        self.obj.toolhead.wait_moves()
+        now_pos = self.obj.toolhead.get_position()
+        self.val.jump_probe_ready = False
+
+        if self.val.g29_cnt == 0:
+            self.shake_motor(self.cfg.shake_cnt)
+            self.probe_ready()
+            now_pos[2] = self.get_best_rdy_z(now_pos[0], now_pos[1], self.val.rdy_pos) + self.cfg.best_above_z
+            self._move(now_pos, self.cfg.g29_xy_speed)        
+
+        if (int(self.val.g29_cnt) % int(x_cnt)) == 0:
+            self.shake_motor(self.cfg.shake_cnt)
+            pass
+
+        now_pos[2] = self._probe_times(10, now_pos, self.cfg.g29_speed, self.cfg.bed_max_err, 0.06, self.cfg.min_hold, self.cfg.max_hold) + self.get_best_rdy_z(now_pos[0], now_pos[1], self.val.gap_pos) + self.cfg.fix_z_offset
+       
+        self.val.g29_cnt += 1
+        if self.val.g29_cnt == x_cnt * y_cnt:
+            self.val.g29_cnt = 0
+            self._move([now_pos[0], now_pos[1], self.cfg.bed_max_err + 1], self.cfg.g29_rdy_speed) 
+            self._move([self.val.home_xy[0], self.val.home_xy[1], self.cfg.bed_max_err + 1], self.cfg.g29_xy_speed)  
+            home_z = self._probe_times(3, [self.val.home_xy[0], self.val.home_xy[1], self.cfg.bed_max_err + 1], 
+                                       self.cfg.g29_speed, self.cfg.bed_max_err * 2, 0.20, self.cfg.min_hold, self.cfg.max_hold)
+            self.pnt_msg('CHECK_STEP_LOST need=0, tri=%.2f' % home_z)
+            if home_z > 1.0:
+                raise self.obj.printer.command_error("""{"code":"key503", "msg":"run_G29_Z: Z-axis motor lost of step detected, Please restart the machine and try again"}""")
+
+        return now_pos
+
+    cmd_PRTOUCH_TEST_help = "Test the PR-Touch."
+    def cmd_PRTOUCH_TEST(self, gcmd):   # PRTOUCH_TEST X=20 Y=20 Z=-4 S=0.0125
+        pos = self.obj.toolhead.get_position()
+        rdy_x = gcmd.get_float('X', pos[0])
+        rdy_y = gcmd.get_float('Y', pos[1])
+        rdy_z = gcmd.get_float('Z', pos[2])
+        speed = gcmd.get_float('SPEED', 1.0)
+        min_hold = gcmd.get_int('MIN_HOLD', self.cfg.min_hold)
+        max_hold = gcmd.get_int('MAX_HOLD', self.cfg.max_hold)
+        self._move([rdy_x, rdy_y, rdy_z], self.cfg.g29_xy_speed)
+        self.probe_by_step([rdy_x, rdy_y, rdy_z], speed, 50, min_hold, max_hold, True)
+        pass
+
+    cmd_PRTOUCH_READY_help = "Test the ready point."
+    def cmd_PRTOUCH_READY(self, gcmd):
+        self.probe_ready()
+        pass
+
+    cmd_CHECK_BED_MESH_help = "Check the bed mesh."
+    def cmd_CHECK_BED_MESH(self, gcmd):
+        self.check_bed_mesh(gcmd.get_int('AUTO_G29', 0) > 0)
+        pass
+
+    cmd_MEASURE_GAP_TEST_help = "Measure z gap."
+    def cmd_MEASURE_GAP_TEST(self, gcmd):
+        self._ck_g28ed()
+        gap_index = gcmd.get_int('INDEX', 0)
+        n_index = [0, 3, 1, 2]
+        self._move([self.val.rdy_pos[n_index[gap_index]][0], self.val.rdy_pos[n_index[gap_index]][1], self.cfg.bed_max_err + 1.], self.cfg.g29_xy_speed)  
+        zero_z = self._probe_times(10, [self.val.rdy_pos[n_index[gap_index]][0], self.val.rdy_pos[n_index[gap_index]][1], self.cfg.bed_max_err + 1.], 
+                                        self.cfg.g29_speed, 10, 0.05, self.cfg.min_hold, self.cfg.max_hold) 
+        self._gap_times(5, zero_z)
+        pass
+
+    cmd_NOZZLE_CLEAR_help = "Clear the nozzle on bed."
+    def cmd_NOZZLE_CLEAR(self, gcmd):
+        hot_min_temp = gcmd.get_float('HOT_MIN_TEMP', self.cfg.hot_min_temp)
+        hot_max_temp = gcmd.get_float('HOT_MAX_TEMP', self.cfg.hot_max_temp)
+        bed_max_temp = gcmd.get_float('BED_MAX_TEMP', self.cfg.bed_max_temp)
+        min_hold = gcmd.get_int('MIN_HOLD', self.cfg.min_hold)
+        max_hold = gcmd.get_int('MAX_HOLD', self.cfg.max_hold)
+        self.clear_nozzle(hot_min_temp, hot_max_temp, bed_max_temp, min_hold, max_hold)
+
+    def change_hot_min_temp(self, temp):
+        self.cfg.hot_min_temp = temp
+
+def load_config(config):
+    prt = PRTouchEndstopWrapper(config)
+    config.get_printer().add_object('probe', probe.PrinterProbe(config, prt))
+    return prt
+
+# G28
+# READ_HX711 C=1
+# NOZZLE_CLEAR
+# PRTOUCH_READY
+# BED_MESH_CALIBRATE
+# CHECK_BED_MESH AUTO_G29=0
+# MEASURE_GAP_TEST INDEX=0
+# FORCE_MOVE STEPPER=stepper_x DISTANCE=10 VELOCITY=5
+
+# g28_sta0_speed、g28_sta1_speed和g29_speed都改为1.8
\ No newline at end of file
--- /dev/null
+++ b/klippy/extras/prtouch_v2.py
@@ -0,0 +1,26 @@
+# prtouch support
+#
+# Copyright (C) 2018-2021  Creality <wangyulong878@sina.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+from . import probe
+from . import prtouch_v2_wrapper
+from . import prtouch_v1_wrapper
+
+def load_config(config):
+    pr_version = config.getint('pr_version', default=1, minval=0, maxval=100)
+    if pr_version == 2:
+        vrt = prtouch_v2_wrapper.PRTouchEndstopWrapper(config)
+    if pr_version == 1:
+        vrt = prtouch_v1_wrapper.PRTouchEndstopWrapper(config)
+    config.get_printer().add_object('probe', probe.PrinterProbe(config, vrt))
+    return vrt
+
+
+# /home/cc/moonraker-env/bin/python3.10 /home/cc/moonraker/moonraker/moonraker.py -d /home/cc/printer_data
+# sudo service klipper stop
+# /home/cc/klippy-env/bin/python3.10 /home/cc/klipper/klippy/klippy.py /home/cc/printer_data/config/printer.cfg -a /home/cc/printer_data/comms/klippy.sock -l /home/cc/printer_data/logs/klippy.log
+
+# ./micropython /home/cc/klipper/klippy/klippy.py /home/cc/printer_data/config/printer.cfg -a /home/cc/printer_data/comms/klippy.sock -l /home/cc/printer_data/logs/klippy.log
+
+# /home/cc/klippy-env/bin/python3.10 /home/cc/micropython_test/klipper/klippy/klippy.py /home/cc/printer_data/config/printer.cfg -a /home/cc/printer_data/comms/klippy.sock -l /home/cc/printer_data/logs/klippy.log
--- /dev/null
+++ b/klippy/extras/prtouch_v3.py
@@ -0,0 +1,18 @@
+# prtouch support
+#
+# Copyright (C) 2018-9999  Creality <wangyulong878@sina.com>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+
+
+# PROBE PROBE_SPEED=5 LIFT_SPEED=5 SAMPLES=5 SAMPLE_RETRACT_DIST=3 SAMPLES_RESULT='median'
+# SET_KINEMATIC_POSITION X=359 Y=-10
+
+from . import prtouch_v3_wrapper
+from . import probe as probes
+
+def load_config(config):
+    prtouch = prtouch_v3_wrapper.PRTouchEndstopWrapper(config)
+    config.get_printer().add_object('axis_twist_compensation', prtouch)
+    config.get_printer().add_object('probe', probes.PrinterProbe(config, prtouch))
+    return prtouch
--- a/klippy/extras/resonance_tester.py
+++ b/klippy/extras/resonance_tester.py
@@ -5,6 +5,7 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, math, os, time
 from . import shaper_calibrate
+from subprocess import call
 
 class TestAxis:
     def __init__(self, axis=None, vib_dir=None):
@@ -59,6 +60,8 @@ class VibrationPulseTest:
 
         self.probe_points = config.getlists('probe_points', seps=(',', '\n'),
                                             parser=float, count=3)
+        self.low_mem = config.getboolean('low_mem', True)
+
     def get_start_test_points(self):
         return self.probe_points
     def prepare_test(self, gcmd):
@@ -201,6 +204,10 @@ class ResonanceTester:
                         raise gcmd.error(
 						        """{"code":"key56", "msg":"accelerometer '%s' measured no data", "values": ["%s"]}""" % (
                                     chip_name, chip_name))
+                    if self.test.low_mem:
+                        new_data = helper.lowmem_process_accelerometer_data(aclient)
+                    else:
+                        new_data = helper.process_accelerometer_data(aclient)
                     if calibration_data[axis] is None:
                         calibration_data[axis] = new_data
                     else:
@@ -267,12 +274,15 @@ class ResonanceTester:
     def cmd_SHAPER_CALIBRATE(self, gcmd):
         # Parse parameters
         axis = gcmd.get("AXIS", None)
+        copy_TestAxis_y_to_x = False
         if not axis:
             calibrate_axes = [TestAxis('x'), TestAxis('y')]
         elif axis.lower() not in 'xy':
             raise gcmd.error("Unsupported axis '%s'" % (axis,))
         else:
             calibrate_axes = [TestAxis(axis.lower())]
+            if axis.lower() == "y":
+                copy_TestAxis_y_to_x = True
 
         max_smoothing = gcmd.get_float(
                 "MAX_SMOOTHING", self.max_smoothing, minval=0.05)
@@ -304,11 +314,27 @@ class ResonanceTester:
             csv_name = self.save_calibration_data(
                     'calibration_data', name_suffix, helper, axis,
                     calibration_data[axis], all_shapers)
+            if copy_TestAxis_y_to_x:
+                helper.save_params(configfile, "x", best_shaper.name, best_shaper.freq)
+                csv_name_x = self.save_calibration_data('calibration_data', name_suffix, helper, TestAxis('x'), calibration_data[axis], all_shapers)
+                gcmd.respond_info("copy_TestAxis_y_to_x Recommended shaper_type_%s = %s, shaper_freq_%s = %.1f Hz" % ("x", best_shaper.name, "x", best_shaper.freq))
+                gcmd.respond_info("copy_TestAxis_y_to_x Shaper calibration data written to %s file" % (csv_name_x,))
             gcmd.respond_info(
                     "Shaper calibration data written to %s file" % (csv_name,))
+        gcode = self.printer.lookup_object('gcode')
+        gcode.run_script_from_command("CXSAVE_CONFIG")
+        call("sync", shell=True)
+        input_shaper = self.printer.lookup_object("input_shaper", None)
+        if not input_shaper:
+            config = configfile.read_main_config()
+            self.printer.reload_object(config, "input_shaper")
+            gcode.run_script_from_command("UPDATE_INPUT_SHAPER")
+            input_shaper = self.printer.lookup_object("input_shaper", None)
+            input_shaper.enable_shaping()
         gcmd.respond_info(
             "The SAVE_CONFIG command will update the printer config file\n"
             "with these parameters and restart the printer.")
+        self.printer.send_event("v_sd:reset_shaper_calibrate_count")
     cmd_MEASURE_AXES_NOISE_help = (
         "Measures noise of all enabled accelerometer chips")
     def cmd_MEASURE_AXES_NOISE(self, gcmd):
--- /dev/null
+++ b/klippy/extras/serial_485.py
@@ -0,0 +1,3 @@
+from .serial_485_wrapper import Serial_485_Wrapper
+def load_config_prefix(config):
+    return(Serial_485_Wrapper(config))
--- a/klippy/extras/shaper_calibrate.py
+++ b/klippy/extras/shaper_calibrate.py
@@ -3,8 +3,11 @@
 # Copyright (C) 2020  Dmitry Butyugin <dmbutyugin@google.com>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import collections, importlib, logging, math, multiprocessing, traceback
+import collections, importlib, logging, math, multiprocessing, traceback, os
+import time, subprocess, shlex
+from multiprocessing import shared_memory
 shaper_defs = importlib.import_module('.shaper_defs', 'extras')
+from .base_info import base_dir
 
 MIN_FREQ = 5.
 MAX_FREQ = 200.
@@ -19,6 +22,27 @@ AUTOTUNE_SHAPERS = ['zv', 'mzv', 'ei', '2hump_ei', '3hump_ei']
 # Frequency response calculation and shaper auto-tuning
 ######################################################################
 
+def exec_cmd(conn, method):
+    try:
+        val = os.nice(10)
+    except:
+        pass
+
+    try:
+        process = subprocess.Popen(shlex.split(method), stdout=subprocess.PIPE)
+        output = process.communicate()[0]
+        retcode = process.poll()
+    except:
+        retcode = -1
+        conn.send((True, retcode))
+        conn.close()
+        return
+    if retcode is 0:
+        conn.send((False, retcode))
+    else:
+        conn.send((True, retcode))
+    conn.close()
+
 class CalibrationData:
     def __init__(self, freq_bins, psd_sum, psd_x, psd_y, psd_z):
         self.freq_bins = freq_bins
@@ -61,6 +85,17 @@ class ShaperCalibrate:
     def __init__(self, printer):
         self.printer = printer
         self.error = printer.command_error if printer else Exception
+        self.autotune_shapers = ['zv', 'mzv', 'ei', '2hump_ei', '3hump_ei']
+        configfile = self.printer.lookup_object('configfile')
+        gcode_macro_path = os.path.join(base_dir, "printer_data/config/gcode_macro.cfg")
+        gconfig = None
+        try:
+            gconfig = configfile.read_config(gcode_macro_path)
+            if gconfig and gconfig.has_section('gcode_macro AUTOTUNE_SHAPERS'):
+                AUTOTUNE_SHAPERS = gconfig.getsection('gcode_macro AUTOTUNE_SHAPERS')
+                self.autotune_shapers = list(map(lambda x: x.replace("'", "") , AUTOTUNE_SHAPERS.getlist('variable_autotune_shapers', ['zv', 'mzv', 'ei', '2hump_ei', '3hump_ei'])))
+        except Exception as err:
+            logging.error("gcode_macro_path: %s, configfile.read_config error:%s" % (gcode_macro_path, err))
         try:
             self.numpy = importlib.import_module('numpy')
         except ImportError:
@@ -75,6 +110,14 @@ class ShaperCalibrate:
         import queuelogger
         parent_conn, child_conn = multiprocessing.Pipe()
         def wrapper():
+            try:
+                gcode = self.printer.lookup_object("gcode")
+                gcode.respond_info("current nice: %d" % os.nice(0), log=False)
+                val = os.nice(10)
+                gcode.respond_info("process id: %d, current nice: %d" % (os.getpid(), val), log=False)
+            except:
+                gcode.respond_info("nice process failed", log=False)
+                pass
             queuelogger.clear_bg_logging()
             try:
                 res = method(*args)
@@ -181,6 +224,76 @@ class ShaperCalibrate:
         calibration_data.set_numpy(self.numpy)
         return calibration_data
 
+    def lowmem_background_process_exec(self, method):
+        if self.printer is None:
+            return None
+
+        ctx = multiprocessing.get_context('spawn')
+        parent_conn, child_conn = multiprocessing.Pipe()
+
+        # Start a process to perform the calculation
+        calc_proc = ctx.Process(target=exec_cmd, args=(child_conn, method))
+        calc_proc.daemon = True
+        calc_proc.start()
+        # Wait for the process to finish
+        reactor = self.printer.get_reactor()
+        gcode = self.printer.lookup_object("gcode")
+        eventtime = last_report_time = reactor.monotonic()
+        while calc_proc.is_alive():
+            if eventtime > last_report_time + 5.:
+                last_report_time = eventtime
+                gcode.respond_info("Wait for calculations..")
+            eventtime = reactor.pause(eventtime + .1)
+        # Return results
+        is_err, res = parent_conn.recv()
+        if is_err:
+            raise self.error("""{"code": "key312", "msg": "Error in remote calculation: %s", "values":["%s"]}""" % (res,res))
+        calc_proc.join()
+        parent_conn.close()
+        return res
+
+    def copy_samples_to_shared_memory(self, data):
+        data.get_samples_to_shared_mem()
+
+    def read_results_from_shared_memory(self, name):
+        gcode = self.printer.lookup_object("gcode")
+        try:
+            shm = shared_memory.SharedMemory(name)
+        except:
+            gcode.respond_info("open shared memory %s fail!" % (name))
+            return None
+
+        np = self.numpy
+        array = np.ndarray((shm.size // 8, ), dtype = np.float64, buffer = shm.buf, offset = 0)
+        shm.unlink()
+
+        return array.copy()
+
+    def lowmem_process_accelerometer_data(self, data):
+        gcode = self.printer.lookup_object("gcode")
+
+        self.copy_samples_to_shared_memory(data)
+
+        # call c++ program and return result by shared memory
+        ret = self.lowmem_background_process_exec("/usr/bin/calc_psd")
+        gcode.respond_info("calc_freq_response return (%d)" % (ret))
+
+        if ret is 0:
+            fx = self.read_results_from_shared_memory("psm_freq")
+            px = self.read_results_from_shared_memory("psm_px")
+            py = self.read_results_from_shared_memory("psm_py")
+            pz = self.read_results_from_shared_memory("psm_pz")
+
+            calibration_data = CalibrationData(fx, px+py+pz, px, py, pz)
+        else:
+            calibration_data = None
+
+        if calibration_data is None:
+            raise self.error(
+                    """{"code": "key313", "msg": "Internal error processing accelerometer data %s", "values":["%s"]}""" % (data,data))
+        calibration_data.set_numpy(self.numpy)
+        return calibration_data
+
     def _estimate_shaper(self, shaper, test_damping_ratio, test_freqs):
         np = self.numpy
 
@@ -304,7 +417,8 @@ class ShaperCalibrate:
         best_shaper = None
         all_shapers = []
         for shaper_cfg in shaper_defs.INPUT_SHAPERS:
-            if shaper_cfg.name not in AUTOTUNE_SHAPERS:
+            # if shaper_cfg.name not in AUTOTUNE_SHAPERS:
+            if shaper_cfg.name not in self.autotune_shapers:
                 continue
             shaper = self.background_process_exec(self.fit_shaper, (
                 shaper_cfg, calibration_data, max_smoothing))
--- /dev/null
+++ b/klippy/extras/statistics_ext.py
@@ -0,0 +1,74 @@
+# Support for logging periodic statistics
+#
+# Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import os, time, logging
+
+class PrinterSysStats:
+    def __init__(self, config):
+        printer = config.get_printer()
+        self.last_process_time = self.total_process_time = 0.
+        self.last_load_avg = 0.
+        self.last_mem_avail = 0
+        self.mem_file = None
+        try:
+            self.mem_file = open("/proc/meminfo", "r")
+        except:
+            pass
+        printer.register_event_handler("klippy:disconnect", self._disconnect)
+    def _disconnect(self):
+        if self.mem_file is not None:
+            self.mem_file.close()
+            self.mem_file = None
+    def stats(self, eventtime):
+        # Get core usage stats
+        ptime = time.process_time()
+        pdiff = ptime - self.last_process_time
+        self.last_process_time = ptime
+        if pdiff > 0.:
+            self.total_process_time += pdiff
+        self.last_load_avg = os.getloadavg()[0]
+        msg = "sysload=%.2f cputime=%.3f" % (self.last_load_avg,
+                                             self.total_process_time)
+        # Get available system memory
+        if self.mem_file is not None:
+            try:
+                self.mem_file.seek(0)
+                data = self.mem_file.read()
+                for line in data.split('\n'):
+                    if line.startswith("MemAvailable:"):
+                        self.last_mem_avail = int(line.split()[1])
+                        msg = "%s memavail=%d" % (msg, self.last_mem_avail)
+                        break
+            except:
+                pass
+        return (False, msg)
+    def get_status(self, eventtime):
+        return {'sysload': self.last_load_avg,
+                'cputime': self.total_process_time,
+                'memavail': self.last_mem_avail}
+
+class PrinterStats:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        reactor = self.printer.get_reactor()
+        self.stats_timer = reactor.register_timer(self.generate_stats)
+        self.stats_cb = []
+        self.printer.register_event_handler("klippy:ready", self.handle_ready)
+    def handle_ready(self):
+        self.stats_cb = [o.stats for n, o in self.printer.lookup_objects()
+                         if hasattr(o, 'stats')]
+        if self.printer.get_start_args().get('debugoutput') is None:
+            reactor = self.printer.get_reactor()
+            reactor.update_timer(self.stats_timer, reactor.NOW)
+    def generate_stats(self, eventtime):
+        stats = [cb(eventtime) for cb in self.stats_cb]
+        if max([s[0] for s in stats]):
+            logging.info("Stats %.1f: %s", eventtime,
+                         ' '.join([s[1] for s in stats]))
+        return eventtime + 3.
+
+def load_config(config):
+    config.get_printer().add_object('system_stats', PrinterSysStats(config))
+    return PrinterStats(config)
--- a/klippy/extras/stepper_enable.py
+++ b/klippy/extras/stepper_enable.py
@@ -73,6 +73,7 @@ class EnableTracking:
 # Global stepper enable line tracking
 class PrinterStepperEnable:
     def __init__(self, config):
+        self.config = config
         self.printer = config.get_printer()
         self.enable_lines = {}
         self.printer.register_event_handler("gcode:request_restart",
@@ -89,6 +90,11 @@ class PrinterStepperEnable:
         enable = setup_enable_pin(self.printer, config.get('enable_pin', None))
         self.enable_lines[name] = EnableTracking(mcu_stepper, enable)
     def motor_off(self):
+        vsd = self.printer.lookup_object('virtual_sdcard')
+        vsd.bed_mesh_calibate_state = False
+        if self.config.has_section("z_align"):
+            z_align = self.printer.lookup_object('z_align')
+            z_align.is_already_zodwn = False
         toolhead = self.printer.lookup_object('toolhead')
         toolhead.dwell(DISABLE_STALL_TIME)
         print_time = toolhead.get_last_move_time()
--- a/klippy/extras/temperature_mcu.py
+++ b/klippy/extras/temperature_mcu.py
@@ -76,6 +76,7 @@ class PrinterTemperatureMCU:
             ('stm32l4', self.config_stm32g0),
             ('stm32h723', self.config_stm32h723),
             ('stm32h7', self.config_stm32h7),
+            ('gd32f303xe', self.config_gd32f303xe),
             ('', self.config_unknown)]
         for name, func in cfg_funcs:
             if self.mcu_type.startswith(name):
@@ -157,6 +158,9 @@ class PrinterTemperatureMCU:
         cal_adc_110 = self.read16(0x1FF1E840) / 65535.
         self.slope = (110. - 30.) / (cal_adc_110 - cal_adc_30)
         self.base_temperature = self.calc_base(30., cal_adc_30)
+    def config_gd32f303xe(self):
+        self.slope = 3.3 / -.004100
+        self.base_temperature = self.calc_base(25., 1.45 / 3.3)
     def read16(self, addr):
         params = self.debug_read_cmd.send([1, addr])
         return params['val']
--- a/klippy/extras/temperature_sensors.cfg
+++ b/klippy/extras/temperature_sensors.cfg
@@ -10,22 +10,22 @@
 [adc_temperature]
 
 # Load "BME280" sensor
-[bme280]
+# [bme280]
 
 # Load "DS18B20" sensor
-[ds18b20]
+# [ds18b20]
 
 # Load "SI7013", "SI7020", "SI7021", "SHT21", and "HTU21D" sensors
-[htu21d]
+# [htu21d]
 
 # Load "LM75" sensor
-[lm75]
+# [lm75]
 
 # Load "MAX6675", "MAX31855", "MAX31856", and "MAX31865" sensors
-[spi_temperature]
+# [spi_temperature]
 
 # Load "temperature_host" sensor
-[temperature_host]
+# [temperature_host]
 
 # Load "temperature_mcu" sensor
 [temperature_mcu]
--- /dev/null
+++ b/klippy/extras/tool.py
@@ -0,0 +1,53 @@
+import re, os, logging, threading
+from subprocess import call
+import json, random, time
+from extras.base_info import base_dir
+
+def send(msg, data={}):
+    pipeFilePath = os.path.join(base_dir, "creality/userdata/config/pipe.json")
+    try:
+        if not os.path.exists(pipeFilePath):
+            call("touch %s" % pipeFilePath, shell=True)
+            os.chmod(pipeFilePath, 0o700)
+        ret = re.findall('key(\d+)', msg)
+        if ret:
+            msg = "key%s" % ret[0]
+            if os.path.getsize(pipeFilePath) > 0:
+                random_float = random.uniform(0.1, 1)
+                time.sleep(random_float)
+
+            result = compress_key701(msg, data)
+            if result:
+                data = result
+            if os.path.getsize(pipeFilePath) == 0:
+                send_data = {"reqId": str(int(time.time()*1000)), "dn": "00000000000000", "code": msg, "data": data}
+                with open(pipeFilePath, "w") as f:
+                    f.write(json.dumps(send_data))
+                    f.flush()
+    except Exception as err:
+        logging.error("reportInformation err:%s" % err)
+
+def reportInformation(msg, data={}):
+    t = threading.Thread(target=send, args=(msg, data))
+    t.start()
+
+def compress_key701(code, data):
+    if code == "key701":
+        try:
+            data = data.get("jobs", [])[0] if data.get("jobs", []) else {}
+            metadata = data.get("metadata", {})
+            model_info = metadata.get("model_info", {})
+            result = "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s" % (
+                data.get("end_time", 0), data.get("filament_used", 0), data.get("filename", ""), data.get("print_duration", 0),
+                data.get("start_time", 0), data.get("status", ""), data.get("error_msg", ""), data.get("total_duration", 0), 
+                metadata.get("estimated_time", 0), metadata.get("filament_total", 0), metadata.get("filament_weight_total", 0), metadata.get("first_layer_bed_temp", 0), metadata.get("first_layer_extr_temp", 0),
+                metadata.get("first_layer_height", 0), metadata.get("gcode_end_byte", 0), metadata.get("gcode_start_byte", 0), metadata.get("layer_count", 0),
+                metadata.get("layer_height", 0), metadata.get("modified", 0), metadata.get("object_height", 0), metadata.get("size", 0),
+                metadata.get("slicer", ""), metadata.get("slicer_version", ""), model_info.get("MaterialType", ""), model_info.get("MaterialName", ""),
+                model_info.get("MAXX", 0), model_info.get("MAXY", 0), model_info.get("MAXZ", 0), model_info.get("MINX", 0), model_info.get("MINY", 0), model_info.get("MINZ", 0),
+            )
+            # "end_time|filament_used|filename|print_duration|start_time|status|error_msg|total_duration|estimated_time|filament_total|filament_weight_total|first_layer_bed_temp|first_layer_extr_temp|first_layer_height|gcode_end_byte|gcode_start_byte|layer_count|layer_height|modified|object_height|size|slicer|slicer_version|MaterialType|MaterialName|MAXX|MAXY|MAXZ|MINX|MINY|MINZ"
+            return result
+        except Exception as err:
+            logging.exception(err)
+    return None
\ No newline at end of file
--- a/klippy/extras/verify_heater.py
+++ b/klippy/extras/verify_heater.py
@@ -56,6 +56,11 @@ class HeaterCheck:
                 self.error = 0.
             self.last_target = target
             return eventtime + 1.
+        if self.heater_name == "chamber_heater" and target > 40 and self.heater.last_pwm_value == 0:
+            # Chamber heater is not heating
+            if temp <= target + self.hysteresis:
+                self.error = 0.
+            return eventtime + 1.
         self.error += (target - self.hysteresis) - temp
         if not self.approaching_target:
             if target != self.last_target:
@@ -67,6 +72,7 @@ class HeaterCheck:
                 self.goal_systime = eventtime + self.check_gain_time
             elif self.error >= self.max_error:
                 # Failure due to inability to maintain target temperature
+                logging.error("verify_heater:heater_fault heater_name:%s, temp:%s, target:%s, hysteresis:%s, self.error:%s, self.max_error:%s" % (self.heater_name, temp, target, self.hysteresis, self.error, self.max_error))
                 return self.heater_fault()
         elif temp >= self.goal_temp:
             # Temperature approaching target - reset checks
@@ -94,6 +100,14 @@ class HeaterCheck:
         elif self.heater_name == "chamber_heater":
             code_key = "key559"
         m = """{"code":"%s","msg":"Heater %s not heating at expected rate"}""" % (code_key, self.heater_name)
+        try:
+            gcode = self.printer.lookup_object('gcode')
+            if gcode:
+                gcode.run_script_from_command("M140 S0")
+                gcode.run_script_from_command("M104 S0")
+                gcode.run_script_from_command("M141 S0")
+        except Exception as err:
+            logging.error(err)
         self.printer.invoke_shutdown(m)
         return self.printer.get_reactor().NEVER
 
--- a/klippy/extras/virtual_sdcard.py
+++ b/klippy/extras/virtual_sdcard.py
@@ -3,17 +3,82 @@
 # Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import os, logging, io
+import os, logging, io, json, time, re, threading
+from .tool import reportInformation
+from .base_info import base_dir, system_info_instance
 
 VALID_GCODE_EXTS = ['gcode', 'g', 'gco']
+LAYER_KEYS = ["; layer #", ";LAYER:", "; layer:", "; LAYER:", ";AFTER_LAYER_CHANGE", ";LAYER_CHANGE"]
+
+MAINTENANCE_ITEM = {
+    "calibrate" : {
+        "cut_calibration": {"cur_value": 0},
+        "shaper_calibrate": {"cur_value": 0},
+        "belt_tensioning": {"cur_value": 0},
+        },
+    "routine_maintenance" : {
+        "motion_mechanism_lubrication": {"cur_value": 0},
+        "camera_maintenance": {"cur_value": 0},
+        "fan_inspection": {"cur_value": 0}
+        },
+    "machine_wear_parts_replacement": {
+        "nozzle": {"cur_value": 0},
+        "cut": {"cur_value": 0},
+        "machine_teflon_tube": {"cur_value": 0},
+        "wipe_mouth_strip": {"cur_value": 0},
+        "air_filter": {"cur_value": 0}
+        },
+    "cfs_wear_parts_replacement" : {
+        "cfs_teflon_tube": {"cur_value": 0},
+        "cfs_desiccant": {"cur_value": 0}
+    }
+}
+
+def capture(end_print=False, frame=15):
+    import subprocess
+    python_path = "/usr/share/klippy-env/bin/python"
+    cmd_path = "/usr/share/klipper/klippy/extras/photograph.py"
+    capture_shell = ""
+    def run_cmd(capture_shell):
+        try:
+            logging.info(capture_shell)
+            capture_ret = subprocess.check_output(capture_shell, shell=True).decode("utf-8")
+            logging.info("%s return:#%s#" % (capture_shell, str(capture_ret)))
+        except Exception as err:
+            logging.error(err)
+    if system_info_instance._h264_encoder_flag == "NO_H264_ENCODER" and end_print == True:
+        capture_shell = "capture 0 1"
+        background_thread = threading.Thread(target=run_cmd, args=(capture_shell,))
+        background_thread.start()
+        logging.info("background_thread capture 0 1")
+        return
+    elif system_info_instance._h264_encoder_flag == "NO_H264_ENCODER" and end_print == False:
+        subprocess.Popen([python_path, cmd_path])
+    elif system_info_instance._h264_encoder_flag == "H264_ENCODER" and end_print == True:
+        interval_time = 1.0 / frame
+        start_time = 1
+        while start_time > 0:
+            run_cmd("capture 0")
+            time.sleep(interval_time)
+            start_time = start_time - interval_time
+    else:
+        capture_shell = "capture 0"
+
+    if capture_shell:
+        run_cmd(capture_shell)
 
 class VirtualSD:
     def __init__(self, config):
+        self.config = config
         self.printer = config.get_printer()
         self.printer.register_event_handler("klippy:shutdown",
                                             self.handle_shutdown)
+        self.printer.register_event_handler('klippy:ready',
+                self._handle_ready)
         # sdcard state
         sd = config.get('path')
+        self.offset_value = config.getfloat('offset_value', 0) # 断电续打偏移补偿值
+        self.forced_leveling = config.getboolean('forced_leveling',  default=False)
         self.sdcard_dirname = os.path.normpath(os.path.expanduser(sd))
         self.current_file = None
         self.file_position = self.file_size = 0
@@ -40,6 +105,273 @@ class VirtualSD:
         self.gcode.register_command(
             "SDCARD_PRINT_FILE", self.cmd_SDCARD_PRINT_FILE,
             desc=self.cmd_SDCARD_PRINT_FILE_help)
+        self.gcode.register_command(
+            "SHOW_GCODE_FLUSH", self.cmd_SHOW_GCODE_FLUSH,
+            desc=self.cmd_SHOW_GCODE_FLUSH_help)
+        self.gcode.register_command("CLEAR_EEPROM_INFO", self.cmd_CLEAR_EEPROM_INFO)
+        self.gcode.register_command("SET_MAINTENANCE_ITEM_VARIABLE", self.cmd_SET_MAINTENANCE_ITEM_VARIABLE)
+        self.count_G1 = 0 
+        self.count_line = 0
+        self.do_resume_status = False
+        self.eepromWriteCount = 1
+        self.fan_state = {}
+        self.gcode_layer_path = os.path.join(base_dir, "creality/userdata/config/gcode_layer.json")
+        self.user_print_refer_path = os.path.join(base_dir, "creality/userdata/config/user_print_refer.json")
+        self.print_file_name_path = os.path.join(base_dir, "creality/userdata/config/print_file_name.json")
+        self.speed_mode_path = os.path.join(base_dir, "creality/userdata/config/speed_mode.json")
+        self.flow_rate_path = os.path.join(base_dir, "creality/userdata/config/flow_rate.json")
+        self.maintenance_item_path = os.path.join(base_dir, "creality/userdata/config/maintenance_item.json")
+        self.print_first_layer = False
+        self.first_layer_stop = False
+        self.count_M204 = 0
+        self.layer = 0
+        self.layer_count = 0
+        self.is_continue_print = False
+        self.slow_print = False
+        self.slow_count = 0
+        self.speed_factor = 1.0/60.0
+        self.run_dis = 0.0
+        self.print_id = ""
+        self.cur_print_data = {}
+        self.gcode_metadata = None
+        self.end_print_state = False
+        self.last_layer = 0
+        self.is_cancel = False
+        self.bed_mesh_calibate_state = False
+        self.run_bed_mesh_calibate = False
+        self.layer_key = ""
+        self.lock = threading.Lock()
+        self.is_move_out_of_range_in_printing = False
+    def _handle_ready(self):
+        self._maintenance_item_timer = self.reactor.register_timer(self.update_maintenance_item_timer)
+        self.reactor.update_timer(self._maintenance_item_timer, self.reactor.NOW)
+        self.printer.register_event_handler('v_sd:update_cut_used', self.update_cut_used)
+        self.printer.register_event_handler('v_sd:update_filament_used', self.update_filament_used)
+        self.printer.register_event_handler('v_sd:cancel_power_loss_update_filament_used', self.cancel_power_loss_update_filament_used)
+        self.printer.register_event_handler('v_sd:reset_cut_calibration_count', self.reset_cut_calibration_count)
+        self.printer.register_event_handler('v_sd:reset_shaper_calibrate_count', self.reset_shaper_calibrate_count)
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("get_maintenance_item", self.get_maintenance_item)
+    def notify_maintenance_item(self):
+        maintenance_item_param = self.printer.lookup_object("gcode_macro MAINTENANCE_ITEM_PARAM", None)
+        if maintenance_item_param and self.config.has_section("gcode_macro MAINTENANCE_ITEM") and os.path.exists(self.maintenance_item_path):
+            try:
+                obj = self.printer.lookup_object("gcode_macro MAINTENANCE_ITEM")
+                with open(self.maintenance_item_path, "r") as f:
+                    result = json.loads(f.read())
+                    result = self.maintenance_item_add_threshold(result)
+                    result = self.maintenance_item_add_timeout(result)
+                    obj.variables = result
+            except Exception as err:
+                logging.exception(err)
+    def calculate_filament_weight(self, filament_used, filament_diameter=1.75, filament_density=1.25e-3):
+        import math
+        # 将耗材直径转为半径
+        radius = filament_diameter / 2
+        # 计算耗材体积 (V = πr^2h)
+        volume = math.pi * (radius ** 2) * filament_used
+        # 计算耗材重量 体积*密度
+        weight = volume * filament_density
+        return weight
+    def update_cut_used(self):
+        self.update_maintenance_item(update_cut_used=True)
+    def update_filament_used(self):
+        filament_used = self.printer.lookup_object('print_stats').filament_used
+        if filament_used > 0:
+            weight = self.calculate_filament_weight(filament_used)
+            self.update_maintenance_item(update_filament_used=True, filament_used=weight)
+    def cancel_power_loss_update_filament_used(self):
+        filament_used = 0
+        try:
+            if os.path.exists(self.print_file_name_path):
+                with open(self.print_file_name_path, "r") as f:
+                    ret = json.loads(f.read())
+                    filament_used = ret.get("filament_used", 0)
+            if filament_used > 0:
+                weight = self.calculate_filament_weight(filament_used)
+                self.update_maintenance_item(update_filament_used=True, filament_used=weight)
+        except Exception as err:
+            pass
+    def reset_cut_calibration_count(self):
+        self.gcode.run_script_from_command("SET_MAINTENANCE_ITEM_VARIABLE NAME=calibrate VARIABLE=cut_calibration VALUE=0")
+    def reset_shaper_calibrate_count(self):
+        self.gcode.run_script_from_command("SET_MAINTENANCE_ITEM_VARIABLE NAME=calibrate VARIABLE=shaper_calibrate VALUE=0")
+    def update_maintenance_item_timer(self, eventtime):
+        # 通知到订阅端
+        self.notify_maintenance_item()
+        try:
+            if not os.path.exists(self.maintenance_item_path):
+                with open(self.maintenance_item_path, 'w') as f:
+                    f.write(json.dumps(MAINTENANCE_ITEM))
+                    f.flush()
+            print_stats = self.printer.lookup_object('print_stats')
+            if print_stats.state == "printing":
+                self.update_maintenance_item()
+        except Exception as e:
+            logging.error("Error in update_maintenance_item: %s" % str(e))
+        return eventtime + 60.0
+    def update_maintenance_item(self, update_cut_used=False, update_filament_used=False, filament_used=0, variable_update=False, update_item_name="", variable_update_obj="", reset_value=0):
+        interval = 60
+        with self.lock:
+            if not os.path.exists(self.maintenance_item_path):
+                with open(self.maintenance_item_path, 'w') as f:
+                    f.write(json.dumps(MAINTENANCE_ITEM))
+                    f.flush()
+            else:
+                result = {}
+                try:
+                    with open(self.maintenance_item_path, 'r') as f:
+                        result = json.loads(f.read())
+                    if not result:
+                        os.remove(self.maintenance_item_path)
+                        return
+                    # 重设记录值
+                    if variable_update:
+                        if result.get(update_item_name) and result.get(update_item_name).get(variable_update_obj):
+                            result[update_item_name][variable_update_obj]["cur_value"] = reset_value
+                            with open(self.maintenance_item_path, 'w') as f:
+                                f.write(json.dumps(result))
+                                f.flush()
+                            # 通知到订阅端
+                            self.notify_maintenance_item()
+                        return
+                    # 更新值
+                    result = self.check_item(result=result, interval=interval, update_cut_used=update_cut_used, update_filament_used=update_filament_used, filament_used=filament_used)
+                    with open(self.maintenance_item_path, 'w') as f:
+                        f.write(json.dumps(result))
+                        f.flush()
+                    # 通知到订阅端
+                    self.notify_maintenance_item()
+                except Exception as err:
+                    logging.error("open maintenance_item_path err:%s" % str(err))
+                    os.remove(self.maintenance_item_path)
+    def check_item(self, result, interval, update_cut_used, update_filament_used, filament_used=0, max_value=999999999999999):
+        if update_cut_used:
+            # 更新切刀使用次数
+            if result["calibrate"]["cut_calibration"]["cur_value"] < max_value:
+                result["calibrate"]["cut_calibration"]["cur_value"] += 1
+            if result["machine_wear_parts_replacement"]["cut"]["cur_value"] < max_value:
+                result["machine_wear_parts_replacement"]["cut"]["cur_value"] += 1
+            return result
+        if update_filament_used:
+            # 更新耗材使用重量
+            if result["machine_wear_parts_replacement"]["nozzle"]["cur_value"] < max_value:
+                result["machine_wear_parts_replacement"]["nozzle"]["cur_value"] += filament_used
+            return result
+        # 更新打印时长
+        if result["calibrate"]["shaper_calibrate"]["cur_value"] < max_value:
+            result["calibrate"]["shaper_calibrate"]["cur_value"] += interval
+        if result["calibrate"]["belt_tensioning"]["cur_value"] < max_value:
+            result["calibrate"]["belt_tensioning"]["cur_value"] += interval
+        if result["routine_maintenance"]["motion_mechanism_lubrication"]["cur_value"] < max_value:
+            result["routine_maintenance"]["motion_mechanism_lubrication"]["cur_value"] += interval
+        if result["routine_maintenance"]["camera_maintenance"]["cur_value"] < max_value:
+            result["routine_maintenance"]["camera_maintenance"]["cur_value"] += interval
+        if result["routine_maintenance"]["fan_inspection"]["cur_value"] < max_value:
+            result["routine_maintenance"]["fan_inspection"]["cur_value"] += interval
+        if result["machine_wear_parts_replacement"]["machine_teflon_tube"]["cur_value"] < max_value:
+            result["machine_wear_parts_replacement"]["machine_teflon_tube"]["cur_value"] += interval
+        if result["machine_wear_parts_replacement"]["wipe_mouth_strip"]["cur_value"] < max_value:
+            result["machine_wear_parts_replacement"]["wipe_mouth_strip"]["cur_value"] += interval
+        if result["machine_wear_parts_replacement"]["air_filter"]["cur_value"] < max_value:
+            result["machine_wear_parts_replacement"]["air_filter"]["cur_value"] += interval
+        if not self.check_cfs_enable():
+            return result
+        if result["cfs_wear_parts_replacement"]["cfs_teflon_tube"]["cur_value"] < max_value:
+            result["cfs_wear_parts_replacement"]["cfs_teflon_tube"]["cur_value"] += interval
+        if result["cfs_wear_parts_replacement"]["cfs_desiccant"]["cur_value"] < max_value:
+            result["cfs_wear_parts_replacement"]["cfs_desiccant"]["cur_value"] += interval
+        return result
+    def check_cfs_enable(self):
+        box_enable = 0
+        try:
+            box = self.printer.lookup_object("box", None)
+            if box and os.path.exists(box.box_state.tn_save_data_path):
+                with open(box.box_state.tn_save_data_path, "r") as f:
+                    data = json.load(f)
+                    box_enable = data.get("enable", 0)
+        except Exception as err:
+            pass
+        return box_enable
+    def get_maintenance_item(self, web_request):
+        response = {}
+        maintenance_item_param = self.printer.lookup_object("gcode_macro MAINTENANCE_ITEM_PARAM", None)
+        if maintenance_item_param and os.path.exists(self.maintenance_item_path):
+            try:
+                with open(self.maintenance_item_path, 'r') as f:
+                    result = json.loads(f.read())
+                    result = self.maintenance_item_add_threshold(result)
+                    result = self.maintenance_item_add_timeout(result)
+                    response = result
+            except Exception as err:
+                logging.exception(err)
+        web_request.send(response)
+        return response
+    def maintenance_item_add_threshold(self, result):
+        maintenance_item_param = self.printer.lookup_object("gcode_macro MAINTENANCE_ITEM_PARAM", None).variables
+        result["calibrate"]["cut_calibration"]["threshold"] = maintenance_item_param.get("cut_calibration")
+        result["calibrate"]["shaper_calibrate"]["threshold"] = maintenance_item_param.get("shaper_calibrate")
+        result["calibrate"]["belt_tensioning"]["threshold"] = maintenance_item_param.get("belt_tensioning")
+        result["routine_maintenance"]["motion_mechanism_lubrication"]["threshold"] = maintenance_item_param.get("motion_mechanism_lubrication")
+        result["routine_maintenance"]["camera_maintenance"]["threshold"] = maintenance_item_param.get("camera_maintenance")
+        result["routine_maintenance"]["fan_inspection"]["threshold"] = maintenance_item_param.get("fan_inspection")
+        result["machine_wear_parts_replacement"]["nozzle"]["threshold"] = maintenance_item_param.get("nozzle")
+        result["machine_wear_parts_replacement"]["cut"]["threshold"] = maintenance_item_param.get("cut")
+        result["machine_wear_parts_replacement"]["machine_teflon_tube"]["threshold"] = maintenance_item_param.get("machine_teflon_tube")
+        result["machine_wear_parts_replacement"]["wipe_mouth_strip"]["threshold"] = maintenance_item_param.get("wipe_mouth_strip")
+        result["machine_wear_parts_replacement"]["air_filter"]["threshold"] = maintenance_item_param.get("air_filter")
+        result["cfs_wear_parts_replacement"]["cfs_teflon_tube"]["threshold"] = maintenance_item_param.get("cfs_teflon_tube")
+        result["cfs_wear_parts_replacement"]["cfs_desiccant"]["threshold"] = maintenance_item_param.get("cfs_desiccant")
+        result["calibrate"]["cut_calibration"]["timeout"] = False
+        result["calibrate"]["shaper_calibrate"]["timeout"] = False
+        result["calibrate"]["belt_tensioning"]["timeout"] = False
+        result["routine_maintenance"]["motion_mechanism_lubrication"]["timeout"] = False
+        result["routine_maintenance"]["camera_maintenance"]["timeout"] = False
+        result["routine_maintenance"]["fan_inspection"]["timeout"] = False
+        result["machine_wear_parts_replacement"]["nozzle"]["timeout"] = False
+        result["machine_wear_parts_replacement"]["cut"]["timeout"] = False
+        result["machine_wear_parts_replacement"]["machine_teflon_tube"]["timeout"] = False
+        result["machine_wear_parts_replacement"]["wipe_mouth_strip"]["timeout"] = False
+        result["machine_wear_parts_replacement"]["air_filter"]["timeout"] = False
+        result["cfs_wear_parts_replacement"]["cfs_teflon_tube"]["timeout"] = False
+        result["cfs_wear_parts_replacement"]["cfs_desiccant"]["timeout"] = False
+        return result
+    def maintenance_item_add_timeout(self, result):
+        maintenance_item_param = self.printer.lookup_object("gcode_macro MAINTENANCE_ITEM_PARAM", None).variables
+        if result["calibrate"]["cut_calibration"]["cur_value"] > maintenance_item_param.get("cut_calibration"):
+            result["calibrate"]["cut_calibration"]["timeout"] = True
+        if result["calibrate"]["shaper_calibrate"]["cur_value"] > maintenance_item_param.get("shaper_calibrate"):
+            result["calibrate"]["shaper_calibrate"]["timeout"] = True
+        if result["calibrate"]["belt_tensioning"]["cur_value"] > maintenance_item_param.get("belt_tensioning"):
+            result["calibrate"]["belt_tensioning"]["timeout"] = True
+        if result["routine_maintenance"]["motion_mechanism_lubrication"]["cur_value"] > maintenance_item_param.get("motion_mechanism_lubrication"):
+            result["routine_maintenance"]["motion_mechanism_lubrication"]["timeout"] = True
+        if result["routine_maintenance"]["camera_maintenance"]["cur_value"] > maintenance_item_param.get("camera_maintenance"):
+            result["routine_maintenance"]["camera_maintenance"]["timeout"] = True
+        if result["routine_maintenance"]["fan_inspection"]["cur_value"] > maintenance_item_param.get("fan_inspection"):
+            result["routine_maintenance"]["fan_inspection"]["timeout"] = True
+        if result["machine_wear_parts_replacement"]["nozzle"]["cur_value"] > maintenance_item_param.get("nozzle"):
+            result["machine_wear_parts_replacement"]["nozzle"]["timeout"] = True
+        if result["machine_wear_parts_replacement"]["cut"]["cur_value"] > maintenance_item_param.get("cut"):
+            result["machine_wear_parts_replacement"]["cut"]["timeout"] = True
+        if result["machine_wear_parts_replacement"]["machine_teflon_tube"]["cur_value"] > maintenance_item_param.get("machine_teflon_tube"):
+            result["machine_wear_parts_replacement"]["machine_teflon_tube"]["timeout"] = True
+        if result["machine_wear_parts_replacement"]["wipe_mouth_strip"]["cur_value"] > maintenance_item_param.get("wipe_mouth_strip"):
+            result["machine_wear_parts_replacement"]["wipe_mouth_strip"]["timeout"] = True
+        if result["machine_wear_parts_replacement"]["air_filter"]["cur_value"] > maintenance_item_param.get("air_filter"):
+            result["machine_wear_parts_replacement"]["air_filter"]["timeout"] = True
+        if result["cfs_wear_parts_replacement"]["cfs_teflon_tube"]["cur_value"] > maintenance_item_param.get("cfs_teflon_tube"):
+            result["cfs_wear_parts_replacement"]["cfs_teflon_tube"]["timeout"] = True
+        if result["cfs_wear_parts_replacement"]["cfs_desiccant"]["cur_value"] > maintenance_item_param.get("cfs_desiccant"):
+            result["cfs_wear_parts_replacement"]["cfs_desiccant"]["timeout"] = True
+        return result
+    def cmd_SET_MAINTENANCE_ITEM_VARIABLE(self, gcmd):
+        # SET_MAINTENANCE_ITEM_VARIABLE NAME=calibrate VARIABLE=cut_calibration VALUE=0
+        name = gcmd.get("NAME", "")
+        variable = gcmd.get("VARIABLE", "")
+        value = gcmd.get_int("VALUE", 0)
+        if name and variable:
+            self.update_maintenance_item(variable_update=True, update_item_name=name, variable_update_obj=variable, reset_value=value)
     def handle_shutdown(self):
         if self.work_timer is not None:
             self.must_pause_work = True
@@ -54,6 +386,11 @@ class VirtualSD:
             logging.info("Virtual sdcard (%d): %s\nUpcoming (%d): %s",
                          readpos, repr(data[:readcount]),
                          self.file_position, repr(data[readcount:]))
+        self.print_first_layer = False
+        self.first_layer_stop = False
+        self.print_stats.power_loss = 0
+        self.count_M204 = 0
+        self.fan_state = {}
     def stats(self, eventtime):
         if self.work_timer is None:
             return False, ""
@@ -90,6 +427,11 @@ class VirtualSD:
             'is_active': self.is_active(),
             'file_position': self.file_position,
             'file_size': self.file_size,
+            'first_layer_stop':  self.first_layer_stop,
+            'layer': self.layer,
+            'layer_count': self.layer_count,
+            'run_dis': self.run_dis,
+            'bed_mesh_calibate_state': self.bed_mesh_calibate_state
         }
     def file_path(self):
         if self.current_file:
@@ -114,12 +456,50 @@ class VirtualSD:
         self.work_timer = self.reactor.register_timer(
             self.work_handler, self.reactor.NOW)
     def do_cancel(self):
+        self.printer.send_event("v_sd:update_filament_used")
+        self.reactor.pause(self.reactor.monotonic() + 0.2)
+        self.is_cancel = True
+        self.print_stats.power_loss = 0
+        self.first_layer_stop = False
+        self.print_first_layer = False
+        self.count_M204 = 0
+        self.layer = 0
+        self.layer_count = 0
+        self.fan_state = {}
+        self.resume_print_speed()
         if self.current_file is not None:
             self.do_pause()
             self.current_file.close()
             self.current_file = None
             self.print_stats.note_cancel()
+        self.is_cancel = False
         self.file_position = self.file_size = 0.
+
+    def cmd_CLEAR_EEPROM_INFO(self, gcmd):
+        from subprocess import call
+        if os.path.exists(self.print_file_name_path):
+            os.remove(self.print_file_name_path)
+        if os.path.exists(self.gcode.exclude_object_info):
+            os.remove(self.gcode.exclude_object_info)
+        call("sync", shell=True)
+        try:
+            power_loss_switch = False
+            if os.path.exists(self.user_print_refer_path):
+                with open(self.user_print_refer_path, "r") as f:
+                    data = json.loads(f.read())
+                    power_loss_switch = data.get("power_loss", {}).get("switch", False)
+            bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+            if power_loss_switch and bl24c16f:
+                bl24c16f.setEepromDisable()
+                # self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+        except Exception as err:
+            logging.error(err)
+        self.update_print_history_info(only_update_status=True, state="cancelled")
+        if self.print_id and self.cur_print_data:
+            reportInformation("key701", data=self.cur_print_data)
+            self.print_id = ""
+            self.cur_print_data = {}
+
     # G-Code commands
     def cmd_error(self, gcmd):
         raise gcmd.error("SD write not supported")
@@ -141,14 +521,132 @@ class VirtualSD:
     cmd_SDCARD_PRINT_FILE_help = "Loads a SD file and starts the print.  May "\
         "include files in subdirectories."
     def cmd_SDCARD_PRINT_FILE(self, gcmd):
+        if self.config.has_section("motor_control") and self.config.getsection('motor_control').getint('switch')==1:
+            if self.printer.lookup_object('motor_control').is_ready == False:
+                self.gcode.respond_info("The motor parameters are initializing, Please try again later...")
+                return
+        if self.config.has_section("prtouch_v3") and self.bed_mesh_calibate_state == False and gcmd.get("ISCONTINUEPRINT", False) == False and self.forced_leveling:
+            self.run_bed_mesh_calibate = True
+        self.end_print_state = False
+        self.layer_key = ""
+        self.print_id = ""
         if self.work_timer is not None:
             raise gcmd.error("SD busy")
         self._reset_file()
         filename = gcmd.get("FILENAME")
+        self.is_continue_print = gcmd.get("ISCONTINUEPRINT", False)
+        self.printer.lookup_object("box").box_state.is_continue_print = gcmd.get("ISCONTINUEPRINT", False)
+        self.rm_power_loss_info()
+        first_floor = gcmd.get("FIRST_FLOOR_PRINT", None)
+        if first_floor is None or first_floor == False:
+            self.print_first_layer = False
+        else:
+            self.print_first_layer = True
         if filename[0] == '/':
             filename = filename[1:]
         self._load_file(gcmd, filename, check_subdirs=True)
+        self.load_gcode_metadata(str(self.current_file.name))
+        self.record_print_history(str(self.current_file.name))
         self.do_resume()
+    cmd_SHOW_GCODE_FLUSH_help = "Load SD file and display multi-color gcode material change flushing parameters."
+    def cmd_SHOW_GCODE_FLUSH(self, gcmd):
+        if self.work_timer is not None:
+            raise gcmd.error("SD busy")
+        filename = gcmd.get("FILENAME")
+        if filename is None:
+            logging.warning('Invalid FILENAME parameter')
+            return
+        if filename[0] == '/':
+            filename = filename[1:]
+        self.load_gcode_metadata(str(filename))
+        flush_para = self.get_gcode_flush_para()
+        if flush_para is None:
+            logging.warning('Error in getting flushing parameters')
+            return
+        self.gcode.respond_info("shwo gcode flush para: %s" % (flush_para))
+
+    def load_gcode_metadata(self, file_path=""):
+        self.gcode_metadata = self.get_print_file_metadata(file_path)
+        logging.info("gcode_metadata: %s" % (self.gcode_metadata))
+
+    def record_print_history(self, file_path=""):
+        try:
+            if os.path.exists(file_path):
+                dir_path = os.path.dirname(file_path)
+                file_name = os.path.basename(file_path)
+                metadata_info = self.get_print_file_metadata(filename=file_name, filepath=dir_path)
+                self.layer_count = self.get_file_layer_count(self.current_file.name, metadata_info=metadata_info)
+                start_time = time.time()
+                self.print_id = str(start_time)
+                metadata = metadata_info.get("metadata", {})
+                # Give print_id to AI Engine
+                json_to_write = {"print_id": self.print_id}
+                with open('/tmp/cx_print_id.json', 'w') as f:
+                    json.dump(json_to_write, f)
+                    f.flush()
+                data = {
+                    "end_time": start_time,
+                    "filament_used": 0,
+                    "filename": file_name,
+                    "metadata": metadata,
+                    "print_duration": 0,
+                    "start_time": start_time,
+                    "status": "in_progress",
+                    "total_duration": 0,
+                }
+                result = {"count": 1, "jobs": [data]}
+                self.cur_print_data = result
+                return
+        except Exception as err:
+            logging.error(err)
+
+    def update_print_history_info(self, only_update_status=False, state="", error_msg=""):
+        if self.print_id:
+            ret = {}
+            try:
+                update_obj = None
+                index = -1
+                ret = self.cur_print_data
+                if ret and ret.get("jobs", []):
+                    print_list = ret.get("jobs", [])
+                    for obj in print_list:
+                        if obj.get("start_time", "") and str(obj.get("start_time", "")) == self.print_id:
+                            index = print_list.index(obj)
+                            update_obj = obj
+                            if not only_update_status:
+                                update_obj["filament_used"] = self.print_stats.filament_used
+                                update_obj["print_duration"] = self.print_stats.print_duration
+                                update_obj["total_duration"] = self.print_stats.total_duration
+                            update_obj["end_time"] = time.time()
+                            if not state:
+                                state = "in_progress"
+                            if error_msg:
+                                update_obj["error_msg"] = error_msg
+                            update_obj["status"] = state
+
+                if index != -1:
+                    print_list[index] = update_obj
+                    ret["jobs"] = print_list
+                    self.cur_print_data = ret
+            except Exception as err:
+                logging.error(err)
+
+    def rm_power_loss_info(self):
+        if not self.is_continue_print and os.path.exists(self.print_file_name_path):
+            try:
+                power_loss_switch = False
+                with open(self.user_print_refer_path, "r") as f:
+                    data = json.loads(f.read())
+                    power_loss_switch = data.get("power_loss", {}).get("switch", False)
+                bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects and power_loss_switch else None
+                if power_loss_switch and bl24c16f:
+                    os.remove(self.print_file_name_path)
+                    if os.path.exists(self.gcode.exclude_object_info):
+                        os.remove(self.gcode.exclude_object_info)
+                    self.gcode.run_script_from_command("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+                    logging.info("rm power_loss info success")
+            except Exception as err:
+                logging.error("rm power_loss info fail, err:%s" % err)
     def cmd_M20(self, gcmd):
         # List SD card
         files = self.get_file_list()
@@ -215,8 +713,486 @@ class VirtualSD:
         self.next_file_position = pos
     def is_cmd_from_sd(self):
         return self.cmd_from_sd
+    def tail_read(self, f):
+        cur_pos = f.tell()
+        buf = ''
+        while True:
+            try:
+                b = str(f.read(1))
+            except UnicodeDecodeError as err:
+                logging.error("UnicodeDecodeError err:%s" % str(err))
+                cur_pos -= 1
+                if cur_pos < 0: break
+                f.seek(cur_pos)
+                continue
+            buf = b + buf
+            cur_pos -= 1
+            if cur_pos < 0: break
+            f.seek(cur_pos)
+            if b.startswith("\n") or b.startswith("\r"):
+                buf = '\n'
+            if (buf.startswith("G1") or buf.startswith("G0")) and buf.endswith("\n"):
+                if ";" in buf:
+                    buf = buf.split(";")[0]+"\n"
+                break
+        return buf
+    def check_Tn(self, file_path):
+        # 判断是否为多色文件
+        READ_SIZE = 512 * 1024
+        header_data = ""
+        # result 0为单色 1为多色中的单色(只有一个T0) 2为多色(有T0、T1、T2等)
+        result = 0
+        count = 5
+        with open(file_path, 'r') as f:
+            while count > 0:
+                count -= 1
+                header_data = f.read(int(READ_SIZE))
+                pattern_T = r"(?m)^\s*T(\d+)\s*$"
+                pattern_G = r"(?m)^\s*G1"
+                value_G = re.findall(pattern_G, header_data)
+                # 匹配到G1指令的时候, 再去匹配T指令
+                if len(value_G)<=1:
+                    continue
+                value_T = re.findall(pattern_T, header_data)
+                if len(value_T) == 1:
+                    result = 1
+                elif len(value_T) > 1:
+                    result = 2
+                break
+        return result
+
+    def getXYZET(self, file_path, file_position):
+        # Tn能拿到值的话 证明是多色文件 需要遍历到T值再退出循环
+        Tn = self.check_Tn(file_path)
+        result = {"X": 0, "Y": 0, "Z": 0, "E": 0, "T": ""}
+        try:
+            import io
+            with io.open(file_path, "r", encoding="utf-8") as f:
+                f.seek(file_position)
+                while True:
+                    cur_pos = f.tell()
+                    if cur_pos<=0:
+                        break
+                    line = self.tail_read(f)
+                    line_list = line.split(" ")
+                    if not result["E"] and "E" in line:
+                        for obj in line_list:
+                            if obj.startswith("E"):
+                                ret = obj[1:].split("\r")[0]
+                                ret = ret.split("\n")[0]
+                                if ret.startswith("."):
+                                    result["E"] = float(("0"+ret.strip(" ")))
+                                else:
+                                    result["E"] = float(ret.strip(" "))
+                    if not result["X"] and not result["Y"] and "X" in line and "Y" in line:
+                        for obj in line_list:
+                            if obj.startswith("X"):
+                                logging.info("power_loss getXYZET X:%s" % obj)
+                                result["X"] = float(obj.split("\r")[0][1:])
+                            if obj.startswith("Y"):
+                                logging.info("power_loss getXYZET Y:%s" % obj)
+                                result["Y"] = float(obj.split("\r")[0][1:])
+                    if not result["Z"] and "Z" in line:
+                        for obj in line_list:
+                            if obj.startswith("Z"):
+                                logging.info("power_loss getXYZET Z:%s" % obj)
+                                result["Z"] = float(obj.split("\r")[0][1:])
+                    if result["X"] and result["Y"] and result["Z"] and result["E"]:
+                        break
+                    self.reactor.pause(self.reactor.monotonic() + .001)
+            if Tn == 1:
+                result["T"] = "T0"
+                logging.info("power_loss get XYZET T:%s" % str(result))
+            elif Tn == 2:
+                # 获取file_postion的位置的上一个Tn值
+                READ_SIZE = 512*1024
+                pattern = r"(?m)^\s*T(\d+)\s*$"
+                with io.open(file_path, "r", encoding="utf-8") as f:
+                    while file_position > 0:
+                        pos = max(file_position - READ_SIZE, 0)
+                        read_size = min(READ_SIZE, file_position)
+                        f.seek(pos)
+                        header_data = f.read(read_size)
+                        values = re.findall(pattern, header_data)
+                        if values:
+                            result["T"] = "T%s"%values[-1]
+                            logging.info("power_loss get XYZET T:%s" % str(result))
+                            break
+                        file_position = pos
+                        if pos == 0:
+                            logging.info("read the file without finding a match")
+                            break
+                        self.reactor.pause(self.reactor.monotonic() + .001)
+            logging.info("power_loss get XYZET:%s" % str(result))
+        except UnicodeDecodeError as err:
+            logging.exception(err)
+            # UnicodeDecodeError 'utf-8' codec can't decode byte 0xff in postion 5278: invalid start byte
+            err_msg = '{"code": "key572", "msg": "File UnicodeDecodeError"}'
+            self.gcode.respond_info(err_msg)
+            raise self.printer.command_error(err_msg)
+        except Exception as err:
+            logging.exception(err)
+        return result
+    def get_print_temperature(self, file_path):
+        bed = 50
+        extruder = 202.0
+        chamber_heater = 0
+        if os.path.exists(self.gcode.last_temperature_info):
+            try:
+                with open(self.gcode.last_temperature_info, "r") as f:
+                    result = f.read()
+                    if len(result) > 0:
+                        result = json.loads(result)
+                        bed = float(result.get("bed", 0))
+                        extruder = float(result.get("extruder", 201.0))
+                        chamber_heater = float(result.get("chamber_heater", 0))
+            except Exception as err:
+                logging.error("get_print_temperature: %s" % err)
+        logging.info("power_loss get_print_temperature: bed:%s, extruder:%s, chamber_heater:%s" % (bed, extruder, chamber_heater))
+        return bed, extruder, chamber_heater
+
+    def record_layer(self, layer):
+        """
+        record current print file layer
+        """
+        with open(self.gcode_layer_path, "w") as f:
+            f.write(json.dumps({"layer": layer}))
+            f.flush()
+            
+    def get_layer(self):
+        """
+        get last print file layer
+        """
+        layer = 0
+        if os.path.exists(self.gcode_layer_path):
+            try:
+                with open(self.gcode_layer_path, "r") as f:
+                    layer = int(json.loads(f.read()).get("layer"))
+            except Exception as err:
+                logging.error(err)
+                os.remove(self.gcode_layer_path)
+        return layer
+
+    def get_print_file_metadata(self, filename, filepath=""):
+        from subprocess import check_output
+        if not filepath:
+            filepath = os.path.join(base_dir, "printer_data/gcodes")
+        result = {}
+        python_env = "/usr/share/klippy-env/bin/python3"
+        # -f gcode filename  -p gcode file dir
+        cmd = "%s /usr/share/klipper/klippy/extras/metadata.py -f '%s' -p %s" % (python_env, filename, filepath)
+        try:
+            result = json.loads(check_output(cmd, shell=True).decode("utf-8"))
+        except Exception as err:
+            logging.error(err)
+        return result
+    
+    def get_file_layer_count(self, filename, metadata_info=None):
+        filename = filename.split("/")[-1]
+        import math
+        layer_count = 0
+        if metadata_info:
+            result = metadata_info
+        else:
+            result = self.get_print_file_metadata(filename, get_layer_count=True)
+        if not result:
+            return layer_count
+        try:
+            layer_count = result.get("metadata").get("layer_count", 0)
+            first_layer_height = result.get("metadata").get("first_layer_height", 0)
+            object_height = result.get("metadata").get("object_height", 0)
+            layer_height = result.get("metadata").get("layer_height", 0)
+            if not layer_count and object_height > 0 and layer_height > 0:
+                layer_count = math.ceil((object_height - first_layer_height) / layer_height + 1)
+        except Exception as err:
+            logging.error(err)
+        return layer_count
+    
+    def get_gcode_flush_para(self):
+        flush_para = None
+        try:
+            flush_para = self.gcode_metadata.get("metadata").get("flush_para", None)
+        except Exception as err:
+            logging.error(err)
+        return flush_para
+        
+    def resume_print_speed(self):
+        if self.slow_print == True:
+            self.slow_print = False
+            self.slow_count = 0
+            try:
+                speed_mode_path = self.speed_mode_path
+                speed_mode = -1
+                value = -1
+                if os.path.exists(speed_mode_path):
+                    with open(speed_mode_path, "r") as f:
+                        result = json.loads(f.read())
+                        speed_mode = result.get("speed_mode", -1)
+                        value = result.get("value", -1)
+                if speed_mode != -1:
+                    speed_cmd = ""
+                    if speed_mode == 1 and value!= -1:
+                        speed_cmd = "M220 S%s" % value
+                    elif speed_mode == 2:
+                        speed_cmd = "Qmode"
+                    if speed_cmd:
+                        self.gcode.run_script_from_command(speed_cmd)
+                        self.gcode.run_script_from_command("M400")
+                        logging.info("power_loss slow_print speed_mode:%s Resume" % speed_cmd)
+            except Exception as err:
+                logging.error("resume_print_speed err:%s" % err)
+            self.resume_flow_rate()
+
+    def resume_flow_rate(self):
+        try:
+            value = -1
+            if os.path.exists(self.flow_rate_path):
+                with open(self.flow_rate_path, "r") as f:
+                    result = json.loads(f.read())
+                    value = result.get("value", -1)
+            speed_cmd = ""
+            
+            if value != -1:
+                speed_cmd = "M221 S%s" % value
+            if speed_cmd:
+                self.gcode.run_script_from_command(speed_cmd)
+                self.gcode.run_script_from_command("M400")
+                logging.info("power_loss slow_print resume_flow_rate:%s Resume" % speed_cmd)
+        except Exception as err:
+            logging.error("resume_flow_rate err:%s" % err)
+
+    def get_delay_photography_info(self):
+        delay_photography_switch = 1
+        location = 0
+        frame = 15
+        interval = 1
+        power_loss_switch = False
+        try:
+            if os.path.exists(self.user_print_refer_path):
+                with open(self.user_print_refer_path, "r") as f:
+                    data = json.loads(f.read())
+                    delay_photography_switch = data.get("delay_image", {}).get("switch", 1)
+                    location = data.get("delay_image", {}).get("location", 0)
+                    frame = data.get("delay_image", {}).get("frame", 15)
+                    interval = data.get("delay_image", {}).get("interval", 1)
+                    power_loss_switch = data.get("power_loss", {}).get("switch", False)
+        except Exception as err:
+            logging.error(err)
+        return delay_photography_switch, location, frame, interval, power_loss_switch
+
+    def restore_print(self, gcode_move, power_loss_switch, bl24c16f, eepromState):
+        sameFileName = False
+        if self.is_continue_print and os.path.exists(self.print_file_name_path):
+            with open(self.print_file_name_path, "r") as f:
+                result = (json.loads(f.read()))
+                if result.get("file_path", "") == self.current_file.name:
+                    sameFileName = True
+                else:
+                    # clear power_loss info
+                    os.remove(self.print_file_name_path)
+                    if os.path.exists(self.gcode.exclude_object_info):
+                        os.remove(self.gcode.exclude_object_info)
+                    if power_loss_switch and bl24c16f:
+                        bl24c16f.setEepromDisable()
+        if power_loss_switch and self.is_continue_print and not self.do_resume_status and sameFileName and bl24c16f:
+            eepromState = bl24c16f.checkEepromFirstEnable() if power_loss_switch and bl24c16f else True
+            if not eepromState:
+                with self.gcode.mutex:
+                    try:
+                        self.print_stats.note_start(info_path=self.print_file_name_path)
+                        self.is_continue_print = False
+                        logging.info("power_loss start do_resume...")
+                        logging.info("power_loss start print, filename:%s" % self.current_file.name)
+                        pos = bl24c16f.eepromReadHeader()
+                        logging.info("power_loss pos:%s" % pos)
+                        print_info = bl24c16f.eepromReadBody(pos)
+                        logging.info("power_loss print_info:%s" % str(print_info))
+                        self.file_position = int(print_info.get("file_position", 0))
+                        logging.info("power_loss file_position:%s" % self.file_position)
+                        self.layer = self.get_layer()
+                        gcode = self.printer.lookup_object('gcode')
+                        temperature = self.get_print_temperature(self.current_file.name)
+                        gcode.run_script_from_command("M140 S%s" % temperature[0])
+                        gcode.run_script_from_command("M109 S%s" % temperature[1])
+                        gcode.run_script_from_command("M141 S%s" % temperature[2]) if temperature[2] > 0 else None
+                        XYZET = self.getXYZET(self.current_file.name, self.file_position)
+                        logging.info("power_loss XYZET:%s, file_position:%s  " % (str(XYZET), self.file_position))
+                        if XYZET.get("Z") == 0:
+                            logging.error("power_loss gcode Z == 0 err")
+                            from subprocess import call
+                            if os.path.exists(self.print_file_name_path):
+                                os.remove(self.print_file_name_path)
+                            if os.path.exists(self.gcode.exclude_object_info):
+                                os.remove(self.gcode.exclude_object_info)
+                            call("sync", shell=True)
+                            try:
+                                power_loss_switch = False
+                                if os.path.exists(self.user_print_refer_path):
+                                    with open(self.user_print_refer_path, "r") as f:
+                                        data = json.loads(f.read())
+                                        power_loss_switch = data.get("power_loss", {}).get("switch", False)
+                                bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects else None
+                                if power_loss_switch and bl24c16f:
+                                    bl24c16f.setEepromDisable()
+                            except Exception as err:
+                                logging.error("power_loss gcode Z == 0: %s" % err)
+                            error_message = "power_loss gcode Z == 0, stop print"
+                            self.print_stats.note_error(error_message)
+                            raise
+                        gcode_move.cmd_CX_RESTORE_GCODE_STATE(print_info, self.print_file_name_path, XYZET)
+                        logging.info("power_loss end do_resume success")
+                        self.print_stats.power_loss = 0
+                        # 此处为设置慢速打印, 多色打印时不设置慢速打印
+                        if self.layer > 1 and XYZET.get("T") == "":
+                            self.slow_print = True
+                            self.slow_count = self.layer + 1
+                            self.speed_factor = gcode_move.speed_factor
+                            self.gcode.run_script_from_command("M220 S20")
+                            logging.info("power_loss slow_print M220 S20 SET")
+                        self.gcode.run_script_from_command("SET_PIN PIN=extruder_fan VALUE=1")
+                    except Exception as err:
+                        self.print_stats.power_loss = 0
+                        logging.error(err)
+            else:
+                self.gcode.run_script("G90")
+        else:
+            self.gcode.run_script("G90")
+        return eepromState
+
+    def record_power_loss_info(self,power_loss_switch, bl24c16f,eepromState, gcode_move, start_time, end_time, interval_start_time, interval_end_time):
+        try:
+            # 置一个标志位 有层信息的判断层信息,一层写一次EEPROM, 把file_postion写到里面
+            # 没有层信息的话 5秒写一次EEPROM
+            state = False
+            if self.layer > 2 and self.layer>self.last_layer and gcode_move.last_position[2] > 1.0:
+                state = True
+            elif self.layer == 0 and gcode_move.last_position[2] > 1.0:
+                if end_time-start_time>5:
+                    state = True
+            # if power_loss_switch and bl24c16f and (self.layer > 2 or (self.count_G1 > 18 and gcode_move.last_position[2] > 0.6)) and end_time-start_time>5 and self.file_position>0:
+            if power_loss_switch and bl24c16f and (self.layer > 6 or (self.count_G1 > 18 and gcode_move.last_position[2] > 1.0)) and state and self.file_position>0:
+                logging.info("record_power_loss_info to eeprom layer:%s last_position[2]:%s" % (self.layer, gcode_move.last_position[2]))
+                self.last_layer = self.layer
+                start_time = end_time
+                base_position_e = round(list(gcode_move.base_position)[-1], 2)
+                pos = bl24c16f.eepromReadHeader()
+                if eepromState:
+                    # eeprom first enable
+                    self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=1")
+                    self.gcode.run_script("EEPROM_WRITE_INT ADDR=%s VAL=%s" % (pos*8, int(self.file_position)))
+                    self.gcode.run_script("EEPROM_WRITE_FLOAT ADDR=%s VAL=%s" % (pos*8+4, base_position_e))
+                    self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=0 VAL=%d" % pos)
+                    eepromState = False
+                else:
+                    # pos = bl24c16f.eepromReadHeader()
+                    if self.eepromWriteCount < 256:
+                        self.gcode.run_script("EEPROM_WRITE_INT ADDR=%s VAL=%s" % (pos*8, int(self.file_position)))
+                        self.gcode.run_script("EEPROM_WRITE_FLOAT ADDR=%s VAL=%s" % (pos*8+4, base_position_e))
+                    else:
+                        self.eepromWriteCount = 1
+                        pos += 1
+                        if pos == 256:
+                            pos = 1
+                        self.gcode.run_script("EEPROM_WRITE_INT ADDR=%s VAL=%s" % (pos*8, int(self.file_position)))
+                        self.gcode.run_script("EEPROM_WRITE_FLOAT ADDR=%s VAL=%s" % (pos*8+4, base_position_e))
+                        self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=0 VAL=%d" % pos)
+                    # logging.info("eepromWriteCount:%d, pos:%d" % (self.eepromWriteCount, pos))
+                self.eepromWriteCount += 1
+        except Exception as err:
+            logging.error("EEPROM_WRITE ERROR:%s" % str(err))
+        
+        if power_loss_switch and bl24c16f and self.count_G1 == 19:
+            gcode_move.recordPrintFileName(self.print_file_name_path, self.current_file.name, fan_state=self.fan_state, filament_used=self.print_stats.filament_used, last_print_duration=self.print_stats.print_duration)
+        # if power_loss_switch and bl24c16f and (self.layer > 2 or gcode_move.last_position[2] > 3) and self.count_line % 999 == 0:
+        if power_loss_switch and bl24c16f and (self.layer > 6 or gcode_move.last_position[2] > 3) and self.current_file and interval_end_time-interval_start_time > 15:
+            interval_start_time = interval_end_time
+            gcode_move.recordPrintFileName(self.print_file_name_path, self.current_file.name, fan_state=self.fan_state, filament_used=self.print_stats.filament_used, last_print_duration=self.print_stats.print_duration)
+        return start_time, end_time, interval_start_time, interval_end_time
+
+    def judge_line_starts_with(self, line, power_loss_switch, bl24c16f):
+        if not power_loss_switch:
+            return line
+        if line.startswith("M106"):
+            M106_line = line.strip("\r").strip("\n")
+            if M106_line.startswith("M106 S"):
+                self.fan_state["M106 S"] = M106_line
+            elif M106_line.startswith("M106 P0"):
+                self.fan_state["M106 P0"] = M106_line
+            elif M106_line.startswith("M106 P1"):
+                self.fan_state["M106 P1"] = M106_line
+            elif M106_line.startswith("M106 P2"):
+                self.fan_state["M106 P2"] = M106_line
+        elif line.startswith("END_PRINT"):
+            self.end_print_state = True
+            if self.print_id and os.path.exists("/tmp/camera_main"):
+                reportInformation("key608", data={"print_id": self.print_id})
+            if os.path.exists(self.print_file_name_path):
+                os.remove(self.print_file_name_path)
+            if os.path.exists(self.gcode.exclude_object_info):
+                os.remove(self.gcode.exclude_object_info)
+            if power_loss_switch and bl24c16f:
+                self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+        elif line.startswith("M600"):
+            line = "PAUSE"
+        return line
+
+    def record_layer_info(self, line, power_loss_switch):
+        if not power_loss_switch:
+            return
+        if line.startswith(";"):
+            if self.layer_key and line.startswith(self.layer_key):
+                self.layer += 1
+                self.record_layer(self.layer)
+                self.reactor.pause(self.reactor.monotonic() + 0.001)
+                return
+            for layer_key in LAYER_KEYS:
+                if line.startswith(layer_key):
+                    self.layer += 1
+                    self.record_layer(self.layer)
+                    self.reactor.pause(self.reactor.monotonic() + 0.001)
+                    if not self.layer_key:
+                        self.layer_key = layer_key
+                    break
+
+    def first_floor_pause(self, line, toolhead):
+        if self.print_first_layer and self.count_G1 >= 20:
+            for layer_key in LAYER_KEYS:
+                if line.startswith(layer_key):
+                    logging.info("print_first_layer layer_key:%s" % layer_key)
+                    X, Y, Z, E = toolhead.get_position()
+                    self.gcode.run_script("FIRST_FLOOR_PAUSE")
+                    self.first_layer_stop = True
+
+    def check_end_print(self, line, power_loss_switch, delay_photography_switch, frame):
+        if not power_loss_switch:
+            return
+        if line.startswith("END_PRINT") and delay_photography_switch and os.path.exists("/tmp/camera_main"):
+            self.printer.send_event("v_sd:update_filament_used")
+            self.gcode.run_script("END_PRINT_POINT_WITHOUT_LIFTING")
+            self.gcode.run_script("M400")
+            capture(end_print=True, frame=frame)
+            self.reactor.pause(self.reactor.monotonic() + 1.2)
+
     # Background work timer
     def work_handler(self, eventtime):
+        logging.info("work_handler start print, filename:%s" % self.current_file.name)
+        # self.print_stats.note_start()
+        self.count_line = 0
+        self.count_G1 = 0 
+        self.eepromWriteCount = 1
+        gcode_move = self.printer.lookup_object('gcode_move', None)
+        delay_photography_switch, location, frame, interval, power_loss_switch = self.get_delay_photography_info()
+        bl24c16f = self.printer.lookup_object('bl24c16f') if "bl24c16f" in self.printer.objects and power_loss_switch else None
+        eepromState = True
+        try:
+            # 断电续打恢复
+            eepromState = self.restore_print(gcode_move, power_loss_switch, bl24c16f, eepromState)
+        except Exception as err:
+            self.print_stats.power_loss = 0
+            logging.exception("work_handler RESTORE_GCODE_STATE error: %s" % err)
+        # 记录打印的文件名
+        if power_loss_switch and bl24c16f and self.current_file:
+            gcode_move.recordPrintFileName(self.print_file_name_path, self.current_file.name)
         logging.info("Starting SD card print (position %d)", self.file_position)
         self.reactor.unregister_timer(self.work_timer)
         try:
@@ -230,11 +1206,38 @@ class VirtualSD:
         partial_input = ""
         lines = []
         error_message = None
+        # 判断是否运行热床调平
+        if self.run_bed_mesh_calibate:
+            self.run_bed_mesh_calibate = False
+            cmd = "BED_MESH_CALIBRATE_START_PRINT GCODE_FILE='%s'" % self.current_file.name
+            try:
+                # 当前目标温度大于热床调平时的默认温度时,用当前目标温度调平
+                custom_macro = self.printer.lookup_object('custom_macro')
+                heater_bed = self.printer.lookup_object('heater_bed').heater
+                target_temp = heater_bed.target_temp
+                default_bed_temp = custom_macro.default_bed_temp
+                if target_temp > default_bed_temp:
+                    cmd += " BED_TEMP=%s" % target_temp
+            except Exception as err:
+                logging.exception("run_bed_mesh_calibate error: %s" % err)
+            self.gcode.run_script(cmd)
+        # self.gcode.run_script("G90")
+        toolhead = self.printer.lookup_object('toolhead')
+        pause_resume = self.printer.lookup_object('pause_resume')
+        toolhead.extrude_below_min_temp_err_is_report = False
+        start_time = interval_start_time = self.reactor.monotonic()
+        self.last_layer = self.layer
         while not self.must_pause_work:
             if not lines:
                 # Read more data
                 try:
                     data = self.current_file.read(8192)
+                except UnicodeDecodeError as err:
+                    logging.exception(err)
+                    err_msg = '{"code": "key571", "msg": "File UnicodeDecodeError"}'
+                    self.gcode._respond_error(err_msg)
+                    self.gcode.run_script("CANCEL_PRINT")
+                    break
                 except:
                     logging.exception("virtual_sdcard read")
                     break
@@ -244,6 +1247,25 @@ class VirtualSD:
                     self.current_file = None
                     logging.info("Finished SD card print")
                     self.gcode.respond_raw("Done printing file")
+                    if os.path.exists(self.print_file_name_path):
+                        os.remove(self.print_file_name_path)
+                    if os.path.exists(self.gcode.exclude_object_info):
+                        os.remove(self.gcode.exclude_object_info)
+                    if power_loss_switch and bl24c16f:
+                        self.gcode.run_script("EEPROM_WRITE_BYTE ADDR=1 VAL=255")
+                    self.first_layer_stop = False
+                    self.print_first_layer = False
+                    self.count_M204 = 0
+                    self.layer = 0
+                    self.layer_count = 0
+                    self.fan_state = {}
+                    self.update_print_history_info(only_update_status=True, state="completed")
+                    if self.print_id and not self.end_print_state and os.path.exists("/tmp/camera_main"):
+                        reportInformation("key608", data={"print_id": self.print_id})
+                    self.reactor.pause(self.reactor.monotonic() + 0.3)
+                    reportInformation("key701", data=self.cur_print_data)
+                    self.cur_print_data = {}
+                    self.print_id = ""
                     break
                 lines = data.split('\n')
                 lines[0] = partial_input + lines[0]
@@ -258,19 +1280,53 @@ class VirtualSD:
             # Dispatch command
             self.cmd_from_sd = True
             line = lines.pop()
-            next_file_position = self.file_position + len(line) + 1
+            # next_file_position = self.file_position + len(line) + 1
+            next_file_position = self.file_position + len(line.encode('utf-8')) + 1
             self.next_file_position = next_file_position
+            end_time = interval_end_time = self.reactor.monotonic()
+            # 更新当前打印信息,已打印时间、剩余时间等, 断电续打开关开启的情况下才进行下面的判断
+            if power_loss_switch and self.count_line % 4999 == 0:
+                self.update_print_history_info()
             try:
-                self.gcode.run_script(line)
+                # 记录断电续打信息, 断电续打开关开启的情况下才进行下面的判断
+                start_time, end_time, interval_start_time, interval_end_time = self.record_power_loss_info(power_loss_switch, bl24c16f,eepromState, 
+                                                                                                           gcode_move, start_time, end_time, interval_start_time, interval_end_time)
+                # 判断line 是否为M106或者END_PRINT来做一些操作
+                line = self.judge_line_starts_with(line, power_loss_switch, bl24c16f)
+                # 判断line 记录层信息
+                self.record_layer_info(line, power_loss_switch)
+                # 根据情况进行首层暂停打印
+                self.first_floor_pause(line, toolhead)
+                # 将断电续打的慢速打印恢复到正常速度
+                if self.slow_print == True and self.layer > 0 and self.slow_count < self.layer:
+                    self.resume_print_speed()
+                # 在读到END_PRINT的时候 判断是否需要拍照
+                self.check_end_print(line, power_loss_switch, delay_photography_switch, frame)
+                if self.is_move_out_of_range_in_printing and pause_resume.pause_start == False:
+                    self.is_move_out_of_range_in_printing = False
+                    self.gcode.run_script_from_command("PAUSE")
+                    self.is_move_out_of_range_in_printing = False
+                else:
+                    self.gcode.run_script(line)
+                if power_loss_switch:
+                    self.count_line += 1
+                if self.count_G1 < 20 and line.startswith("G1"):
+                    self.count_G1 += 1
             except self.gcode.error as e:
                 error_message = str(e)
                 try:
                     self.gcode.run_script(self.on_error_gcode.render())
                 except:
                     logging.exception("virtual_sdcard on_error")
+                self.layer = 0
+                self.layer_count = 0
+                self.resume_print_speed()
                 break
             except:
                 logging.exception("virtual_sdcard dispatch")
+                self.layer = 0
+                self.layer_count = 0
+                self.resume_print_speed()
                 break
             self.cmd_from_sd = False
             self.file_position = self.next_file_position
@@ -285,12 +1341,20 @@ class VirtualSD:
                 lines = []
                 partial_input = ""
         logging.info("Exiting SD card print (position %d)", self.file_position)
+        self.count_line = 0
+        self.count_G1 = 0
+        self.do_resume_status = False
+        self.eepromWriteCount = 1
         self.work_timer = None
         self.cmd_from_sd = False
+        toolhead.extrude_below_min_temp_err_is_report = False
         if error_message is not None:
             self.print_stats.note_error(error_message)
         elif self.current_file is not None:
-            self.print_stats.note_pause()
+            if self.is_cancel:
+                self.print_stats.note_cancel()
+            else:
+                self.print_stats.note_pause()
         else:
             self.print_stats.note_complete()
         return self.reactor.NEVER
--- /dev/null
+++ b/klippy/extras/z_align.py
@@ -0,0 +1,257 @@
+import mcu, logging, os
+from extras.base_info import base_dir
+
+"""
+[z_align]
+quick_speed: 60 # mm/s  下降速度
+slow_speed: 20 # mm/s  探测速度
+rising_dist: 20 # mm  首次探测到光电后的上升距离
+filter_cnt: 10 # 连续触发限位的次数，用作滤波
+timeout: 30 # s 单次探测超时时间
+retries: 5 # 重试次数
+retry_tolerance: 10  # 两个光电的调整允许的最大偏差 10步 步距是0.0025mm
+endstop_pin_z: PA15  # 光电触发
+endstop_pin_z1: PA8  # 光电触发
+zd_up: 0  # 步进电机远离限位开关的电平
+zes_untrig: 1  # 限位开关未触发时的电平
+"""
+
+MOTOR_PROTECT_ERROR = -10001
+
+class CommandError(Exception):
+    pass
+
+class Zalign:
+    error = CommandError
+    def __init__(self, config):
+        self.config = config
+        self.printer = config.get_printer()
+        self.full_steps_pre_rev = 200
+        self.distance_ratio = self.config.getsection('z_align').getfloat('distance_ratio')
+        self.quickSpeed = self.config.getsection('z_align').getint('quick_speed')
+        self.slowSpeed = self.config.getsection('z_align').getint('slow_speed')
+        self.risingDist = self.config.getsection('z_align').getint('rising_dist')
+        self.safeDist = self.config.getsection('z_align').getint('safe_dist')
+        self.filterCnt = self.config.getsection('z_align').getint('filter_cnt')
+        self.timeout = self.config.getsection('z_align').getint('timeout')
+        self.retries = self.config.getsection('z_align').getint('retries')
+        self.retry_tolerance = self.config.getsection('z_align').getint('retry_tolerance')
+        self.endstop_pin_z = self.config.getsection('z_align').getlist('endstop_pin_z')     
+        self.zd_up = self.config.getsection('z_align').getint('zd_up')
+        self.zes_untrig = self.config.getsection('z_align').getint('zes_untrig')
+        self.zmax_safe_pox_diff = self.config.getsection('z_align').getint('zmax_safe_pox_diff')
+        self.mcu = mcu.get_printer_mcu(self.printer, "mcu")
+        self.oidz = self.mcu.create_oid()
+        self.mcu.register_config_callback(self._build_config)
+        self.cur_retries = 0
+        self.gcode = config.get_printer().lookup_object('gcode')
+        self.gcode.register_command("GET_MAX_Z", self.cmd_GET_MAX_Z)
+        self.gcode.register_command("ZDOWN", self.cmd_ZDOWN)
+        self.gcode.register_command("ZDOWN_SWITCH", self.cmd_ZDOWN_SWITCH)
+        self.gcode.register_command("ZDOWN_FORCE_STOP", self.cmd_ZDOWN_FORCE_STOP)
+        self.zdown_switch_enable = 0
+        self.z_align_force_stop = None
+        self.force_stop_flag = False
+        self.is_already_zodwn = False
+        webhooks = self.printer.lookup_object('webhooks')
+        webhooks.register_endpoint("zdown_force_stop", self.zdown_force_stop)
+        self.real_zmax_path = os.path.join(base_dir, "creality/userdata/config/real_zmax.json")
+    def zdown_force_stop(self, web_request):
+        self.force_stop_flag = True
+        self.gcode.respond_info("zdown_force_stop start")
+        self.z_align_force_stop.send([self.oidz])
+        self.gcode.respond_info("zdown_force_stop end")
+        web_request.send({"result": "success"})
+    def _build_config(self):  
+        config_z_align = "config_z_align oid=%d"%self.oidz
+        logging.info(config_z_align)
+        self.mcu.add_config_cmd(config_z_align)
+        for stepper_indx_z, endstop_pin in enumerate(self.endstop_pin_z):
+            step_pin_z = self.config.getsection(f'stepper_z{stepper_indx_z}' if stepper_indx_z > 0 else 'stepper_z').get('step_pin')
+            dir_pin_z = self.config.getsection(f'stepper_z{stepper_indx_z}' if stepper_indx_z > 0 else 'stepper_z').get('dir_pin')
+            # 如果遇到step_dir是取反值，需要将取反去掉，否则下位机无法识别，并且修改zd_up配置，使Z电机正常方向运动
+            if dir_pin_z.startswith('!'):
+                dir_pin_z = dir_pin_z[1:]
+            config_z_align_add_z = "config_z_align_add oid=%d z_indx=%d zs_pin=%s" \
+                                    " zd_pin=%s zd_up=%d zes_pin=%s zes_untrig=%d" % (
+                                        self.oidz, stepper_indx_z, step_pin_z, dir_pin_z, self.zd_up, endstop_pin, self.zes_untrig)
+            self.mcu.add_config_cmd(config_z_align_add_z)
+            logging.info("[stepper_indx_z=%d] config_z_align_add oid=%d z_indx=%d zs_pin=%s zd_pin=%s zd_up=%d zes_pin=%s zes_untrig=%d" % (
+                stepper_indx_z, self.oidz, stepper_indx_z, step_pin_z, dir_pin_z, self.zd_up, endstop_pin, self.zes_untrig))
+        self.z_align_force_stop = self.mcu.lookup_command("z_align_force_stop oid=%c", cq=None)
+    def get_real_zmax_path(self):
+        return self.real_zmax_path
+    def cmd_ZDOWN_FORCE_STOP(self, gcmd):
+        self.force_stop_flag = True
+        self.gcode.respond_info("zdown_force_stop start")
+        self.z_align_force_stop.send([self.oidz])
+        self.gcode.respond_info("zdown_force_stop end")
+    def cmd_ZDOWN_SWITCH(self, gcmd):
+        self.zdown_switch_enable = gcmd.get_int('ENABLE', default=1)
+    def cmd_GET_MAX_Z(self, gcmd):
+        self.gcode.run_script_from_command("BED_MESH_CLEAR")
+        query_finetuning = self.mcu.lookup_query_command("query_finetuning oid=%c enable=%c speed=%u maxDist=%u filterCnt=%c",
+                                                      "finetuning_status oid=%c flag=%i steps=%u", oid=self.oidz)
+        rotation_distance = self.config.getsection('stepper_z').getfloat('rotation_distance')  # 8
+        microsteps = self.config.getsection('stepper_z').getfloat('microsteps')  # 16
+
+        mcu_freq = self.mcu._serial.msgparser.get_constant_float('CLOCK_FREQ')
+        subdivision = self.full_steps_pre_rev*microsteps # 200*16 = 3200
+        step_distance = rotation_distance/subdivision # 8/3200 = 0.0025mm
+        quickSpeedTicks = int(1/(self.quickSpeed/step_distance)*mcu_freq/2) # 除以2才和klipper的速度一致
+        enable = 1
+        maxDist = int(360/8 * 200 * 16 * 2) # 乘以2才和klipper的步数一致 steps = position_max/rotation_distance  * 200 * microsteps
+        self.filterCnt
+        self.gcode.run_script_from_command("M84")
+        self.gcode.run_script_from_command("G28")
+        self.gcode.run_script_from_command("G4 P3000")
+        query_finetuning.send([self.oidz, enable, quickSpeedTicks, maxDist, self.filterCnt])
+        gcode_move = self.printer.lookup_object('gcode_move')
+        cur_z_pos = gcode_move.last_position[2]
+        reactor = self.printer.get_reactor()
+        self.mcu._serial.finetuning_status = {}
+        curtime = reactor.monotonic()
+        steps = 0
+        while True:
+            self.gcode.respond_info(str(self.mcu._serial.finetuning_status))
+            nowtime = reactor.monotonic()
+            usetime = nowtime-curtime
+            flag = self.mcu._serial.finetuning_status.get("flag", 0)
+            if flag == 1:
+                steps = int(self.mcu._serial.finetuning_status.get("steps", 0))
+                break
+            elif flag == 2:
+                self.gcode.respond_info("finetuning_status mcu timeout")
+                break
+            elif usetime > self.timeout:
+                self.gcode.respond_info("finetuning_status 30s timeout")
+                break
+            reactor.pause(reactor.monotonic() + 1.0)
+        self.gcode.respond_info("finetuning_status result: %s+%s=%s" % (cur_z_pos, steps*0.0025/2, steps*0.0025/2+5))
+        toolhead = self.printer.lookup_object('toolhead')
+        now_pos = toolhead.get_position()
+        now_pos[2] = self.config.getsection('stepper_z').getfloat('position_max')
+        toolhead.set_position(now_pos, homing_axes=(2,))
+        now_pos = toolhead.get_position()
+        toolhead.set_position(now_pos, homing_axes=(2,))
+        now_pos[2] = now_pos[2] - 306
+        gcmd = 'G1 F%d X%.3f Y%.3f Z%.3f' % (30 * 60, now_pos[0], now_pos[1], now_pos[2])
+        self.gcode.run_script_from_command(gcmd)
+        self.gcode.run_script_from_command("G28 Z")
+
+    def cmd_ZDOWN(self, gcmd):
+        self.gcode.run_script_from_command("RESTORE_Z_LIMIT")
+        self.gcode.run_script_from_command("BED_MESH_CLEAR")
+        reactor = self.printer.get_reactor()
+        query_z_align = self.mcu.lookup_query_command("query_z_align oid=%c enable=%c quickSpeed=%u slowSpeed=%u risingDist=%u filterCnt=%c safeDist=%u",
+                                                      "z_align_status oid=%c flag=%i deltaError1=%i", oid=self.oidz)
+
+        rotation_distance = self.config.getsection('stepper_z').getfloat('rotation_distance')  # 8
+        microsteps = self.config.getsection('stepper_z').getfloat('microsteps')  # 16
+
+        mcu_freq = self.mcu._serial.msgparser.get_constant_float('CLOCK_FREQ')
+        subdivision = self.full_steps_pre_rev*microsteps # 200*16 = 3200
+        step_distance = rotation_distance/subdivision # 8/3200 = 0.0025mm
+        quickSpeedTicks = int(1/(self.quickSpeed/step_distance)*mcu_freq/2) # 除以2才和klipper的速度一致
+        slowSpeedTicks = int(1/(self.slowSpeed/step_distance)*mcu_freq/2) # 除以2才和klipper的速度一致
+        risingDistStep = int(self.risingDist/step_distance)*2 # 乘2才和klipper的步数一致
+        safeDistStep = int(self.safeDist/step_distance)*2
+        enable = 1
+        def run_cmd(cur_retries):
+            deltaError = 0
+            msg = "send query_z_align cur_retries:%s oid=%d enable=%d quickSpeed=%s slowSpeed=%s risingDist=%s filterCnt:%s safeDist:%s"%(cur_retries, self.oidz, enable, quickSpeedTicks, slowSpeedTicks, risingDistStep, self.filterCnt, safeDistStep)
+            params = query_z_align.send([self.oidz, enable, quickSpeedTicks, slowSpeedTicks, risingDistStep, self.filterCnt, safeDistStep])
+            # {'oid': 1, 'flag': 0, 'deltaError1': 5, '#name': 'z_align_status', '#sent_time': 49.895344040666664, '#receive_time': 49.995911207}
+            self.gcode.respond_info(msg)
+            curtime = reactor.monotonic()
+            reactor.pause(reactor.monotonic() + 1.0)
+            while True:
+                nowtime = reactor.monotonic()
+                usetime = nowtime-curtime
+                if self.force_stop_flag:
+                    self.force_stop_flag = False
+                    return MOTOR_PROTECT_ERROR
+                if usetime > self.timeout:
+                    self.gcode._respond_error("""{"code":"key351", "msg":"z_align ZDOWN timeout:%ss result: %s", "values":[]}"""%(self.timeout, str(self.mcu._serial.z_align_status)))
+                    return -10000
+                if self.mcu._serial.z_align_status.get("flag", 0) == 1:
+                    self.gcode.respond_info("usetime:%s z_align_status :%s"%(usetime, str(self.mcu._serial.z_align_status)))
+                    deltaError = int(self.mcu._serial.z_align_status.get("deltaError1", 0))
+                    break
+                elif self.mcu._serial.z_align_status.get("flag", 0) == 2:
+                    self.gcode._respond_error("""{"code":"key357", "msg":"光电开关状态异常或者是热床过于倾斜", "values":[]}""")
+                    reactor.pause(reactor.monotonic() + 5.0)
+                    return MOTOR_PROTECT_ERROR
+                reactor.pause(reactor.monotonic() + 0.1)
+            return deltaError
+        toolhead = self.printer.lookup_object('toolhead')
+        now_pos = toolhead.get_position()
+        toolhead.set_position(now_pos, homing_axes=(2,))
+        for stepper_indx_z in range(len(self.endstop_pin_z)):
+            stepper_name = f"stepper_z{stepper_indx_z}" if stepper_indx_z > 0 else "stepper_z"
+            self.gcode.run_script_from_command(f"SET_STEPPER_ENABLE STEPPER={stepper_name} ENABLE=1")
+        self.cur_retries = 0
+        while True:
+            if self.cur_retries < self.retries:
+                deltaError = run_cmd(self.cur_retries)
+            else:
+                self.gcode._respond_error("""{"code":"key352", "msg":"z_align ZDOWN too many retries: %s, deltaError:%s retry_tolerance:%s", "values":[]}"""%(deltaError, self.retry_tolerance, str(self.retries)))
+                break
+            if deltaError == -10000:
+                # timeout 
+                toolhead = self.printer.lookup_object('toolhead')
+                now_pos = toolhead.get_position()
+                toolhead.set_position(now_pos, homing_axes=(0,1,2))
+                gcmd = 'G1 F%d X%.3f Y%.3f Z%.3f' % (1000, now_pos[0]+0.001, now_pos[1], now_pos[2])
+                self.gcode.run_script_from_command(gcmd)
+                self.gcode.run_script_from_command("M84")
+                break
+            elif deltaError == MOTOR_PROTECT_ERROR:
+                self.gcode.run_script_from_command("M84")
+                self.gcode.respond_info("zdown_force_stop success")
+                return MOTOR_PROTECT_ERROR
+            if abs(deltaError) < self.retry_tolerance:
+                self.gcode.respond_info("ZDOWN end")
+                break
+            self.cur_retries += 1
+        if toolhead.G29_flag == False:
+            offset_value = 0
+            now_pos = toolhead.get_position()
+            real_zmax = self.read_real_zmax()
+            za = real_zmax + offset_value
+            # 在恢复双Z校准值前,先恢复设置Z轴最大高度值
+            toolhead.set_position([now_pos[0], now_pos[1], za, now_pos[3]], homing_axes=(2,))
+            logging.info("ZDOWN G29_flag is Fasle, real_zmax:%s offset_value:%s za:%s now_pos:%s" % (real_zmax, offset_value, za,str(now_pos)))
+            self.gcode.run_script_from_command("G91\nG1 Z-10 F600\nG90")
+            self.gcode.run_script_from_command("M400")
+            self.gcode.run_script_from_command("ADJUST_STEPPERS")
+            self.gcode.run_script_from_command("M400")
+            now_pos = toolhead.get_position()
+            logging.info("ZDOWN G29_flag is Fasle, after ADJUST_STEPPERS now_pos:%s"%str(now_pos))
+        else:
+            self.gcode.run_script_from_command("M400")
+            toolhead = self.printer.lookup_object('toolhead')
+            now_pos = toolhead.get_position()
+            now_pos[2] = self.config.getsection('stepper_z').getfloat('position_max')
+            toolhead.set_position(now_pos, homing_axes=(2,))
+            logging.info("ZDOWN G29_flag is True, set zmax:%s" % str(now_pos))
+        return 0
+
+    def read_real_zmax(self):
+        import os,json
+        max_z = self.config.getsection('stepper_z').getfloat('position_max', default=360)
+        logging.info("stepper_z position_max:%s" % max_z)
+        data = max_z - 10
+        if os.path.exists(self.real_zmax_path):
+            try:
+                with open(self.real_zmax_path, "r") as f:
+                    data = json.loads(f.read()).get("zmax", 0)
+                    if data > max_z:
+                        data = max_z - 10
+            except Exception as err:
+                logging.error(err)
+        self.gcode.respond_info("real_zmax:%s"%data)
+        return data  
+
+def load_config(config):
+    return Zalign(config)
--- a/klippy/extras/z_tilt.py
+++ b/klippy/extras/z_tilt.py
@@ -1,179 +1,238 @@
-# Mechanical bed tilt calibration with multiple Z steppers
-#
-# Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-import mathutil
-from . import probe
-
-class ZAdjustHelper:
-    def __init__(self, config, z_count):
-        self.printer = config.get_printer()
-        self.name = config.get_name()
-        self.z_count = z_count
-        self.z_steppers = []
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-    def handle_connect(self):
-        kin = self.printer.lookup_object('toolhead').get_kinematics()
-        z_steppers = [s for s in kin.get_steppers() if s.is_active_axis('z')]
-        if len(z_steppers) != self.z_count:
-            raise self.printer.config_error(
-                "%s z_positions needs exactly %d items" % (
-                    self.name, len(z_steppers)))
-        if len(z_steppers) < 2:
-            raise self.printer.config_error(
-                "%s requires multiple z steppers" % (self.name,))
-        self.z_steppers = z_steppers
-    def adjust_steppers(self, adjustments, speed):
-        toolhead = self.printer.lookup_object('toolhead')
-        gcode = self.printer.lookup_object('gcode')
-        curpos = toolhead.get_position()
-        # Report on movements
-        stepstrs = ["%s = %.6f" % (s.get_name(), a)
-                    for s, a in zip(self.z_steppers, adjustments)]
-        msg = "Making the following Z adjustments:\n%s" % ("\n".join(stepstrs),)
-        gcode.respond_info(msg)
-        # Disable Z stepper movements
-        toolhead.flush_step_generation()
-        for s in self.z_steppers:
-            s.set_trapq(None)
-        # Move each z stepper (sorted from lowest to highest) until they match
-        positions = [(-a, s) for a, s in zip(adjustments, self.z_steppers)]
-        positions.sort()
-        first_stepper_offset, first_stepper = positions[0]
-        z_low = curpos[2] - first_stepper_offset
-        for i in range(len(positions)-1):
-            stepper_offset, stepper = positions[i]
-            next_stepper_offset, next_stepper = positions[i+1]
-            toolhead.flush_step_generation()
-            stepper.set_trapq(toolhead.get_trapq())
-            curpos[2] = z_low + next_stepper_offset
-            try:
-                toolhead.move(curpos, speed)
-                toolhead.set_position(curpos)
-            except:
-                logging.exception("ZAdjustHelper adjust_steppers")
-                toolhead.flush_step_generation()
-                for s in self.z_steppers:
-                    s.set_trapq(toolhead.get_trapq())
-                raise
-        # Z should now be level - do final cleanup
-        last_stepper_offset, last_stepper = positions[-1]
-        toolhead.flush_step_generation()
-        last_stepper.set_trapq(toolhead.get_trapq())
-        curpos[2] += first_stepper_offset
-        toolhead.set_position(curpos)
-
-class ZAdjustStatus:
-    def __init__(self, printer):
-        self.applied = False
-        printer.register_event_handler("stepper_enable:motor_off",
-                                        self._motor_off)
-    def check_retry_result(self, retry_result):
-        if retry_result == "done":
-            self.applied = True
-        return retry_result
-    def reset(self):
-        self.applied = False
-    def get_status(self, eventtime):
-        return {'applied': self.applied}
-    def _motor_off(self, print_time):
-        self.reset()
-
-class RetryHelper:
-    def __init__(self, config, error_msg_extra = ""):
-        self.gcode = config.get_printer().lookup_object('gcode')
-        self.default_max_retries = config.getint("retries", 0, minval=0)
-        self.default_retry_tolerance = \
-            config.getfloat("retry_tolerance", 0., above=0.)
-        self.value_label = "Probed points range"
-        self.error_msg_extra = error_msg_extra
-    def start(self, gcmd):
-        self.max_retries = gcmd.get_int('RETRIES', self.default_max_retries,
-                                        minval=0, maxval=30)
-        self.retry_tolerance = gcmd.get_float('RETRY_TOLERANCE',
-                                              self.default_retry_tolerance,
-                                              minval=0.0, maxval=1.0)
-        self.current_retry = 0
-        self.previous = None
-        self.increasing = 0
-    def check_increase(self, error):
-        if self.previous and error > self.previous + 0.0000001:
-            self.increasing += 1
-        elif self.increasing > 0:
-            self.increasing -= 1
-        self.previous = error
-        return self.increasing > 1
-    def check_retry(self, z_positions):
-        if self.max_retries == 0:
-            return
-        error = round(max(z_positions) - min(z_positions),6)
-        self.gcode.respond_info(
-            "Retries: %d/%d %s: %0.6f tolerance: %0.6f" % (
-                self.current_retry, self.max_retries, self.value_label,
-                error, self.retry_tolerance))
-        if self.check_increase(error):
-            raise self.gcode.error("Retries aborting: %s is increasing. %s"
-                                   % (self.value_label, self.error_msg_extra))
-        if error <= self.retry_tolerance:
-            return "done"
-        self.current_retry += 1
-        if self.current_retry > self.max_retries:
-            raise self.gcode.error("Too many retries")
-        return "retry"
-
-class ZTilt:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.z_positions = config.getlists('z_positions', seps=(',', '\n'),
-                                           parser=float, count=2)
-        self.retry_helper = RetryHelper(config)
-        self.probe_helper = probe.ProbePointsHelper(config, self.probe_finalize)
-        self.probe_helper.minimum_points(2)
-        self.z_status = ZAdjustStatus(self.printer)
-        self.z_helper = ZAdjustHelper(config, len(self.z_positions))
-        # Register Z_TILT_ADJUST command
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_command('Z_TILT_ADJUST', self.cmd_Z_TILT_ADJUST,
-                               desc=self.cmd_Z_TILT_ADJUST_help)
-    cmd_Z_TILT_ADJUST_help = "Adjust the Z tilt"
-    def cmd_Z_TILT_ADJUST(self, gcmd):
-        self.z_status.reset()
-        self.retry_helper.start(gcmd)
-        self.probe_helper.start_probe(gcmd)
-    def probe_finalize(self, offsets, positions):
-        # Setup for coordinate descent analysis
-        z_offset = offsets[2]
-        logging.info("Calculating bed tilt with: %s", positions)
-        params = { 'x_adjust': 0., 'y_adjust': 0., 'z_adjust': z_offset }
-        # Perform coordinate descent
-        def adjusted_height(pos, params):
-            x, y, z = pos
-            return (z - x*params['x_adjust'] - y*params['y_adjust']
-                    - params['z_adjust'])
-        def errorfunc(params):
-            total_error = 0.
-            for pos in positions:
-                total_error += adjusted_height(pos, params)**2
-            return total_error
-        new_params = mathutil.coordinate_descent(
-            params.keys(), params, errorfunc)
-        # Apply results
-        speed = self.probe_helper.get_lift_speed()
-        logging.info("Calculated bed tilt parameters: %s", new_params)
-        x_adjust = new_params['x_adjust']
-        y_adjust = new_params['y_adjust']
-        z_adjust = (new_params['z_adjust'] - z_offset
-                    - x_adjust * offsets[0] - y_adjust * offsets[1])
-        adjustments = [x*x_adjust + y*y_adjust + z_adjust
-                       for x, y in self.z_positions]
-        self.z_helper.adjust_steppers(adjustments, speed)
-        return self.z_status.check_retry_result(
-            self.retry_helper.check_retry([p[2] for p in positions]))
-    def get_status(self, eventtime):
-            return self.z_status.get_status(eventtime)
-
-def load_config(config):
-    return ZTilt(config)
+# Mechanical bed tilt calibration with multiple Z steppers
+#
+# Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
+#
+# This file may be distributed under the terms of the GNU GPLv3 license.
+import logging, os
+import mathutil
+from . import probe
+from extras.base_info import base_dir
+
+class ZAdjustHelper:
+    def __init__(self, config, z_count):
+        self.printer = config.get_printer()
+        self.name = config.get_name()
+        self.z_count = z_count
+        self.z_steppers = []
+        self.printer.register_event_handler("klippy:connect",
+                                            self.handle_connect)
+    def handle_connect(self):
+        kin = self.printer.lookup_object('toolhead').get_kinematics()
+        z_steppers = [s for s in kin.get_steppers() if s.is_active_axis('z')]
+        if len(z_steppers) != self.z_count:
+            err_msg = """{"code":"key346", "msg":"%s z_positions needs exactly %d items", "values":[]}""" % (self.name, len(z_steppers))
+            raise self.printer.config_error(err_msg)
+        if len(z_steppers) < 2:
+            err_msg = """{"code":"key347", "msg":"%s requires multiple z steppers", "values":[]}""" % self.name
+            raise self.printer.config_error(err_msg)
+        self.z_steppers = z_steppers
+    def adjust_steppers(self, adjustments, speed):
+        toolhead = self.printer.lookup_object('toolhead')
+        gcode = self.printer.lookup_object('gcode')
+        curpos = toolhead.get_position()
+        # Report on movements
+        stepstrs = ["%s = %.6f" % (s.get_name(), a)
+                    for s, a in zip(self.z_steppers, adjustments)]
+        msg = "Making the following Z adjustments:\n%s" % ("\n".join(stepstrs),)
+        gcode.respond_info(msg)
+        z_tilt = self.printer.lookup_object('z_tilt')
+        for s, a in zip(self.z_steppers, adjustments):
+            if s.get_name() == "stepper_z":
+                z_tilt.stepper_z_adjustment += a
+            elif s.get_name() == "stepper_z1":
+                z_tilt.stepper_z1_adjustment += a
+        gcode.respond_info("stepper_z_adjustment:%s stepper_z1_adjustment:%s"%(z_tilt.stepper_z_adjustment,z_tilt.stepper_z1_adjustment))
+        # Disable Z stepper movements
+        toolhead.flush_step_generation()
+        for s in self.z_steppers:
+            s.set_trapq(None)
+        # Move each z stepper (sorted from lowest to highest) until they match
+        positions = [(-a, s) for a, s in zip(adjustments, self.z_steppers)]
+        positions.sort(key=(lambda k: k[0]))
+        first_stepper_offset, first_stepper = positions[0]
+        z_low = curpos[2] - first_stepper_offset
+        for i in range(len(positions)-1):
+            stepper_offset, stepper = positions[i]
+            next_stepper_offset, next_stepper = positions[i+1]
+            toolhead.flush_step_generation()
+            stepper.set_trapq(toolhead.get_trapq())
+            curpos[2] = z_low + next_stepper_offset
+            try:
+                toolhead.move(curpos, speed)
+                toolhead.set_position(curpos)
+            except Exception as err:
+                logging.exception("ZAdjustHelper adjust_steppers")
+                toolhead.flush_step_generation()
+                for s in self.z_steppers:
+                    s.set_trapq(toolhead.get_trapq())
+                err_msg = """{"code":"key348", "msg":"toolhead.move(%s, %s) ZAdjustHelper adjust_steppers error:%s", "values":[]}""" % (str(curpos), speed, str(err))
+                raise gcode.error(err_msg)
+        # Z should now be level - do final cleanup
+        last_stepper_offset, last_stepper = positions[-1]
+        toolhead.flush_step_generation()
+        last_stepper.set_trapq(toolhead.get_trapq())
+        curpos[2] += first_stepper_offset
+        toolhead.set_position(curpos)
+
+class ZAdjustStatus:
+    def __init__(self, printer):
+        self.applied = False
+        printer.register_event_handler("stepper_enable:motor_off",
+                                        self._motor_off)
+    def check_retry_result(self, retry_result):
+        if retry_result == "done":
+            self.applied = True
+        return retry_result
+    def reset(self):
+        self.applied = False
+    def get_status(self, eventtime):
+        return {'applied': self.applied}
+    def _motor_off(self, print_time):
+        self.reset()
+
+class RetryHelper:
+    def __init__(self, config, error_msg_extra = ""):
+        self.printer = config.get_printer()
+        self.gcode = config.get_printer().lookup_object('gcode')
+        self.default_max_retries = config.getint("retries", 0, minval=0)
+        self.default_retry_tolerance = \
+            config.getfloat("retry_tolerance", 0., above=0.)
+        self.value_label = "Probed points range"
+        self.error_msg_extra = error_msg_extra
+    def start(self, gcmd):
+        self.max_retries = gcmd.get_int('RETRIES', self.default_max_retries,
+                                        minval=0, maxval=30)
+        self.retry_tolerance = gcmd.get_float('RETRY_TOLERANCE',
+                                              self.default_retry_tolerance,
+                                              minval=0.0, maxval=1.0)
+        self.current_retry = 0
+        self.previous = None
+        self.increasing = 0
+    def check_increase(self, error):
+        if self.previous and error > self.previous + 0.0000001:
+            self.increasing += 1
+        elif self.increasing > 0:
+            self.increasing -= 1
+        self.previous = error
+        return self.increasing > 1
+    def check_retry(self, z_positions):
+        if self.max_retries == 0:
+            return
+        error = round(max(z_positions) - min(z_positions),6)
+        self.gcode.respond_info(
+            "Retries: %d/%d %s: %0.6f tolerance: %0.6f" % (
+                self.current_retry, self.max_retries, self.value_label,
+                error, self.retry_tolerance))
+        if self.check_increase(error):
+            err_msg = """{"code":"key349", "msg":"Retries aborting: %s is increasing. %s", "values":[]}""" % (self.value_label, self.error_msg_extra)
+            raise self.gcode.error(err_msg)
+        if error <= self.retry_tolerance:
+            toolhead = self.printer.lookup_object('toolhead')
+            if toolhead.G29_flag == True:
+                self.write_z_adjustment()
+            return "done"
+        self.current_retry += 1
+        if self.current_retry > self.max_retries:
+            err_msg = """{"code":"key350", "msg":"Too many retries", "values":[]}"""
+            raise self.gcode.error(err_msg)
+        return "retry"
+    def write_z_adjustment(self):
+        import json
+        z_tilt = self.printer.lookup_object('z_tilt')
+        with open(z_tilt.stepper_adjustment_path, "w") as f:
+            f.write(json.dumps({"stepper_z_adjustment": z_tilt.stepper_z_adjustment, "stepper_z1_adjustment": z_tilt.stepper_z1_adjustment}))
+            f.flush()
+
+class ZTilt:
+    def __init__(self, config):
+        self.printer = config.get_printer()
+        self.z_positions = config.getlists('z_positions', seps=(',', '\n'),
+                                           parser=float, count=2)
+        self.retry_helper = RetryHelper(config)
+        self.probe_helper = probe.ProbePointsHelper(config, self.probe_finalize)
+        self.probe_helper.minimum_points(2)
+        self.z_status = ZAdjustStatus(self.printer)
+        self.z_helper = ZAdjustHelper(config, len(self.z_positions))
+        # Register Z_TILT_ADJUST command
+        gcode = self.printer.lookup_object('gcode')
+        gcode.register_command('Z_TILT_ADJUST', self.cmd_Z_TILT_ADJUST,
+                               desc=self.cmd_Z_TILT_ADJUST_help)
+        gcode.register_command('ADJUST_STEPPERS', self.cmd_ADJUST_STEPPERS)
+        gcode.register_command('RM_ADJUSTMENT_FILE', self.cmd_RM_ADJUSTMENT_FILE)
+        self.stepper_z_adjustment = 0
+        self.stepper_z1_adjustment = 0
+        self.stepper_adjustment_path = os.path.join(base_dir, "creality/userdata/config/stepper_adjustment.json")
+        self.real_zmax_path = os.path.join(base_dir, "creality/userdata/config/real_zmax.json")
+    cmd_Z_TILT_ADJUST_help = "Adjust the Z tilt"
+    def cmd_Z_TILT_ADJUST(self, gcmd):
+        self.stepper_z_adjustment = 0
+        self.stepper_z1_adjustment = 0
+        # if os.path.exists(self.stepper_adjustment_path):
+        #     os.remove(self.stepper_adjustment_path) 
+        self.z_status.reset()
+        self.retry_helper.start(gcmd)
+        self.probe_helper.start_probe(gcmd)
+    def cmd_RM_ADJUSTMENT_FILE(self, gcmd):
+        if os.path.exists(self.stepper_adjustment_path):
+            os.remove(self.stepper_adjustment_path)  
+    def cmd_ADJUST_STEPPERS(self, gcmd):
+        self.stepper_z_adjustment = 0
+        self.stepper_z1_adjustment = 0
+        adjustments = self.get_adjustments()
+        speed = self.probe_helper.get_lift_speed()
+        if adjustments:
+            self.printer.lookup_object('gcode').run_script_from_command("G4 P200")
+            self.z_helper.adjust_steppers(adjustments, speed)       
+            self.printer.lookup_object('gcode').run_script_from_command("G4 P500")
+    def get_adjustments(self):
+        import json
+        # 默认一个不可能的值
+        stepper_z_adjustment = -10
+        stepper_z1_adjustment = -10
+        if os.path.exists(self.stepper_adjustment_path):
+            result = {}
+            with open(self.stepper_adjustment_path, "r") as f:
+                try:
+                    result = json.loads(f.read())
+                    stepper_z_adjustment = result.get("stepper_z_adjustment", -10)
+                    stepper_z1_adjustment = result.get("stepper_z1_adjustment", -10)
+                except Exception as err:
+                    logging.exception(err)
+        if stepper_z_adjustment != -10 and stepper_z1_adjustment != -10:
+            return [stepper_z_adjustment, stepper_z1_adjustment]
+        return None
+
+    def probe_finalize(self, offsets, positions):
+        # Setup for coordinate descent analysis
+        z_offset = offsets[2]
+        logging.info("Calculating bed tilt with: %s", positions)
+        params = { 'x_adjust': 0., 'y_adjust': 0., 'z_adjust': z_offset }
+        # Perform coordinate descent
+        def adjusted_height(pos, params):
+            x, y, z = pos
+            return (z - x*params['x_adjust'] - y*params['y_adjust']
+                    - params['z_adjust'])
+        def errorfunc(params):
+            total_error = 0.
+            for pos in positions:
+                total_error += adjusted_height(pos, params)**2
+            return total_error
+        new_params = mathutil.coordinate_descent(
+            params.keys(), params, errorfunc)
+        # Apply results
+        speed = self.probe_helper.get_lift_speed()
+        logging.info("Calculated bed tilt parameters: %s", new_params)
+        x_adjust = new_params['x_adjust']
+        y_adjust = new_params['y_adjust']
+        z_adjust = (new_params['z_adjust'] - z_offset
+                    - x_adjust * offsets[0] - y_adjust * offsets[1])
+        adjustments = [x*x_adjust + y*y_adjust + z_adjust
+                       for x, y in self.z_positions]
+        self.z_helper.adjust_steppers(adjustments, speed)
+        return self.z_status.check_retry_result(
+            self.retry_helper.check_retry([p[2] for p in positions]))
+    def get_status(self, eventtime):
+            return self.z_status.get_status(eventtime)
+
+def load_config(config):
+    return ZTilt(config)
--- a/klippy/gcode.py
+++ b/klippy/gcode.py
@@ -4,7 +4,11 @@
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import os, re, logging, collections, shlex
-
+import time
+from extras.tool import reportInformation
+from extras.base_info import base_dir
+import cProfile
+import pstats
 class CommandError(Exception):
     pass
 
@@ -106,6 +110,7 @@ class GCodeDispatch:
         self.ready_gcode_handlers = {}
         self.mux_commands = {}
         self.gcode_help = {}
+        self.gcode_move=None
         # Register commands needed before config file is loaded
         handlers = ['M110', 'M112', 'M115',
                     'RESTART', 'FIRMWARE_RESTART', 'ECHO', 'STATUS', 'HELP']
@@ -113,6 +118,8 @@ class GCodeDispatch:
             func = getattr(self, 'cmd_' + cmd)
             desc = getattr(self, 'cmd_' + cmd + '_help', None)
             self.register_command(cmd, func, True, desc)
+        self.last_temperature_info = os.path.join(base_dir, "creality/userdata/config/temperature_info.json")
+        self.exclude_object_info = os.path.join(base_dir, "creality/userdata/config/exclude_object_info.json")
     def is_traditional_gcode(self, cmd):
         # A "traditional" g-code command is a letter and followed by a number
         try:
@@ -173,44 +180,159 @@ class GCodeDispatch:
         self.gcode_handlers = self.ready_gcode_handlers
         self._respond_state("Ready")
     # Parse input into commands
+    def is_digit_or_delimiter(self,c):
+        if '0' <= c <= '9':
+            return True
+        if c in '=+-.':
+            return True
+        return False
+    def split_param(self, param):
+        for i, char in enumerate(param):
+            if self.is_digit_or_delimiter(char):
+                return param[:i], param[i:]
+        return param, ''
     args_r = re.compile('([A-Z_]+|[A-Z*/])')
     def _process_commands(self, commands, need_ack=True):
         for line in commands:
-            # Ignore comments and leading/trailing spaces
-            line = origline = line.strip()
-            cpos = line.find(';')
-            if cpos >= 0:
-                line = line[:cpos]
-            # Break line into parts and determine command
-            parts = self.args_r.split(line.upper())
-            numparts = len(parts)
-            cmd = ""
-            if numparts >= 3 and parts[1] != 'N':
-                cmd = parts[1] + parts[2].strip()
-            elif numparts >= 5 and parts[1] == 'N':
-                # Skip line number at start of command
-                cmd = parts[3] + parts[4].strip()
-            # Build gcode "params" dictionary
-            params = { parts[i]: parts[i+1].strip()
-                       for i in range(1, numparts, 2) }
-            gcmd = GCodeCommand(self, cmd, origline, params, need_ack)
-            # Invoke handler for command
-            handler = self.gcode_handlers.get(cmd, self.cmd_default)
-            try:
-                handler(gcmd)
-            except self.error as e:
-                self._respond_error(str(e))
-                self.printer.send_event("gcode:command_error")
-                if not need_ack:
-                    raise
-            except:
-                msg = 'Internal error on command:"%s"' % (cmd,)
-                logging.exception(msg)
-                self.printer.invoke_shutdown(msg)
-                self._respond_error(msg)
-                if not need_ack:
-                    raise
-            gcmd.ack()
+            
+            if not line:
+                continue
+            # print(f"process_commands line {line}")
+            if (line[0] == "G" or line[0] == "g") and (line[1] == "1" or line[1] == "0") and line[2] == " ":
+                try:
+                    self.gcode_move.simple_cmd_G1(line)
+                except self.error as e:
+                    self._respond_error(str(e))
+                    self.printer.send_event("gcode:command_error")
+                    if not need_ack:
+                        raise
+                except:
+                    msg = """{"code":"key60", "msg":"Internal error on command:%s", "values": ["%s"]}""" % (line.strip("\n"), line.strip("\n"))
+                    logging.exception(msg)
+                    self.printer.invoke_shutdown(msg)
+                    self._respond_error(msg)
+                    if not need_ack:
+                        raise
+                if need_ack:
+                    self.respond_raw("ok")
+            else:
+                
+                # # print(f"process_commands line {line},line[0] {ord(line[0])}")
+                # # Ignore comments and leading/trailing spaces
+                # if line[0]==';' or line[0]=='\r' :
+                #     continue
+                line = origline = line.strip()
+                if not line:
+                    continue
+                if ';' in line:
+                    cpos = line.find(';')
+                    if cpos > 0:
+                        line = line[:cpos]
+                    elif cpos == 0:
+                        continue
+
+                parts = line.upper().split()
+                # print(f"process_commands parts {parts}")
+                cmd = parts[0]
+                params = {}
+                for part in parts:
+                    isset=False
+                    for i, char in enumerate(part):
+                        if self.is_digit_or_delimiter(char):
+                            params[part[:i]] = part[i:]
+                            isset=True
+                            break
+                    if isset:
+                        continue
+                    params[part] = ''
+                # print(f"process_commands params {params},cmd {cmd}")
+                gcmd = GCodeCommand(self, cmd, origline, params, need_ack)
+                # Invoke handler for command
+                handler = self.gcode_handlers.get(cmd, self.cmd_default)
+                try:
+                    handler(gcmd)
+                except self.error as e:
+                    self._respond_error(str(e))
+                    self.printer.send_event("gcode:command_error")
+                    if not need_ack:
+                        raise
+                except:
+                    msg = """{"code":"key60", "msg":"Internal error on command:%s", "values": ["%s"]}""" % (cmd, cmd)
+                    logging.exception(msg)
+                    self.printer.invoke_shutdown(msg)
+                    self._respond_error(msg)
+                    if not need_ack:
+                        raise
+                gcmd.ack()
+                if line.startswith("M104"):
+                    self.set_temperature("extruder", line)
+                elif line.startswith("M140"):
+                    self.set_temperature("bed", line)
+                elif line.startswith("M109"):
+                    self.set_temperature("extruder", line)
+                elif line.startswith("M190"):
+                    self.set_temperature("bed", line)
+                elif line.startswith("EXCLUDE_OBJECT_DEFINE") or line.startswith("EXCLUDE_OBJECT NAME"):
+                    self.record_exclude_object_info(line)
+                elif line.startswith("M141"):
+                    self.set_temperature("chamber_heater", line)
+    def set_temperature(self, key, value):
+        import json
+        try:
+            # configfile = self.printer.lookup_object('configfile')
+            # print_stats = self.printer.load_object(configfile, 'print_stats')
+            temp_value = float(value.strip("\n").split("S")[-1])
+            # if key == "extruder" and print_stats and print_stats.state == "printing":
+            #     if temp_value >= 240:
+            #         self.run_script_from_command("M107 P1")
+            #         logging.info("Fan Off SET M107 P1")
+            #     elif temp_value >= 170:
+            #         self.run_script_from_command("M106 P1 S255")
+            #         logging.info("Fan On SET M106 P1 S255")
+            if key == "extruder" and temp_value < 170:
+                return
+            if not os.path.exists(self.last_temperature_info):
+                from subprocess import call
+                call("touch %s" % self.last_temperature_info, shell=True)
+            with open(self.last_temperature_info, "r") as f:
+                ret = f.read()
+                if len(ret) > 0:
+                    ret = json.loads(ret)
+                else:
+                    ret = {}
+            ret[key] = temp_value
+            with open(self.last_temperature_info, "w") as f:
+                f.write(json.dumps(ret))
+                f.flush()
+        except Exception as err:
+            logging.error("set_temperature error: %s" % err)
+    def record_exclude_object_info(self, line):
+        import json
+        try:
+            if not os.path.exists(self.exclude_object_info):
+                with open(self.exclude_object_info, "w") as f:
+                    data = {}
+                    data["EXCLUDE_OBJECT_DEFINE"] = []
+                    data["EXCLUDE_OBJECT"] = []
+                    f.write(json.dumps(data))
+                    f.flush()
+            with open(self.exclude_object_info, "r") as f:
+                ret = f.read()
+                if len(ret) > 0:
+                    ret = eval(ret)
+                else:
+                    ret = {}
+            if line.startswith("EXCLUDE_OBJECT_DEFINE"):
+                if line not in ret["EXCLUDE_OBJECT_DEFINE"]:
+                    ret["EXCLUDE_OBJECT_DEFINE"].append(line)
+            elif line.startswith("EXCLUDE_OBJECT NAME"):
+                if line not in ret["EXCLUDE_OBJECT"]:
+                    ret["EXCLUDE_OBJECT"].append(line)
+            with open(self.exclude_object_info, "w") as f:
+                f.write(json.dumps(ret))
+                f.flush()
+        except Exception as err:
+            logging.error("record_exclude_object_info error: %s" % err)
     def run_script_from_command(self, script):
         self._process_commands(script.split('\n'), need_ack=False)
     def run_script(self, script):
@@ -230,6 +352,23 @@ class GCodeDispatch:
         lines = [l.strip() for l in msg.strip().split('\n')]
         self.respond_raw("// " + "\n// ".join(lines))
     def _respond_error(self, msg):
+        import time
+        from extras.tool import reportInformation
+        try:
+            v_sd = self.printer.lookup_object('virtual_sdcard')
+            if v_sd.print_id and "key" in msg and re.findall('key(\d+)', msg) and v_sd.cur_print_data:
+                v_sd.update_print_history_info(only_update_status=True, state="error", error_msg=eval(msg))
+                if os.path.exists("/tmp/camera_main"):
+                    reportInformation("key608", data={"print_id": v_sd.print_id})
+                    time.sleep(0.2)
+                v_sd.print_id = ""
+                reportInformation("key701", data=v_sd.cur_print_data)
+                v_sd.cur_print_data = {}
+        except Exception as err:
+            logging.error(err)
+            
+        # TODO: klipper端上报key***冗余代码待清理及优化逻辑，目前只删除上报逻辑，保留特殊key601/602/603/608/701/
+
         logging.warning(msg)
         lines = msg.strip().split('\n')
         if len(lines) > 1:
@@ -242,11 +381,20 @@ class GCodeDispatch:
     # Parameter parsing helpers
     extended_r = re.compile(
         r'^\s*(?:N[0-9]+\s*)?'
-        r'(?P<cmd>[a-zA-Z_][a-zA-Z0-9_]+)(?:\s+|$)'
+        r'(?P<cmd>[a-zA-Z_][a-zA-Z0-9_]*)(?:\s+|$)'
         r'(?P<args>[^#*;]*?)'
         r'\s*(?:[#*;].*)?$')
+    extended_r1 = re.compile(
+        r'^\s*(?:N[0-9]+\s*)?'
+        r'(?P<cmd>[a-zA-Z_][a-zA-Z0-9_]+)(?:\s+|$)'
+        r'(?P<args>[^\|*]*?)'
+        r'\s*(?:[\|*].*)?$')
     def _get_extended_params(self, gcmd):
-        m = self.extended_r.match(gcmd.get_commandline())
+        if gcmd.get_commandline().startswith("SDCARD_PRINT_FILE"):
+            # Support filename contain '#'
+            m = self.extended_r1.match(gcmd.get_commandline())
+        else:
+            m = self.extended_r.match(gcmd.get_commandline())
         if m is None:
             raise self.error("""{"code":"key513", "msg": "Malformed command '%s'", "values": ["%s"]}""" % (gcmd.get_commandline(), gcmd.get_commandline()))
         eargs = m.group('args')
@@ -290,6 +438,11 @@ class GCodeDispatch:
             # Don't warn about requests to turn off fan when fan not present
             return
         gcmd.respond_info("""{"code":"key61, "msg":"Unknown command:%s", "values": ["%s"]}""" % (cmd, cmd))
+    def get_muxcmd(self, cmdkey):
+        if cmdkey in self.mux_commands:
+            key, values = self.mux_commands[cmdkey]
+            return values
+        return None
     def _cmd_mux(self, command, gcmd):
         key, values = self.mux_commands[command]
         if None in values:
@@ -396,12 +549,15 @@ class GCodeIO:
     m112_r = re.compile('^(?:[nN][0-9]+)?\s*[mM]112(?:\s|$)')
     def _process_data(self, eventtime):
         # Read input, separate by newline, and add to pending_commands
+        # start_time = time.time()
+        profile = cProfile.Profile()
+        profile.enable()
         try:
             data = str(os.read(self.fd, 4096).decode())
         except (os.error, UnicodeDecodeError):
             logging.exception("Read g-code")
             return
-        self.input_log.append((eventtime, data))
+        # self.input_log.append((eventtime, data))
         self.bytes_read += len(data)
         lines = data.split('\n')
         lines[0] = self.partial_input + lines[0]
@@ -440,10 +596,16 @@ class GCodeIO:
         if self.fd_handle is None:
             self.fd_handle = self.reactor.register_fd(self.fd,
                                                       self._process_data)
+        profile.disable()
+        stats = pstats.Stats(profile)
+        stats.sort_stats('cumulative')
+        stats.print_stats(20)
     def _respond_raw(self, msg):
         if self.pipe_is_active:
             try:
                 os.write(self.fd, (msg+"\n").encode())
+                # if 'key506' not in msg and 'key507' not in msg and 'key3"' not in msg and "key" in msg:
+                #     reportInformation(msg)
             except os.error:
                 logging.exception("Write g-code response")
                 self.pipe_is_active = False
--- a/klippy/kinematics/corexy.py
+++ b/klippy/kinematics/corexy.py
@@ -5,6 +5,8 @@
 # This file may be distributed under the terms of the GNU GPLv3 license.
 import logging, math
 import stepper
+import mymodule.mymovie as mymovie
+import inspect
 
 class CoreXYKinematics:
     def __init__(self, toolhead, config):
@@ -25,30 +27,111 @@ class CoreXYKinematics:
                                                     self._motor_off)
         # Setup boundary checks
         max_velocity, max_accel = toolhead.get_max_velocity()
-        self.max_z_velocity = config.getfloat(
+        self.__max_z_velocity = config.getfloat(
             'max_z_velocity', max_velocity, above=0., maxval=max_velocity)
-        self.max_z_accel = config.getfloat(
+        self.__max_z_accel = config.getfloat(
             'max_z_accel', max_accel, above=0., maxval=max_accel)
         self.limits = [(1.0, -1.0)] * 3
         ranges = [r.get_range() for r in self.rails]
         self.axes_min = toolhead.Coord(*[r[0] for r in ranges], e=0.)
         self.axes_max = toolhead.Coord(*[r[1] for r in ranges], e=0.)
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
+    def get_max_z_velocity(self):
+        return self.__max_z_velocity
+    def set_max_z_velocity(self, max_velocity):
+        self.__max_z_velocity = max_velocity
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
+    def get_max_z_accel(self):
+        return self.__max_z_accel
+    def set_max_z_accel(self, max_accel):
+        for frame in inspect.stack():
+             print(frame.function)
+        self.__max_z_accel = max_accel
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
     def get_steppers(self):
         return [s for rail in self.rails for s in rail.get_steppers()]
     def calc_position(self, stepper_positions):
         pos = [stepper_positions[rail.get_name()] for rail in self.rails]
         return [0.5 * (pos[0] + pos[1]), 0.5 * (pos[0] - pos[1]), pos[2]]
+    def set_z_limit(self, min_z, max_z):
+        self.limits[2] = (min_z, max_z)
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
+    def set_limits(self, min_x, max_x, min_y, max_y):
+        self.limits[0] = (min_x,max_x)
+        self.limits[1] = (min_y,max_y)
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
+    def restore_limits(self):
+        for i, rail in enumerate(self.rails):
+            if i==0 or i==1:
+                self.limits[i] = rail.get_range()
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
     def set_position(self, newpos, homing_axes):
         for i, rail in enumerate(self.rails):
             rail.set_position(newpos)
             if i in homing_axes:
                 self.limits[i] = rail.get_range()
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
     def note_z_not_homed(self):
         # Helper for Safe Z Home
         self.limits[2] = (1.0, -1.0)
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
     def note_xy_not_homed(self):
         self.limits[0] = (1.0, -1.0)
         self.limits[1] = (1.0, -1.0)
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
+    def home_z_with_sensorless(self, homing_state, top):
+        # Each axis is homed independently and in order
+        # for axis in homing_state.get_axes():
+        rail = self.rails[2]
+        # Determine movement
+        position_min, position_max = rail.get_range()
+        #gcode = self.printer.lookup_object('gcode')
+        position_min = top
+        #gcode.respond_info("position_min {}".format(position_min))
+        hi = rail.get_homing_info()
+        homepos = [None, None, None, None]
+        homepos[2] = hi.position_endstop + position_min
+        forcepos = list(homepos)
+        # forcepos[2] -= position_min
+        forcepos[2] -= 1.5 * (hi.position_endstop - position_min)
+        #gcode.respond_info("[INFO] forcepos:{}".format(forcepos))
+        # forcepos[2] += 1.5 * (position_max - hi.position_endstop)
+        # if hi.positive_dir:
+        #     forcepos[axis] -= 1.5 * (hi.position_endstop - position_min)
+        # else:
+        #     forcepos[axis] += 1.5 * (position_max - hi.position_endstop)
+        # Perform homing
+        rail.homing_retract_dist = 0
+        homing_state.stepper_z_sensorless_flag = True
+        homing_state.home_rails([rail], forcepos, homepos)
+        homing_state.stepper_z_sensorless_flag = False
     def home(self, homing_state):
         # Each axis is homed independently and in order
         for axis in homing_state.get_axes():
@@ -67,6 +150,10 @@ class CoreXYKinematics:
             homing_state.home_rails([rail], forcepos, homepos)
     def _motor_off(self, print_time):
         self.limits = [(1.0, -1.0)] * 3
+        mymovie.Py_set_corexykin_info(self.limits[0][0], self.limits[0][1],
+                                       self.limits[1][0], self.limits[1][1],
+                                       self.limits[2][0], self.limits[2][1],
+                                       self.__max_z_velocity, self.__max_z_accel)
     def _check_endstops(self, move):
         end_pos = move.end_pos
         for i in (0, 1, 2):
@@ -89,7 +176,7 @@ class CoreXYKinematics:
         self._check_endstops(move)
         z_ratio = move.move_d / abs(move.axes_d[2])
         move.limit_speed(
-            self.max_z_velocity * z_ratio, self.max_z_accel * z_ratio)
+            self.__max_z_velocity * z_ratio, self.__max_z_accel * z_ratio)
     def get_status(self, eventtime):
         axes = [a for a, (l, h) in zip("xyz", self.limits) if l <= h]
         return {
@@ -97,6 +184,10 @@ class CoreXYKinematics:
             'axis_minimum': self.axes_min,
             'axis_maximum': self.axes_max,
         }
-
+    def get_status_for_record_z_pos(self):
+        if self.limits[2][0] <= self.limits[2][1]:
+            return True
+        else:
+            return False
 def load_kinematics(toolhead, config):
     return CoreXYKinematics(toolhead, config)
--- a/klippy/kinematics/delta.py
+++ b/klippy/kinematics/delta.py
@@ -65,8 +65,6 @@ class DeltaKinematics:
         self.min_z = config.getfloat('minimum_z_position', 0, maxval=self.max_z)
         self.limit_z = min([ep - arm
                             for ep, arm in zip(self.abs_endstops, arm_lengths)])
-        self.min_arm_length = min_arm_length = min(arm_lengths)
-        self.min_arm2 = min_arm_length**2
         logging.info(
             "Delta max build height %.2fmm (radius tapered above %.2fmm)"
             % (self.max_z, self.limit_z))
@@ -125,11 +123,7 @@ class DeltaKinematics:
         end_z = end_pos[2]
         limit_xy2 = self.max_xy2
         if end_z > self.limit_z:
-            above_z_limit = end_z - self.limit_z
-            allowed_radius = self.radius - math.sqrt(
-                self.min_arm2 - (self.min_arm_length - above_z_limit)**2
-            )
-            limit_xy2 = min(limit_xy2, allowed_radius**2)
+            limit_xy2 = min(limit_xy2, (self.max_z - end_z)**2)
         if end_xy2 > limit_xy2 or end_z > self.max_z or end_z < self.min_z:
             # Move out of range - verify not a homing move
             if (end_pos[:2] != self.home_position[:2]
--- a/klippy/kinematics/extruder.py
+++ b/klippy/kinematics/extruder.py
@@ -3,9 +3,9 @@
 # Copyright (C) 2016-2022  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging
+import math, logging, os
 import stepper, chelper
-
+import numpy as np
 class ExtruderStepper:
     def __init__(self, config):
         self.printer = config.get_printer()
@@ -101,6 +101,13 @@ class ExtruderStepper:
                % (pressure_advance, smooth_time))
         self.printer.set_rollover_info(self.name, "%s: %s" % (self.name, msg))
         gcmd.respond_info(msg, log=False)
+        try:
+            v_sd = self.printer.lookup_object('virtual_sdcard')
+            gcode_move = self.printer.lookup_object('gcode_move')
+            if os.path.exists(v_sd.print_file_name_path) and v_sd.current_file:
+                gcode_move.recordPrintFileName(v_sd.print_file_name_path, v_sd.current_file.name, pressure_advance="SET_PRESSURE_ADVANCE ADVANCE=%s SMOOTH_TIME=%s" % (pressure_advance, smooth_time))
+        except Exception as err:
+            logging.error(err)
     cmd_SET_E_ROTATION_DISTANCE_help = "Set extruder rotation distance"
     def cmd_SET_E_ROTATION_DISTANCE(self, gcmd):
         rotation_dist = gcmd.get_float('DISTANCE', None)
@@ -149,6 +156,9 @@ class ExtruderStepper:
 # Tracking for hotend heater, extrusion motion queue, and extruder stepper
 class PrinterExtruder:
     def __init__(self, config, extruder_num):
+        self._info_array = [0.0]*(7)
+        self.info_array = np.array(self._info_array, dtype=np.float64)
+        self.info_array_addr_int = self.info_array.ctypes.data
         self.printer = config.get_printer()
         self.name = config.get_name()
         self.last_position = 0.
@@ -162,27 +172,30 @@ class PrinterExtruder:
             config.deprecate('shared_heater')
             self.heater = pheaters.lookup_heater(shared_heater)
         # Setup kinematic checks
-        self.nozzle_diameter = config.getfloat('nozzle_diameter', above=0.)
+        self.__nozzle_diameter = config.getfloat('nozzle_diameter', above=0.)
+        user_nozzle_diameter = config.getfloat('user_nozzle_diameter', default=0.)
+        if user_nozzle_diameter >= 0.1:
+            self.__nozzle_diameter = user_nozzle_diameter
         filament_diameter = config.getfloat(
-            'filament_diameter', minval=self.nozzle_diameter)
+            'filament_diameter', minval=self.__nozzle_diameter)
         self.filament_area = math.pi * (filament_diameter * .5)**2
-        def_max_cross_section = 4. * self.nozzle_diameter**2
+        def_max_cross_section = 4. * self.__nozzle_diameter**2
         def_max_extrude_ratio = def_max_cross_section / self.filament_area
         max_cross_section = config.getfloat(
             'max_extrude_cross_section', def_max_cross_section, above=0.)
-        self.max_extrude_ratio = max_cross_section / self.filament_area
-        logging.info("Extruder max_extrude_ratio=%.6f", self.max_extrude_ratio)
+        self.__max_extrude_ratio = max_cross_section / self.filament_area
+        logging.info("Extruder max_extrude_ratio=%.6f", self.__max_extrude_ratio)
         toolhead = self.printer.lookup_object('toolhead')
         max_velocity, max_accel = toolhead.get_max_velocity()
-        self.max_e_velocity = config.getfloat(
+        self.__max_e_velocity = config.getfloat(
             'max_extrude_only_velocity', max_velocity * def_max_extrude_ratio
             , above=0.)
-        self.max_e_accel = config.getfloat(
+        self.__max_e_accel = config.getfloat(
             'max_extrude_only_accel', max_accel * def_max_extrude_ratio
             , above=0.)
-        self.max_e_dist = config.getfloat(
+        self.__max_e_dist = config.getfloat(
             'max_extrude_only_distance', 50., minval=0.)
-        self.instant_corner_v = config.getfloat(
+        self.__instant_corner_v = config.getfloat(
             'instantaneous_corner_velocity', 1., minval=0.)
         # Setup extruder trapq (trapezoidal motion queue)
         ffi_main, ffi_lib = chelper.get_ffi()
@@ -200,16 +213,27 @@ class PrinterExtruder:
         gcode = self.printer.lookup_object('gcode')
         if self.name == 'extruder':
             toolhead.set_extruder(self, 0.)
+            gcode.register_command("SET_NOZZLE_DIAMETER", self.cmd_SET_NOZZLE_DIAMETER)
             gcode.register_command("M104", self.cmd_M104)
             gcode.register_command("M109", self.cmd_M109)
         gcode.register_mux_command("ACTIVATE_EXTRUDER", "EXTRUDER",
                                    self.name, self.cmd_ACTIVATE_EXTRUDER,
                                    desc=self.cmd_ACTIVATE_EXTRUDER_help)
+        self.info_array[0]=self.heater.info_array_addr_int
+        self.info_array[1]=self.__max_e_velocity
+        self.info_array[2]=self.__max_e_accel
+        self.info_array[3]=self.__max_extrude_ratio
+        self.info_array[4]=self.__nozzle_diameter
+        self.info_array[5]=self.__max_e_dist
+        self.info_array[6]=self.__instant_corner_v
+        self.extrude_below_min_temp_err_is_report = False
     def update_move_time(self, flush_time):
         self.trapq_finalize_moves(self.trapq, flush_time)
     def get_status(self, eventtime):
         sts = self.heater.get_status(eventtime)
         sts['can_extrude'] = self.heater.can_extrude
+        sts['extrude_below_min_temp_err_is_report'] = self.extrude_below_min_temp_err_is_report
+        sts['nozzle_diameter'] = self.__nozzle_diameter
         if self.extruder_stepper is not None:
             sts.update(self.extruder_stepper.get_status(eventtime))
         return sts
@@ -238,21 +262,21 @@ class PrinterExtruder:
             return
         if (not move.axes_d[0] and not move.axes_d[1]) or axis_r < 0.:
             # Extrude only move (or retraction move) - limit accel and velocity
-            if abs(move.axes_d[3]) > self.max_e_dist:
+            if abs(move.axes_d[3]) > self.__max_e_dist:
                 raise self.printer.command_error(
                     "Extrude only move too long (%.3fmm vs %.3fmm)\n"
                     "See the 'max_extrude_only_distance' config"
-                    " option for details" % (move.axes_d[3], self.max_e_dist))
+                    " option for details" % (move.axes_d[3], self.__max_e_dist))
             inv_extrude_r = 1. / abs(axis_r)
-            move.limit_speed(self.max_e_velocity * inv_extrude_r,
-                             self.max_e_accel * inv_extrude_r)
-        elif axis_r > self.max_extrude_ratio:
-            if move.axes_d[3] <= self.nozzle_diameter * self.max_extrude_ratio:
+            move.limit_speed(self.__max_e_velocity * inv_extrude_r,
+                             self.__max_e_accel * inv_extrude_r)
+        elif axis_r > self.__max_extrude_ratio:
+            if move.axes_d[3] <= self.__nozzle_diameter * self.__max_extrude_ratio:
                 # Permit extrusion if amount extruded is tiny
                 return
             area = axis_r * self.filament_area
             logging.debug("Overextrude: %s vs %s (area=%.3f dist=%.3f)",
-                          axis_r, self.max_extrude_ratio, area, move.move_d)
+                          axis_r, self.__max_extrude_ratio, area, move.move_d)
             raise self.printer.command_error(
                 """{"code":"key112", "msg": "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\nSee the 'max_extrude_cross_section' config option for details", "values": [%.3f, %.3f]}"""
                 % (
@@ -260,7 +284,7 @@ class PrinterExtruder:
     def calc_junction(self, prev_move, move):
         diff_r = move.axes_r[3] - prev_move.axes_r[3]
         if diff_r:
-            return (self.instant_corner_v / abs(diff_r))**2
+            return (self.__instant_corner_v / abs(diff_r))**2
         return move.max_cruise_v2
     def move(self, print_time, move):
         axis_r = move.axes_r[3]
@@ -301,6 +325,13 @@ class PrinterExtruder:
     def cmd_M109(self, gcmd):
         # Set Extruder Temperature and Wait
         self.cmd_M104(gcmd, wait=True)
+    def cmd_SET_NOZZLE_DIAMETER(self, gcmd):
+        value = gcmd.get_float('VALUE', 0.4)
+        self.__nozzle_diameter = value
+        configfile = self.printer.lookup_object('configfile')
+        configfile.set('extruder', 'user_nozzle_diameter', '%.3f' % (self.__nozzle_diameter))
+        gcode = self.printer.lookup_object('gcode')
+        gcode.run_script_from_command('CXSAVE_CONFIG')
     cmd_ACTIVATE_EXTRUDER_help = "Change the active extruder"
     def cmd_ACTIVATE_EXTRUDER(self, gcmd):
         toolhead = self.printer.lookup_object('toolhead')
--- a/klippy/klippy.py
+++ b/klippy/klippy.py
@@ -111,9 +111,31 @@ class Printer:
         py_dirname = os.path.join(os.path.dirname(__file__),
                                   'extras', module_name, '__init__.py')
         if not os.path.exists(py_name) and not os.path.exists(py_dirname):
+            if default is not configfile.sentinel:
+                return default
+            raise self.config_error("""{"code":"key124", "msg": "Unable to load module '%s'", "values": ["%s"]}""" % (section, section))
+        mod = importlib.import_module('extras.' + module_name)
+        init_func = 'load_config'
+        if len(module_parts) > 1:
+            init_func = 'load_config_prefix'
+        init_func = getattr(mod, init_func, None)
+        if init_func is None:
             if default is not configfile.sentinel:
                 return default
             raise self.config_error("Unable to load module '%s'" % (section,))
+        self.objects[section] = init_func(config.getsection(section))
+        return self.objects[section]
+    def reload_object(self, config, section, default=configfile.sentinel):
+        module_parts = section.split()
+        module_name = module_parts[0]
+        py_name = os.path.join(os.path.dirname(__file__),
+                               'extras', module_name + '.py')
+        py_dirname = os.path.join(os.path.dirname(__file__),
+                                  'extras', module_name, '__init__.py')
+        if not os.path.exists(py_name) and not os.path.exists(py_dirname):
+            if default is not configfile.sentinel:
+                return default
+            raise self.config_error("""{"code":"key124", "msg": "Unable to load module '%s'", "values": ["%s"]}""" % (section, section))
         mod = importlib.import_module('extras.' + module_name)
         init_func = 'load_config'
         if len(module_parts) > 1:
@@ -175,8 +197,38 @@ class Printer:
                     return
                 cb()
         except (self.config_error, pins.error) as e:
+            # logging.exception("Config error")^M
+            logging.error(e)
+            # self._set_state("%s\n%s" % (str(e), message_restart))^M
+            if '{"code":' in str(e):
+                try:
+                    import json
+                    tmp_state = eval(str(e))
+                    tmp_state["msg"] = tmp_state["msg"] + "\n" + message_restart
+                    self._set_state(json.dumps(tmp_state))
+                except Exception as e:
+                    logging.exception(e)
+                    self._set_state("%s\n%s" % (str(e), message_restart))
+            else:
+                if "File contains no section headers." in str(e):
+                    value = str(e)
+                    value = value.replace("File contains no section headers.", "").replace("'*\n'", "'*\\n'")
+
+                    msg = """{"code": "key336", "msg": "File contains no section headers.<br/>%s", "values":["%s"]}""" % (
+                        value, value
+                    )
+                    self._set_state(msg)
+                elif "File contains parsing errors:" in str(e):
+                    value = str(e)
+                    value = value.replace("File contains parsing errors:", "").replace("'*\n'", "'*\\n'")
+
+                    msg = """{"code": "key337", "msg": "File contains parsing errors:%s<br/>%s", "values":["%s"]}""" % (
+                        value, message_restart, value
+                    )
+                    self._set_state(msg)
+                else:
+                    self._set_state("%s\n%s" % (str(e), message_restart))
             logging.exception("Config error")
-            self._set_state("%s\n%s" % (str(e), message_restart))
             return
         except msgproto.error as e:
             logging.exception("Protocol error")
@@ -300,6 +352,7 @@ def arg_dictionary(option, opt_str, value, parser):
         parser.values.dictionary = {}
     parser.values.dictionary[key] = fname
 
+
 def main():
     usage = "%prog [options] <config file>"
     opts = optparse.OptionParser(usage)
--- a/klippy/mcu.py
+++ b/klippy/mcu.py
@@ -71,7 +71,7 @@ class MCU_trsync:
             "trsync_state oid=%c can_trigger=%c trigger_reason=%c clock=%u")
         ffi_main, ffi_lib = chelper.get_ffi()
         self._trdispatch_mcu = ffi_main.gc(ffi_lib.trdispatch_mcu_alloc(
-            self._trdispatch, mcu._serial.get_serialqueue(), # XXX
+            self._trdispatch, mcu._serial.serialqueue, # XXX
             self._cmd_queue, self._oid, set_timeout_tag, trigger_tag,
             state_tag), ffi_lib.free)
     def _shutdown(self):
@@ -460,6 +460,7 @@ class MCU_adc:
 class RetryAsyncCommand:
     TIMEOUT_TIME = 5.0
     RETRY_TIME = 0.500
+    IS_RESEND = True
     def __init__(self, serial, name, oid=None):
         self.serial = serial
         self.name = name
@@ -486,12 +487,46 @@ class RetryAsyncCommand:
                 self.serial.register_response(None, self.name, self.oid)
                 raise serialhdl.error("""{"code": "key294", "msg": "Timeout on wait for '%s' response", "values":["%s"]}"""
                                       % (self.oid, self.name))
-            self.serial.raw_send(cmd, minclock, minclock, cmd_queue)
+            if self.IS_RESEND:
+                self.serial.raw_send(cmd, minclock, minclock, cmd_queue)
+
+class ExtruderRetryAsyncCommand:
+    TIMEOUT_TIME = 60.0
+    RETRY_TIME = 0.500
+    IS_RESEND = False
+    def __init__(self, serial, name, oid=None):
+        self.serial = serial
+        self.name = name
+        self.oid = oid
+        self.reactor = serial.get_reactor()
+        self.completion = self.reactor.completion()
+        self.min_query_time = self.reactor.monotonic()
+        self.serial.register_response(self.handle_callback, name, oid)
+    def handle_callback(self, params):
+        if params['#sent_time'] >= self.min_query_time:
+            self.min_query_time = self.reactor.NEVER
+            self.reactor.async_complete(self.completion, params)
+    def get_response(self, cmds, cmd_queue, minclock=0, reqclock=0):
+        cmd, = cmds
+        self.serial.raw_send_wait_ack(cmd, minclock, reqclock, cmd_queue)
+        first_query_time = query_time = self.reactor.monotonic()
+        while 1:
+            params = self.completion.wait(query_time + self.RETRY_TIME)
+            if params is not None:
+                self.serial.register_response(None, self.name, self.oid)
+                return params
+            query_time = self.reactor.monotonic()
+            if query_time > first_query_time + self.TIMEOUT_TIME:
+                self.serial.register_response(None, self.name, self.oid)
+                raise serialhdl.error("""{"code": "key294", "msg": "ExtruderRetryAsyncCommand Timeout on wait for '%s' response", "values":["%s"]}"""
+                                      % (self.oid, self.name))
+            if self.IS_RESEND:
+                self.serial.raw_send(cmd, minclock, minclock, cmd_queue)
 
 # Wrapper around query commands
 class CommandQueryWrapper:
     def __init__(self, serial, msgformat, respformat, oid=None,
-                 cmd_queue=None, is_async=False, error=serialhdl.error):
+                 cmd_queue=None, is_async=False, error=serialhdl.error, extruder_transparent=False):
         self._serial = serial
         self._cmd = serial.get_msgparser().lookup_command(msgformat)
         serial.get_msgparser().lookup_command(respformat)
@@ -501,6 +536,8 @@ class CommandQueryWrapper:
         self._xmit_helper = serialhdl.SerialRetryCommand
         if is_async:
             self._xmit_helper = RetryAsyncCommand
+        if extruder_transparent:
+            self._xmit_helper = ExtruderRetryAsyncCommand
         if cmd_queue is None:
             cmd_queue = serial.get_default_command_queue()
         self._cmd_queue = cmd_queue
@@ -597,6 +634,75 @@ class MCU:
         printer.register_event_handler("klippy:connect", self._connect)
         printer.register_event_handler("klippy:shutdown", self._shutdown)
         printer.register_event_handler("klippy:disconnect", self._disconnect)
+        self.cur_code_key = ""
+        if self._name == "mcu" or self._name == "nozzle_mcu":
+            self._do_query_timer = self._reactor.register_timer(self._do_query)
+            self._reactor.update_timer(self._do_query_timer, self._reactor.NOW)
+    def _do_query(self, eventtime):
+        try:
+            mcu_temp_obj = self._printer.lookup_object('temperature_sensor mcu_temp') if self._printer.objects.get('temperature_sensor mcu_temp') else None
+            chamber_temp_obj = self._printer.lookup_object('temperature_sensor chamber_temp') if self._printer.objects.get('temperature_sensor chamber_temp') else None
+            heater_bed_obj = self._printer.lookup_object('heater_bed') if self._printer.objects.get('heater_bed') else None
+            extruder_obj = self._printer.lookup_object('extruder') if self._printer.objects.get('extruder') else None
+            gcode = self._printer.lookup_object('gcode')
+            code_key_string = ""
+            msg = "adc out of range"
+            if self._serial.adc_out_of_range_info["mcu0"]:
+                if heater_bed_obj and heater_bed_obj.heater.smoothed_temp < 0:
+                    msg += " heater_bed_temp:%s" % round(heater_bed_obj.heater.smoothed_temp, 2)
+                    code_key_string = "key510"
+                elif heater_bed_obj and heater_bed_obj.heater.smoothed_temp > 500:
+                    msg += " heater_bed_temp:%s" % round(heater_bed_obj.heater.smoothed_temp, 2)
+                    code_key_string = "key516"
+                if code_key_string and not self._serial.adc_out_of_range_info["bed0_isReport"]:
+                    # self._serial.adc_out_of_range_info["bed0_isReport"] = True
+                    gcode.run_script("TURN_OFF_HEATERS")
+                    gcode._respond_error("""{"code": "%s", "msg":"bed %s", "values": []}""" % (code_key_string, self._name + " " + msg))
+                code_key_string = ""
+                if chamber_temp_obj and chamber_temp_obj.last_temp < 0:
+                    msg += " chamber_temp:%s" % round(chamber_temp_obj.last_temp, 2)
+                    code_key_string = "key511"
+                elif chamber_temp_obj and chamber_temp_obj.last_temp > 500:
+                    msg += " chamber_temp:%s" % round(chamber_temp_obj.last_temp, 2)
+                    code_key_string = "key517"
+                if mcu_temp_obj and mcu_temp_obj.last_temp < 0:
+                    msg += " mcu_temp:%s" % round(mcu_temp_obj.last_temp, 2)
+                    code_key_string = "key512"
+                elif mcu_temp_obj and mcu_temp_obj.last_temp > 500:
+                    msg += " mcu_temp:%s" % round(mcu_temp_obj.last_temp, 2)
+                    code_key_string = "key518"
+                if code_key_string and not self._serial.adc_out_of_range_info["mcu0_isReport"]:
+                    # self._serial.adc_out_of_range_info["mcu0_isReport"] = True
+                    gcode.run_script("TURN_OFF_HEATERS")
+                    gcode._respond_error("""{"code": "%s", "msg":"mcu %s", "values": []}""" % (code_key_string, self._name + " " + msg))
+                code_key_string = ""
+
+            if self._serial.adc_out_of_range_info["noz0"]:
+                if extruder_obj and extruder_obj.heater.smoothed_temp < 0:
+                    msg += " extruder_temp:%s" % round(extruder_obj.heater.smoothed_temp, 2)
+                    code_key_string = "key509"
+                elif extruder_obj and extruder_obj.heater.smoothed_temp > 500:
+                    msg += " extruder_temp:%s" % round(extruder_obj.heater.smoothed_temp, 2)
+                    code_key_string = "key515"
+                if code_key_string and not self._serial.adc_out_of_range_info["noz0_isReport"]:
+                    # self._serial.adc_out_of_range_info["noz0_isReport"] = True
+                    gcode.run_script("TURN_OFF_HEATERS")
+                    gcode._respond_error("""{"code": "%s", "msg":"nozzle %s", "values": []}""" % (code_key_string, self._name + " " + msg))
+                code_key_string = ""
+
+            if (chamber_temp_obj and -20 < chamber_temp_obj.last_temp < 500) and (mcu_temp_obj and -20 < mcu_temp_obj.last_temp < 500):
+                self._serial.adc_out_of_range_info["mcu0"] = False
+                self._serial.adc_out_of_range_info["mcu0_isReport"] = False
+            if extruder_obj and -20 < extruder_obj.heater.smoothed_temp < 500:
+                self._serial.adc_out_of_range_info["noz0"] = False
+                self._serial.adc_out_of_range_info["noz0_isReport"] = False
+            if heater_bed_obj and -20 < heater_bed_obj.heater.smoothed_temp < 500:
+                self._serial.adc_out_of_range_info["bed0"] = False
+                self._serial.adc_out_of_range_info["bed0_isReport"] = False
+        except Exception as err:
+            logging.error(err)
+        return eventtime + 3.0
+
     # Serial callbacks
     def _handle_mcu_stats(self, params):
         count = params['count']
@@ -783,7 +889,7 @@ class MCU:
             raise error("""{"code": "key302", "msg": "Too few moves available on MCU '%s'", "values":["%s"]}""" % (self._name, self._name))
         ffi_main, ffi_lib = chelper.get_ffi()
         self._steppersync = ffi_main.gc(
-            ffi_lib.steppersync_alloc(self._serial.get_serialqueue(),
+            ffi_lib.steppersync_alloc(self._serial.serialqueue,
                                       self._stepqueues, len(self._stepqueues),
                                       move_count-self._reserved_move_slots),
             ffi_lib.steppersync_free)
@@ -888,9 +994,9 @@ class MCU:
     def lookup_command(self, msgformat, cq=None):
         return CommandWrapper(self._serial, msgformat, cq)
     def lookup_query_command(self, msgformat, respformat, oid=None,
-                             cq=None, is_async=False):
+                             cq=None, is_async=False, extruder_transparent=False):
         return CommandQueryWrapper(self._serial, msgformat, respformat, oid,
-                                   cq, is_async, self._printer.command_error)
+                                   cq, is_async, self._printer.command_error, extruder_transparent)
     def try_lookup_command(self, msgformat):
         try:
             return self.lookup_command(msgformat)
--- a/klippy/queuelogger.py
+++ b/klippy/queuelogger.py
@@ -61,9 +61,13 @@ def setup_bg_logging(filename, debuglevel):
     global MainQueueHandler
     ql = QueueListener(filename)
     MainQueueHandler = QueueHandler(ql.bg_queue)
+    formatter = logging.Formatter(
+        '[%(levelname)s] %(asctime)s [%(name)s] [%(module)s:%(funcName)s:%(lineno)d] %(message)s')
+    MainQueueHandler.setFormatter(formatter)
     root = logging.getLogger()
     root.addHandler(MainQueueHandler)
     root.setLevel(debuglevel)
+    ql.setFormatter(formatter)
     return ql
 
 def clear_bg_logging():
--- a/klippy/reactor.py
+++ b/klippy/reactor.py
@@ -6,7 +6,7 @@
 import os, gc, select, math, time, logging, queue
 import greenlet
 import chelper, util
-
+import mymodule.mymovie as mymovie
 _NOW = 0.
 _NEVER = 9999999999999999.
 
@@ -97,7 +97,8 @@ class SelectReactor:
     def __init__(self, gc_checking=False):
         # Main code
         self._process = False
-        self.monotonic = chelper.get_ffi()[1].get_monotonic
+        # self.monotonic = chelper.get_ffi()[1].get_monotonic
+        self.monotonic = mymovie.Py_get_monotonic
         # Python garbage collection
         self._check_gc = gc_checking
         self._last_gc_times = [0., 0., 0.]
@@ -119,7 +120,9 @@ class SelectReactor:
     # Timers
     def update_timer(self, timer_handler, waketime):
         timer_handler.waketime = waketime
-        self._next_timer = min(self._next_timer, waketime)
+        if waketime < self._next_timer:
+            self._next_timer = waketime
+        # self._next_timer = min(self._next_timer, waketime)
     def register_timer(self, callback, waketime=NEVER):
         timer_handler = ReactorTimer(callback, waketime)
         timers = list(self._timers)
@@ -336,6 +339,12 @@ class PollReactor(SelectReactor):
         self._g_dispatch = g_dispatch = greenlet.getcurrent()
         busy = True
         eventtime = self.monotonic()
+        try:
+            logging.info("_dispatch_loop current nice = %d", os.nice(0))
+            val = os.nice(-10)
+            logging.info("_dispatch_loop new nice = %d", val)
+        except:
+            pass
         while self._process:
             timeout = self._check_timers(eventtime, busy)
             busy = False
--- a/klippy/serialhdl.py
+++ b/klippy/serialhdl.py
@@ -33,8 +33,18 @@ class SerialReader:
         # Sent message notification tracking
         self.last_notify_id = 0
         self.pending_notifications = {}
+        self.z_align_status = {}
+        self.finetuning_status = {}
+        self.adc_out_of_range_info = {"mcu0": False, "mcu0_isReport": False, "noz0": False, "noz0_isReport": False,
+                                      "bed0": False, "bed0_isReport": False}
     def _bg_thread(self):
         response = self.ffi_main.new('struct pull_queue_message *')
+        try:
+            val = os.nice(-20)
+            logging.info("%scurrent nice = %d" ,self.warn_prefix, val)
+        except:
+            logging.info("%snice process failed", self.warn_prefix)
+            pass
         while 1:
             self.ffi_lib.serialqueue_pull(self.serialqueue, response)
             count = response.len
@@ -233,8 +243,6 @@ class SerialReader:
         return self.reactor
     def get_msgparser(self):
         return self.msgparser
-    def get_serialqueue(self):
-        return self.serialqueue
     def get_default_command_queue(self):
         return self.default_cmd_queue
     # Serial response callbacks
@@ -305,7 +313,16 @@ class SerialReader:
                      params['#name'], params['#msg'])
     def handle_default(self, params):
         logging.warn("%sgot %s", self.warn_prefix, params)
-
+        if isinstance(params, dict):
+            if params.get("#name", "") == "z_align_status":
+                self.z_align_status = params
+            elif params.get("#name", "") == "finetuning_status":
+                self.finetuning_status = params
+            elif params.get("static_string_id", "").endswith("ADC out of range"):
+                if params.get("static_string_id", "")==("mcu0 ADC out of range"):
+                    self.adc_out_of_range_info["mcu0"] = True
+                elif params.get("static_string_id", "")==("noz0 ADC out of range"):
+                    self.adc_out_of_range_info["noz0"] = True
 # Class to send a query command and return the received response
 class SerialRetryCommand:
     def __init__(self, serial, name, oid=None):
--- a/klippy/stepper.py
+++ b/klippy/stepper.py
@@ -54,6 +54,10 @@ class MCU_stepper:
                                                        self._query_mcu_position)
     def get_mcu(self):
         return self._mcu
+
+    def get_pin_info(self):
+        return self._dir_pin, self._step_pin, self._invert_dir, self._invert_step
+
     def get_name(self, short=False):
         if short and self._name.startswith('stepper_'):
             return self._name[8:]
@@ -295,6 +299,7 @@ class PrinterRail:
     def __init__(self, config, need_position_minmax=True,
                  default_position_endstop=None, units_in_radians=False):
         # Primary stepper and endstop
+        self.config = config
         self.stepper_units_in_radians = units_in_radians
         self.steppers = []
         self.endstops = []
@@ -318,11 +323,15 @@ class PrinterRail:
             self.position_min = config.getfloat('position_min', 0.)
             self.position_max = config.getfloat(
                 'position_max', above=self.position_min)
+            if config.has_section('gcode_macro PRINTER_PARAM'):
+                if config.get_name() == "stepper_y":
+                    self.position_max = config.getsection('gcode_macro PRINTER_PARAM').getfloat("variable_max_y_position", 350.0)
         else:
             self.position_min = 0.
             self.position_max = self.position_endstop
+        self.set_stepper_x_position_min(self.config)
         if (self.position_endstop < self.position_min
-            or self.position_endstop > self.position_max):
+            or self.position_endstop > self.position_max) and config.get_name() != "stepper_x":
             raise config.error(
                 "position_endstop in section '%s' must be between"
                 " position_min and position_max" % config.get_name())
@@ -354,7 +363,15 @@ class PrinterRail:
             raise config.error(
                 "Invalid homing_positive_dir / position_endstop in '%s'"
                 % (config.get_name(),))
+    def set_stepper_x_position_min(self, config):
+        try:
+            if config.get_name() == "stepper_x":
+                box_action = config.get_printer().lookup_object('box').box_action
+                self.position_min = box_action.boxcfg.cut_pos_x
+        except Exception as err:
+            logging.exception(err)
     def get_range(self):
+        self.set_stepper_x_position_min(self.config)
         return self.position_min, self.position_max
     def get_homing_info(self):
         homing_info = collections.namedtuple('homing_info', [
--- a/klippy/toolhead.py
+++ b/klippy/toolhead.py
@@ -3,108 +3,21 @@
 # Copyright (C) 2016-2021  Kevin O'Connor <kevin@koconnor.net>
 #
 # This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging, importlib
+import math, logging, importlib, os, json
 import mcu, chelper, kinematics.extruder
-
+from extras.base_info import base_dir
+import time
+import inspect
+import mymodule.mymovie as mymovie
+import numpy as np
+import ctypes
+import cProfile
+import pstats
 # Common suffixes: _d is distance (in mm), _v is velocity (in
 #   mm/second), _v2 is velocity squared (mm^2/s^2), _t is time (in
 #   seconds), _r is ratio (scalar between 0.0 and 1.0)
 
 # Class to track each move request
-class Move:
-    def __init__(self, toolhead, start_pos, end_pos, speed):
-        self.toolhead = toolhead
-        self.start_pos = tuple(start_pos)
-        self.end_pos = tuple(end_pos)
-        self.accel = toolhead.max_accel
-        self.junction_deviation = toolhead.junction_deviation
-        self.timing_callbacks = []
-        velocity = min(speed, toolhead.max_velocity)
-        self.is_kinematic_move = True
-        self.axes_d = axes_d = [end_pos[i] - start_pos[i] for i in (0, 1, 2, 3)]
-        self.move_d = move_d = math.sqrt(sum([d*d for d in axes_d[:3]]))
-        if move_d < .000000001:
-            # Extrude only move
-            self.end_pos = (start_pos[0], start_pos[1], start_pos[2],
-                            end_pos[3])
-            axes_d[0] = axes_d[1] = axes_d[2] = 0.
-            self.move_d = move_d = abs(axes_d[3])
-            inv_move_d = 0.
-            if move_d:
-                inv_move_d = 1. / move_d
-            self.accel = 99999999.9
-            velocity = speed
-            self.is_kinematic_move = False
-        else:
-            inv_move_d = 1. / move_d
-        self.axes_r = [d * inv_move_d for d in axes_d]
-        self.min_move_t = move_d / velocity
-        # Junction speeds are tracked in velocity squared.  The
-        # delta_v2 is the maximum amount of this squared-velocity that
-        # can change in this move.
-        self.max_start_v2 = 0.
-        self.max_cruise_v2 = velocity**2
-        self.delta_v2 = 2.0 * move_d * self.accel
-        self.max_smoothed_v2 = 0.
-        self.smooth_delta_v2 = 2.0 * move_d * toolhead.max_accel_to_decel
-    def limit_speed(self, speed, accel):
-        speed2 = speed**2
-        if speed2 < self.max_cruise_v2:
-            self.max_cruise_v2 = speed2
-            self.min_move_t = self.move_d / speed
-        self.accel = min(self.accel, accel)
-        self.delta_v2 = 2.0 * self.move_d * self.accel
-        self.smooth_delta_v2 = min(self.smooth_delta_v2, self.delta_v2)
-    def move_error(self, msg="Move out of range"):
-        ep = self.end_pos
-        m = "%s: %.3f %.3f %.3f [%.3f]" % (msg, ep[0], ep[1], ep[2], ep[3])
-        return self.toolhead.printer.command_error(m)
-    def calc_junction(self, prev_move):
-        if not self.is_kinematic_move or not prev_move.is_kinematic_move:
-            return
-        # Allow extruder to calculate its maximum junction
-        extruder_v2 = self.toolhead.extruder.calc_junction(prev_move, self)
-        # Find max velocity using "approximated centripetal velocity"
-        axes_r = self.axes_r
-        prev_axes_r = prev_move.axes_r
-        junction_cos_theta = -(axes_r[0] * prev_axes_r[0]
-                               + axes_r[1] * prev_axes_r[1]
-                               + axes_r[2] * prev_axes_r[2])
-        if junction_cos_theta > 0.999999:
-            return
-        junction_cos_theta = max(junction_cos_theta, -0.999999)
-        sin_theta_d2 = math.sqrt(0.5*(1.0-junction_cos_theta))
-        R_jd = sin_theta_d2 / (1. - sin_theta_d2)
-        # Approximated circle must contact moves no further away than mid-move
-        tan_theta_d2 = sin_theta_d2 / math.sqrt(0.5*(1.0+junction_cos_theta))
-        move_centripetal_v2 = .5 * self.move_d * tan_theta_d2 * self.accel
-        prev_move_centripetal_v2 = (.5 * prev_move.move_d * tan_theta_d2
-                                    * prev_move.accel)
-        # Apply limits
-        self.max_start_v2 = min(
-            R_jd * self.junction_deviation * self.accel,
-            R_jd * prev_move.junction_deviation * prev_move.accel,
-            move_centripetal_v2, prev_move_centripetal_v2,
-            extruder_v2, self.max_cruise_v2, prev_move.max_cruise_v2,
-            prev_move.max_start_v2 + prev_move.delta_v2)
-        self.max_smoothed_v2 = min(
-            self.max_start_v2
-            , prev_move.max_smoothed_v2 + prev_move.smooth_delta_v2)
-    def set_junction(self, start_v2, cruise_v2, end_v2):
-        # Determine accel, cruise, and decel portions of the move distance
-        half_inv_accel = .5 / self.accel
-        accel_d = (cruise_v2 - start_v2) * half_inv_accel
-        decel_d = (cruise_v2 - end_v2) * half_inv_accel
-        cruise_d = self.move_d - accel_d - decel_d
-        # Determine move velocities
-        self.start_v = start_v = math.sqrt(start_v2)
-        self.cruise_v = cruise_v = math.sqrt(cruise_v2)
-        self.end_v = end_v = math.sqrt(end_v2)
-        # Determine time spent in each portion of move (time is the
-        # distance divided by average velocity)
-        self.accel_t = accel_d / ((start_v + cruise_v) * 0.5)
-        self.cruise_t = cruise_d / cruise_v
-        self.decel_t = decel_d / ((end_v + cruise_v) * 0.5)
 
 LOOKAHEAD_FLUSH_TIME = 0.250
 
@@ -116,6 +29,7 @@ class MoveQueue:
         self.queue = []
         self.junction_flush = LOOKAHEAD_FLUSH_TIME
     def reset(self):
+        mymovie.Py_move_queue_del(len(self.queue))
         del self.queue[:]
         self.junction_flush = LOOKAHEAD_FLUSH_TIME
     def set_flush_time(self, flush_time):
@@ -126,61 +40,41 @@ class MoveQueue:
         return None
     def flush(self, lazy=False):
         self.junction_flush = LOOKAHEAD_FLUSH_TIME
-        update_flush_count = lazy
+        # update_flush_count = lazy
         queue = self.queue
         flush_count = len(queue)
-        # Traverse queue from last to first move and determine maximum
-        # junction speed assuming the robot comes to a complete stop
-        # after the last move.
-        delayed = []
-        next_end_v2 = next_smoothed_v2 = peak_cruise_v2 = 0.
-        for i in range(flush_count-1, -1, -1):
-            move = queue[i]
-            reachable_start_v2 = next_end_v2 + move.delta_v2
-            start_v2 = min(move.max_start_v2, reachable_start_v2)
-            reachable_smoothed_v2 = next_smoothed_v2 + move.smooth_delta_v2
-            smoothed_v2 = min(move.max_smoothed_v2, reachable_smoothed_v2)
-            if smoothed_v2 < reachable_smoothed_v2:
-                # It's possible for this move to accelerate
-                if (smoothed_v2 + move.smooth_delta_v2 > next_smoothed_v2
-                    or delayed):
-                    # This move can decelerate or this is a full accel
-                    # move after a full decel move
-                    if update_flush_count and peak_cruise_v2:
-                        flush_count = i
-                        update_flush_count = False
-                    peak_cruise_v2 = min(move.max_cruise_v2, (
-                        smoothed_v2 + reachable_smoothed_v2) * .5)
-                    if delayed:
-                        # Propagate peak_cruise_v2 to any delayed moves
-                        if not update_flush_count and i < flush_count:
-                            mc_v2 = peak_cruise_v2
-                            for m, ms_v2, me_v2 in reversed(delayed):
-                                mc_v2 = min(mc_v2, ms_v2)
-                                m.set_junction(min(ms_v2, mc_v2), mc_v2
-                                               , min(me_v2, mc_v2))
-                        del delayed[:]
-                if not update_flush_count and i < flush_count:
-                    cruise_v2 = min((start_v2 + reachable_start_v2) * .5
-                                    , move.max_cruise_v2, peak_cruise_v2)
-                    move.set_junction(min(start_v2, cruise_v2), cruise_v2
-                                      , min(next_end_v2, cruise_v2))
-            else:
-                # Delay calculating this move until peak_cruise_v2 is known
-                delayed.append((move, start_v2, next_end_v2))
-            next_end_v2 = start_v2
-            next_smoothed_v2 = smoothed_v2
-        if update_flush_count or not flush_count:
+        if not flush_count:
             return
+        # if flush_count > 150:
+        #     profile = cProfile.Profile()
+        #     profile.enable()
+        starttime = time.time()
+        flush_count=mymovie.Py_move_queue_flush_cal(flush_count,lazy)
+        # print(f"flush_count:{flush_count} time:{time.time()-starttime}")
         # Generate step times for all moves ready to be flushed
-        self.toolhead._process_moves(queue[:flush_count])
-        # Remove processed moves from the queue
-        del queue[:flush_count]
+        if flush_count:
+            # starttime = time.time()
+            self.toolhead._process_moves(queue[:flush_count])
+            # print(f"_process_moves flush_count:{flush_count} time:{time.time()-starttime}")
+            # Remove processed moves from the queue
+            mymovie.Py_move_queue_del(flush_count)
+            print(f"c++ flush:{flush_count} time:{time.time()-starttime}")
+            del queue[:flush_count]
+        # if flush_count > 150:
+        #     profile.disable()
+        #     stats = pstats.Stats(profile)
+        #     stats.sort_stats('cumulative')
+        #     stats.print_stats(20)
     def add_move(self, move):
-        self.queue.append(move)
+        self.queue.append([move,[]])
+        # mymovie.Py_move_queue_add(move)
         if len(self.queue) == 1:
             return
-        move.calc_junction(self.queue[-2])
+        # pre_move = self.queue[-2][0]
+        # if not move.is_kinematic_move or not pre_move.is_kinematic_move:
+        #     return
+        # extruder_v2 = self.toolhead.extruder.calc_junction(pre_move, move)
+        # move.calc_junction(pre_move,extruder_v2)
         self.junction_flush -= move.min_move_t
         if self.junction_flush <= 0.:
             # Enough moves have been queued to reach the target flush time.
@@ -198,6 +92,21 @@ class DripModeEndSignal(Exception):
 # Main code to track events (and their timing) on the printer toolhead
 class ToolHead:
     def __init__(self, config):
+        # double_array_type = ctypes.c_double * 14
+        self._double_array = [0.0,0.0,0.0,0.0,
+                             0.0,0.0,0.0,0.0,
+                             0.0,0.0,0.0,0.0,
+                             0.0,0.0]
+        # n_items = len(self._double_array)
+
+        # self.double_array = (ctypes.c_double * n_items)(*self._double_array)
+        # self.double_array_ptr_int =ctypes.cast(self.double_array, ctypes.c_void_p).value
+
+        self.double_array = np.array(self._double_array, dtype=np.float64)
+        self.double_array_ptr_int = self.double_array.ctypes.data
+        mymovie.Py_set_cur_move_addr(self.double_array_ptr_int)
+        self.config = config
+        self.qmode_flag = 0
         self.printer = config.get_printer()
         self.reactor = self.printer.get_reactor()
         self.all_mcus = [
@@ -208,17 +117,27 @@ class ToolHead:
             self.can_pause = False
         self.move_queue = MoveQueue(self)
         self.commanded_pos = [0., 0., 0., 0.]
+        self.double_array[4]=self.commanded_pos[0]
+        self.double_array[5]=self.commanded_pos[1]
+        self.double_array[6]=self.commanded_pos[2]
+        self.double_array[7]=self.commanded_pos[3]
         self.printer.register_event_handler("klippy:shutdown",
                                             self._handle_shutdown)
         # Velocity and acceleration control
-        self.max_velocity = config.getfloat('max_velocity', above=0.)
-        self.max_accel = config.getfloat('max_accel', above=0.)
+        self.__max_velocity = config.getfloat('max_velocity', above=0.)
+        self.double_array[1]=self.__max_velocity
+        self.__max_accel = config.getfloat('max_accel', above=0.)
+        self.double_array[0]=self.__max_accel
         self.requested_accel_to_decel = config.getfloat(
-            'max_accel_to_decel', self.max_accel * 0.5, above=0.)
-        self.max_accel_to_decel = self.requested_accel_to_decel
+            'max_accel_to_decel', self.__max_accel * 0.5, above=0.)
+        self.__max_accel_to_decel = self.requested_accel_to_decel
+        self.double_array[3]=self.__max_accel_to_decel
         self.square_corner_velocity = config.getfloat(
             'square_corner_velocity', 5., minval=0.)
-        self.junction_deviation = 0.
+        self.square_corner_max_velocity = config.getfloat(
+            'square_corner_max_velocity', 200., minval=0.)
+        self.__junction_deviation = 0.
+        self.double_array[2]=self.__junction_deviation
         self._calc_junction_deviation()
         # Print time tracking
         self.buffer_time_low = config.getfloat(
@@ -246,11 +165,14 @@ class ToolHead:
         self.trapq = ffi_main.gc(ffi_lib.trapq_alloc(), ffi_lib.trapq_free)
         self.trapq_append = ffi_lib.trapq_append
         self.trapq_finalize_moves = ffi_lib.trapq_finalize_moves
+        self.trapq_append_from_moveq = ffi_lib.trapq_append_from_moveq
         self.step_generators = []
         # Create kinematics class
         gcode = self.printer.lookup_object('gcode')
         self.Coord = gcode.Coord
         self.extruder = kinematics.extruder.DummyExtruder(self.printer)
+        if hasattr(self.extruder, 'info_array_addr_int'):
+            mymovie.Py_set_extruder_info(self.extruder.info_array_addr_int)
         kin_name = config.get('kinematics')
         try:
             mod = importlib.import_module('kinematics.' + kin_name)
@@ -264,6 +186,7 @@ class ToolHead:
             logging.exception(msg)
             raise config.error(msg)
         # Register commands
+        gcode.register_command('SET_G29_FLAG', self.cmd_SET_G29_FLAG)
         gcode.register_command('G4', self.cmd_G4)
         gcode.register_command('M400', self.cmd_M400)
         gcode.register_command('SET_VELOCITY_LIMIT',
@@ -271,10 +194,45 @@ class ToolHead:
                                desc=self.cmd_SET_VELOCITY_LIMIT_help)
         gcode.register_command('M204', self.cmd_M204)
         # Load some default modules
-        modules = ["gcode_move", "homing", "idle_timeout", "statistics",
+        modules = ["gcode_move", "homing", "idle_timeout", "statistics_ext",
                    "manual_probe", "tuning_tower"]
         for module_name in modules:
             self.printer.load_object(config, module_name)
+        self.z_pos_filepath = os.path.join(base_dir, "creality/userdata/config/z_pos.json")
+        self.z_pos = self.get_z_pos()
+        if self.config.has_section("motor_control") and self.config.getsection('motor_control').getint('switch')==1:
+            self.printer.register_event_handler("klippy:ready", self.printer.lookup_object('motor_control').set_motor_pin)
+        self.G29_flag = False
+    def cmd_SET_G29_FLAG(self, gcmd):
+        value = gcmd.get_int('VALUE', 0)
+        if value == 1:
+            self.G29_flag = True
+        else:
+            self.G29_flag = False
+    def get_max_accel(self):
+        return self.__max_accel
+    def set_max_accel(self, value):
+        self.__max_accel = value
+        self.double_array[0]=value
+    def get_max_velocity_only(self):
+        return self.__max_velocity
+    def set_max_velocity(self, value):
+        self.__max_velocity = value
+        self.double_array[1]=value
+    def get_max_accel_to_decel(self):
+        return self.__max_accel_to_decel
+    def set_max_accel_to_decel(self, value):
+        self.__max_accel_to_decel = value
+        self.double_array[3]=value
+    def get_z_pos(self):
+        z_pos = 0
+        if os.path.exists(self.z_pos_filepath):
+            try:
+                with open(self.z_pos_filepath, "r") as f:
+                    z_pos = float(json.loads(f.read()).get("z_pos", 0))
+            except Exception as err:
+                logging.error(err)
+        return z_pos
     # Print time tracking
     def _update_move_time(self, next_print_time):
         batch_time = MOVE_BATCH_TIME
@@ -314,25 +272,33 @@ class ToolHead:
             self._calc_print_time()
         # Queue moves into trapezoid motion queue (trapq)
         next_move_time = self.print_time
-        for move in moves:
-            if move.is_kinematic_move:
-                self.trapq_append(
-                    self.trapq, next_move_time,
-                    move.accel_t, move.cruise_t, move.decel_t,
-                    move.start_pos[0], move.start_pos[1], move.start_pos[2],
-                    move.axes_r[0], move.axes_r[1], move.axes_r[2],
-                    move.start_v, move.cruise_v, move.accel)
-            if move.axes_d[3]:
-                self.extruder.move(next_move_time, move)
-            next_move_time = (next_move_time + move.accel_t
-                              + move.cruise_t + move.decel_t)
-            for cb in move.timing_callbacks:
-                cb(next_move_time)
+        # start=time.time()
+        return_value=self.trapq_append_from_moveq(self.trapq,self.extruder.trapq,next_move_time,mymovie.Py_get_moveq_only_data_buffer(),len(moves))
+        if return_value.extru_last_position < 109999999:
+            self.extruder.last_position=return_value.extru_last_position
+        # for move in moves:
+        #     _move=move[0]
+        #     _move_cb=move[1]
+        #     if _move.is_kinematic_move:
+        #         self.trapq_append(
+        #             self.trapq, next_move_time,
+        #             _move.accel_t, _move.cruise_t, _move.decel_t,
+        #             _move.start_pos[0], _move.start_pos[1], _move.start_pos[2],
+        #             _move.axes_r[0], _move.axes_r[1], _move.axes_r[2],
+        #             _move.start_v, _move.cruise_v, _move.accel)
+        #     if _move.axes_d[3]:
+        #         self.extruder.move(next_move_time, _move)
+        #     next_move_time = (next_move_time + _move.accel_t
+        #                       + _move.cruise_t + _move.decel_t)
+            # for cb in _move_cb:
+            #     cb(next_move_time)
+        # time.sleep(0.100)
+        # print(f"trapq_append:{time.time()-start}")
         # Generate steps for moves
         if self.special_queuing_state:
-            self._update_drip_move_time(next_move_time)
-        self._update_move_time(next_move_time)
-        self.last_kin_move_time = next_move_time
+            self._update_drip_move_time(return_value.next_move_time)
+        self._update_move_time(return_value.next_move_time)
+        self.last_kin_move_time = return_value.next_move_time
     def flush_step_generation(self):
         # Transition from "Flushed"/"Priming"/main state to "Flushed" state
         self.move_queue.flush()
@@ -406,17 +372,191 @@ class ToolHead:
         ffi_lib.trapq_set_position(self.trapq, self.print_time,
                                    newpos[0], newpos[1], newpos[2])
         self.commanded_pos[:] = newpos
+        self.double_array[4]=self.commanded_pos[0]
+        self.double_array[5]=self.commanded_pos[1]
+        self.double_array[6]=self.commanded_pos[2]
+        self.double_array[7]=self.commanded_pos[3]
         self.kin.set_position(newpos, homing_axes)
         self.printer.send_event("toolhead:set_position")
+    def record_z_pos(self, commanded_pos_z):
+        if(self.kin.__class__.__name__ == "CoreXYKinematics"):
+            if(self.kin.get_status_for_record_z_pos()):
+                if abs(commanded_pos_z-self.z_pos) > 5:
+                    self.z_pos = commanded_pos_z
+                    with open(self.z_pos_filepath, "w") as f:
+                        f.write(json.dumps({"z_pos": commanded_pos_z}))
+                        f.flush()
+                    print_stats = self.printer.lookup_object('print_stats', None)
+                    print_stats.z_pos = self.z_pos
+                    logging.info("record_z_pos:%s" % commanded_pos_z)
+            return
+        else:
+            curtime = self.printer.get_reactor().monotonic()
+            kin_status = self.kin.get_status(curtime)
+        if ('z' in kin_status['homed_axes']):
+            try:
+                if abs(commanded_pos_z-self.z_pos) > 5:
+                    self.z_pos = commanded_pos_z
+                    with open(self.z_pos_filepath, "w") as f:
+                        f.write(json.dumps({"z_pos": commanded_pos_z}))
+                        f.flush()
+                    print_stats = self.printer.lookup_object('print_stats', None)
+                    print_stats.z_pos = self.z_pos
+                    logging.info("record_z_pos:%s" % commanded_pos_z)
+            except Exception as err:
+                logging.error(err)
+    def check_move_out_of_range(self, ep):
+        toolhead = self.printer.lookup_object('toolhead')
+        code_key = "key243"
+        min_x = toolhead.kin.limits[0][0]
+        max_x = toolhead.kin.limits[0][1]
+        min_y = toolhead.kin.limits[1][0]
+        max_y = toolhead.kin.limits[1][1]
+        min_z = toolhead.kin.limits[2][0]
+        max_z = toolhead.kin.limits[2][1]
+        if min_x > ep[0] or ep[0] > max_x:
+            code_key = "key585"
+        elif min_y > ep[1] or ep[1] > max_y:
+            code_key = "key586"
+        elif min_z > ep[2] or ep[2] > max_z:
+            code_key = "key587"
+        msg="Move out of range"
+        logging.info("stepper xyz min_x:%s max_x:%s|min_y:%s max_y:%s|min_z:%s max_z:%s, toolhead.kin.limits:%s" % (min_x, max_x, min_y, max_y, min_z, max_z, str(toolhead.kin.limits)))
+        m = """{"code":"%s","msg":"%s: %.3f %.3f %.3f [%.3f]", "values":[%.3f, %.3f, %.3f, %.3f]}""" % (
+            code_key, msg, ep[0], ep[1], ep[2], ep[3], ep[0], ep[1], ep[2], ep[3])
+        return m
+    def simple_move(self, newpos):
+        # print("get #################################################move: %s %s" % (newpos, speed))
+        if newpos[2] < self.kin.limits[2][1]:
+            self.record_z_pos(newpos[2])
+        # starttime=time.time()
+        
+        
+        # self.double_array[12]=speed
+        # print(f"time cost of move: {time.time()-starttime}")
+        
+        # starttime=time.time()
+        move = mymovie.PyMove()
+        # print(f"time cost of PyMove: {time.time()-starttime}")
+        
+        if self.double_array[13]==0:
+            self.commanded_pos[:] = newpos
+        elif self.double_array[13]==1:
+            self.commanded_pos[3] = newpos[3]
+        elif self.double_array[13]==-4:
+            print_stats = self.printer.lookup_object('print_stats')
+            gcode = self.printer.lookup_object('gcode')
+            m = """{"code":"key111", "msg": "Extrude below minimum temp, See the 'min_extrude_temp' config option for details", "values": []}"""
+            if print_stats.state == "printing" and self.extrude_below_min_temp_err_is_report==False:
+                gcode._respond_error(m)
+                self.extrude_below_min_temp_err_is_report = True
+                gcode.respond_info("state:%s pause_start:%s" % (self.printer.lookup_object('print_stats').state, self.printer.lookup_object('pause_resume').pause_start))
+                if self.printer.lookup_object('print_stats').state == "printing" and self.printer.lookup_object('pause_resume').pause_start == False:
+                    self.printer.lookup_object('gcode').run_script_from_command("PAUSE")
+            elif print_stats.state == "standby":
+            # elif print_stats.state != "printing":
+                gcode._respond_error(m)
+            return
+            # raise self.printer.command_error("""{"code":"key111", "msg": "Extrude below minimum temp\nSee the 'min_extrude_temp' config option for details", "values": []}""")
+        elif self.double_array[13]==-2:
+            raise self.printer.command_error("Must home axis first")
+        elif self.double_array[13]==-3:
+            m = self.check_move_out_of_range(newpos)
+            # self.printer.lookup_object('gcode')._respond_error(m)
+            print_stats = self.printer.lookup_object('print_stats')
+            if print_stats.state == "printing" and self.printer.lookup_object('pause_resume').pause_start == False and self.printer.lookup_object('virtual_sdcard').is_move_out_of_range_in_printing==False:
+                self.printer.lookup_object('virtual_sdcard').is_move_out_of_range_in_printing=True
+                self.printer.lookup_object('gcode')._respond_error(m)
+            elif print_stats.state != "printing" and print_stats.state != "paused":
+                self.printer.lookup_object('gcode')._respond_error(m)
+            return
+            # raise self.printer.command_error(m)
+            # raise self.printer.command_error("Move out of range")
+        elif self.double_array[13]==-1:
+            return
+        elif self.double_array[13]==-5:
+            raise self.printer.command_error("Extrude only move too long")
+        elif self.double_array[13]==-6:
+            raise self.printer.command_error("""{"code":"key112", "msg": "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\nSee the 'max_extrude_cross_section' config option for details", "values": [%.3f, %.3f]}""")
+        # if not move.move_d:
+        #     return
+        # if move.is_kinematic_move:
+        #     self.kin.check_move(move)
+        # if move.axes_d[3]:
+        #     self.extruder.check_move(move)
+        # self.commanded_pos[:] = move.end_pos
+        self.move_queue.add_move(move)
+        if self.print_time > self.need_check_stall:
+            # print(f"before _check_stall: {self.print_time} {self.need_check_stall} {self.special_queuing_state}")
+            self._check_stall()
+            # print(f"after _check_stall: {self.print_time} {self.need_check_stall} {self.special_queuing_state}")
     def move(self, newpos, speed):
-        move = Move(self, self.commanded_pos, newpos, speed)
-        if not move.move_d:
+        # print("get #################################################move: %s %s" % (newpos, speed))
+        if newpos[2] < self.kin.limits[2][1]:
+            self.record_z_pos(newpos[2])
+        # starttime=time.time()
+        # print(f"move:{self.commanded_pos} {newpos} {speed}")
+        self.double_array[4]=self.commanded_pos[0]
+        self.double_array[5]=self.commanded_pos[1]
+        self.double_array[6]=self.commanded_pos[2]
+        self.double_array[7]=self.commanded_pos[3]
+        self.double_array[8]=newpos[0]
+        self.double_array[9]=newpos[1]
+        self.double_array[10]=newpos[2]
+        self.double_array[11]=newpos[3]
+        self.double_array[12]=speed
+        # print(f"time cost of move: {time.time()-starttime}")
+        
+        # starttime=time.time()
+        move = mymovie.PyMove()
+        # print(f"time cost of PyMove: {time.time()-starttime}")
+        # print(f"return:{self.double_array[13]}")
+        if self.double_array[13]==0:
+            self.commanded_pos[:] = newpos
+        elif self.double_array[13]==1:
+            self.commanded_pos[3] = newpos[3]
+        elif self.double_array[13]==-4:
+            print_stats = self.printer.lookup_object('print_stats')
+            gcode = self.printer.lookup_object('gcode')
+            m = """{"code":"key111", "msg": "Extrude below minimum temp, See the 'min_extrude_temp' config option for details", "values": []}"""
+            if print_stats.state == "printing" and self.extrude_below_min_temp_err_is_report==False:
+                gcode._respond_error(m)
+                self.extrude_below_min_temp_err_is_report = True
+                gcode.respond_info("state:%s pause_start:%s" % (self.printer.lookup_object('print_stats').state, self.printer.lookup_object('pause_resume').pause_start))
+                if self.printer.lookup_object('print_stats').state == "printing" and self.printer.lookup_object('pause_resume').pause_start == False:
+                    self.printer.lookup_object('gcode').run_script_from_command("PAUSE")
+            elif print_stats.state == "standby":
+            # elif print_stats.state != "printing":
+                gcode._respond_error(m)
+            return
+            # raise self.printer.command_error("""{"code":"key111", "msg": "Extrude below minimum temp\nSee the 'min_extrude_temp' config option for details", "values": []}""")
+        elif self.double_array[13]==-2:
+            raise self.printer.command_error("Must home axis first")
+        elif self.double_array[13]==-3:
+            m = self.check_move_out_of_range(newpos)
+            # self.printer.lookup_object('gcode')._respond_error(m)
+            print_stats = self.printer.lookup_object('print_stats')
+            if print_stats.state == "printing" and self.printer.lookup_object('pause_resume').pause_start == False and self.printer.lookup_object('virtual_sdcard').is_move_out_of_range_in_printing==False:
+                self.printer.lookup_object('virtual_sdcard').is_move_out_of_range_in_printing=True
+                self.printer.lookup_object('gcode')._respond_error(m)
+            elif print_stats.state != "printing" and print_stats.state != "paused":
+                self.printer.lookup_object('gcode')._respond_error(m)
             return
-        if move.is_kinematic_move:
-            self.kin.check_move(move)
-        if move.axes_d[3]:
-            self.extruder.check_move(move)
-        self.commanded_pos[:] = move.end_pos
+            # raise self.printer.command_error(m)
+            # raise self.printer.command_error("Move out of range")
+        elif self.double_array[13]==-1:
+            return
+        elif self.double_array[13]==-5:
+            raise self.printer.command_error("Extrude only move too long")
+        elif self.double_array[13]==-6:
+            raise self.printer.command_error("""{"code":"key112", "msg": "Move exceeds maximum extrusion (%.3fmm^2 vs %.3fmm^2)\nSee the 'max_extrude_cross_section' config option for details", "values": [%.3f, %.3f]}""")
+        # if not move.move_d:
+        #     return
+        # if move.is_kinematic_move:
+        #     self.kin.check_move(move)
+        # if move.axes_d[3]:
+        #     self.extruder.check_move(move)
+        # self.commanded_pos[:] = move.end_pos
         self.move_queue.add_move(move)
         if self.print_time > self.need_check_stall:
             self._check_stall()
@@ -441,7 +581,10 @@ class ToolHead:
             eventtime = self.reactor.pause(eventtime + 0.100)
     def set_extruder(self, extruder, extrude_pos):
         self.extruder = extruder
+        if hasattr(self.extruder, 'info_array_addr_int'):
+            mymovie.Py_set_extruder_info(self.extruder.info_array_addr_int)
         self.commanded_pos[3] = extrude_pos
+        self.double_array[7]=self.commanded_pos[3]
     def get_extruder(self):
         return self.extruder
     # Homing "drip move" handling
@@ -506,10 +649,11 @@ class ToolHead:
                      'estimated_print_time': estimated_print_time,
                      'extruder': self.extruder.get_name(),
                      'position': self.Coord(*self.commanded_pos),
-                     'max_velocity': self.max_velocity,
-                     'max_accel': self.max_accel,
+                     'max_velocity': self.__max_velocity,
+                     'max_accel': self.__max_accel,
                      'max_accel_to_decel': self.requested_accel_to_decel,
-                     'square_corner_velocity': self.square_corner_velocity})
+                     'square_corner_velocity': self.square_corner_velocity,
+                     "G29_flag": self.G29_flag})
         return res
     def _handle_shutdown(self):
         self.can_pause = False
@@ -534,16 +678,18 @@ class ToolHead:
         if last_move is None:
             callback(self.get_last_move_time())
             return
-        last_move.timing_callbacks.append(callback)
+        last_move[1].append(callback)
     def note_kinematic_activity(self, kin_time):
         self.last_kin_move_time = max(self.last_kin_move_time, kin_time)
     def get_max_velocity(self):
-        return self.max_velocity, self.max_accel
+        return self.__max_velocity, self.__max_accel
     def _calc_junction_deviation(self):
         scv2 = self.square_corner_velocity**2
-        self.junction_deviation = scv2 * (math.sqrt(2.) - 1.) / self.max_accel
-        self.max_accel_to_decel = min(self.requested_accel_to_decel,
-                                      self.max_accel)
+        self.__junction_deviation = scv2 * (math.sqrt(2.) - 1.) / self.__max_accel
+        self.double_array[2]=self.__junction_deviation
+        self.__max_accel_to_decel = min(self.requested_accel_to_decel,
+                                      self.__max_accel)
+        self.double_array[3]=self.__max_accel_to_decel
     def cmd_G4(self, gcmd):
         # Dwell
         delay = gcmd.get_float('P', 0., minval=0.) / 1000.
@@ -553,6 +699,21 @@ class ToolHead:
         self.wait_moves()
     cmd_SET_VELOCITY_LIMIT_help = "Set printer velocity limits"
     def cmd_SET_VELOCITY_LIMIT(self, gcmd):
+
+        qmode_max_accel = 0
+        qmode_max_accel_to_decel = 0
+
+        custom_macro = self.printer.lookup_object('custom_macro')
+        self.qmode_flag = custom_macro.qmode_flag
+
+        if self.config.has_section('gcode_macro Qmode'):
+            Qmode = self.config.getsection('gcode_macro Qmode')
+            qmode_max_accel = Qmode.getfloat('variable_max_accel')
+            qmode_max_accel_to_decel = Qmode.getfloat('variable_max_accel_to_decel')
+            # gcmd.respond_info("SET_VELOCITY_LIMIT] qmode_flag={}".format(self.qmode_flag))
+            # gcmd.respond_info("SET_VELOCITY_LIMIT] qmode_max_accel={}".format(qmode_max_accel))
+            # gcmd.respond_info("SET_VELOCITY_LIMIT] qmode_max_accel_to_decel={}".format(qmode_max_accel_to_decel))
+
         max_velocity = gcmd.get_float('VELOCITY', None, above=0.)
         max_accel = gcmd.get_float('ACCEL', None, above=0.)
         square_corner_velocity = gcmd.get_float(
@@ -560,30 +721,49 @@ class ToolHead:
         requested_accel_to_decel = gcmd.get_float(
             'ACCEL_TO_DECEL', None, above=0.)
         if max_velocity is not None:
-            self.max_velocity = max_velocity
+            self.__max_velocity = max_velocity
+            self.double_array[1]=self.__max_velocity
         if max_accel is not None:
-            self.max_accel = max_accel
+            if self.qmode_flag and max_accel > qmode_max_accel:
+                self.__max_accel = qmode_max_accel
+            else:
+                self.__max_accel = max_accel
+            self.double_array[0]=self.__max_accel
+            # gcmd.respond_info("SET_VELOCITY_LIMIT] self.__max_accel={}".format(self.__max_accel))
         if square_corner_velocity is not None:
+            if square_corner_velocity > self.square_corner_max_velocity:
+                square_corner_velocity = self.square_corner_max_velocity
             self.square_corner_velocity = square_corner_velocity
         if requested_accel_to_decel is not None:
-            self.requested_accel_to_decel = requested_accel_to_decel
+            if self.qmode_flag and requested_accel_to_decel > qmode_max_accel_to_decel:
+                self.requested_accel_to_decel = qmode_max_accel_to_decel
+            else:
+                self.requested_accel_to_decel = requested_accel_to_decel
+            # gcmd.respond_info("SET_VELOCITY_LIMIT] self.requested_accel_to_decel={}".format(self.requested_accel_to_decel))
+
         self._calc_junction_deviation()
-        msg = ("max_velocity: %.6f\n"
-               "max_accel: %.6f\n"
-               "max_accel_to_decel: %.6f\n"
-               "square_corner_velocity: %.6f" % (
-                   self.max_velocity, self.max_accel,
-                   self.requested_accel_to_decel,
-                   self.square_corner_velocity))
-        self.printer.set_rollover_info("toolhead", "toolhead: %s" % (msg,))
+        # msg = ("max_velocity: %.6f\n"
+        #        "max_accel: %.6f\n"
+        #        "max_accel_to_decel: %.6f\n"
+        #        "square_corner_velocity: %.6f" % (
+        #            self.max_velocity, self.max_accel,
+        #            self.requested_accel_to_decel,
+        #            self.square_corner_velocity))
+        # self.printer.set_rollover_info("toolhead", "toolhead: %s" % (msg,))
         if (max_velocity is None and
             max_accel is None and
             square_corner_velocity is None and
             requested_accel_to_decel is None):
             gcmd.respond_info(msg, log=False)
     def cmd_M204(self, gcmd):
+        accel_S = int(float(gcmd.get('S', -1)))
+        if accel_S != -1 and accel_S <= 100:
+            accel = 100
+        else:
+            accel = gcmd.get_float('S', None, above=0.)
         # Use S for accel
-        accel = gcmd.get_float('S', None, above=0.)
+        # accel = gcmd.get_float('S', None, above=0.)
+        cmd = "M204 S%s" % accel
         if accel is None:
             # Use minimum of P and T for accel
             p = gcmd.get_float('P', None, above=0.)
@@ -593,8 +773,21 @@ class ToolHead:
                                   % (gcmd.get_commandline(),gcmd.get_commandline()))
                 return
             accel = min(p, t)
-        self.max_accel = accel
+            cmd = "M204 P%s T%s" % (p, t)
+        self.__max_accel = accel
+        self.double_array[0]=self.__max_accel
         self._calc_junction_deviation()
+        v_sd = self.printer.lookup_object('virtual_sdcard', None)
+        print_stats = self.printer.lookup_object('print_stats', None)
+        if print_stats and print_stats.state == "printing" and v_sd and v_sd.count_M204 < 3 and os.path.exists(v_sd.print_file_name_path):
+            v_sd.count_M204 += 1
+            with open(v_sd.print_file_name_path, "r") as f:
+                result = (json.loads(f.read()))
+                result["M204"] = cmd
+            with open(v_sd.print_file_name_path, "w") as f:
+                f.write(json.dumps(result))
+                f.flush()
+            logging.info("Record cmd_M204")
 
 def add_printer_objects(config):
     config.get_printer().add_object('toolhead', ToolHead(config))
--- a/klippy/util.py
+++ b/klippy/util.py
@@ -136,6 +136,8 @@ def get_version_from_file(klippy_src):
 def get_git_version(from_file=True):
     klippy_src = os.path.dirname(__file__)
 
+    return "09faed31-dirty"
+
     # Obtain version info from "git" program
     gitdir = os.path.join(klippy_src, '..')
     prog = ('git', '-C', gitdir, 'describe', '--always',
--- a/klippy/webhooks.py
+++ b/klippy/webhooks.py
@@ -228,11 +228,15 @@ class ClientConnection:
         except socket.error as e:
             # If bad file descriptor allow connection to be
             # closed by the data check
+            logging.error("process_received 1 e:%s" % str(e))
             if e.errno == errno.EBADF:
+                logging.error("process_received 2 e:%s" % str(e))
                 data = b""
             else:
+                logging.error("process_received 3 %s" % str(e.errno))
                 return
         if not data:
+            logging.error("process_received 4 not data Socket Closed")
             # Socket Closed
             self.close()
             return
@@ -300,6 +304,7 @@ class WebHooks:
         self._endpoints = {"list_endpoints": self._handle_list_endpoints}
         self._remote_methods = {}
         self._mux_endpoints = {}
+        self.register_endpoint("shakehands", self._handle_shakehands_request)
         self.register_endpoint("info", self._handle_info_request)
         self.register_endpoint("emergency_stop", self._handle_estop_request)
         self.register_endpoint("register_remote_method",
@@ -341,6 +346,19 @@ class WebHooks:
     def _handle_list_endpoints(self, web_request):
         web_request.send({'endpoints': list(self._endpoints.keys())})
 
+    def _handle_shakehands_request(self, web_request):
+        try:
+            state_message, state = self.printer.get_state_message()
+            response = {"state": state, "state_message": state_message}
+            curtime = self.printer.get_reactor().monotonic()
+            web_request_id = web_request.id
+            response["shakehands_id"] = web_request_id
+            response["curtime"] = curtime
+            web_request.send(response)
+        except Exception as err:
+            err_msg = "_handle_shakehands_request err " + str(err)
+            logging.error(err_msg)
+
     def _handle_info_request(self, web_request):
         client_info = web_request.get_dict('client_info', None)
         if client_info is not None:
@@ -507,8 +525,9 @@ class QueryStatusHelper:
             self.query_timer = None
             return reactor.NEVER
         return eventtime + SUBSCRIPTION_REFRESH_TIME
-    def _handle_query(self, web_request, is_subscribe=False):
+    def _handle_query(self, web_request, is_subscribe=False, handle_subscribe=False):
         objects = web_request.get_dict('objects')
+        logging.info("_handle_query objects/subscribe:%s" % str(objects)) if handle_subscribe else None
         # Validate subscription format
         for k, v in objects.items():
             if type(k) != str or (v is not None and type(v) != list):
@@ -530,12 +549,14 @@ class QueryStatusHelper:
             qt = reactor.register_timer(self._do_query, reactor.NOW)
             self.query_timer = qt
         # Wait for data to be queried
+        logging.info("_handle_query before complete.wait") if handle_subscribe else None
         msg = complete.wait()
+        logging.info("_handle_query after complete.wait:%s" % str(msg['params'])) if handle_subscribe else None
         web_request.send(msg['params'])
         if is_subscribe:
             self.clients[cconn] = (cconn, objects, cconn.send, template)
     def _handle_subscribe(self, web_request):
-        self._handle_query(web_request, is_subscribe=True)
+        self._handle_query(web_request, is_subscribe=True, handle_subscribe=True)
 
 def add_early_printer_objects(printer):
     printer.add_object('webhooks', WebHooks(printer))
--- a/scripts/spi_flash/board_defs.py
+++ b/scripts/spi_flash/board_defs.py
@@ -110,12 +110,6 @@ BOARD_DEFS = {
         'mcu': "stm32f405xx",
         'spi_bus': "spi1",
         "cs_pin": "PA4"
-    },
-    'fysetc-cheetah': {
-        'mcu': "stm32f401xc",
-        'spi_bus': "spi1",
-        "cs_pin": "PA4",
-        "current_firmware_path": "OLD.BIN"
     }
 }
 
@@ -144,8 +138,7 @@ BOARD_ALIASES = {
     'btt-skr-e3-dip': BOARD_DEFS['btt-skr-mini'],
     'btt002-v1': BOARD_DEFS['btt-skr-mini'],
     'creality-v4.2.7': BOARD_DEFS['creality-v4.2.2'],
-    'btt-skr-2-f407': BOARD_DEFS['btt-octopus-f407-v1'],
-    'btt-skr-2-f429': BOARD_DEFS['btt-octopus-f429-v1'],
+    'btt-skr-2': BOARD_DEFS['btt-octopus-f407-v1'],
     'btt-octopus-f407-v1.0': BOARD_DEFS['btt-octopus-f407-v1'],
     'btt-octopus-f407-v1.1': BOARD_DEFS['btt-octopus-f407-v1'],
     'btt-octopus-f429-v1.0': BOARD_DEFS['btt-octopus-f429-v1'],
@@ -158,7 +151,6 @@ BOARD_ALIASES = {
     'btt-skr-pro-v1.2': BOARD_DEFS['btt-skr-pro'],
     'btt-gtr-v1': BOARD_DEFS['btt-gtr'],
     'mks-robin-e3d': BOARD_DEFS['mks-robin-e3'],
-    'fysetc-cheetah-v2': BOARD_DEFS['fysetc-cheetah'],
     'fysetc-spider-v1': BOARD_DEFS['fysetc-spider'],
     'fysetc-s6-v1.2': BOARD_DEFS['fysetc-spider'],
     'fysetc-s6-v2': BOARD_DEFS['fysetc-spider'],

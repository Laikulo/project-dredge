--- a/klippy/chelper/stepcompress.c
+++ b/klippy/chelper/stepcompress.c
@@ -63,6 +63,7 @@ struct history_steps {
     int step_count, interval, add;
 };
 
+// uint32_t pre_interval;
 
 /****************************************************************
  * Step compression
@@ -209,10 +210,22 @@ check_line(struct stepcompress *sc, struct step_move move)
 {
     if (!CHECK_LINES)
         return 0;
+
     if (!move.count || (!move.interval && !move.add && move.count > 1)
         || move.interval >= 0x80000000) {
         errorf("stepcompress o=%d i=%d c=%d a=%d: Invalid sequence"
                , sc->oid, move.interval, move.count, move.add);
+        errorf("stepcompress queue[%p]=%u queue_end[%p]=%u queue_pos[%p]=%u queue_next[%p]=%u last_step_clock=%llu max_error=%u : lxc check_line"
+               , sc->queue, *(sc->queue), sc->queue_end, *(sc->queue_end), sc->queue_pos, *(sc->queue_pos),
+               sc->queue_next, *(sc->queue_next), sc->last_step_clock, sc->max_error);
+        uint16_t i;
+        uint32_t intervals = move.interval, ps = 0;
+        for (i=0; i<move.count; i++) {
+            ps += intervals;
+            struct points points = minmax_point(sc, sc->queue_pos + i);
+            errorf("stepcompress queue_pos+i=%u ps=%u minp=%u maxp=%u : lxc Invalid sequence 2"
+               , *(sc->queue_pos + i), ps, points.minp, points.maxp);
+        }
         return ERROR_RET;
     }
     uint32_t interval = move.interval, p = 0;
@@ -359,6 +372,7 @@ add_move(struct stepcompress *sc, uint64_t first_clock, struct step_move *move)
     list_add_tail(&qm->node, &sc->msg_queue);
     sc->last_step_clock = last_clock;
 
+    // pre_interval = move->interval;
     // Create and store move in history tracking
     struct history_steps *hs = malloc(sizeof(*hs));
     hs->first_clock = first_clock;

--- a/klippy/extras/ad5206.py
+++ /dev/null
@@ -1,22 +0,0 @@
-# AD5206 digipot code
-#
-# Copyright (C) 2017,2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus
-
-class ad5206:
-    def __init__(self, config):
-        self.spi = bus.MCU_SPI_from_config(
-            config, 0, pin_option="enable_pin", default_speed=25000000)
-        scale = config.getfloat('scale', 1., above=0.)
-        for i in range(6):
-            val = config.getfloat('channel_%d' % (i+1,), None,
-                                  minval=0., maxval=scale)
-            if val is not None:
-                self.set_register(i, int(val * 256. / scale + .5))
-    def set_register(self, reg, value):
-        self.spi.spi_send([reg, value])
-
-def load_config_prefix(config):
-    return ad5206(config)
deleted file mode 100644
--- a/klippy/extras/angle.py
+++ /dev/null
@@ -1,578 +0,0 @@
-# Support for reading SPI magnetic angle sensors
-#
-# Copyright (C) 2021,2022  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, math, threading
-from . import bus, motion_report
-
-MIN_MSG_TIME = 0.100
-TCODE_ERROR = 0xff
-
-TRINAMIC_DRIVERS = ["tmc2130", "tmc2208", "tmc2209", "tmc2660", "tmc5160"]
-
-CALIBRATION_BITS = 6 # 64 entries
-ANGLE_BITS = 16 # angles range from 0..65535
-
-class AngleCalibration:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name()
-        self.stepper_name = config.get('stepper', None)
-        if self.stepper_name is None:
-            # No calibration
-            return
-        try:
-            import numpy
-        except:
-            raise config.error("Angle calibration requires numpy module")
-        sconfig = config.getsection(self.stepper_name)
-        sconfig.getint('microsteps', note_valid=False)
-        self.tmc_module = self.mcu_stepper = None
-        # Current calibration data
-        self.mcu_pos_offset = None
-        self.angle_phase_offset = 0.
-        self.calibration_reversed = False
-        self.calibration = []
-        cal = config.get('calibrate', None)
-        if cal is not None:
-            data = [d.strip() for d in cal.split(',')]
-            angles = [float(d) for d in data if d]
-            self.load_calibration(angles)
-        # Register commands
-        self.printer.register_event_handler("stepper:sync_mcu_position",
-                                            self.handle_sync_mcu_pos)
-        self.printer.register_event_handler("klippy:connect", self.connect)
-        cname = self.name.split()[-1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("ANGLE_CALIBRATE", "CHIP",
-                                   cname, self.cmd_ANGLE_CALIBRATE,
-                                   desc=self.cmd_ANGLE_CALIBRATE_help)
-    def handle_sync_mcu_pos(self, mcu_stepper):
-        if mcu_stepper.get_name() == self.stepper_name:
-            self.mcu_pos_offset = None
-    def calc_mcu_pos_offset(self, sample):
-        # Lookup phase information
-        mcu_phase_offset, phases = self.tmc_module.get_phase_offset()
-        if mcu_phase_offset is None:
-            return
-        # Find mcu position at time of sample
-        angle_time, angle_pos = sample
-        mcu_pos = self.mcu_stepper.get_past_mcu_position(angle_time)
-        # Convert angle_pos to mcu_pos units
-        microsteps, full_steps = self.get_microsteps()
-        angle_to_mcu_pos = full_steps * microsteps / float(1<<ANGLE_BITS)
-        angle_mpos = angle_pos * angle_to_mcu_pos
-        # Calculate adjustment for stepper phases
-        phase_diff = ((angle_mpos + self.angle_phase_offset * angle_to_mcu_pos)
-                      - (mcu_pos + mcu_phase_offset)) % phases
-        if phase_diff > phases//2:
-            phase_diff -= phases
-        # Store final offset
-        self.mcu_pos_offset = mcu_pos - (angle_mpos - phase_diff)
-    def apply_calibration(self, samples):
-        calibration = self.calibration
-        if not calibration:
-            return None
-        calibration_reversed = self.calibration_reversed
-        interp_bits = ANGLE_BITS - CALIBRATION_BITS
-        interp_mask = (1 << interp_bits) - 1
-        interp_round = 1 << (interp_bits - 1)
-        for i, (samp_time, angle) in enumerate(samples):
-            bucket = (angle & 0xffff) >> interp_bits
-            cal1 = calibration[bucket]
-            cal2 = calibration[bucket + 1]
-            adj = (angle & interp_mask) * (cal2 - cal1)
-            adj = cal1 + ((adj + interp_round) >> interp_bits)
-            angle_diff = (angle - adj) & 0xffff
-            angle_diff -= (angle_diff & 0x8000) << 1
-            new_angle = angle - angle_diff
-            if calibration_reversed:
-                new_angle = -new_angle
-            samples[i] = (samp_time, new_angle)
-        if self.mcu_pos_offset is None:
-            self.calc_mcu_pos_offset(samples[0])
-            if self.mcu_pos_offset is None:
-                return None
-        return self.mcu_stepper.mcu_to_commanded_position(self.mcu_pos_offset)
-    def load_calibration(self, angles):
-        # Calculate linear intepolation calibration buckets by solving
-        # linear equations
-        angle_max = 1 << ANGLE_BITS
-        calibration_count = 1 << CALIBRATION_BITS
-        bucket_size = angle_max // calibration_count
-        full_steps = len(angles)
-        nominal_step = float(angle_max) / full_steps
-        self.angle_phase_offset = (angles.index(min(angles)) & 3) * nominal_step
-        self.calibration_reversed = angles[-2] > angles[-1]
-        if self.calibration_reversed:
-            angles = list(reversed(angles))
-        first_step = angles.index(min(angles))
-        angles = angles[first_step:] + angles[:first_step]
-        import numpy
-        eqs = numpy.zeros((full_steps, calibration_count))
-        ans = numpy.zeros((full_steps,))
-        for step, angle in enumerate(angles):
-            int_angle = int(angle + .5) % angle_max
-            bucket = int(int_angle / bucket_size)
-            bucket_start = bucket * bucket_size
-            ang_diff = angle - bucket_start
-            ang_diff_per = ang_diff / bucket_size
-            eq = eqs[step]
-            eq[bucket] = 1. - ang_diff_per
-            eq[(bucket + 1) % calibration_count] = ang_diff_per
-            ans[step] = float(step * nominal_step)
-            if bucket + 1 >= calibration_count:
-                ans[step] -= ang_diff_per * angle_max
-        sol = numpy.linalg.lstsq(eqs, ans, rcond=None)[0]
-        isol = [int(s + .5) for s in sol]
-        self.calibration = isol + [isol[0] + angle_max]
-    def lookup_tmc(self):
-        for driver in TRINAMIC_DRIVERS:
-            driver_name = "%s %s" % (driver, self.stepper_name)
-            module = self.printer.lookup_object(driver_name, None)
-            if module is not None:
-                return module
-        raise self.printer.command_error("Unable to find TMC driver for %s"
-                                         % (self.stepper_name,))
-    def connect(self):
-        self.tmc_module = self.lookup_tmc()
-        fmove = self.printer.lookup_object('force_move')
-        self.mcu_stepper = fmove.lookup_stepper(self.stepper_name)
-    def get_microsteps(self):
-        configfile = self.printer.lookup_object('configfile')
-        sconfig = configfile.get_status(None)['settings']
-        stconfig = sconfig.get(self.stepper_name, {})
-        microsteps = stconfig['microsteps']
-        full_steps = stconfig['full_steps_per_rotation']
-        return microsteps, full_steps
-    def get_stepper_phase(self):
-        mcu_phase_offset, phases = self.tmc_module.get_phase_offset()
-        if mcu_phase_offset is None:
-            raise self.printer.command_error("Driver phase not known for %s"
-                                             % (self.stepper_name,))
-        mcu_pos = self.mcu_stepper.get_mcu_position()
-        return (mcu_pos + mcu_phase_offset) % phases
-    def do_calibration_moves(self):
-        move = self.printer.lookup_object('force_move').manual_move
-        # Start data collection
-        angle_sensor = self.printer.lookup_object(self.name)
-        cconn = angle_sensor.start_internal_client()
-        # Move stepper several turns (to allow internal sensor calibration)
-        microsteps, full_steps = self.get_microsteps()
-        mcu_stepper = self.mcu_stepper
-        step_dist = mcu_stepper.get_step_dist()
-        full_step_dist = step_dist * microsteps
-        rotation_dist = full_steps * full_step_dist
-        align_dist = step_dist * self.get_stepper_phase()
-        move_time = 0.010
-        move_speed = full_step_dist / move_time
-        move(mcu_stepper, -(rotation_dist+align_dist), move_speed)
-        move(mcu_stepper, 2. * rotation_dist, move_speed)
-        move(mcu_stepper, -2. * rotation_dist, move_speed)
-        move(mcu_stepper, .5 * rotation_dist - full_step_dist, move_speed)
-        # Move to each full step position
-        toolhead = self.printer.lookup_object('toolhead')
-        times = []
-        samp_dist = full_step_dist
-        for i in range(2 * full_steps):
-            move(mcu_stepper, samp_dist, move_speed)
-            start_query_time = toolhead.get_last_move_time() + 0.050
-            end_query_time = start_query_time + 0.050
-            times.append((start_query_time, end_query_time))
-            toolhead.dwell(0.150)
-            if i == full_steps-1:
-                # Reverse direction and test each full step again
-                move(mcu_stepper, .5 * rotation_dist, move_speed)
-                move(mcu_stepper, -.5 * rotation_dist + samp_dist, move_speed)
-                samp_dist = -samp_dist
-        move(mcu_stepper, .5*rotation_dist + align_dist, move_speed)
-        toolhead.wait_moves()
-        # Finish data collection
-        cconn.finalize()
-        msgs = cconn.get_messages()
-        # Correlate query responses
-        cal = {}
-        step = 0
-        for msg in msgs:
-            for query_time, pos in msg['params']['data']:
-                # Add to step tracking
-                while step < len(times) and query_time > times[step][1]:
-                    step += 1
-                if step < len(times) and query_time >= times[step][0]:
-                    cal.setdefault(step, []).append(pos)
-        if len(cal) != len(times):
-            raise self.printer.command_error(
-                "Failed calibration - incomplete sensor data")
-        fcal = { i: cal[i] for i in range(full_steps) }
-        rcal = { full_steps-i-1: cal[i+full_steps] for i in range(full_steps) }
-        return fcal, rcal
-    def calc_angles(self, meas):
-        total_count = total_variance = 0
-        angles = {}
-        for step, data in meas.items():
-            count = len(data)
-            angle_avg = float(sum(data)) / count
-            angles[step] = angle_avg
-            total_count += count
-            total_variance += sum([(d - angle_avg)**2 for d in data])
-        return angles, math.sqrt(total_variance / total_count), total_count
-    cmd_ANGLE_CALIBRATE_help = "Calibrate angle sensor to stepper motor"
-    def cmd_ANGLE_CALIBRATE(self, gcmd):
-        # Perform calibration movement and capture
-        old_calibration = self.calibration
-        self.calibration = []
-        try:
-            fcal, rcal = self.do_calibration_moves()
-        finally:
-            self.calibration = old_calibration
-        # Calculate each step position average and variance
-        microsteps, full_steps = self.get_microsteps()
-        fangles, fstd, ftotal = self.calc_angles(fcal)
-        rangles, rstd, rtotal = self.calc_angles(rcal)
-        if (len({a: i for i, a in fangles.items()}) != len(fangles)
-            or len({a: i for i, a in rangles.items()}) != len(rangles)):
-            raise self.printer.command_error(
-                "Failed calibration - sensor not updating for each step")
-        merged = { i: fcal[i] + rcal[i] for i in range(full_steps) }
-        angles, std, total = self.calc_angles(merged)
-        gcmd.respond_info("angle: stddev=%.3f (%.3f forward / %.3f reverse)"
-                          " in %d queries" % (std, fstd, rstd, total))
-        # Order data with lowest/highest magnet position first
-        anglist = [angles[i] % 0xffff for i in range(full_steps)]
-        if angles[0] > angles[1]:
-            first_ang = max(anglist)
-        else:
-            first_ang = min(anglist)
-        first_phase = anglist.index(first_ang) & ~3
-        anglist = anglist[first_phase:] + anglist[:first_phase]
-        # Save results
-        cal_contents = []
-        for i, angle in enumerate(anglist):
-            if not i % 8:
-                cal_contents.append('\n')
-            cal_contents.append("%.1f" % (angle,))
-            cal_contents.append(',')
-        cal_contents.pop()
-        configfile = self.printer.lookup_object('configfile')
-        configfile.remove_section(self.name)
-        configfile.set(self.name, 'calibrate', ''.join(cal_contents))
-
-class HelperA1333:
-    SPI_MODE = 3
-    SPI_SPEED = 10000000
-    def __init__(self, config, spi, oid):
-        self.spi = spi
-        self.is_tcode_absolute = False
-        self.last_temperature = None
-    def get_static_delay(self):
-        return .000001
-    def start(self):
-        # Setup for angle query
-        self.spi.spi_transfer([0x32, 0x00])
-
-class HelperAS5047D:
-    SPI_MODE = 1
-    SPI_SPEED = int(1. / .000000350)
-    def __init__(self, config, spi, oid):
-        self.spi = spi
-        self.is_tcode_absolute = False
-        self.last_temperature = None
-    def get_static_delay(self):
-        return .000100
-    def start(self):
-        # Clear any errors from device
-        self.spi.spi_transfer([0xff, 0xfc]) # Read DIAAGC
-        self.spi.spi_transfer([0x40, 0x01]) # Read ERRFL
-        self.spi.spi_transfer([0xc0, 0x00]) # Read NOP
-
-class HelperTLE5012B:
-    SPI_MODE = 1
-    SPI_SPEED = 4000000
-    def __init__(self, config, spi, oid):
-        self.printer = config.get_printer()
-        self.spi = spi
-        self.oid = oid
-        self.is_tcode_absolute = True
-        self.last_temperature = None
-        self.mcu = spi.get_mcu()
-        self.mcu.register_config_callback(self._build_config)
-        self.spi_angle_transfer_cmd = None
-        self.last_chip_mcu_clock = self.last_chip_clock = 0
-        self.chip_freq = 0.
-        name = config.get_name().split()[-1]
-        gcode = self.printer.lookup_object("gcode")
-        gcode.register_mux_command("ANGLE_DEBUG_READ", "CHIP", name,
-                                   self.cmd_ANGLE_DEBUG_READ,
-                                   desc=self.cmd_ANGLE_DEBUG_READ_help)
-        gcode.register_mux_command("ANGLE_DEBUG_WRITE", "CHIP", name,
-                                   self.cmd_ANGLE_DEBUG_WRITE,
-                                   desc=self.cmd_ANGLE_DEBUG_WRITE_help)
-    def _build_config(self):
-        cmdqueue = self.spi.get_command_queue()
-        self.spi_angle_transfer_cmd = self.mcu.lookup_query_command(
-            "spi_angle_transfer oid=%c data=%*s",
-            "spi_angle_transfer_response oid=%c clock=%u response=%*s",
-            oid=self.oid, cq=cmdqueue)
-    def get_tcode_params(self):
-        return self.last_chip_mcu_clock, self.last_chip_clock, self.chip_freq
-    def _calc_crc(self, data):
-        crc = 0xff
-        for d in data:
-            crc ^= d
-            for i in range(8):
-                if crc & 0x80:
-                    crc = (crc << 1) ^ 0x1d
-                else:
-                    crc <<= 1
-        return (~crc) & 0xff
-    def _send_spi(self, msg):
-        for retry in range(5):
-            if msg[0] & 0x04:
-                params = self.spi_angle_transfer_cmd.send([self.oid, msg])
-            else:
-                params = self.spi.spi_transfer(msg)
-            resp = bytearray(params['response'])
-            crc = self._calc_crc(bytearray(msg[:2]) + resp[2:-2])
-            if crc == resp[-1]:
-                return params
-        raise self.printer.command_error("Unable to query tle5012b chip")
-    def _read_reg(self, reg):
-        cw = 0x8000 | ((reg & 0x3f) << 4) | 0x01
-        if reg >= 0x05 and reg <= 0x11:
-            cw |= 0x5000
-        msg = [cw >> 8, cw & 0xff, 0, 0, 0, 0]
-        params = self._send_spi(msg)
-        resp = bytearray(params['response'])
-        return (resp[2] << 8) | resp[3]
-    def _write_reg(self, reg, val):
-        cw = ((reg & 0x3f) << 4) | 0x01
-        if reg >= 0x05 and reg <= 0x11:
-            cw |= 0x5000
-        msg = [cw >> 8, cw & 0xff, (val >> 8) & 0xff, val & 0xff, 0, 0]
-        for retry in range(5):
-            self._send_spi(msg)
-            rval = self._read_reg(reg)
-            if rval == val:
-                return
-        raise self.printer.command_error("Unable to write to tle5012b chip")
-    def _mask_reg(self, reg, off, on):
-        rval = self._read_reg(reg)
-        self._write_reg(reg, (rval & ~off) | on)
-    def _query_clock(self):
-        # Read frame counter (and normalize to a 16bit counter)
-        msg = [0x84, 0x42, 0, 0, 0, 0, 0, 0] # Read with latch, AREV and FSYNC
-        params = self._send_spi(msg)
-        resp = bytearray(params['response'])
-        mcu_clock = self.mcu.clock32_to_clock64(params['clock'])
-        chip_clock = ((resp[2] & 0x7e) << 9) | ((resp[4] & 0x3e) << 4)
-        # Calculate temperature
-        temper = resp[5] - ((resp[4] & 0x01) << 8)
-        self.last_temperature = (temper + 152) / 2.776
-        return mcu_clock, chip_clock
-    def update_clock(self):
-        mcu_clock, chip_clock = self._query_clock()
-        mdiff = mcu_clock - self.last_chip_mcu_clock
-        chip_mclock = self.last_chip_clock + int(mdiff * self.chip_freq + .5)
-        cdiff = (chip_mclock - chip_clock) & 0xffff
-        cdiff -= (cdiff & 0x8000) << 1
-        new_chip_clock = chip_mclock - cdiff
-        self.chip_freq = float(new_chip_clock - self.last_chip_clock) / mdiff
-        self.last_chip_clock = new_chip_clock
-        self.last_chip_mcu_clock = mcu_clock
-    def start(self):
-        # Clear any errors from device
-        self._read_reg(0x00) # Read STAT
-        # Initialize chip (so different chip variants work the same way)
-        self._mask_reg(0x06, 0xc003, 0x4000) # MOD1: 42.7us, IIF disable
-        self._mask_reg(0x08, 0x0007, 0x0001) # MOD2: Predict off, autocal=1
-        self._mask_reg(0x0e, 0x0003, 0x0000) # MOD4: IIF mode
-        # Setup starting clock values
-        mcu_clock, chip_clock = self._query_clock()
-        self.last_chip_clock = chip_clock
-        self.last_chip_mcu_clock = mcu_clock
-        self.chip_freq = float(1<<5) / self.mcu.seconds_to_clock(1. / 750000.)
-        self.update_clock()
-    cmd_ANGLE_DEBUG_READ_help = "Query low-level angle sensor register"
-    def cmd_ANGLE_DEBUG_READ(self, gcmd):
-        reg = gcmd.get("REG", minval=0, maxval=0x30, parser=lambda x: int(x, 0))
-        val = self._read_reg(reg)
-        gcmd.respond_info("ANGLE REG[0x%02x] = 0x%04x" % (reg, val))
-    cmd_ANGLE_DEBUG_WRITE_help = "Set low-level angle sensor register"
-    def cmd_ANGLE_DEBUG_WRITE(self, gcmd):
-        reg = gcmd.get("REG", minval=0, maxval=0x30, parser=lambda x: int(x, 0))
-        val = gcmd.get("VAL", minval=0, maxval=0xffff,
-                       parser=lambda x: int(x, 0))
-        self._write_reg(reg, val)
-
-SAMPLE_PERIOD = 0.000400
-
-class Angle:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.sample_period = config.getfloat('sample_period', SAMPLE_PERIOD,
-                                             above=0.)
-        self.calibration = AngleCalibration(config)
-        # Measurement conversion
-        self.start_clock = self.time_shift = self.sample_ticks = 0
-        self.last_sequence = self.last_angle = 0
-        # Measurement storage (accessed from background thread)
-        self.lock = threading.Lock()
-        self.raw_samples = []
-        # Sensor type
-        sensors = { "a1333": HelperA1333, "as5047d": HelperAS5047D,
-                    "tle5012b": HelperTLE5012B }
-        sensor_type = config.getchoice('sensor_type', {s: s for s in sensors})
-        sensor_class = sensors[sensor_type]
-        self.spi = bus.MCU_SPI_from_config(config, sensor_class.SPI_MODE,
-                                           default_speed=sensor_class.SPI_SPEED)
-        self.mcu = mcu = self.spi.get_mcu()
-        self.oid = oid = mcu.create_oid()
-        self.sensor_helper = sensor_class(config, self.spi, oid)
-        # Setup mcu sensor_spi_angle bulk query code
-        self.query_spi_angle_cmd = self.query_spi_angle_end_cmd = None
-        mcu.add_config_cmd(
-            "config_spi_angle oid=%d spi_oid=%d spi_angle_type=%s"
-            % (oid, self.spi.get_oid(), sensor_type))
-        mcu.add_config_cmd(
-            "query_spi_angle oid=%d clock=0 rest_ticks=0 time_shift=0"
-            % (oid,), on_restart=True)
-        mcu.register_config_callback(self._build_config)
-        mcu.register_response(self._handle_spi_angle_data,
-                              "spi_angle_data", oid)
-        # API server endpoints
-        self.api_dump = motion_report.APIDumpHelper(
-            self.printer, self._api_update, self._api_startstop, 0.100)
-        self.name = config.get_name().split()[1]
-        wh = self.printer.lookup_object('webhooks')
-        wh.register_mux_endpoint("angle/dump_angle", "sensor", self.name,
-                                 self._handle_dump_angle)
-    def _build_config(self):
-        freq = self.mcu.seconds_to_clock(1.)
-        while float(TCODE_ERROR << self.time_shift) / freq < 0.002:
-            self.time_shift += 1
-        cmdqueue = self.spi.get_command_queue()
-        self.query_spi_angle_cmd = self.mcu.lookup_command(
-            "query_spi_angle oid=%c clock=%u rest_ticks=%u time_shift=%c",
-            cq=cmdqueue)
-        self.query_spi_angle_end_cmd = self.mcu.lookup_query_command(
-            "query_spi_angle oid=%c clock=%u rest_ticks=%u time_shift=%c",
-            "spi_angle_end oid=%c sequence=%hu", oid=self.oid, cq=cmdqueue)
-    def get_status(self, eventtime=None):
-        return {'temperature': self.sensor_helper.last_temperature}
-    # Measurement collection
-    def is_measuring(self):
-        return self.start_clock != 0
-    def _handle_spi_angle_data(self, params):
-        with self.lock:
-            self.raw_samples.append(params)
-    def _extract_samples(self, raw_samples):
-        # Load variables to optimize inner loop below
-        sample_ticks = self.sample_ticks
-        start_clock = self.start_clock
-        clock_to_print_time = self.mcu.clock_to_print_time
-        last_sequence = self.last_sequence
-        last_angle = self.last_angle
-        time_shift = 0
-        static_delay = 0.
-        last_chip_mcu_clock = last_chip_clock = chip_freq = inv_chip_freq = 0.
-        is_tcode_absolute = self.sensor_helper.is_tcode_absolute
-        if is_tcode_absolute:
-            tparams = self.sensor_helper.get_tcode_params()
-            last_chip_mcu_clock, last_chip_clock, chip_freq = tparams
-            inv_chip_freq = 1. / chip_freq
-        else:
-            time_shift = self.time_shift
-            static_delay = self.sensor_helper.get_static_delay()
-        # Process every message in raw_samples
-        count = error_count = 0
-        samples = [None] * (len(raw_samples) * 16)
-        for params in raw_samples:
-            seq = (last_sequence & ~0xffff) | params['sequence']
-            if seq < last_sequence:
-                seq += 0x10000
-            last_sequence = seq
-            d = bytearray(params['data'])
-            msg_mclock = start_clock + seq*16*sample_ticks
-            for i in range(len(d) // 3):
-                tcode = d[i*3]
-                if tcode == TCODE_ERROR:
-                    error_count += 1
-                    continue
-                raw_angle = d[i*3 + 1] | (d[i*3 + 2] << 8)
-                angle_diff = (last_angle - raw_angle) & 0xffff
-                angle_diff -= (angle_diff & 0x8000) << 1
-                last_angle -= angle_diff
-                mclock = msg_mclock + i*sample_ticks
-                if is_tcode_absolute:
-                    # tcode is tle5012b frame counter
-                    mdiff = mclock - last_chip_mcu_clock
-                    chip_mclock = last_chip_clock + int(mdiff * chip_freq + .5)
-                    cdiff = ((tcode << 10) - chip_mclock) & 0xffff
-                    cdiff -= (cdiff & 0x8000) << 1
-                    sclock = mclock + (cdiff - 0x800) * inv_chip_freq
-                else:
-                    # tcode is mcu clock offset shifted by time_shift
-                    sclock = mclock + (tcode<<time_shift)
-                ptime = round(clock_to_print_time(sclock) - static_delay, 6)
-                samples[count] = (ptime, last_angle)
-                count += 1
-        self.last_sequence = last_sequence
-        self.last_angle = last_angle
-        del samples[count:]
-        return samples, error_count
-    # API interface
-    def _api_update(self, eventtime):
-        if self.sensor_helper.is_tcode_absolute:
-            self.sensor_helper.update_clock()
-        with self.lock:
-            raw_samples = self.raw_samples
-            self.raw_samples = []
-        if not raw_samples:
-            return {}
-        samples, error_count = self._extract_samples(raw_samples)
-        if not samples:
-            return {}
-        offset = self.calibration.apply_calibration(samples)
-        return {'data': samples, 'errors': error_count,
-                'position_offset': offset}
-    def _start_measurements(self):
-        if self.is_measuring():
-            return
-        logging.info("Starting angle '%s' measurements", self.name)
-        self.sensor_helper.start()
-        # Start bulk reading
-        with self.lock:
-            self.raw_samples = []
-        self.last_sequence = 0
-        systime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(systime) + MIN_MSG_TIME
-        self.start_clock = reqclock = self.mcu.print_time_to_clock(print_time)
-        rest_ticks = self.mcu.seconds_to_clock(self.sample_period)
-        self.sample_ticks = rest_ticks
-        self.query_spi_angle_cmd.send([self.oid, reqclock, rest_ticks,
-                                       self.time_shift], reqclock=reqclock)
-    def _finish_measurements(self):
-        if not self.is_measuring():
-            return
-        # Halt bulk reading
-        params = self.query_spi_angle_end_cmd.send([self.oid, 0, 0, 0])
-        self.start_clock = 0
-        with self.lock:
-            self.raw_samples = []
-        self.sensor_helper.last_temperature = None
-        logging.info("Stopped angle '%s' measurements", self.name)
-    def _api_startstop(self, is_start):
-        if is_start:
-            self._start_measurements()
-        else:
-            self._finish_measurements()
-    def _handle_dump_angle(self, web_request):
-        self.api_dump.add_client(web_request)
-        hdr = ('time', 'angle')
-        web_request.send({'header': hdr})
-    def start_internal_client(self):
-        return self.api_dump.add_internal_client()
-
-def load_config_prefix(config):
-    return Angle(config)
deleted file mode 100644
--- a/klippy/extras/bed_screws.py
+++ /dev/null
@@ -1,118 +0,0 @@
-# Helper script to adjust bed screws
-#
-# Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class BedScrews:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reset()
-        self.number_of_screws = 0
-        # Read config
-        screws = []
-        fine_adjust = []
-        for i in range(99):
-            prefix = "screw%d" % (i + 1,)
-            if config.get(prefix, None) is None:
-                break
-            screw_coord = config.getfloatlist(prefix, count=2)
-            screw_name = "screw at %.3f,%.3f" % screw_coord
-            screw_name = config.get(prefix + "_name", screw_name)
-            screws.append((screw_coord, screw_name))
-            pfa = prefix + "_fine_adjust"
-            if config.get(pfa, None) is not None:
-                fine_coord = config.getfloatlist(pfa, count=2)
-                fine_adjust.append((fine_coord, screw_name))
-        if len(screws) < 3:
-            raise config.error("bed_screws: Must have at least three screws")
-        self.number_of_screws = len(screws)
-        self.states = {'adjust': screws, 'fine': fine_adjust}
-        self.speed = config.getfloat('speed', 50., above=0.)
-        self.lift_speed = config.getfloat('probe_speed', 5., above=0.)
-        self.horizontal_move_z = config.getfloat('horizontal_move_z', 5.)
-        self.probe_z = config.getfloat('probe_height', 0.)
-        # Register command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command("BED_SCREWS_ADJUST",
-                                    self.cmd_BED_SCREWS_ADJUST,
-                                    desc=self.cmd_BED_SCREWS_ADJUST_help)
-    def reset(self):
-        self.state = None
-        self.current_screw = 0
-        self.accepted_screws = 0
-    def move(self, coord, speed):
-        self.printer.lookup_object('toolhead').manual_move(coord, speed)
-    def move_to_screw(self, state, screw):
-        # Move up, over, and then down
-        self.move((None, None, self.horizontal_move_z), self.lift_speed)
-        coord, name = self.states[state][screw]
-        self.move((coord[0], coord[1], self.horizontal_move_z), self.speed)
-        self.move((coord[0], coord[1], self.probe_z), self.lift_speed)
-        # Update state
-        self.state = state
-        self.current_screw = screw
-        # Register commands
-        self.gcode.respond_info(
-            "Adjust %s. Then run ACCEPT, ADJUSTED, or ABORT\n"
-            "Use ADJUSTED if a significant screw adjustment is made" % (name,))
-        self.gcode.register_command('ACCEPT', self.cmd_ACCEPT,
-                                    desc=self.cmd_ACCEPT_help)
-        self.gcode.register_command('ADJUSTED', self.cmd_ADJUSTED,
-                                    desc=self.cmd_ADJUSTED_help)
-        self.gcode.register_command('ABORT', self.cmd_ABORT,
-                                    desc=self.cmd_ABORT_help)
-    def unregister_commands(self):
-        self.gcode.register_command('ACCEPT', None)
-        self.gcode.register_command('ADJUSTED', None)
-        self.gcode.register_command('ABORT', None)
-    def get_status(self, eventtime):
-        return {
-            'is_active': self.state is not None,
-            'state': self.state,
-            'current_screw': self.current_screw,
-            'accepted_screws': self.accepted_screws
-        }
-    cmd_BED_SCREWS_ADJUST_help = "Tool to help adjust bed leveling screws"
-    def cmd_BED_SCREWS_ADJUST(self, gcmd):
-        if self.state is not None:
-            raise gcmd.error("Already in bed_screws helper; use ABORT to exit")
-        # reset accepted screws
-        self.accepted_screws = 0
-        self.move((None, None, self.horizontal_move_z), self.speed)
-        self.move_to_screw('adjust', 0)
-    cmd_ACCEPT_help = "Accept bed screw position"
-    def cmd_ACCEPT(self, gcmd):
-        self.unregister_commands()
-        self.accepted_screws = self.accepted_screws + 1
-        if self.current_screw + 1 < len(self.states[self.state]) \
-                and self.accepted_screws < self.number_of_screws:
-            # Continue with next screw
-            self.move_to_screw(self.state, self.current_screw + 1)
-            return
-        if self.accepted_screws < self.number_of_screws:
-            # Retry coarse adjustments
-            self.move_to_screw('adjust', 0)
-            return
-        if self.state == 'adjust' and self.states['fine']:
-            # Reset accepted screws for fine adjustment
-            self.accepted_screws = 0
-            # Perform fine screw adjustments
-            self.move_to_screw('fine', 0)
-            return
-        # Done
-        self.reset()
-        self.move((None, None, self.horizontal_move_z), self.lift_speed)
-        gcmd.respond_info("Bed screws tool completed successfully")
-    cmd_ADJUSTED_help = "Accept bed screw position after notable adjustment"
-    def cmd_ADJUSTED(self, gcmd):
-        self.unregister_commands()
-        self.accepted_screws = -1
-        self.cmd_ACCEPT(gcmd)
-    cmd_ABORT_help = "Abort bed screws tool"
-    def cmd_ABORT(self, gcmd):
-        self.unregister_commands()
-        self.reset()
-
-def load_config(config):
-    return BedScrews(config)
deleted file mode 100644
--- a/klippy/extras/bed_tilt.py
+++ /dev/null
@@ -1,99 +0,0 @@
-# Bed tilt compensation
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-import mathutil
-from . import probe
-
-class BedTilt:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-        self.x_adjust = config.getfloat('x_adjust', 0.)
-        self.y_adjust = config.getfloat('y_adjust', 0.)
-        self.z_adjust = config.getfloat('z_adjust', 0.)
-        if config.get('points', None) is not None:
-            BedTiltCalibrate(config, self)
-        self.toolhead = None
-        # Register move transform with g-code class
-        gcode_move = self.printer.load_object(config, 'gcode_move')
-        gcode_move.set_move_transform(self)
-    def handle_connect(self):
-        self.toolhead = self.printer.lookup_object('toolhead')
-    def get_position(self):
-        x, y, z, e = self.toolhead.get_position()
-        return [x, y, z - x*self.x_adjust - y*self.y_adjust - self.z_adjust, e]
-    def move(self, newpos, speed):
-        x, y, z, e = newpos
-        self.toolhead.move([x, y, z + x*self.x_adjust + y*self.y_adjust
-                            + self.z_adjust, e], speed)
-    def update_adjust(self, x_adjust, y_adjust, z_adjust):
-        self.x_adjust = x_adjust
-        self.y_adjust = y_adjust
-        self.z_adjust = z_adjust
-        gcode_move = self.printer.lookup_object('gcode_move')
-        gcode_move.reset_last_position()
-        configfile = self.printer.lookup_object('configfile')
-        configfile.set('bed_tilt', 'x_adjust', "%.6f" % (x_adjust,))
-        configfile.set('bed_tilt', 'y_adjust', "%.6f" % (y_adjust,))
-        configfile.set('bed_tilt', 'z_adjust', "%.6f" % (z_adjust,))
-
-# Helper script to calibrate the bed tilt
-class BedTiltCalibrate:
-    def __init__(self, config, bedtilt):
-        self.printer = config.get_printer()
-        self.bedtilt = bedtilt
-        self.probe_helper = probe.ProbePointsHelper(config, self.probe_finalize)
-        self.probe_helper.minimum_points(3)
-        # Register BED_TILT_CALIBRATE command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command(
-            'BED_TILT_CALIBRATE', self.cmd_BED_TILT_CALIBRATE,
-            desc=self.cmd_BED_TILT_CALIBRATE_help)
-    cmd_BED_TILT_CALIBRATE_help = "Bed tilt calibration script"
-    def cmd_BED_TILT_CALIBRATE(self, gcmd):
-        self.probe_helper.start_probe(gcmd)
-    def probe_finalize(self, offsets, positions):
-        # Setup for coordinate descent analysis
-        z_offset = offsets[2]
-        logging.info("Calculating bed_tilt with: %s", positions)
-        params = { 'x_adjust': self.bedtilt.x_adjust,
-                   'y_adjust': self.bedtilt.y_adjust,
-                   'z_adjust': z_offset }
-        logging.info("Initial bed_tilt parameters: %s", params)
-        # Perform coordinate descent
-        def adjusted_height(pos, params):
-            x, y, z = pos
-            return (z - x*params['x_adjust'] - y*params['y_adjust']
-                    - params['z_adjust'])
-        def errorfunc(params):
-            total_error = 0.
-            for pos in positions:
-                total_error += adjusted_height(pos, params)**2
-            return total_error
-        new_params = mathutil.coordinate_descent(
-            params.keys(), params, errorfunc)
-        # Update current bed_tilt calculations
-        x_adjust = new_params['x_adjust']
-        y_adjust = new_params['y_adjust']
-        z_adjust = (new_params['z_adjust'] - z_offset
-                    - x_adjust * offsets[0] - y_adjust * offsets[1])
-        self.bedtilt.update_adjust(x_adjust, y_adjust, z_adjust)
-        # Log and report results
-        logging.info("Calculated bed_tilt parameters: %s", new_params)
-        for pos in positions:
-            logging.info("orig: %s new: %s", adjusted_height(pos, params),
-                         adjusted_height(pos, new_params))
-        msg = "x_adjust: %.6f y_adjust: %.6f z_adjust: %.6f" % (
-            x_adjust, y_adjust, z_adjust)
-        self.printer.set_rollover_info("bed_tilt", "bed_tilt: %s" % (msg,))
-        self.gcode.respond_info(
-            "%s\nThe above parameters have been applied to the current\n"
-            "session. The SAVE_CONFIG command will update the printer\n"
-            "config file and restart the printer." % (msg,))
-
-def load_config(config):
-    return BedTilt(config)
deleted file mode 100644
--- a/klippy/extras/bltouch.py
+++ /dev/null
@@ -1,276 +0,0 @@
-# BLTouch support
-#
-# Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import probe
-
-SIGNAL_PERIOD = 0.020
-MIN_CMD_TIME = 5 * SIGNAL_PERIOD
-
-TEST_TIME = 5 * 60.
-RETRY_RESET_TIME = 1.
-ENDSTOP_REST_TIME = .001
-ENDSTOP_SAMPLE_TIME = .000015
-ENDSTOP_SAMPLE_COUNT = 4
-
-Commands = {
-    'pin_down': 0.000650, 'touch_mode': 0.001165,
-    'pin_up': 0.001475, 'self_test': 0.001780, 'reset': 0.002190,
-    'set_5V_output_mode' : 0.001988, 'set_OD_output_mode' : 0.002091,
-    'output_mode_store' : 0.001884,
-}
-
-# BLTouch "endstop" wrapper
-class BLTouchEndstopWrapper:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-        self.printer.register_event_handler('klippy:mcu_identify',
-                                            self.handle_mcu_identify)
-        self.position_endstop = config.getfloat('z_offset', minval=0.)
-        self.stow_on_each_sample = config.getboolean('stow_on_each_sample',
-                                                     True)
-        self.probe_touch_mode = config.getboolean('probe_with_touch_mode',
-                                                  False)
-        # Create a pwm object to handle the control pin
-        ppins = self.printer.lookup_object('pins')
-        self.mcu_pwm = ppins.setup_pin('pwm', config.get('control_pin'))
-        self.mcu_pwm.setup_max_duration(0.)
-        self.mcu_pwm.setup_cycle_time(SIGNAL_PERIOD)
-        # Command timing
-        self.next_cmd_time = self.action_end_time = 0.
-        self.finish_home_complete = self.wait_trigger_complete = None
-        # Create an "endstop" object to handle the sensor pin
-        pin = config.get('sensor_pin')
-        pin_params = ppins.lookup_pin(pin, can_invert=True, can_pullup=True)
-        mcu = pin_params['chip']
-        self.mcu_endstop = mcu.setup_pin('endstop', pin_params)
-        # output mode
-        omodes = {'5V': '5V', 'OD': 'OD', None: None}
-        self.output_mode = config.getchoice('set_output_mode', omodes, None)
-        # Setup for sensor test
-        self.next_test_time = 0.
-        self.pin_up_not_triggered = config.getboolean(
-            'pin_up_reports_not_triggered', True)
-        self.pin_up_touch_triggered = config.getboolean(
-            'pin_up_touch_mode_reports_triggered', True)
-        # Calculate pin move time
-        self.pin_move_time = config.getfloat('pin_move_time', 0.680, above=0.)
-        # Wrappers
-        self.get_mcu = self.mcu_endstop.get_mcu
-        self.add_stepper = self.mcu_endstop.add_stepper
-        self.get_steppers = self.mcu_endstop.get_steppers
-        self.home_wait = self.mcu_endstop.home_wait
-        self.query_endstop = self.mcu_endstop.query_endstop
-        # Register BLTOUCH_DEBUG command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command("BLTOUCH_DEBUG", self.cmd_BLTOUCH_DEBUG,
-                                    desc=self.cmd_BLTOUCH_DEBUG_help)
-        self.gcode.register_command("BLTOUCH_STORE", self.cmd_BLTOUCH_STORE,
-                                    desc=self.cmd_BLTOUCH_STORE_help)
-        # multi probes state
-        self.multi = 'OFF'
-    def handle_mcu_identify(self):
-        kin = self.printer.lookup_object('toolhead').get_kinematics()
-        for stepper in kin.get_steppers():
-            if stepper.is_active_axis('z'):
-                self.add_stepper(stepper)
-    def handle_connect(self):
-        self.sync_mcu_print_time()
-        self.next_cmd_time += 0.200
-        self.set_output_mode(self.output_mode)
-        try:
-            self.raise_probe()
-            self.verify_raise_probe()
-        except self.printer.command_error as e:
-            logging.warning("BLTouch raise probe error: %s", str(e))
-    def sync_mcu_print_time(self):
-        curtime = self.printer.get_reactor().monotonic()
-        est_time = self.mcu_pwm.get_mcu().estimated_print_time(curtime)
-        self.next_cmd_time = max(self.next_cmd_time, est_time + MIN_CMD_TIME)
-    def sync_print_time(self):
-        toolhead = self.printer.lookup_object('toolhead')
-        print_time = toolhead.get_last_move_time()
-        if self.next_cmd_time > print_time:
-            toolhead.dwell(self.next_cmd_time - print_time)
-        else:
-            self.next_cmd_time = print_time
-    def send_cmd(self, cmd, duration=MIN_CMD_TIME):
-        # Translate duration to ticks to avoid any secondary mcu clock skew
-        mcu = self.mcu_pwm.get_mcu()
-        cmd_clock = mcu.print_time_to_clock(self.next_cmd_time)
-        pulse = int((duration - MIN_CMD_TIME) / SIGNAL_PERIOD) * SIGNAL_PERIOD
-        cmd_clock += mcu.seconds_to_clock(max(MIN_CMD_TIME, pulse))
-        end_time = mcu.clock_to_print_time(cmd_clock)
-        # Schedule command followed by PWM disable
-        self.mcu_pwm.set_pwm(self.next_cmd_time, Commands[cmd] / SIGNAL_PERIOD)
-        self.mcu_pwm.set_pwm(end_time, 0.)
-        # Update time tracking
-        self.action_end_time = self.next_cmd_time + duration
-        self.next_cmd_time = max(self.action_end_time, end_time + MIN_CMD_TIME)
-    def verify_state(self, triggered):
-        # Perform endstop check to verify bltouch reports desired state
-        self.mcu_endstop.home_start(self.action_end_time, ENDSTOP_SAMPLE_TIME,
-                                    ENDSTOP_SAMPLE_COUNT, ENDSTOP_REST_TIME,
-                                    triggered=triggered)
-        trigger_time = self.mcu_endstop.home_wait(self.action_end_time + 0.100)
-        return trigger_time > 0.
-    def raise_probe(self):
-        self.sync_mcu_print_time()
-        if not self.pin_up_not_triggered:
-            self.send_cmd('reset')
-        self.send_cmd('pin_up', duration=self.pin_move_time)
-    def verify_raise_probe(self):
-        if not self.pin_up_not_triggered:
-            # No way to verify raise attempt
-            return
-        for retry in range(3):
-            success = self.verify_state(False)
-            if success:
-                # The "probe raised" test completed successfully
-                break
-            if retry >= 2:
-                raise self.printer.command_error(
-                    "BLTouch failed to raise probe")
-            msg = "Failed to verify BLTouch probe is raised; retrying."
-            self.gcode.respond_info(msg)
-            self.sync_mcu_print_time()
-            self.send_cmd('reset', duration=RETRY_RESET_TIME)
-            self.send_cmd('pin_up', duration=self.pin_move_time)
-    def lower_probe(self):
-        self.test_sensor()
-        self.sync_print_time()
-        self.send_cmd('pin_down', duration=self.pin_move_time)
-        if self.probe_touch_mode:
-            self.send_cmd('touch_mode')
-    def test_sensor(self):
-        if not self.pin_up_touch_triggered:
-            # Nothing to test
-            return
-        toolhead = self.printer.lookup_object('toolhead')
-        print_time = toolhead.get_last_move_time()
-        if print_time < self.next_test_time:
-            self.next_test_time = print_time + TEST_TIME
-            return
-        # Raise the bltouch probe and test if probe is raised
-        self.sync_print_time()
-        for retry in range(3):
-            self.send_cmd('pin_up', duration=self.pin_move_time)
-            self.send_cmd('touch_mode')
-            success = self.verify_state(True)
-            self.sync_print_time()
-            if success:
-                # The "bltouch connection" test completed successfully
-                self.next_test_time = print_time + TEST_TIME
-                return
-            msg = "BLTouch failed to verify sensor state"
-            if retry >= 2:
-                raise self.printer.command_error(msg)
-            self.gcode.respond_info(msg + '; retrying.')
-            self.send_cmd('reset', duration=RETRY_RESET_TIME)
-    def multi_probe_begin(self):
-        if self.stow_on_each_sample:
-            return
-        self.multi = 'FIRST'
-    def multi_probe_end(self):
-        if self.stow_on_each_sample:
-            return
-        self.sync_print_time()
-        self.raise_probe()
-        self.verify_raise_probe()
-        self.sync_print_time()
-        self.multi = 'OFF'
-    def probe_prepare(self, hmove):
-        if self.multi == 'OFF' or self.multi == 'FIRST':
-            self.lower_probe()
-            if self.multi == 'FIRST':
-                self.multi = 'ON'
-        self.sync_print_time()
-    def home_start(self, print_time, sample_time, sample_count, rest_time,
-                   triggered=True):
-        rest_time = min(rest_time, ENDSTOP_REST_TIME)
-        self.finish_home_complete = self.mcu_endstop.home_start(
-            print_time, sample_time, sample_count, rest_time, triggered)
-        # Schedule wait_for_trigger callback
-        r = self.printer.get_reactor()
-        self.wait_trigger_complete = r.register_callback(self.wait_for_trigger)
-        return self.finish_home_complete
-    def wait_for_trigger(self, eventtime):
-        self.finish_home_complete.wait()
-        if self.multi == 'OFF':
-            self.raise_probe()
-    def probe_finish(self, hmove):
-        self.wait_trigger_complete.wait()
-        if self.multi == 'OFF':
-            self.verify_raise_probe()
-        self.sync_print_time()
-        if hmove.check_no_movement() is not None:
-            raise self.printer.command_error("BLTouch failed to deploy")
-    def get_position_endstop(self):
-        return self.position_endstop
-    def set_output_mode(self, mode):
-        # If this is inadvertently/purposely issued for a
-        # BLTOUCH pre V3.0 and clones:
-        #   No reaction at all.
-        # BLTOUCH V3.0 and V3.1:
-        #   This will set the mode.
-        if mode is None:
-            return
-        logging.info("BLTouch set output mode: %s", mode)
-        self.sync_mcu_print_time()
-        if mode == '5V':
-            self.send_cmd('set_5V_output_mode')
-        if mode == 'OD':
-            self.send_cmd('set_OD_output_mode')
-    def store_output_mode(self, mode):
-        # If this command is inadvertently/purposely issued for a
-        # BLTOUCH pre V3.0 and clones:
-        #   No reaction at all to this sequence apart from a pin-down/pin-up
-        # BLTOUCH V3.0:
-        #   This will set the mode (twice) and sadly, a pin-up is needed at
-        #   the end, because of the pin-down
-        # BLTOUCH V3.1:
-        #   This will set the mode and store it in the eeprom.
-        #   The pin-up is not needed but does not hurt
-        logging.info("BLTouch store output mode: %s", mode)
-        self.sync_print_time()
-        self.send_cmd('pin_down')
-        if mode == '5V':
-            self.send_cmd('set_5V_output_mode')
-        else:
-            self.send_cmd('set_OD_output_mode')
-        self.send_cmd('output_mode_store')
-        if mode == '5V':
-            self.send_cmd('set_5V_output_mode')
-        else:
-            self.send_cmd('set_OD_output_mode')
-        self.send_cmd('pin_up')
-    cmd_BLTOUCH_DEBUG_help = "Send a command to the bltouch for debugging"
-    def cmd_BLTOUCH_DEBUG(self, gcmd):
-        cmd = gcmd.get('COMMAND', None)
-        if cmd is None or cmd not in Commands:
-            gcmd.respond_info("BLTouch commands: %s" % (
-                ", ".join(sorted([c for c in Commands if c is not None]))))
-            return
-        gcmd.respond_info("Sending BLTOUCH_DEBUG COMMAND=%s" % (cmd,))
-        self.sync_print_time()
-        self.send_cmd(cmd, duration=self.pin_move_time)
-        self.sync_print_time()
-    cmd_BLTOUCH_STORE_help = "Store an output mode in the BLTouch EEPROM"
-    def cmd_BLTOUCH_STORE(self, gcmd):
-        cmd = gcmd.get('MODE', None)
-        if cmd is None or cmd not in ['5V', 'OD']:
-            gcmd.respond_info("BLTouch output modes: 5V, OD")
-            return
-        gcmd.respond_info("Storing BLTouch output mode: %s" % (cmd,))
-        self.sync_print_time()
-        self.store_output_mode(cmd)
-        self.sync_print_time()
-
-def load_config(config):
-    blt = BLTouchEndstopWrapper(config)
-    config.get_printer().add_object('probe', probe.PrinterProbe(config, blt))
-    return blt
deleted file mode 100644
--- a/klippy/extras/bme280.py
+++ /dev/null
@@ -1,480 +0,0 @@
-# Support for i2c based temperature sensors
-#
-# Copyright (C) 2020  Eric Callahan <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-REPORT_TIME = .8
-BME280_CHIP_ADDR = 0x76
-BME280_REGS = {
-    'RESET': 0xE0, 'CTRL_HUM': 0xF2,
-    'STATUS': 0xF3, 'CTRL_MEAS': 0xF4, 'CONFIG': 0xF5,
-    'PRESSURE_MSB': 0xF7, 'PRESSURE_LSB': 0xF8, 'PRESSURE_XLSB': 0xF9,
-    'TEMP_MSB': 0xFA, 'TEMP_LSB': 0xFB, 'TEMP_XLSB': 0xFC,
-    'HUM_MSB': 0xFD, 'HUM_LSB': 0xFE, 'CAL_1': 0x88, 'CAL_2': 0xE1
-}
-
-BME680_REGS = {
-    'RESET': 0xE0, 'CTRL_HUM': 0x72, 'CTRL_GAS_1': 0x71, 'CTRL_GAS_0': 0x70,
-    'GAS_WAIT_0': 0x64, 'RES_HEAT_0': 0x5A, 'IDAC_HEAT_0': 0x50,
-    'STATUS': 0x73, 'EAS_STATUS_0': 0x1D, 'CTRL_MEAS': 0x74, 'CONFIG': 0x75,
-    'GAS_R_LSB': 0x2B, 'GAS_R_MSB': 0x2A,
-    'PRESSURE_MSB': 0x1F, 'PRESSURE_LSB': 0x20, 'PRESSURE_XLSB': 0x21,
-    'TEMP_MSB': 0x22, 'TEMP_LSB': 0x23, 'TEMP_XLSB': 0x24,
-    'HUM_MSB': 0x25, 'HUM_LSB': 0x26, 'CAL_1': 0x88, 'CAL_2': 0xE1,
-    'RES_HEAT_VAL': 0x00, 'RES_HEAT_RANGE': 0x02, 'RANGE_SWITCHING_ERROR': 0x04
-}
-
-BME680_GAS_CONSTANTS = {
-    0: (1., 8000000.),
-    1: (1., 4000000.),
-    2: (1., 2000000.),
-    3: (1., 1000000.),
-    4: (1., 499500.4995),
-    5: (0.99, 248262.1648),
-    6: (1., 125000.),
-    7: (0.992, 63004.03226),
-    8: (1., 31281.28128),
-    9: (1., 15625.),
-    10: (0.998, 7812.5),
-    11: (0.995, 3906.25),
-    12: (1., 1953.125),
-    13: (0.99, 976.5625),
-    14: (1., 488.28125),
-    15: (1., 244.140625)
-}
-
-STATUS_MEASURING = 1 << 3
-STATUS_IM_UPDATE = 1
-MODE = 1
-RUN_GAS = 1 << 4
-NB_CONV_0 = 0
-EAS_NEW_DATA = 1 << 7
-GAS_DONE = 1 << 6
-MEASURE_DONE = 1 << 5
-RESET_CHIP_VALUE = 0xB6
-
-BME_CHIPS = {
-    0x58: 'BMP280', 0x60: 'BME280', 0x61: 'BME680'
-}
-BME_CHIP_ID_REG = 0xD0
-
-
-def get_twos_complement(val, bit_size):
-    if val & (1 << (bit_size - 1)):
-        val -= (1 << bit_size)
-    return val
-
-
-def get_unsigned_short(bits):
-    return bits[1] << 8 | bits[0]
-
-
-def get_signed_short(bits):
-    val = get_unsigned_short(bits)
-    return get_twos_complement(val, 16)
-
-
-def get_signed_byte(bits):
-    return get_twos_complement(bits, 8)
-
-
-class BME280:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.reactor = self.printer.get_reactor()
-        self.i2c = bus.MCU_I2C_from_config(
-            config, default_addr=BME280_CHIP_ADDR, default_speed=100000)
-        self.mcu = self.i2c.get_mcu()
-        self.iir_filter = config.getint('bme280_iir_filter', 1)
-        self.os_temp = config.getint('bme280_oversample_temp', 2)
-        self.os_hum = config.getint('bme280_oversample_hum', 2)
-        self.os_pres = config.getint('bme280_oversample_pressure', 2)
-        self.gas_heat_temp = config.getint('bme280_gas_target_temp', 320)
-        self.gas_heat_duration = config.getint('bme280_gas_heat_duration', 150)
-        logging.info("BMxx80: Oversampling: Temp %dx Humid %dx Pressure %dx" % (
-            pow(2, self.os_temp - 1), pow(2, self.os_hum - 1),
-            pow(2, self.os_pres - 1)))
-        logging.info("BMxx80: IIR: %dx" % (pow(2, self.iir_filter) - 1))
-
-        self.temp = self.pressure = self.humidity = self.gas = self.t_fine = 0.
-        self.min_temp = self.max_temp = self.range_switching_error = 0.
-        self.max_sample_time = None
-        self.dig = self.sample_timer = None
-        self.chip_type = 'BMP280'
-        self.chip_registers = BME280_REGS
-        self.printer.add_object("bme280 " + self.name, self)
-        if self.printer.get_start_args().get('debugoutput') is not None:
-            return
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self._init_bmxx80()
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return REPORT_TIME
-
-    def _init_bmxx80(self):
-        def read_calibration_data_bmp280(calib_data_1):
-            dig = {}
-            dig['T1'] = get_unsigned_short(calib_data_1[0:2])
-            dig['T2'] = get_signed_short(calib_data_1[2:4])
-            dig['T3'] = get_signed_short(calib_data_1[4:6])
-
-            dig['P1'] = get_unsigned_short(calib_data_1[6:8])
-            dig['P2'] = get_signed_short(calib_data_1[8:10])
-            dig['P3'] = get_signed_short(calib_data_1[10:12])
-            dig['P4'] = get_signed_short(calib_data_1[12:14])
-            dig['P5'] = get_signed_short(calib_data_1[14:16])
-            dig['P6'] = get_signed_short(calib_data_1[16:18])
-            dig['P7'] = get_signed_short(calib_data_1[18:20])
-            dig['P8'] = get_signed_short(calib_data_1[20:22])
-            dig['P9'] = get_signed_short(calib_data_1[22:24])
-            return dig
-
-        def read_calibration_data_bme280(calib_data_1, calib_data_2):
-            dig = read_calibration_data_bmp280(calib_data_1)
-            dig['H1'] = calib_data_1[25] & 0xFF
-            dig['H2'] = get_signed_short(calib_data_2[0:2])
-            dig['H3'] = calib_data_2[2] & 0xFF
-            dig['H4'] = get_twos_complement(
-                (calib_data_2[3] << 4) | (calib_data_2[4] & 0x0F), 12)
-            dig['H5'] = get_twos_complement(
-                (calib_data_2[5] << 4) | ((calib_data_2[4] & 0xF0) >> 4), 12)
-            dig['H6'] = get_twos_complement(calib_data_2[6], 8)
-            return dig
-
-        def read_calibration_data_bme680(calib_data_1, calib_data_2):
-            dig = {}
-            dig['T1'] = get_unsigned_short(calib_data_2[8:10])
-            dig['T2'] = get_signed_short(calib_data_1[2:4])
-            dig['T3'] = get_signed_byte(calib_data_1[4])
-
-            dig['P1'] = get_unsigned_short(calib_data_1[6:8])
-            dig['P2'] = get_signed_short(calib_data_1[8:10])
-            dig['P3'] = calib_data_1[10]
-            dig['P4'] = get_signed_short(calib_data_1[12:14])
-            dig['P5'] = get_signed_short(calib_data_1[14:16])
-            dig['P6'] = get_signed_byte(calib_data_1[17])
-            dig['P7'] = get_signed_byte(calib_data_1[16])
-            dig['P8'] = get_signed_short(calib_data_1[20:22])
-            dig['P9'] = get_signed_short(calib_data_1[22:24])
-            dig['P10'] = calib_data_1[24]
-
-            dig['H1'] = get_twos_complement(
-                (calib_data_2[2] << 4) | (calib_data_2[1] & 0x0F), 12)
-            dig['H2'] = get_twos_complement(
-                (calib_data_2[0] << 4) | ((calib_data_2[1] & 0xF0) >> 4), 12)
-            dig['H3'] = get_signed_byte(calib_data_2[3])
-            dig['H4'] = get_signed_byte(calib_data_2[4])
-            dig['H5'] = get_signed_byte(calib_data_2[5])
-            dig['H6'] = calib_data_2[6]
-            dig['H7'] = get_signed_byte(calib_data_2[7])
-
-            dig['G1'] = get_signed_byte(calib_data_2[12])
-            dig['G2'] = get_signed_short(calib_data_2[10:12])
-            dig['G3'] = get_signed_byte(calib_data_2[13])
-            return dig
-
-        chip_id = self.read_id()
-        if chip_id not in BME_CHIPS.keys():
-            logging.info("bme280: Unknown Chip ID received %#x" % chip_id)
-        else:
-            self.chip_type = BME_CHIPS[chip_id]
-            logging.info("bme280: Found Chip %s at %#x" % (
-                self.chip_type, self.i2c.i2c_address))
-
-        # Reset chip
-        self.write_register('RESET', [RESET_CHIP_VALUE])
-        self.reactor.pause(self.reactor.monotonic() + .5)
-
-        # Make sure non-volatile memory has been copied to registers
-        status = self.read_register('STATUS', 1)[0]
-        while status & STATUS_IM_UPDATE:
-            self.reactor.pause(self.reactor.monotonic() + .01)
-            status = self.read_register('STATUS', 1)[0]
-
-        if self.chip_type == 'BME680':
-            self.max_sample_time = 0.5
-            self.sample_timer = self.reactor.register_timer(self._sample_bme680)
-            self.chip_registers = BME680_REGS
-        else:
-            self.max_sample_time = \
-                (1.25 + (2.3 * self.os_temp) + ((2.3 * self.os_pres) + .575)
-                 + ((2.3 * self.os_hum) + .575)) / 1000
-            self.sample_timer = self.reactor.register_timer(self._sample_bme280)
-            self.chip_registers = BME280_REGS
-
-        if self.chip_type in ('BME680', 'BME280'):
-            self.write_register('CONFIG', (self.iir_filter & 0x07) << 2)
-
-        # Read out and calculate the trimming parameters
-        cal_1 = self.read_register('CAL_1', 26)
-        cal_2 = self.read_register('CAL_2', 16)
-        if self.chip_type == 'BME280':
-            self.dig = read_calibration_data_bme280(cal_1, cal_2)
-        elif self.chip_type == 'BMP280':
-            self.dig = read_calibration_data_bmp280(cal_1)
-        elif self.chip_type == 'BME680':
-            self.dig = read_calibration_data_bme680(cal_1, cal_2)
-
-    def _sample_bme280(self, eventtime):
-        # Enter forced mode
-        if self.chip_type == 'BME280':
-            self.write_register('CTRL_HUM', self.os_hum)
-        meas = self.os_temp << 5 | self.os_pres << 2 | MODE
-        self.write_register('CTRL_MEAS', meas)
-
-        try:
-            # wait until results are ready
-            status = self.read_register('STATUS', 1)[0]
-            while status & STATUS_MEASURING:
-                self.reactor.pause(
-                    self.reactor.monotonic() + self.max_sample_time)
-                status = self.read_register('STATUS', 1)[0]
-
-            if self.chip_type == 'BME280':
-                data = self.read_register('PRESSURE_MSB', 8)
-            elif self.chip_type == 'BMP280':
-                data = self.read_register('PRESSURE_MSB', 6)
-            else:
-                return self.reactor.NEVER
-        except Exception:
-            logging.exception("BME280: Error reading data")
-            self.temp = self.pressure = self.humidity = .0
-            return self.reactor.NEVER
-
-        temp_raw = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4)
-        self.temp = self._compensate_temp(temp_raw)
-        pressure_raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)
-        self.pressure = self._compensate_pressure_bme280(pressure_raw) / 100.
-        if self.chip_type == 'BME280':
-            humid_raw = (data[6] << 8) | data[7]
-            self.humidity = self._compensate_humidity_bme280(humid_raw)
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "BME280 temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-        measured_time = self.reactor.monotonic()
-        self._callback(self.mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + REPORT_TIME
-
-    def _sample_bme680(self, eventtime):
-        self.write_register('CTRL_HUM', self.os_hum & 0x07)
-        meas = self.os_temp << 5 | self.os_pres << 2
-        self.write_register('CTRL_MEAS', [meas])
-
-        gas_wait_0 = self._calculate_gas_heater_duration(self.gas_heat_duration)
-        self.write_register('GAS_WAIT_0', [gas_wait_0])
-        res_heat_0 = self._calculate_gas_heater_resistance(self.gas_heat_temp)
-        self.write_register('RES_HEAT_0', [res_heat_0])
-        gas_config = RUN_GAS | NB_CONV_0
-        self.write_register('CTRL_GAS_1', [gas_config])
-
-        def data_ready(stat):
-            new_data = (stat & EAS_NEW_DATA)
-            gas_done = not (stat & GAS_DONE)
-            meas_done = not (stat & MEASURE_DONE)
-            return new_data and gas_done and meas_done
-
-        # Enter forced mode
-        meas = meas | MODE
-        self.write_register('CTRL_MEAS', meas)
-        try:
-            # wait until results are ready
-            status = self.read_register('EAS_STATUS_0', 1)[0]
-            while not data_ready(status):
-                self.reactor.pause(
-                    self.reactor.monotonic() + self.max_sample_time)
-                status = self.read_register('EAS_STATUS_0', 1)[0]
-
-            data = self.read_register('PRESSURE_MSB', 8)
-            gas_data = self.read_register('GAS_R_MSB', 2)
-        except Exception:
-            logging.exception("BME680: Error reading data")
-            self.temp = self.pressure = self.humidity = self.gas = .0
-            return self.reactor.NEVER
-
-        temp_raw = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4)
-        if temp_raw != 0x80000:
-            self.temp = self._compensate_temp(temp_raw)
-        pressure_raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)
-        if pressure_raw != 0x80000:
-            self.pressure = self._compensate_pressure_bme680(
-                pressure_raw) / 100.
-        humid_raw = (data[6] << 8) | data[7]
-        self.humidity = self._compensate_humidity_bme680(humid_raw)
-
-        gas_valid = ((gas_data[1] & 0x20) == 0x20)
-        if gas_valid:
-            gas_heater_stable = ((gas_data[1] & 0x10) == 0x10)
-            if not gas_heater_stable:
-                logging.warning("BME680: Gas heater didn't reach target")
-            gas_raw = (gas_data[0] << 2) | ((gas_data[1] & 0xC0) >> 6)
-            gas_range = (gas_data[1] & 0x0F)
-            self.gas = self._compensate_gas(gas_raw, gas_range)
-
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "BME680 temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-        measured_time = self.reactor.monotonic()
-        self._callback(self.mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + REPORT_TIME * 4
-
-    def _compensate_temp(self, raw_temp):
-        dig = self.dig
-        var1 = ((raw_temp / 16384. - (dig['T1'] / 1024.)) * dig['T2'])
-        var2 = (
-                ((raw_temp / 131072.) - (dig['T1'] / 8192.)) *
-                ((raw_temp / 131072.) - (dig['T1'] / 8192.)) * dig['T3'])
-        self.t_fine = var1 + var2
-        return self.t_fine / 5120.0
-
-    def _compensate_pressure_bme280(self, raw_pressure):
-        dig = self.dig
-        t_fine = self.t_fine
-        var1 = t_fine / 2. - 64000.
-        var2 = var1 * var1 * dig['P6'] / 32768.
-        var2 = var2 + var1 * dig['P5'] * 2.
-        var2 = var2 / 4. + (dig['P4'] * 65536.)
-        var1 = (dig['P3'] * var1 * var1 / 524288. + dig['P2'] * var1) / 524288.
-        var1 = (1. + var1 / 32768.) * dig['P1']
-        if var1 == 0:
-            return 0.
-        else:
-            pressure = 1048576.0 - raw_pressure
-            pressure = ((pressure - var2 / 4096.) * 6250.) / var1
-            var1 = dig['P9'] * pressure * pressure / 2147483648.
-            var2 = pressure * dig['P8'] / 32768.
-            return pressure + (var1 + var2 + dig['P7']) / 16.
-
-    def _compensate_pressure_bme680(self, raw_pressure):
-        dig = self.dig
-        t_fine = self.t_fine
-        var1 = t_fine / 2. - 64000.
-        var2 = var1 * var1 * dig['P6'] / 131072.
-        var2 = var2 + var1 * dig['P5'] * 2.
-        var2 = var2 / 4. + (dig['P4'] * 65536.)
-        var1 = (dig['P3'] * var1 * var1 / 16384. + dig['P2'] * var1) / 524288.
-        var1 = (1. + var1 / 32768.) * dig['P1']
-        if var1 == 0:
-            return 0.
-        else:
-            pressure = 1048576.0 - raw_pressure
-            pressure = ((pressure - var2 / 4096.) * 6250.) / var1
-            var1 = dig['P9'] * pressure * pressure / 2147483648.
-            var2 = pressure * dig['P8'] / 32768.
-            var3 = (pressure / 256.) * (pressure / 256.) * (pressure / 256.) * (
-                    dig['P10'] / 131072.)
-            return pressure + (var1 + var2 + var3 + (dig['P7'] * 128.)) / 16.
-
-    def _compensate_humidity_bme280(self, raw_humidity):
-        dig = self.dig
-        t_fine = self.t_fine
-        humidity = t_fine - 76800.
-        h1 = (
-                raw_humidity - (
-                dig['H4'] * 64. + dig['H5'] / 16384. * humidity))
-        h2 = (dig['H2'] / 65536. * (1. + dig['H6'] / 67108864. * humidity *
-                                    (1. + dig['H3'] / 67108864. * humidity)))
-        humidity = h1 * h2
-        humidity = humidity * (1. - dig['H1'] * humidity / 524288.)
-        return min(100., max(0., humidity))
-
-    def _compensate_humidity_bme680(self, raw_humidity):
-        dig = self.dig
-        temp_comp = self.temp
-
-        var1 = raw_humidity - (
-                (dig['H1'] * 16.) + ((dig['H3'] / 2.) * temp_comp))
-        var2 = var1 * ((dig['H2'] / 262144.) *
-                       (1. + ((dig['H4'] / 16384.) * temp_comp) +
-                        ((dig['H5'] / 1048576.) * temp_comp * temp_comp)))
-        var3 = dig['H6'] / 16384.
-        var4 = dig['H7'] / 2097152.
-        humidity = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2)
-        return min(100., max(0., humidity))
-
-    def _compensate_gas(self, gas_raw, gas_range):
-        gas_switching_error = self.read_register('RANGE_SWITCHING_ERROR', 1)[0]
-        var1 = (1340. + 5. * gas_switching_error) * \
-               BME680_GAS_CONSTANTS[gas_range][0]
-        gas = var1 * BME680_GAS_CONSTANTS[gas_range][1] / (
-                gas_raw - 512. + var1)
-        return gas
-
-    def _calculate_gas_heater_resistance(self, target_temp):
-        amb_temp = self.temp
-        heater_data = self.read_register('RES_HEAT_VAL', 3)
-        res_heat_val = get_signed_byte(heater_data[0])
-        res_heat_range = (heater_data[2] & 0x30) >> 4
-        dig = self.dig
-        var1 = (dig['G1'] / 16.) + 49.
-        var2 = ((dig['G2'] / 32768.) * 0.0005) + 0.00235
-        var3 = dig['G3'] / 1024.
-        var4 = var1 * (1. + (var2 * target_temp))
-        var5 = var4 + (var3 * amb_temp)
-        res_heat = (3.4 * ((var5 * (4. / (4. + res_heat_range))
-                            * (1. / (1. + (res_heat_val * 0.002)))) - 25))
-        return int(res_heat)
-
-    def _calculate_gas_heater_duration(self, duration_ms):
-        if duration_ms >= 4032:
-            duration_reg = 0xff
-        else:
-            factor = 0
-            while duration_ms > 0x3F:
-                duration_ms //= 4
-                factor += 1
-            duration_reg = duration_ms + (factor * 64)
-
-        return duration_reg
-
-    def read_id(self):
-        # read chip id register
-        regs = [BME_CHIP_ID_REG]
-        params = self.i2c.i2c_read(regs, 1)
-        return bytearray(params['response'])[0]
-
-    def read_register(self, reg_name, read_len):
-        # read a single register
-        regs = [self.chip_registers[reg_name]]
-        params = self.i2c.i2c_read(regs, read_len)
-        return bytearray(params['response'])
-
-    def write_register(self, reg_name, data):
-        if type(data) is not list:
-            data = [data]
-        reg = self.chip_registers[reg_name]
-        data.insert(0, reg)
-        self.i2c.i2c_write(data)
-
-    def get_status(self, eventtime):
-        data = {
-            'temperature': round(self.temp, 2),
-            'pressure': self.pressure
-        }
-        if self.chip_type in ('BME280', 'BME680'):
-            data['humidity'] = self.humidity
-        if self.chip_type == 'BME680':
-            data['gas'] = self.gas
-        return data
-
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("BME280", BME280)
deleted file mode 100644
--- a/klippy/extras/canbus_ids.py
+++ /dev/null
@@ -1,26 +0,0 @@
-# Support for tracking canbus node ids
-#
-# Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-NODEID_FIRST = 4
-
-class PrinterCANBus:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.ids = {}
-    def add_uuid(self, config, canbus_uuid, canbus_iface):
-        if canbus_uuid in self.ids:
-            raise config.error("Duplicate canbus_uuid")
-        new_id = len(self.ids) + NODEID_FIRST
-        self.ids[canbus_uuid] = new_id
-        return new_id
-    def get_nodeid(self, canbus_uuid):
-        if canbus_uuid not in self.ids:
-            raise self.printer.config_error("Unknown canbus_uuid %s"
-                                            % (canbus_uuid,))
-        return self.ids[canbus_uuid]
-
-def load_config(config):
-    return PrinterCANBus(config)
deleted file mode 100644
--- a/klippy/extras/dac084S085.py
+++ /dev/null
@@ -1,25 +0,0 @@
-# SPI DAC DAC084S085 implementation
-#
-# Copyright (C) 2021  Lorenzo Franco <lorenzo.franco@lorenzing.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-from . import bus
-
-class dac084S085:
-    def __init__(self, config):
-        self.spi = bus.MCU_SPI_from_config(
-            config, 1, pin_option="enable_pin", default_speed=10000000)
-        scale = config.getfloat('scale', 1., above=0.)
-        for chan, name in enumerate("ABCD"):
-            val = config.getfloat('channel_%s' % (name,), None,
-                                   minval=0., maxval=scale)
-            if val is not None:
-                self.set_register(chan, int(val * 255. / scale))
-    def set_register(self, chan, value):
-        b1 = (chan << 6) | (1 << 4) | ((value >> 4) & 0x0f)
-        b2 = (value << 4) & 0xf0
-        self.spi.spi_send([b1, b2])
-
-def load_config_prefix(config):
-    return dac084S085(config)
deleted file mode 100644
--- a/klippy/extras/display/__init__.py
+++ /dev/null
@@ -1,21 +0,0 @@
-# Package definition for the extras/display directory
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import display
-
-def load_config(config):
-    return display.load_config(config)
-
-def load_config_prefix(config):
-    if not config.has_section('display'):
-        raise config.error(
-            "A primary [display] section must be defined in printer.cfg "
-            "to use auxilary displays")
-    name = config.get_name().split()[-1]
-    if name == "display":
-        raise config.error(
-            "Section name [display display] is not valid. "
-            "Please choose a different postfix.")
-    return display.load_config(config)
deleted file mode 100644
--- a/klippy/extras/display/display.cfg
+++ /dev/null
@@ -1,461 +0,0 @@
-# This file defines the default layout of the printer's lcd display.
-
-# It is not necessary to edit this file to change the display.
-# Instead, one may override any of the sections defined here by
-# defining a section with the same name in the main printer.cfg config
-# file.
-
-
-######################################################################
-# Helper macros for showing common screen values
-######################################################################
-
-[display_template _heater_temperature]
-param_heater_name: "extruder"
-text:
-  {% if param_heater_name in printer %}
-    {% set heater = printer[param_heater_name] %}
-    # Show glyph
-    {% if param_heater_name == "heater_bed" %}
-      {% if heater.target %}
-        {% set frame = (printer.toolhead.estimated_print_time|int % 2) + 1 %}
-        ~bed_heat{frame}~
-      {% else %}
-        ~bed~
-      {% endif %}
-    {% else %}
-      ~extruder~
-    {% endif %}
-    # Show temperature
-    { "%3.0f" % (heater.temperature,) }
-    # Optionally show target
-    {% if heater.target and (heater.temperature - heater.target)|abs > 2 %}
-      ~right_arrow~
-      { "%0.0f" % (heater.target,) }
-    {% endif %}
-    ~degrees~
-  {% endif %}
-
-[display_template _fan_speed]
-text:
-  {% if 'fan' in printer %}
-    {% set speed = printer.fan.speed %}
-    {% if speed %}
-      {% set frame = (printer.toolhead.estimated_print_time|int % 2) + 1 %}
-      ~fan{frame}~
-    {% else %}
-      ~fan1~
-    {% endif %}
-    { "{:>4.0%}".format(speed) }
-  {% endif %}
-
-[display_template _printing_time]
-text:
-  {% set ptime = printer.idle_timeout.printing_time %}
-  { "%02d:%02d" % (ptime // (60 * 60), (ptime // 60) % 60) }
-
-[display_template _print_status]
-text:
-  {% if printer.display_status.message %}
-    { printer.display_status.message }
-  {% elif printer.idle_timeout.printing_time %}
-    {% set pos = printer.toolhead.position %}
-    { "X%-4.0fY%-4.0fZ%-5.2f" % (pos.x, pos.y, pos.z) }
-  {% else %}
-    Ready
-  {% endif %}
-
-
-######################################################################
-# Default 16x4 display
-######################################################################
-
-[display_data _default_16x4 extruder]
-position: 0, 0
-text:
-  {% set active_extruder = printer.toolhead.extruder %}
-  { render("_heater_temperature", param_heater_name=active_extruder) }
-
-[display_data _default_16x4 fan]
-position: 0, 10
-text: { render("_fan_speed") }
-
-[display_data _default_16x4 heater_bed]
-position: 1, 0
-text: { render("_heater_temperature", param_heater_name="heater_bed") }
-
-[display_data _default_16x4 speed_factor]
-position: 1, 10
-text:
-  ~feedrate~
-  { "{:>4.0%}".format(printer.gcode_move.speed_factor) }
-
-[display_data _default_16x4 print_progress]
-position: 2, 0
-text: { "{:^10.0%}".format(printer.display_status.progress) }
-[display_data _default_16x4 progress_bar]
-position: 2, 1 # Draw graphical progress bar after text is written
-text: { draw_progress_bar(2, 0, 10, printer.display_status.progress) }
-
-[display_data _default_16x4 printing_time]
-position: 2, 10
-text: { "%6s" % (render("_printing_time").strip(),) }
-
-[display_data _default_16x4 print_status]
-position: 3, 0
-text: { render("_print_status") }
-
-
-######################################################################
-# Alternative 16x4 layout for multi-extruders
-######################################################################
-
-[display_data _multiextruder_16x4 extruder]
-position: 0, 0
-text: { render("_heater_temperature", param_heater_name="extruder") }
-
-[display_data _multiextruder_16x4 fan]
-position: 0, 10
-text: { render("_fan_speed") }
-
-[display_data _multiextruder_16x4 extruder1]
-position: 1, 0
-text: { render("_heater_temperature", param_heater_name="extruder1") }
-
-[display_data _multiextruder_16x4 print_progress]
-position: 1, 10
-text: { "{:^6.0%}".format(printer.display_status.progress) }
-[display_data _multiextruder_16x4 progress_bar]
-position: 1, 11 # Draw graphical progress bar after text is written
-text: { draw_progress_bar(1, 10, 6, printer.display_status.progress) }
-
-[display_data _multiextruder_16x4 heater_bed]
-position: 2, 0
-text: { render("_heater_temperature", param_heater_name="heater_bed") }
-
-[display_data _multiextruder_16x4 printing_time]
-position: 2, 10
-text: { "%6s" % (render("_printing_time").strip(),) }
-
-[display_data _multiextruder_16x4 print_status]
-position: 3, 0
-text: { render("_print_status") }
-
-
-######################################################################
-# Default 20x4 display
-######################################################################
-
-[display_data _default_20x4 extruder]
-position: 0, 0
-text: { render("_heater_temperature", param_heater_name="extruder") }
-
-[display_data _default_20x4 heater_bed]
-position: 0, 10
-text: { render("_heater_temperature", param_heater_name="heater_bed") }
-
-[display_data _default_20x4 extruder1]
-position: 1, 0
-text: { render("_heater_temperature", param_heater_name="extruder1") }
-
-[display_data _default_20x4 fan]
-position: 1, 10
-text:
-  {% if 'fan' in printer %}
-    { "Fan {:^4.0%}".format(printer.fan.speed) }
-  {% endif %}
-
-[display_data _default_20x4 speed_factor]
-position: 2, 0
-text:
-  ~feedrate~
-  { "{:^4.0%}".format(printer.gcode_move.speed_factor) }
-
-[display_data _default_20x4 print_progress]
-position: 2, 8
-text:
-  {% if 'virtual_sdcard' in printer and printer.virtual_sdcard.progress %}
-    ~sd~
-  {% else %}
-    ~usb~
-  {% endif %}
-  { "{:^4.0%}".format(printer.display_status.progress) }
-
-[display_data _default_20x4 printing_time]
-position: 2, 14
-text:
-  ~clock~
-  { render("_printing_time") }
-
-[display_data _default_20x4 print_status]
-position: 3, 0
-text: { render("_print_status") }
-
-
-######################################################################
-# Default 16x4 glyphs
-######################################################################
-
-[display_glyph extruder]
-data:
-  ................
-  ................
-  ..************..
-  .....******.....
-  ..************..
-  .....******.....
-  ..************..
-  ................
-  ....********....
-  ....******.*....
-  ....********....
-  ................
-  ......****......
-  .......**.......
-  ................
-  ................
-
-[display_glyph bed]
-data:
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ................
-  ...*********....
-  ..*.........*...
-  .*************..
-  ................
-  ................
-
-[display_glyph bed_heat1]
-data:
-  ................
-  ................
-  ..*....*....*...
-  .*....*....*....
-  ..*....*....*...
-  ...*....*....*..
-  ..*....*....*...
-  .*....*....*....
-  ..*....*....*...
-  ................
-  ................
-  ...*********....
-  ..*.........*...
-  .*************..
-  ................
-  ................
-
-[display_glyph bed_heat2]
-data:
-  ................
-  ................
-  ..*....*....*...
-  ...*....*....*..
-  ..*....*....*...
-  .*....*....*....
-  ..*....*....*...
-  ...*....*....*..
-  ..*....*....*...
-  ................
-  ................
-  ...*********....
-  ..*.........*...
-  .*************..
-  ................
-  ................
-
-[display_glyph fan1]
-data:
-  ................
-  ................
-  ....***.........
-  ...****....**...
-  ...****...****..
-  ....***..*****..
-  .....*....****..
-  .......**.......
-  .......**.......
-  ..****....*.....
-  ..*****..***....
-  ..****...****...
-  ...**....****...
-  .........***....
-  ................
-  ................
-
-[display_glyph fan2]
-data:
-  ................
-  ................
-  .......****.....
-  .......****.....
-  .......***......
-  ..**...**.......
-  ..***...........
-  ..****.**.****..
-  ..****.**.****..
-  ...........***..
-  .......**...**..
-  ......***.......
-  .....****.......
-  .....****.......
-  ................
-  ................
-
-[display_glyph feedrate]
-data:
-  ................
-  ................
-  ***.***.***.**..
-  *...*...*...*.*.
-  **..**..**..*.*.
-  *...*...*...*.*.
-  *...***.***.**..
-  ................
-  **...*..***.***.
-  *.*.*.*..*..*...
-  **..***..*..**..
-  *.*.*.*..*..*...
-  *.*.*.*..*..***.
-  ................
-  ................
-  ................
-
-# In addition to the above glyphs, 16x4 displays also have the
-# following hard-coded single character glyphs: right_arrow, degrees.
-
-
-######################################################################
-# Default 20x4 glyphs
-######################################################################
-
-[display_glyph extruder]
-hd44780_slot: 0
-hd44780_data:
-  ..*..
-  .*.*.
-  .*.*.
-  .*.*.
-  .*.*.
-  *...*
-  *...*
-  .***.
-
-[display_glyph bed]
-hd44780_slot: 1
-hd44780_data:
-  .....
-  *****
-  *.*.*
-  *...*
-  *.*.*
-  *****
-  .....
-  .....
-
-[display_glyph bed_heat1]
-hd44780_slot: 1
-hd44780_data:
-  .*..*
-  *..*.
-  .*..*
-  *..*.
-  .....
-  *****
-  .....
-  .....
-
-[display_glyph bed_heat2]
-hd44780_slot: 1
-hd44780_data:
-  *..*.
-  .*..*
-  *..*.
-  .*..*
-  .....
-  *****
-  .....
-  .....
-
-[display_glyph fan]
-hd44780_slot: 2
-hd44780_data:
-  .....
-  *..**
-  **.*.
-  ..*..
-  .*.**
-  **..*
-  .....
-  .....
-
-[display_glyph feedrate]
-hd44780_slot: 3
-hd44780_data:
-  ***..
-  *....
-  **...
-  *.***
-  ..*.*
-  ..**.
-  ..*.*
-  .....
-
-[display_glyph clock]
-hd44780_slot: 4
-hd44780_data:
-  .....
-  .***.
-  *..**
-  *.*.*
-  *...*
-  .***.
-  .....
-  .....
-
-[display_glyph degrees]
-hd44780_slot: 5
-hd44780_data:
-  .**..
-  *..*.
-  *..*.
-  .**..
-  .....
-  .....
-  .....
-  .....
-
-[display_glyph usb]
-hd44780_slot: 6
-hd44780_data:
-  .***.
-  .***.
-  .***.
-  *****
-  *****
-  *****
-  ..*..
-  ..*..
-
-[display_glyph sd]
-hd44780_slot: 6
-hd44780_data:
-  .....
-  ..***
-  .****
-  *****
-  *****
-  *****
-  *****
-  .....
-
-# In addition to the above glyphs, 20x4 displays also have the
-# following hard-coded glyphs: right_arrow.
deleted file mode 100644
--- a/klippy/extras/display/display.py
+++ /dev/null
@@ -1,271 +0,0 @@
-# Basic LCD display support
-#
-# Copyright (C) 2018-2022  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Aleph Objects, Inc <marcio@alephobjects.com>
-# Copyright (C) 2018  Eric Callahan <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, os, ast
-from . import hd44780, hd44780_spi, st7920, uc1701, menu
-
-# Normal time between each screen redraw
-REDRAW_TIME = 0.500
-# Minimum time between screen redraws
-REDRAW_MIN_TIME = 0.100
-
-LCD_chips = {
-    'st7920': st7920.ST7920, 'emulated_st7920': st7920.EmulatedST7920,
-    'hd44780': hd44780.HD44780, 'uc1701': uc1701.UC1701,
-    'ssd1306': uc1701.SSD1306, 'sh1106': uc1701.SH1106,
-    'hd44780_spi': hd44780_spi.hd44780_spi
-}
-
-# Storage of [display_template my_template] config sections
-class DisplayTemplate:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        name_parts = config.get_name().split()
-        if len(name_parts) != 2:
-            raise config.error("Section name '%s' is not valid"
-                               % (config.get_name(),))
-        self.name = name_parts[1]
-        self.params = {}
-        for option in config.get_prefix_options('param_'):
-            try:
-                self.params[option] = ast.literal_eval(config.get(option))
-            except ValueError as e:
-                raise config.error(
-                    "Option '%s' in section '%s' is not a valid literal" % (
-                        option, config.get_name()))
-        gcode_macro = self.printer.load_object(config, 'gcode_macro')
-        self.template = gcode_macro.load_template(config, 'text')
-    def get_params(self):
-        return self.params
-    def render(self, context, **kwargs):
-        params = dict(self.params)
-        params.update(**kwargs)
-        if len(params) != len(self.params):
-            raise self.printer.command_error(
-                "Invalid parameter to display_template %s" % (self.name,))
-        context = dict(context)
-        context.update(params)
-        return self.template.render(context)
-
-# Store [display_data my_group my_item] sections (one instance per group name)
-class DisplayGroup:
-    def __init__(self, config, name, data_configs):
-        # Load and parse the position of display_data items
-        items = []
-        for c in data_configs:
-            pos = c.get('position')
-            try:
-                row, col = [int(v.strip()) for v in pos.split(',')]
-            except:
-                raise config.error("Unable to parse 'position' in section '%s'"
-                                   % (c.get_name(),))
-            items.append((row, col, c.get_name()))
-        # Load all templates and store sorted by display position
-        configs_by_name = {c.get_name(): c for c in data_configs}
-        printer = config.get_printer()
-        gcode_macro = printer.load_object(config, 'gcode_macro')
-        self.data_items = []
-        for row, col, name in sorted(items):
-            c = configs_by_name[name]
-            if c.get('text'):
-                template = gcode_macro.load_template(c, 'text')
-                self.data_items.append((row, col, template))
-    def show(self, display, templates, eventtime):
-        context = self.data_items[0][2].create_template_context(eventtime)
-        context['draw_progress_bar'] = display.draw_progress_bar
-        def render(name, **kwargs):
-            return templates[name].render(context, **kwargs)
-        context['render'] = render
-        for row, col, template in self.data_items:
-            text = template.render(context)
-            display.draw_text(row, col, text.replace('\n', ''), eventtime)
-        context.clear() # Remove circular references for better gc
-
-# Global cache of DisplayTemplate, DisplayGroup, and glyphs
-class PrinterDisplayTemplate:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.display_templates = {}
-        self.display_data_groups = {}
-        self.display_glyphs = {}
-        self.load_config(config)
-    def get_display_templates(self):
-        return self.display_templates
-    def get_display_data_groups(self):
-        return self.display_data_groups
-    def get_display_glyphs(self):
-        return self.display_glyphs
-    def _parse_glyph(self, config, glyph_name, data, width, height):
-        glyph_data = []
-        for line in data.split('\n'):
-            line = line.strip().replace('.', '0').replace('*', '1')
-            if not line:
-                continue
-            if len(line) != width or line.replace('0', '').replace('1', ''):
-                raise config.error("Invalid glyph line in %s" % (glyph_name,))
-            glyph_data.append(int(line, 2))
-        if len(glyph_data) != height:
-            raise config.error("Glyph %s incorrect lines" % (glyph_name,))
-        return glyph_data
-    def load_config(self, config):
-        # Load default display config file
-        pconfig = self.printer.lookup_object('configfile')
-        filename = os.path.join(os.path.dirname(__file__), 'display.cfg')
-        try:
-            dconfig = pconfig.read_config(filename)
-        except Exception:
-            raise self.printer.config_error("Cannot load config '%s'"
-                                            % (filename,))
-        # Load display_template sections
-        dt_main = config.get_prefix_sections('display_template ')
-        dt_main_names = { c.get_name(): 1 for c in dt_main }
-        dt_def = [c for c in dconfig.get_prefix_sections('display_template ')
-                  if c.get_name() not in dt_main_names]
-        for c in dt_main + dt_def:
-            dt = DisplayTemplate(c)
-            self.display_templates[dt.name] = dt
-        # Load display_data sections
-        dd_main = config.get_prefix_sections('display_data ')
-        dd_main_names = { c.get_name(): 1 for c in dd_main }
-        dd_def = [c for c in dconfig.get_prefix_sections('display_data ')
-                  if c.get_name() not in dd_main_names]
-        groups = {}
-        for c in dd_main + dd_def:
-            name_parts = c.get_name().split()
-            if len(name_parts) != 3:
-                raise config.error("Section name '%s' is not valid"
-                                   % (c.get_name(),))
-            groups.setdefault(name_parts[1], []).append(c)
-        for group_name, data_configs in groups.items():
-            dg = DisplayGroup(config, group_name, data_configs)
-            self.display_data_groups[group_name] = dg
-        # Load display glyphs
-        dg_prefix = 'display_glyph '
-        self.display_glyphs = icons = {}
-        dg_main = config.get_prefix_sections(dg_prefix)
-        dg_main_names = {c.get_name(): 1 for c in dg_main}
-        dg_def = [c for c in dconfig.get_prefix_sections(dg_prefix)
-                  if c.get_name() not in dg_main_names]
-        for dg in dg_main + dg_def:
-            glyph_name = dg.get_name()[len(dg_prefix):]
-            data = dg.get('data', None)
-            if data is not None:
-                idata = self._parse_glyph(config, glyph_name, data, 16, 16)
-                icon1 = [(bits >> 8) & 0xff for bits in idata]
-                icon2 = [bits & 0xff for bits in idata]
-                icons.setdefault(glyph_name, {})['icon16x16'] = (icon1, icon2)
-            data = dg.get('hd44780_data', None)
-            if data is not None:
-                slot = dg.getint('hd44780_slot', minval=0, maxval=7)
-                idata = self._parse_glyph(config, glyph_name, data, 5, 8)
-                icons.setdefault(glyph_name, {})['icon5x8'] = (slot, idata)
-
-def lookup_display_templates(config):
-    printer = config.get_printer()
-    dt = printer.lookup_object("display_template", None)
-    if dt is None:
-        dt = PrinterDisplayTemplate(config)
-        printer.add_object("display_template", dt)
-    return dt
-
-class PrinterLCD:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        # Load low-level lcd handler
-        self.lcd_chip = config.getchoice('lcd_type', LCD_chips)(config)
-        # Load menu and display_status
-        self.menu = None
-        name = config.get_name()
-        if name == 'display':
-            # only load menu for primary display
-            self.menu = menu.MenuManager(config, self)
-        self.printer.load_object(config, "display_status")
-        # Configurable display
-        templates = lookup_display_templates(config)
-        self.display_templates = templates.get_display_templates()
-        self.display_data_groups = templates.get_display_data_groups()
-        self.lcd_chip.set_glyphs(templates.get_display_glyphs())
-        dgroup = "_default_16x4"
-        if self.lcd_chip.get_dimensions()[0] == 20:
-            dgroup = "_default_20x4"
-        dgroup = config.get('display_group', dgroup)
-        self.show_data_group = self.display_data_groups.get(dgroup)
-        if self.show_data_group is None:
-            raise config.error("Unknown display_data group '%s'" % (dgroup,))
-        # Screen updating
-        self.printer.register_event_handler("klippy:ready", self.handle_ready)
-        self.screen_update_timer = self.reactor.register_timer(
-            self.screen_update_event)
-        self.redraw_request_pending = False
-        self.redraw_time = 0.
-        # Register g-code commands
-        gcode = self.printer.lookup_object("gcode")
-        gcode.register_mux_command('SET_DISPLAY_GROUP', 'DISPLAY', name,
-                                   self.cmd_SET_DISPLAY_GROUP,
-                                   desc=self.cmd_SET_DISPLAY_GROUP_help)
-        if name == 'display':
-            gcode.register_mux_command('SET_DISPLAY_GROUP', 'DISPLAY', None,
-                                       self.cmd_SET_DISPLAY_GROUP)
-    def get_dimensions(self):
-        return self.lcd_chip.get_dimensions()
-    def handle_ready(self):
-        self.lcd_chip.init()
-        # Start screen update timer
-        self.reactor.update_timer(self.screen_update_timer, self.reactor.NOW)
-    # Screen updating
-    def screen_update_event(self, eventtime):
-        if self.redraw_request_pending:
-            self.redraw_request_pending = False
-            self.redraw_time = eventtime + REDRAW_MIN_TIME
-        self.lcd_chip.clear()
-        # update menu component
-        if self.menu is not None:
-            ret = self.menu.screen_update_event(eventtime)
-            if ret:
-                self.lcd_chip.flush()
-                return eventtime + REDRAW_TIME
-        # Update normal display
-        try:
-            self.show_data_group.show(self, self.display_templates, eventtime)
-        except:
-            logging.exception("Error during display screen update")
-        self.lcd_chip.flush()
-        return eventtime + REDRAW_TIME
-    def request_redraw(self):
-        if self.redraw_request_pending:
-            return
-        self.redraw_request_pending = True
-        self.reactor.update_timer(self.screen_update_timer, self.redraw_time)
-    def draw_text(self, row, col, mixed_text, eventtime):
-        pos = col
-        for i, text in enumerate(mixed_text.split('~')):
-            if i & 1 == 0:
-                # write text
-                self.lcd_chip.write_text(pos, row, text.encode())
-                pos += len(text)
-            else:
-                # write glyph
-                pos += self.lcd_chip.write_glyph(pos, row, text)
-        return pos
-    def draw_progress_bar(self, row, col, width, value):
-        pixels = -1 << int(width * 8 * (1. - value) + .5)
-        pixels |= (1 << (width * 8 - 1)) | 1
-        for i in range(width):
-            data = [0xff] + [(pixels >> (i * 8)) & 0xff] * 14 + [0xff]
-            self.lcd_chip.write_graphics(col + width - 1 - i, row, data)
-        return ""
-    cmd_SET_DISPLAY_GROUP_help = "Set the active display group"
-    def cmd_SET_DISPLAY_GROUP(self, gcmd):
-        group = gcmd.get('GROUP')
-        new_dg = self.display_data_groups.get(group)
-        if new_dg is None:
-            raise gcmd.error("Unknown display_data group '%s'" % (group,))
-        self.show_data_group = new_dg
-
-def load_config(config):
-    return PrinterLCD(config)
deleted file mode 100644
--- a/klippy/extras/display/font8x14.py
+++ /dev/null
@@ -1,276 +0,0 @@
-# Fonts for connected displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan  <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-
-######################################################################
-# Font - VGA 8x14, Row Major, MSB, 2 bytes padding
-#
-# Font comes from fntcol16.zip package found at:
-# ftp://ftp.simtel.net/pub/simtelnet/msdos/screen/fntcol16.zip
-# (c) Joseph Gil
-#
-# Indivdual fonts are public domain
-######################################################################
-
-VGA_FONT = [
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\x81\xa5\x81\x81\xbd\x99\x81\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\xff\xdb\xff\xff\xc3\xe7\xff\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x6c\xfe\xfe\xfe\xfe\x7c\x38\x10\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x10\x38\x7c\xfe\x7c\x38\x10\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x3c\xe7\xe7\xe7\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\xff\xff\x7e\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x18\x3c\x3c\x18\x00\x00\x00\x00\x00\x00',
-    b'\x00\xff\xff\xff\xff\xff\xe7\xc3\xc3\xe7\xff\xff\xff\xff\xff\x00',
-    b'\x00\x00\x00\x00\x00\x3c\x66\x42\x42\x66\x3c\x00\x00\x00\x00\x00',
-    b'\x00\xff\xff\xff\xff\xc3\x99\xbd\xbd\x99\xc3\xff\xff\xff\xff\x00',
-    b'\x00\x00\x00\x1e\x0e\x1a\x32\x78\xcc\xcc\xcc\x78\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\x66\x66\x3c\x18\x7e\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3f\x33\x3f\x30\x30\x30\x70\xf0\xe0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7f\x63\x7f\x63\x63\x63\x67\xe7\xe6\xc0\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\xdb\x3c\xe7\x3c\xdb\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x80\xc0\xe0\xf8\xfe\xf8\xe0\xc0\x80\x00\x00\x00\x00',
-    b'\x00\x00\x00\x02\x06\x0e\x3e\xfe\x3e\x0e\x06\x02\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\x18\x18\x18\x7e\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x66\x66\x66\x66\x00\x66\x66\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7f\xdb\xdb\xdb\x7b\x1b\x1b\x1b\x1b\x00\x00\x00\x00',
-    b'\x00\x00\x7c\xc6\x60\x38\x6c\xc6\xc6\x6c\x38\x0c\xc6\x7c\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\xfe\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\x18\x18\x18\x7e\x3c\x18\x7e\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x7e\x18\x18\x18\x18\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\x18\x18\x18\x18\x7e\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x18\x0c\xfe\x0c\x18\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x30\x60\xfe\x60\x30\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc0\xc0\xc0\xfe\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x28\x6c\xfe\x6c\x28\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x10\x38\x38\x7c\x7c\xfe\xfe\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\xfe\xfe\x7c\x7c\x38\x38\x10\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x3c\x3c\x3c\x18\x18\x00\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x66\x66\x66\x24\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x6c\x6c\xfe\x6c\x6c\x6c\xfe\x6c\x6c\x00\x00\x00\x00',
-    b'\x00\x18\x18\x7c\xc6\xc2\xc0\x7c\x06\x86\xc6\x7c\x18\x18\x00\x00',
-    b'\x00\x00\x00\x00\x00\xc2\xc6\x0c\x18\x30\x66\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\x6c\x38\x76\xdc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x30\x30\x30\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0c\x18\x30\x30\x30\x30\x30\x18\x0c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x30\x18\x0c\x0c\x0c\x0c\x0c\x18\x30\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x66\x3c\xff\x3c\x66\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x18\x18\x7e\x18\x18\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x18\x18\x30\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\xfe\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x02\x06\x0c\x18\x30\x60\xc0\x80\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xce\xde\xf6\xe6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x38\x78\x18\x18\x18\x18\x18\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\x06\x0c\x18\x30\x60\xc6\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\x06\x06\x3c\x06\x06\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0c\x1c\x3c\x6c\xcc\xfe\x0c\x0c\x1e\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc0\xc0\xc0\xfc\x06\x06\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x60\xc0\xc0\xfc\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\x06\x0c\x18\x30\x30\x30\x30\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xc6\x7c\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xc6\x7e\x06\x06\x0c\x78\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x00\x00\x00\x18\x18\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x00\x00\x00\x18\x18\x30\x00\x00\x00\x00',
-    b'\x00\x00\x00\x06\x0c\x18\x30\x60\x30\x18\x0c\x06\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7e\x00\x00\x7e\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x60\x30\x18\x0c\x06\x0c\x18\x30\x60\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\x0c\x18\x18\x00\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xde\xde\xde\xdc\xc0\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x10\x38\x6c\xc6\xc6\xfe\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfc\x66\x66\x66\x7c\x66\x66\x66\xfc\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\xc2\xc0\xc0\xc0\xc2\x66\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xf8\x6c\x66\x66\x66\x66\x66\x6c\xf8\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\x66\x62\x68\x78\x68\x62\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\x66\x62\x68\x78\x68\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\xc2\xc0\xc0\xde\xc6\x66\x3a\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xfe\xc6\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x18\x18\x18\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1e\x0c\x0c\x0c\x0c\x0c\xcc\xcc\x78\x00\x00\x00\x00',
-    b'\x00\x00\x00\xe6\x66\x6c\x6c\x78\x6c\x6c\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\xf0\x60\x60\x60\x60\x60\x62\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xee\xfe\xfe\xd6\xc6\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xe6\xf6\xfe\xde\xce\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\xc6\xc6\xc6\xc6\xc6\x6c\x38\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfc\x66\x66\x66\x7c\x60\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\xc6\xc6\xd6\xde\x7c\x0c\x0e\x00\x00\x00',
-    b'\x00\x00\x00\xfc\x66\x66\x66\x7c\x6c\x66\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7c\xc6\xc6\x60\x38\x0c\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\x7e\x5a\x18\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xc6\xc6\x6c\x38\x10\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\xc6\xc6\xd6\xd6\xfe\x7c\x6c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\x6c\x38\x38\x38\x6c\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x66\x66\x3c\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\x8c\x18\x30\x60\xc2\xc6\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x30\x30\x30\x30\x30\x30\x30\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x80\xc0\xe0\x70\x38\x1c\x0e\x06\x02\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x3c\x00\x00\x00\x00',
-    b'\x00\x10\x38\x6c\xc6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00',
-    b'\x00\x30\x30\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\xe0\x60\x60\x78\x6c\x66\x66\x66\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\xc0\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1c\x0c\x0c\x3c\x6c\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\x64\x60\xf0\x60\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x76\xcc\xcc\xcc\x7c\x0c\xcc\x78\x00\x00',
-    b'\x00\x00\x00\xe0\x60\x60\x6c\x76\x66\x66\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x06\x06\x00\x0e\x06\x06\x06\x06\x66\x66\x3c\x00\x00',
-    b'\x00\x00\x00\xe0\x60\x60\x66\x6c\x78\x6c\x66\xe6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x18\x18\x18\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xec\xfe\xd6\xd6\xd6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xdc\x66\x66\x66\x66\x66\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xdc\x66\x66\x66\x7c\x60\x60\xf0\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x76\xcc\xcc\xcc\x7c\x0c\x0c\x1e\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xdc\x76\x66\x60\x60\xf0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7c\xc6\x70\x1c\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x10\x30\x30\xfc\x30\x30\x30\x36\x1c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x66\x66\x66\x66\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc6\xc6\xd6\xd6\xfe\x6c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc6\x6c\x38\x38\x6c\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xc6\xc6\xc6\xc6\x7e\x06\x0c\xf8\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xfe\xcc\x18\x30\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0e\x18\x18\x18\x70\x18\x18\x18\x0e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x18\x18\x18\x18\x00\x18\x18\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x70\x18\x18\x18\x0e\x18\x18\x18\x70\x00\x00\x00\x00',
-    b'\x00\x00\x00\x76\xdc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x10\x38\x6c\xc6\xc6\xfe\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3c\x66\xc2\xc0\xc0\xc2\x66\x3c\x0c\x06\x7c\x00\x00',
-    b'\x00\x00\x00\xcc\xcc\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x0c\x18\x30\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x10\x38\x6c\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\xcc\xcc\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x38\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x3c\x66\x60\x66\x3c\x0c\x06\x3c\x00\x00\x00',
-    b'\x00\x00\x10\x38\x6c\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xcc\xcc\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x7c\xc6\xfe\xc0\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x3c\x66\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\xc6\xc6\x10\x38\x6c\xc6\xc6\xfe\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x38\x6c\x38\x00\x38\x6c\xc6\xc6\xfe\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x18\x30\x60\x00\xfe\x66\x60\x7c\x60\x66\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\xcc\x76\x36\x7e\xd8\xd8\x6e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x3e\x6c\xcc\xcc\xfe\xcc\xcc\xcc\xce\x00\x00\x00\x00',
-    b'\x00\x00\x10\x38\x6c\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x30\x78\xcc\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x60\x30\x18\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\xc6\xc6\x00\xc6\xc6\xc6\xc6\x7e\x06\x0c\x78\x00\x00',
-    b'\x00\x00\xc6\xc6\x38\x6c\xc6\xc6\xc6\xc6\x6c\x38\x00\x00\x00\x00',
-    b'\x00\x00\xc6\xc6\x00\xc6\xc6\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x18\x3c\x66\x60\x60\x66\x3c\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x64\x60\xf0\x60\x60\x60\xe6\xfc\x00\x00\x00\x00',
-    b'\x00\x00\x00\x66\x66\x3c\x18\x7e\x18\x7e\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\xf8\xcc\xcc\xf8\xc4\xcc\xde\xcc\xcc\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x0e\x1b\x18\x18\x18\x7e\x18\x18\x18\x18\xd8\x70\x00\x00',
-    b'\x00\x00\x18\x30\x60\x00\x78\x0c\x7c\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x0c\x18\x30\x00\x38\x18\x18\x18\x18\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x30\x60\x00\x7c\xc6\xc6\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x18\x30\x60\x00\xcc\xcc\xcc\xcc\xcc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x76\xdc\x00\xdc\x66\x66\x66\x66\x66\x00\x00\x00\x00',
-    b'\x00\x76\xdc\x00\xc6\xe6\xf6\xfe\xde\xce\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x3c\x6c\x6c\x3e\x00\x7e\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x6c\x38\x00\x7c\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x30\x30\x00\x30\x30\x60\xc6\xc6\x7c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\xfe\xc0\xc0\xc0\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\xfe\x06\x06\x06\x00\x00\x00\x00\x00',
-    b'\x00\x00\xc0\xc0\xc6\xcc\xd8\x30\x60\xdc\x86\x0c\x18\x3e\x00\x00',
-    b'\x00\x00\xc0\xc0\xc6\xcc\xd8\x30\x66\xce\x9e\x3e\x06\x06\x00\x00',
-    b'\x00\x00\x00\x18\x18\x00\x18\x18\x3c\x3c\x3c\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x36\x6c\xd8\x6c\x36\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\xd8\x6c\x36\x6c\xd8\x00\x00\x00\x00\x00\x00',
-    b'\x00\x11\x44\x11\x44\x11\x44\x11\x44\x11\x44\x11\x44\x11\x44\x00',
-    b'\x00\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x55\xaa\x00',
-    b'\x00\xdd\x77\xdd\x77\xdd\x77\xdd\x77\xdd\x77\xdd\x77\xdd\x77\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\xf8\x18\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xf6\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\xf8\x18\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf6\x06\xf6\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\xfe\x06\xf6\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf6\x06\xfe\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xfe\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\xf8\x18\xf8\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xf8\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x1f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x1f\x18\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\x37\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x37\x30\x3f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x3f\x30\x37\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf7\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xff\x00\xf7\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x37\x30\x37\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x00\x00\x00\x00\x00\xff\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x36\x36\x36\x36\x36\xf7\x00\xf7\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x18\x18\x18\x18\x18\xff\x00\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xff\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\xff\x00\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\x3f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x18\x18\x18\x18\x18\x1f\x18\x1f\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x1f\x18\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x3f\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x36\x36\x36\x36\x36\x36\x36\xff\x36\x36\x36\x36\x36\x36\x00',
-    b'\x00\x18\x18\x18\x18\x18\xff\x18\xff\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\xf8\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\x00',
-    b'\x00\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0\x00',
-    b'\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x00',
-    b'\x00\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x76\xdc\xd8\xd8\xdc\x76\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x7c\xc6\xfc\xc6\xc6\xfc\xc0\xc0\x40\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\xc6\xc0\xc0\xc0\xc0\xc0\xc0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\xfe\x6c\x6c\x6c\x6c\x6c\x6c\x00\x00\x00\x00',
-    b'\x00\x00\x00\xfe\xc6\x60\x30\x18\x30\x60\xc6\xfe\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7e\xd8\xd8\xd8\xd8\x70\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x66\x66\x66\x66\x7c\x60\x60\xc0\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x76\xdc\x18\x18\x18\x18\x18\x00\x00\x00\x00',
-    b'\x00\x00\x00\x7e\x18\x3c\x66\x66\x66\x3c\x18\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\xc6\xc6\xfe\xc6\xc6\x6c\x38\x00\x00\x00\x00',
-    b'\x00\x00\x00\x38\x6c\xc6\xc6\xc6\x6c\x6c\x6c\xee\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1e\x30\x18\x0c\x3e\x66\x66\x66\x3c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x7e\xdb\xdb\x7e\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x03\x06\x7e\xdb\xdb\xf3\x7e\x60\xc0\x00\x00\x00\x00',
-    b'\x00\x00\x00\x1c\x30\x60\x60\x7c\x60\x60\x30\x1c\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x7c\xc6\xc6\xc6\xc6\xc6\xc6\xc6\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\xfe\x00\x00\xfe\x00\x00\xfe\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x7e\x18\x18\x00\x00\xff\x00\x00\x00\x00',
-    b'\x00\x00\x00\x30\x18\x0c\x06\x0c\x18\x30\x00\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0c\x18\x30\x60\x30\x18\x0c\x00\x7e\x00\x00\x00\x00',
-    b'\x00\x00\x00\x0e\x1b\x1b\x18\x18\x18\x18\x18\x18\x18\x18\x18\x00',
-    b'\x00\x18\x18\x18\x18\x18\x18\x18\x18\xd8\xd8\x70\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x18\x18\x00\x7e\x00\x18\x18\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x76\xdc\x00\x76\xdc\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x38\x6c\x6c\x38\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x18\x18\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x0f\x0c\x0c\x0c\x0c\x0c\xec\x6c\x3c\x1c\x00\x00\x00\x00',
-    b'\x00\x00\xd8\x6c\x6c\x6c\x6c\x6c\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x70\xd8\x30\x60\xc8\xf8\x00\x00\x00\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x7c\x7c\x7c\x7c\x7c\x7c\x00\x00\x00\x00\x00',
-    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
-]
deleted file mode 100644
--- a/klippy/extras/display/hd44780.py
+++ /dev/null
@@ -1,134 +0,0 @@
-# Support for HD44780 (20x4 text) LCD displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-LINE_LENGTH_DEFAULT=20
-LINE_LENGTH_OPTIONS={16:16, 20:20}
-
-TextGlyphs = { 'right_arrow': b'\x7e' }
-
-HD44780_DELAY = .000040
-
-class HD44780:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        # pin config
-        ppins = self.printer.lookup_object('pins')
-        pins = [ppins.lookup_pin(config.get(name + '_pin'))
-                for name in ['rs', 'e', 'd4', 'd5', 'd6', 'd7']]
-        self.hd44780_protocol_init = config.getboolean('hd44780_protocol_init',
-                                                       True)
-        self.line_length = config.getchoice('line_length', LINE_LENGTH_OPTIONS,
-                                            LINE_LENGTH_DEFAULT)
-        mcu = None
-        for pin_params in pins:
-            if mcu is not None and pin_params['chip'] != mcu:
-                raise ppins.error("hd44780 all pins must be on same mcu")
-            mcu = pin_params['chip']
-        self.pins = [pin_params['pin'] for pin_params in pins]
-        self.mcu = mcu
-        self.oid = self.mcu.create_oid()
-        self.mcu.register_config_callback(self.build_config)
-        self.send_data_cmd = self.send_cmds_cmd = None
-        self.icons = {}
-        # framebuffers
-        self.text_framebuffers = [bytearray(b' '*2*self.line_length),
-                                  bytearray(b' '*2*self.line_length)]
-        self.glyph_framebuffer = bytearray(64)
-        self.all_framebuffers = [
-            # Text framebuffers
-            (self.text_framebuffers[0], bytearray(b'~'*2*self.line_length),
-             0x80),
-            (self.text_framebuffers[1], bytearray(b'~'*2*self.line_length),
-             0xc0),
-            # Glyph framebuffer
-            (self.glyph_framebuffer, bytearray(b'~'*64), 0x40) ]
-    def build_config(self):
-        self.mcu.add_config_cmd(
-            "config_hd44780 oid=%d rs_pin=%s e_pin=%s"
-            " d4_pin=%s d5_pin=%s d6_pin=%s d7_pin=%s delay_ticks=%d" % (
-                self.oid, self.pins[0], self.pins[1],
-                self.pins[2], self.pins[3], self.pins[4], self.pins[5],
-                self.mcu.seconds_to_clock(HD44780_DELAY)))
-        cmd_queue = self.mcu.alloc_command_queue()
-        self.send_cmds_cmd = self.mcu.lookup_command(
-            "hd44780_send_cmds oid=%c cmds=%*s", cq=cmd_queue)
-        self.send_data_cmd = self.mcu.lookup_command(
-            "hd44780_send_data oid=%c data=%*s", cq=cmd_queue)
-    def send(self, cmds, is_data=False):
-        cmd_type = self.send_cmds_cmd
-        if is_data:
-            cmd_type = self.send_data_cmd
-        cmd_type.send([self.oid, cmds], reqclock=BACKGROUND_PRIORITY_CLOCK)
-        #logging.debug("hd44780 %d %s", is_data, repr(cmds))
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, fb_id in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 4 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for pos, count in diffs:
-                chip_pos = pos
-                self.send([fb_id + chip_pos])
-                self.send(new_data[pos:pos+count], is_data=True)
-            old_data[:] = new_data
-    def init(self):
-        curtime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(curtime)
-        # Program 4bit / 2-line mode and then issue 0x02 "Home" command
-        if self.hd44780_protocol_init:
-            init = [[0x33], [0x33], [0x32], [0x28, 0x28, 0x02]]
-        else:
-            init = [[0x02]]
-        # Reset (set positive direction ; enable display and hide cursor)
-        init.append([0x06, 0x0c])
-        for i, cmds in enumerate(init):
-            minclock = self.mcu.print_time_to_clock(print_time + i * .100)
-            self.send_cmds_cmd.send([self.oid, cmds], minclock=minclock)
-        self.flush()
-    def write_text(self, x, y, data):
-        if x + len(data) > self.line_length:
-            data = data[:self.line_length - min(x, self.line_length)]
-        pos = x + ((y & 0x02) >> 1) * self.line_length
-        self.text_framebuffers[y & 1][pos:pos+len(data)] = data
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            data = glyph_data.get('icon5x8')
-            if data is not None:
-                self.icons[glyph_name] = data
-    def write_glyph(self, x, y, glyph_name):
-        data = self.icons.get(glyph_name)
-        if data is not None:
-            slot, bits = data
-            self.write_text(x, y, [slot])
-            self.glyph_framebuffer[slot * 8:(slot + 1) * 8] = bits
-            return 1
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        return 0
-    def write_graphics(self, x, y, data):
-        pass
-    def clear(self):
-        spaces = b' ' * 2*self.line_length
-        self.text_framebuffers[0][:] = spaces
-        self.text_framebuffers[1][:] = spaces
-    def get_dimensions(self):
-        return (self.line_length, 4)
deleted file mode 100644
--- a/klippy/extras/display/hd44780_spi.py
+++ /dev/null
@@ -1,125 +0,0 @@
-# Support for HD44780 (20x4 text) LCD displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan <arksine.code@gmail.com>
-# Copyright (C) 2021  Marc-Andre Denis <marcadenis@msn.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from .. import bus
-
-LINE_LENGTH_DEFAULT=20
-LINE_LENGTH_OPTIONS={16:16, 20:20}
-
-TextGlyphs = { 'right_arrow': b'\x7e' }
-
-
-
-class hd44780_spi:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.hd44780_protocol_init = config.getboolean('hd44780_protocol_init',
-                                                       True)
-        # spi config
-        self.spi = bus.MCU_SPI_from_config(
-            config, 0x00, pin_option="latch_pin")
-        self.mcu = self.spi.get_mcu()
-        #self.spi.spi_send([0x01,0xa0])
-        self.data_mask = (1<<1)
-        self.command_mask = 0
-        self.enable_mask = (1<<3)
-
-        self.icons = {}
-        self.line_length = config.getchoice('line_length', LINE_LENGTH_OPTIONS,
-                                            LINE_LENGTH_DEFAULT)
-
-        # framebuffers
-        self.text_framebuffers = [bytearray(b' '*2*self.line_length),
-                                  bytearray(b' '*2*self.line_length)]
-        self.glyph_framebuffer = bytearray(64)
-        self.all_framebuffers = [
-            # Text framebuffers
-            (self.text_framebuffers[0], bytearray(b'~'*2*self.line_length),
-             0x80),
-            (self.text_framebuffers[1], bytearray(b'~'*2*self.line_length),
-             0xc0),
-            # Glyph framebuffer
-            (self.glyph_framebuffer, bytearray(b'~'*64), 0x40) ]
-    def send_4_bits(self, cmd, is_data, minclock):
-        if is_data:
-            mask = self.data_mask
-        else:
-            mask = self.command_mask
-        self.spi.spi_send([(cmd & 0xF0) | mask], minclock)
-        self.spi.spi_send([(cmd & 0xF0) | mask | self.enable_mask], minclock)
-        self.spi.spi_send([(cmd & 0xF0) | mask], minclock)
-    def send(self, cmds, is_data=False, minclock=0):
-        for data in cmds:
-            self.send_4_bits(data,is_data,minclock)
-            self.send_4_bits(data<<4,is_data,minclock)
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, fb_id in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 4 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for pos, count in diffs:
-                chip_pos = pos
-                self.send([fb_id + chip_pos])
-                self.send(new_data[pos:pos+count], is_data=True)
-            old_data[:] = new_data
-    def init(self):
-        curtime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(curtime)
-        # Program 4bit / 2-line mode and then issue 0x02 "Home" command
-        if self.hd44780_protocol_init:
-            init = [[0x33], [0x33], [0x32], [0x28, 0x28, 0x02]]
-        else:
-            init = [[0x02]]
-        # Reset (set positive direction ; enable display and hide cursor)
-        init.append([0x06, 0x0c])
-        for i, cmds in enumerate(init):
-            minclock = self.mcu.print_time_to_clock(print_time + i * .100)
-            self.send(cmds, minclock=minclock)
-        self.flush()
-    def write_text(self, x, y, data):
-        if x + len(data) > self.line_length:
-            data = data[:self.line_length - min(x, self.line_length)]
-        pos = x + ((y & 0x02) >> 1) * self.line_length
-        self.text_framebuffers[y & 1][pos:pos+len(data)] = data
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            data = glyph_data.get('icon5x8')
-            if data is not None:
-                self.icons[glyph_name] = data
-    def write_glyph(self, x, y, glyph_name):
-        data = self.icons.get(glyph_name)
-        if data is not None:
-            slot, bits = data
-            self.write_text(x, y, [slot])
-            self.glyph_framebuffer[slot * 8:(slot + 1) * 8] = bits
-            return 1
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        return 0
-    def write_graphics(self, x, y, data):
-        pass
-    def clear(self):
-        spaces = b' ' * 2*self.line_length
-        self.text_framebuffers[0][:] = spaces
-        self.text_framebuffers[1][:] = spaces
-    def get_dimensions(self):
-        return (self.line_length, 4)
deleted file mode 100644
--- a/klippy/extras/display/menu.cfg
+++ /dev/null
@@ -1,782 +0,0 @@
-# This file defines the default layout of the printer's menu.
-
-# It is not necessary to edit this file to change the menu. Instead,
-# one may override any of the sections defined here by defining a
-# section with the same name in the main printer.cfg config file.
-
-### DEFAULT MENU ###
-# Main
-#   + Tune
-#       + Speed: 000%
-#       + Flow: 000%
-#       + Offset Z:00.00
-#   + OctoPrint
-#       + Pause printing
-#       + Resume printing
-#       + Abort printing
-#   + SD Card
-#       + Start printing
-#       + Resume printing
-#       + Pause printing
-#       + Cancel printing
-#       + ... (files)
-#   + Control
-#       + Home All
-#       + Home Z
-#       + Home X/Y
-#       + Z Tilt
-#       + Quad Gantry Lvl
-#       + Bed Mesh
-#       + Steppers off
-#       + Fan: OFF
-#       + Fan speed: 000%
-#       + Lights: OFF
-#       + Lights: 000%
-#       + Move 10mm
-#           + Move X:000.0
-#           + Move Y:000.0
-#           + Move Z:000.0
-#           + Move E:+000.0
-#       + Move 1mm
-#           + Move X:000.0
-#           + Move Y:000.0
-#           + Move Z:000.0
-#           + Move E:+000.0
-#       + Move 0.1mm
-#           + Move X:000.0
-#           + Move Y:000.0
-#           + Move Z:000.0
-#           + Move E:+000.0
-#   + Temperature
-#       + Ex0:000 (0000)
-#       + Ex1:000 (0000)
-#       + Bed:000 (0000)
-#       + Preheat PLA
-#           + Preheat all
-#           + Preheat hotend
-#           + Preheat hotbed
-#       + Preheat ABS
-#           + Preheat all
-#           + Preheat hotend
-#           + Preheat hotbed
-#       + Cooldown
-#           + Cooldown all
-#           + Cooldown hotend
-#           + Cooldown hotbed
-#   + Filament
-#       + Ex0:000 (0000)
-#       + Load Fil. fast
-#       + Load Fil. slow
-#       + Unload Fil.fast
-#       + Unload Fil.slow
-#       + Feed: 000.0
-#   + Setup
-#       + Save config
-#       + Restart
-#           + Restart host
-#           + Restart FW
-#       + PID tuning
-#           + Tune Hotend PID
-#           + Tune Hotbed PID
-#       + Calibration
-#           + Delta cal. auto
-#           + Delta cal. man
-#               + Start probing
-#               + Move Z: 000.00
-#               + Test Z: ++
-#               + Accept
-#               + Abort
-#           + Bed probe
-#       + Dump parameters
-
-### menu main ###
-[menu __main]
-type: list
-name: Main
-
-### menu tune ###
-[menu __main __tune]
-type: list
-enable: {printer.idle_timeout.state == "Printing"}
-name: Tune
-
-[menu __main __tune __speed]
-type: input
-name: Speed: {'%3d' % (menu.input*100)}%
-input: {printer.gcode_move.speed_factor}
-input_min: 0.01
-input_max: 5
-input_step: 0.01
-realtime: True
-gcode:
-    M220 S{'%d' % (menu.input*100)}
-
-[menu __main __tune __flow]
-type: input
-name: Flow: {'%3d' % (menu.input*100)}%
-input: {printer.gcode_move.extrude_factor}
-input_min: 0.01
-input_max: 2
-input_step: 0.01
-realtime: True
-gcode:
-    M221 S{'%d' % (menu.input*100)}
-
-[menu __main __tune __offsetz]
-type: input
-name: Offset Z:{'%05.3f' % menu.input}
-input: {printer.gcode_move.homing_origin.z}
-input_min: -5
-input_max: 5
-input_step: 0.005
-realtime: True
-gcode:
-    SET_GCODE_OFFSET Z={'%.3f' % menu.input} MOVE=1
-
-
-### menu octoprint ###
-[menu __main __octoprint]
-type: list
-name: OctoPrint
-
-[menu __main __octoprint __pause]
-type: command
-enable: {printer.idle_timeout.state == "Printing"}
-name: Pause printing
-gcode:
-    {action_respond_info('action:pause')}
-
-[menu __main __octoprint __resume]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Resume printing
-gcode:
-    {action_respond_info('action:resume')}
-
-[menu __main __octoprint __abort]
-type: command
-enable: {printer.idle_timeout.state == "Printing"}
-name: Abort printing
-gcode:
-    {action_respond_info('action:cancel')}
-
-### menu virtual sdcard ###
-[menu __main __sdcard]
-type: vsdlist
-enable: {('virtual_sdcard' in printer)}
-name: SD Card
-
-[menu __main __sdcard __start]
-type: command
-enable: {('virtual_sdcard' in printer) and printer.virtual_sdcard.file_path and not printer.virtual_sdcard.is_active}
-name: Start printing
-gcode: M24
-
-[menu __main __sdcard __resume]
-type: command
-enable: {('virtual_sdcard' in printer) and printer.print_stats.state == "paused"}
-name: Resume printing
-gcode:
-    {% if "pause_resume" in printer %}
-        RESUME
-    {% else %}
-        M24
-    {% endif %}
-
-[menu __main __sdcard __pause]
-type: command
-enable: {('virtual_sdcard' in printer) and printer.print_stats.state == "printing"}
-name: Pause printing
-gcode:
-    {% if "pause_resume" in printer %}
-        PAUSE
-    {% else %}
-        M25
-    {% endif %}
-
-[menu __main __sdcard __cancel]
-type: command
-enable: {('virtual_sdcard' in printer) and (printer.print_stats.state == "printing" or printer.print_stats.state == "paused")}
-name: Cancel printing
-gcode:
-    {% if 'pause_resume' in printer %}
-        CANCEL_PRINT
-    {% else %}
-        M25
-        M27
-        M26 S0
-        TURN_OFF_HEATERS
-        {% if printer.toolhead.position.z <= printer.toolhead.axis_maximum.z - 5 %}
-            G91
-            G0 Z5 F1000
-            G90
-        {% endif %}
-    {% endif %}
-
-### menu control ###
-[menu __main __control]
-type: list
-name: Control
-
-[menu __main __control __home]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Home All
-gcode: G28
-
-[menu __main __control __homez]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Home Z
-gcode: G28 Z
-
-[menu __main __control __homexy]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Home X/Y
-gcode: G28 X Y
-
-[menu __main __control __z_tilt]
-type: command
-enable: {not printer.idle_timeout.state == "Printing" and ('z_tilt' in printer)}
-name: Z Tilt
-gcode: Z_TILT_ADJUST
-
-[menu __main __control __quad_gantry_level]
-type: command
-enable: {not printer.idle_timeout.state == "Printing" and ('quad_gantry_level' in printer)}
-name: Quad Gantry Lvl
-gcode: QUAD_GANTRY_LEVEL
-
-[menu __main __control __bed_mesh]
-type: command
-enable: {not printer.idle_timeout.state == "Printing" and ('bed_mesh' in printer)}
-name: Bed Mesh
-gcode: BED_MESH_CALIBRATE
-
-[menu __main __control __disable]
-type: command
-name: Steppers off
-gcode:
-    M84
-    M18
-
-[menu __main __control __fanonoff]
-type: input
-enable: {'fan' in printer}
-name: Fan: {'ON ' if menu.input else 'OFF'}
-input: {printer.fan.speed}
-input_min: 0
-input_max: 1
-input_step: 1
-gcode:
-    M106 S{255 if menu.input else 0}
-
-[menu __main __control __fanspeed]
-type: input
-enable: {'fan' in printer}
-name: Fan speed: {'%3d' % (menu.input*100)}%
-input: {printer.fan.speed}
-input_min: 0
-input_max: 1
-input_step: 0.01
-gcode:
-    M106 S{'%d' % (menu.input*255)}
-
-[menu __main __control __caselightonoff]
-type: input
-enable: {'output_pin caselight' in printer}
-name: Lights: {'ON ' if menu.input else 'OFF'}
-input: {printer['output_pin caselight'].value}
-input_min: 0
-input_max: 1
-input_step: 1
-gcode:
-    SET_PIN PIN=caselight VALUE={1 if menu.input else 0}
-
-[menu __main __control __caselightpwm]
-type: input
-enable: {'output_pin caselight' in printer}
-name: Lights: {'%3d' % (menu.input*100)}%
-input: {printer['output_pin caselight'].value}
-input_min: 0.0
-input_max: 1.0
-input_step: 0.01
-gcode:
-    SET_PIN PIN=caselight VALUE={menu.input}
-
-### menu move 10mm ###
-[menu __main __control __move_10mm]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move 10mm
-
-[menu __main __control __move_10mm __axis_x]
-type: input
-name: Move X:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.x}
-input_min: {printer.toolhead.axis_minimum.x}
-input_max: {printer.toolhead.axis_maximum.x}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 X{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_10mm __axis_y]
-type: input
-name: Move Y:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.y}
-input_min: {printer.toolhead.axis_minimum.y}
-input_max: {printer.toolhead.axis_maximum.y}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Y{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_10mm __axis_z]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move Z:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_min: 0
-input_max: {printer.toolhead.axis_maximum.z}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Z{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_10mm __axis_e]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move E:{'%+06.1f' % menu.input}
-input: 0
-input_min: -{printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_max: {printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_step: 10.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    M83
-    G1 E{menu.input} F240
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-### menu move 1mm ###
-[menu __main __control __move_1mm]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move 1mm
-
-[menu __main __control __move_1mm __axis_x]
-type: input
-name: Move X:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.x}
-input_min: {printer.toolhead.axis_minimum.x}
-input_max: {printer.toolhead.axis_maximum.x}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 X{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_1mm __axis_y]
-type: input
-name: Move Y:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.y}
-input_min: {printer.toolhead.axis_minimum.y}
-input_max: {printer.toolhead.axis_maximum.y}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Y{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_1mm __axis_z]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move Z:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_min: 0
-input_max: {printer.toolhead.axis_maximum.z}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Z{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_1mm __axis_e]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move E:{'%+06.1f' % menu.input}
-input: 0
-input_min: -{printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_max: {printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_step: 1.0
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    M83
-    G1 E{menu.input} F240
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-### menu move 0.1mm ###
-[menu __main __control __move_01mm]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move 0.1mm
-
-[menu __main __control __move_01mm __axis_x]
-type: input
-name: Move X:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.x}
-input_min: {printer.toolhead.axis_minimum.x}
-input_max: {printer.toolhead.axis_maximum.x}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 X{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_01mm __axis_y]
-type: input
-name: Move Y:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.y}
-input_min: {printer.toolhead.axis_minimum.y}
-input_max: {printer.toolhead.axis_maximum.y}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Y{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_01mm __axis_z]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move Z:{'%05.1f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_min: 0
-input_max: {printer.toolhead.axis_maximum.z}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    G90
-    G1 Z{menu.input}
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-[menu __main __control __move_01mm __axis_e]
-type: input
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Move E:{'%+06.1f' % menu.input}
-input: 0
-input_min: -{printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_max: {printer.configfile.config.extruder.max_extrude_only_distance|default(50)}
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__move__axis
-    M83
-    G1 E{menu.input} F240
-    RESTORE_GCODE_STATE NAME=__move__axis
-
-### menu temperature ###
-[menu __main __temp]
-type: list
-name: Temperature
-
-[menu __main __temp __hotend0_target]
-type: input
-enable: {('extruder' in printer) and ('extruder' in printer.heaters.available_heaters)}
-name: {"Ex0:%3.0f (%4.0f)" % (menu.input, printer.extruder.temperature)}
-input: {printer.extruder.target}
-input_min: 0
-input_max: {printer.configfile.config.extruder.max_temp}
-input_step: 1
-gcode: M104 T0 S{'%.0f' % menu.input}
-
-[menu __main __temp __hotend1_target]
-type: input
-enable: {('extruder1' in printer) and ('extruder1' in printer.heaters.available_heaters)}
-name: {"Ex1:%3.0f (%4.0f)" % (menu.input, printer.extruder1.temperature)}
-input: {printer.extruder1.target}
-input_min: 0
-input_max: {printer.configfile.config.extruder1.max_temp}
-input_step: 1
-gcode: M104 T1 S{'%.0f' % menu.input}
-
-[menu __main __temp __hotbed_target]
-type: input
-enable: {'heater_bed' in printer}
-name: {"Bed:%3.0f (%4.0f)" % (menu.input, printer.heater_bed.temperature)}
-input: {printer.heater_bed.target}
-input_min: 0
-input_max: {printer.configfile.config.heater_bed.max_temp}
-input_step: 1
-gcode: M140 S{'%.0f' % menu.input}
-
-[menu __main __temp __preheat_pla]
-type: list
-name: Preheat PLA
-
-[menu __main __temp __preheat_pla __all]
-type: command
-enable: {('extruder' in printer) and ('heater_bed' in printer)}
-name: Preheat all
-gcode:
-    M140 S60
-    M104 S200
-
-[menu __main __temp __preheat_pla __hotend]
-type: command
-enable: {'extruder' in printer}
-name: Preheat hotend
-gcode: M104 S200
-
-[menu __main __temp __preheat_pla __hotbed]
-type: command
-enable: {'heater_bed' in printer}
-name: Preheat hotbed
-gcode: M140 S60
-
-[menu __main __temp __preheat_abs]
-type: list
-name: Preheat ABS
-
-[menu __main __temp __preheat_abs __all]
-type: command
-enable: {('extruder' in printer) and ('heater_bed' in printer)}
-name: Preheat all
-gcode:
-    M140 S110
-    M104 S245
-
-[menu __main __temp __preheat_abs __hotend]
-type: command
-enable: {'extruder' in printer}
-name: Preheat hotend
-gcode: M104 S245
-
-[menu __main __temp __preheat_abs __hotbed]
-type: command
-enable: {'heater_bed' in printer}
-name: Preheat hotbed
-gcode: M140 S110
-
-[menu __main __temp __cooldown]
-type: list
-name: Cooldown
-
-[menu __main __temp __cooldown __all]
-type: command
-enable: {('extruder' in printer) and ('heater_bed' in printer)}
-name: Cooldown all
-gcode:
-    M104 S0
-    M140 S0
-
-[menu __main __temp __cooldown __hotend]
-type: command
-enable: {'extruder' in printer}
-name: Cooldown hotend
-gcode: M104 S0
-
-[menu __main __temp __cooldown __hotbed]
-type: command
-enable: {'heater_bed' in printer}
-name: Cooldown hotbed
-gcode: M140 S0
-
-### menu filament ###
-
-[menu __main __filament]
-type: list
-name: Filament
-
-[menu __main __filament __hotend0_target]
-type: input
-enable: {'extruder' in printer}
-name: {"Ex0:%3.0f (%4.0f)" % (menu.input, printer.extruder.temperature)}
-input: {printer.extruder.target}
-input_min: 0
-input_max: {printer.configfile.config.extruder.max_temp}
-input_step: 1
-gcode: M104 T0 S{'%.0f' % menu.input}
-
-[menu __main __filament __loadf]
-type: command
-name: Load Fil. fast
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E50 F960
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __loads]
-type: command
-name: Load Fil. slow
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E50 F240
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __unloadf]
-type: command
-name: Unload Fil.fast
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E-50 F960
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __unloads]
-type: command
-name: Unload Fil.slow
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E-50 F240
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-[menu __main __filament __feed]
-type: input
-name: Feed: {'%.1f' % menu.input}
-input: 5
-input_step: 0.1
-gcode:
-    SAVE_GCODE_STATE NAME=__filament__load
-    M83
-    G1 E{'%.1f' % menu.input} F60
-    RESTORE_GCODE_STATE NAME=__filament__load
-
-### menu setup ###
-[menu __main __setup]
-type: list
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Setup
-
-[menu __main __setup __save_config]
-type: command
-name: Save config
-gcode: SAVE_CONFIG
-
-[menu __main __setup __restart]
-type: list
-name: Restart
-
-[menu __main __setup __restart __host_restart]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Restart host
-gcode: RESTART
-
-[menu __main __setup __restart __firmware_restart]
-type: command
-enable: {not printer.idle_timeout.state == "Printing"}
-name: Restart FW
-gcode: FIRMWARE_RESTART
-
-[menu __main __setup __tuning]
-type: list
-name: PID tuning
-
-[menu __main __setup __tuning __hotend_pid_tuning]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('extruder' in printer)}
-name: Tune Hotend PID
-gcode: PID_CALIBRATE HEATER=extruder TARGET=210 WRITE_FILE=1
-
-[menu __main __setup __tuning __hotbed_pid_tuning]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('heater_bed' in printer)}
-name: Tune Hotbed PID
-gcode: PID_CALIBRATE HEATER=heater_bed TARGET=60 WRITE_FILE=1
-
-[menu __main __setup __calib]
-type: list
-name: Calibration
-
-[menu __main __setup __calib __delta_calib_auto]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('delta_calibrate' in printer)}
-name: Delta cal. auto
-gcode:
-    G28
-    DELTA_CALIBRATE
-
-[menu __main __setup __calib __delta_calib_man]
-type: list
-enable: {(not printer.idle_timeout.state == "Printing") and ('delta_calibrate' in printer)}
-name: Delta cal. man
-
-[menu __main __setup __calib __bedprobe]
-type: command
-enable: {(not printer.idle_timeout.state == "Printing") and ('probe' in printer)}
-name: Bed probe
-gcode: PROBE
-
-[menu __main __setup __calib __delta_calib_man __start]
-type: command
-name: Start probing
-gcode:
-    G28
-    DELTA_CALIBRATE METHOD=manual
-
-[menu __main __setup __calib __delta_calib_man __move_z]
-type: input
-name: Move Z: {'%03.2f' % menu.input}
-input: {printer.gcode_move.gcode_position.z}
-input_step: 1
-realtime: True
-gcode:
-    {%- if menu.event == 'change' -%}
-        G1 Z{'%.2f' % menu.input}
-    {%- elif menu.event == 'long_click' -%}
-        G1 Z{'%.2f' % menu.input}
-        SAVE_GCODE_STATE NAME=__move__axis
-        G91
-        G1 Z2
-        G1 Z-2
-        RESTORE_GCODE_STATE NAME=__move__axis
-    {%- endif -%}
-
-[menu __main __setup __calib __delta_calib_man __test_z]
-type: input
-name: Test Z: {['++','+','+.01','+.05','+.1','+.5','-.5','-.1','-.05','-.01','-','--'][menu.input|int]}
-input: 6
-input_min: 0
-input_max: 11
-input_step: 1
-gcode:
-    {%- if menu.event == 'long_click' -%}
-        TESTZ Z={['++','+','+.01','+.05','+.1','+.5','-.5','-.1','-.05','-.01','-','--'][menu.input|int]}
-    {%- endif -%}
-
-[menu __main __setup __calib __delta_calib_man __accept]
-type: command
-name: Accept
-gcode: ACCEPT
-
-[menu __main __setup __calib __delta_calib_man __abort]
-type: command
-name: Abort
-gcode: ABORT
-
-[menu __main __setup __dump]
-type: command
-name: Dump parameters
-gcode:
-   {% for name1 in printer %}
-      {% for name2 in printer[name1] %}
-         { action_respond_info("printer['%s'].%s = %s"
-                               % (name1, name2, printer[name1][name2])) }
-      {% else %}
-         { action_respond_info("printer['%s'] = %s" % (name1, printer[name1])) }
-      {% endfor %}
-   {% endfor %}
deleted file mode 100644
--- a/klippy/extras/display/menu.py
+++ /dev/null
@@ -1,1067 +0,0 @@
-# -*- coding: utf-8 -*-
-# Basic LCD menu support
-#
-# Copyright (C) 2020  Janar St <janar.soot@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import os, logging, ast, re
-from string import Template
-from . import menu_keys
-
-
-class sentinel:
-    pass
-
-
-class error(Exception):
-    pass
-
-
-# Scriptable menu element abstract baseclass
-class MenuElement(object):
-    def __init__(self, manager, config, **kwargs):
-        if type(self) is MenuElement:
-            raise error(
-                'Abstract MenuElement cannot be instantiated directly')
-        self._manager = manager
-        self._cursor = '>'
-        # set class defaults and attributes from arguments
-        self._index = kwargs.get('index', None)
-        self._enable = kwargs.get('enable', True)
-        self._name = kwargs.get('name', None)
-        self._enable_tpl = self._name_tpl = None
-        if config is not None:
-            # overwrite class attributes from config
-            self._index = config.getint('index', self._index)
-            self._name_tpl = manager.gcode_macro.load_template(
-                config, 'name', self._name)
-            try:
-                self._enable = config.getboolean('enable', self._enable)
-            except config.error:
-                self._enable_tpl = manager.gcode_macro.load_template(
-                    config, 'enable')
-            # item namespace - used in relative paths
-            self._ns = str(" ".join(config.get_name().split(' ')[1:])).strip()
-        else:
-            # ns - item namespace key, used in item relative paths
-            # $__id - generated id text variable
-            __id = '__menu_' + hex(id(self)).lstrip("0x").rstrip("L")
-            self._ns = Template(
-                'menu ' + kwargs.get('ns', __id)).safe_substitute(__id=__id)
-        self._last_heartbeat = None
-        self.__scroll_pos = None
-        self.__scroll_request_pending = False
-        self.__scroll_next = 0
-        # menu scripts
-        self._scripts = {}
-        # init
-        self.init()
-
-    # override
-    def init(self):
-        pass
-
-    def _render_name(self):
-        if self._name_tpl is not None:
-            context = self.get_context()
-            return self.manager.asflat(self._name_tpl.render(context))
-        return self.manager.asflat(self._name)
-
-    def _load_script(self, config, name, option=None):
-        """Load script template from config or callback from dict"""
-        if name in self._scripts:
-            logging.info(
-                "Declaration of '%s' hides "
-                "previous script declaration" % (name,))
-        option = option or name
-        if isinstance(config, dict):
-            self._scripts[name] = config.get(option, None)
-        else:
-            self._scripts[name] = self.manager.gcode_macro.load_template(
-                config, option, '')
-
-    # override
-    def is_editing(self):
-        return False
-
-    # override
-    def is_scrollable(self):
-        return True
-
-    # override
-    def is_enabled(self):
-        context = self.get_context()
-        return self.eval_enable(context)
-
-    # override
-    def start_editing(self):
-        pass
-
-    # override
-    def stop_editing(self):
-        pass
-
-    # override
-    def get_context(self, cxt=None):
-        # get default menu context
-        context = self.manager.get_context(cxt)
-        context['menu'].update({
-            'ns': self.get_ns()
-        })
-        return context
-
-    def eval_enable(self, context):
-        if self._enable_tpl is not None:
-            return bool(ast.literal_eval(self._enable_tpl.render(context)))
-        return bool(self._enable)
-
-    # Called when a item is selected
-    def select(self):
-        self.__reset_scroller()
-
-    def heartbeat(self, eventtime):
-        self._last_heartbeat = eventtime
-        if eventtime >= self.__scroll_next:
-            self.__scroll_next = eventtime + 0.5
-            if not self.is_editing():
-                self.__update_scroller()
-
-    def __update_scroller(self):
-        if self.__scroll_pos is None and self.__scroll_request_pending is True:
-            self.__scroll_pos = 0
-        elif self.__scroll_request_pending is True:
-            self.__scroll_pos += 1
-            self.__scroll_request_pending = False
-        elif self.__scroll_request_pending is False:
-            pass  # hold scroll position
-        elif self.__scroll_request_pending is None:
-            self.__reset_scroller()
-
-    def __reset_scroller(self):
-        self.__scroll_pos = None
-        self.__scroll_request_pending = False
-
-    def need_scroller(self, value):
-        """
-        Allows to control the scroller
-        Parameters:
-            value (bool, None): True  - inc. scroll pos. on next update
-                                False - hold scroll pos.
-                                None  - reset the scroller
-        """
-        self.__scroll_request_pending = value
-
-    def __slice_name(self, name, index):
-        chunks = []
-        for i, text in enumerate(re.split(r'(\~.*?\~)', name)):
-            if i & 1 == 0:  # text
-                chunks += text
-            else:  # glyph placeholder
-                chunks.append(text)
-        return "".join(chunks[index:])
-
-    def render_name(self, selected=False):
-        name = str(self._render_name())
-        if selected and self.__scroll_pos is not None:
-            name = self.__slice_name(name, self.__scroll_pos)
-        else:
-            self.__reset_scroller()
-        return name
-
-    def get_ns(self, name='.'):
-        name = str(name).strip()
-        if name.startswith('..'):
-            name = ' '.join(
-                [(' '.join(str(self._ns).split(' ')[:-1])), name[2:]])
-        elif name.startswith('.'):
-            name = ' '.join([str(self._ns), name[1:]])
-        return name.strip()
-
-    def send_event(self, event, *args):
-        return self.manager.send_event(
-            "%s:%s" % (self.get_ns(), str(event)), *args)
-
-    def get_script(self, name):
-        if name in self._scripts:
-            return self._scripts[name]
-        return None
-
-    def _run_script(self, name, context):
-        _render = getattr(self._scripts[name], 'render', None)
-        # check template
-        if _render is not None and callable(_render):
-            return _render(context)
-        # check callback
-        elif callable(self._scripts[name]):
-            return self._scripts[name](self, context)
-        # check static string
-        elif isinstance(self._scripts[name], str):
-            return self._scripts[name]
-
-    def run_script(self, name, **kwargs):
-        event = kwargs.get('event', None)
-        context = kwargs.get('context', None)
-        render_only = kwargs.get('render_only', False)
-        result = ""
-        # init context
-        if name in self._scripts:
-            context = self.get_context(context)
-            context['menu'].update({
-                'event': event or name
-            })
-            result = self._run_script(name, context)
-        if not render_only:
-            # run result as gcode
-            self.manager.queue_gcode(result)
-            # default behaviour
-            _handle = getattr(self, "handle_script_" + name, None)
-            if callable(_handle):
-                _handle()
-        return result
-
-    @property
-    def cursor(self):
-        return str(self._cursor)[:1]
-
-    @property
-    def manager(self):
-        return self._manager
-
-    @property
-    def index(self):
-        return self._index
-
-
-class MenuContainer(MenuElement):
-    """Menu container abstract class"""
-    def __init__(self, manager, config, **kwargs):
-        if type(self) is MenuContainer:
-            raise error(
-                'Abstract MenuContainer cannot be instantiated directly')
-        super(MenuContainer, self).__init__(manager, config, **kwargs)
-        self._populate_cb = kwargs.get('populate', None)
-        self._cursor = '>'
-        self.__selected = None
-        self._allitems = []
-        self._names = []
-        self._items = []
-
-    def init(self):
-        super(MenuContainer, self).init()
-        # recursive guard
-        self._parents = []
-
-    # overload
-    def _names_aslist(self):
-        return []
-
-    # overload
-    def is_accepted(self, item):
-        return isinstance(item, MenuElement)
-
-    def is_editing(self):
-        return any([item.is_editing() for item in self._items])
-
-    def stop_editing(self):
-        for item in self._items:
-            if item.is_editing():
-                item.stop_editing()
-
-    def lookup_item(self, item):
-        if isinstance(item, str):
-            name = item.strip()
-            ns = self.get_ns(name)
-            return (self.manager.lookup_menuitem(ns), name)
-        elif isinstance(item, MenuElement):
-            return (item, item.get_ns())
-        return (None, item)
-
-    # overload
-    def _lookup_item(self, item):
-        return self.lookup_item(item)
-
-    def _index_of(self, item):
-        try:
-            index = None
-            if isinstance(item, str):
-                s = item.strip()
-                index = self._names.index(s)
-            elif isinstance(item, MenuElement):
-                index = self._items.index(item)
-            return index
-        except ValueError:
-            return None
-
-    def index_of(self, item, look_inside=False):
-        index = self._index_of(item)
-        if index is None and look_inside is True:
-            for con in self:
-                if isinstance(con, MenuContainer) and con._index_of(item):
-                    index = self._index_of(con)
-        return index
-
-    def add_parents(self, parents):
-        if isinstance(parents, list):
-            self._parents.extend(parents)
-        else:
-            self._parents.append(parents)
-
-    def assert_recursive_relation(self, parents=None):
-        assert self not in (parents or self._parents), \
-            "Recursive relation of '%s' container" % (self.get_ns(),)
-
-    def insert_item(self, s, index=None):
-        self._insert_item(s, index)
-
-    def _insert_item(self, s, index=None):
-        item, name = self._lookup_item(s)
-        if item is not None:
-            if not self.is_accepted(item):
-                raise error("Menu item '%s'is not accepted!" % str(type(item)))
-            if isinstance(item, (MenuElement)):
-                item.init()
-            if isinstance(item, (MenuContainer)):
-                item.add_parents(self._parents)
-                item.add_parents(self)
-                item.assert_recursive_relation()
-            if index is None:
-                self._allitems.append((item, name))
-            else:
-                self._allitems.insert(index, (item, name))
-
-    # overload
-    def _populate(self):
-        pass
-
-    def populate(self):
-        self._allitems = []  # empty list
-        for name in self._names_aslist():
-            self._insert_item(name)
-        # populate successor items
-        self._populate()
-        # run populate callback
-        if self._populate_cb is not None and callable(self._populate_cb):
-            self._populate_cb(self)
-        # send populate event
-        self.send_event('populate', self)
-
-    def update_items(self):
-        _a = [(item, name) for item, name in self._allitems
-              if item.is_enabled()]
-        self._items, self._names = zip(*_a) or ([], [])
-
-    # select methods
-    def init_selection(self):
-        self.select_at(0)
-
-    def select_at(self, index):
-        self.__selected = index
-        # select element
-        item = self.selected_item()
-        if isinstance(item, MenuElement):
-            item.select()
-        return item
-
-    def select_item(self, needle):
-        if isinstance(needle, MenuElement):
-            if self.selected_item() is not needle:
-                index = self.index_of(needle)
-                if index is not None:
-                    self.select_at(index)
-        else:
-            logging.error("Cannot select non menuitem")
-        return self.selected
-
-    def selected_item(self):
-        if isinstance(self.selected, int) and 0 <= self.selected < len(self):
-            return self[self.selected]
-        else:
-            return None
-
-    def select_next(self):
-        if not isinstance(self.selected, int):
-            index = 0 if len(self) else None
-        elif 0 <= self.selected < len(self) - 1:
-            index = self.selected + 1
-        else:
-            index = self.selected
-        return self.select_at(index)
-
-    def select_prev(self):
-        if not isinstance(self.selected, int):
-            index = 0 if len(self) else None
-        elif 0 < self.selected < len(self):
-            index = self.selected - 1
-        else:
-            index = self.selected
-        return self.select_at(index)
-
-    # override
-    def draw_container(self, nrows, eventtime):
-        pass
-
-    def __iter__(self):
-        return iter(self._items)
-
-    def __len__(self):
-        return len(self._items)
-
-    def __getitem__(self, key):
-        return self._items[key]
-
-    @property
-    def selected(self):
-        return self.__selected
-
-
-class MenuDisabled(MenuElement):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuDisabled, self).__init__(manager, config, name='')
-
-    def is_enabled(self):
-        return False
-
-
-class MenuCommand(MenuElement):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuCommand, self).__init__(manager, config, **kwargs)
-        self._load_script(config or kwargs, 'gcode')
-
-
-class MenuInput(MenuCommand):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuInput, self).__init__(manager, config, **kwargs)
-        # set class defaults and attributes from arguments
-        self._input = kwargs.get('input', None)
-        self._input_min = kwargs.get('input_min', -999999.0)
-        self._input_max = kwargs.get('input_max', 999999.0)
-        self._input_step = kwargs.get('input_step', 1.0)
-        self._realtime = kwargs.get('realtime', False)
-        self._input_tpl = self._input_min_tpl = self._input_max_tpl = None
-        if config is not None:
-            # overwrite class attributes from config
-            self._realtime = config.getboolean('realtime', self._realtime)
-            self._input_tpl = manager.gcode_macro.load_template(
-                config, 'input')
-            self._input_min_tpl = manager.gcode_macro.load_template(
-                config, 'input_min', str(self._input_min))
-            self._input_max_tpl = manager.gcode_macro.load_template(
-                config, 'input_max', str(self._input_max))
-            self._input_step = config.getfloat(
-                'input_step', self._input_step, above=0.)
-
-    def init(self):
-        super(MenuInput, self).init()
-        self._is_dirty = False
-        self.__last_change = None
-        self._input_value = None
-
-    def is_scrollable(self):
-        return False
-
-    def is_editing(self):
-        return self._input_value is not None
-
-    def stop_editing(self):
-        if not self.is_editing():
-            return
-        self._reset_value()
-
-    def start_editing(self):
-        if self.is_editing():
-            return
-        self._init_value()
-
-    def heartbeat(self, eventtime):
-        super(MenuInput, self).heartbeat(eventtime)
-        if (self._is_dirty is True
-                and self.__last_change is not None
-                and self._input_value is not None
-                and (eventtime - self.__last_change) > 0.250):
-            if self._realtime is True:
-                self.run_script('gcode', event='change')
-                self.run_script('change')
-            self._is_dirty = False
-
-    def get_context(self, cxt=None):
-        context = super(MenuInput, self).get_context(cxt)
-        value = (self._eval_value(context) if self._input_value is None
-                 else self._input_value)
-        context['menu'].update({
-            'input': value
-        })
-        return context
-
-    def is_enabled(self):
-        context = super(MenuInput, self).get_context()
-        return self.eval_enable(context)
-
-    def _eval_min(self, context):
-        try:
-            if self._input_min_tpl is not None:
-                return float(ast.literal_eval(
-                    self._input_min_tpl.render(context)))
-            return float(self._input_min)
-        except ValueError:
-            logging.exception("Input min value evaluation error")
-
-    def _eval_max(self, context):
-        try:
-            if self._input_max_tpl is not None:
-                return float(ast.literal_eval(
-                    self._input_max_tpl.render(context)))
-            return float(self._input_max)
-        except ValueError:
-            logging.exception("Input max value evaluation error")
-
-    def _eval_value(self, context):
-        try:
-            if self._input_tpl is not None:
-                return float(ast.literal_eval(
-                    self._input_tpl.render(context)))
-            return float(self._input)
-        except ValueError:
-            logging.exception("Input value evaluation error")
-
-    def _value_changed(self):
-        self.__last_change = self._last_heartbeat
-        self._is_dirty = True
-
-    def _init_value(self):
-        context = super(MenuInput, self).get_context()
-        self._input_value = None
-        self._input_min = self._eval_min(context)
-        self._input_max = self._eval_max(context)
-        self._input_value = min(self._input_max, max(
-            self._input_min, self._eval_value(context)))
-        self._value_changed()
-
-    def _reset_value(self):
-        self._input_value = None
-
-    def _get_input_step(self, fast_rate=False):
-        return ((10.0 * self._input_step) if fast_rate and (
-                (self._input_max - self._input_min) / self._input_step > 100.0)
-                else self._input_step)
-
-    def inc_value(self, fast_rate=False):
-        last_value = self._input_value
-        if self._input_value is None:
-            return
-
-        input_step = self._get_input_step(fast_rate)
-        self._input_value += abs(input_step)
-        self._input_value = min(self._input_max, max(
-            self._input_min, self._input_value))
-
-        if last_value != self._input_value:
-            self._value_changed()
-
-    def dec_value(self, fast_rate=False):
-        last_value = self._input_value
-        if self._input_value is None:
-            return
-
-        input_step = self._get_input_step(fast_rate)
-        self._input_value -= abs(input_step)
-        self._input_value = min(self._input_max, max(
-            self._input_min, self._input_value))
-
-        if last_value != self._input_value:
-            self._value_changed()
-
-    # default behaviour on click
-    def handle_script_click(self):
-        if not self.is_editing():
-            self.start_editing()
-        elif self.is_editing():
-            self.stop_editing()
-
-
-class MenuList(MenuContainer):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuList, self).__init__(manager, config, **kwargs)
-        self._viewport_top = 0
-
-        def _cb(el, context):
-            el.manager.back()
-        # create back item
-        self._itemBack = self.manager.menuitem_from(
-            'command', name='..', gcode=_cb)
-
-    def _names_aslist(self):
-        return self.manager.lookup_children(self.get_ns())
-
-    def _populate(self):
-        super(MenuList, self)._populate()
-        self._viewport_top = 0
-        #  add back as first item
-        self.insert_item(self._itemBack, 0)
-
-    def draw_container(self, nrows, eventtime):
-        display = self.manager.display
-        selected_row = self.selected
-        # adjust viewport
-        if selected_row is not None:
-            if selected_row >= (self._viewport_top + nrows):
-                self._viewport_top = (selected_row - nrows) + 1
-            if selected_row < self._viewport_top:
-                self._viewport_top = selected_row
-        else:
-            self._viewport_top = 0
-        # clamps viewport
-        self._viewport_top = max(0, min(self._viewport_top, len(self) - nrows))
-        try:
-            y = 0
-            for row in range(self._viewport_top, self._viewport_top + nrows):
-                text = ""
-                prefix = ""
-                suffix = ""
-                if row < len(self):
-                    current = self[row]
-                    selected = (row == selected_row)
-                    if selected:
-                        current.heartbeat(eventtime)
-                    text = current.render_name(selected)
-                    # add prefix (selection indicator)
-                    if selected and not current.is_editing():
-                        prefix = current.cursor
-                    elif selected and current.is_editing():
-                        prefix = '*'
-                    else:
-                        prefix = ' '
-                    # add suffix (folder indicator)
-                    if isinstance(current, MenuList):
-                        suffix += '>'
-                # draw to display
-                plen = len(prefix)
-                slen = len(suffix)
-                width = self.manager.cols - plen - slen
-                # draw item prefix (cursor)
-                ppos = display.draw_text(y, 0, prefix, eventtime)
-                # draw item name
-                tpos = display.draw_text(y, ppos, text.ljust(width), eventtime)
-                # check scroller
-                if (selected and tpos > self.manager.cols
-                        and current.is_scrollable()):
-                    # scroll next
-                    current.need_scroller(True)
-                else:
-                    # reset scroller
-                    current.need_scroller(None)
-                # draw item suffix
-                if suffix:
-                    display.draw_text(
-                        y, self.manager.cols - slen, suffix, eventtime)
-                # next display row
-                y += 1
-        except Exception:
-            logging.exception('List drawing error')
-
-
-class MenuVSDList(MenuList):
-    def __init__(self, manager, config, **kwargs):
-        super(MenuVSDList, self).__init__(manager, config, **kwargs)
-
-    def _populate(self):
-        super(MenuVSDList, self)._populate()
-        sdcard = self.manager.printer.lookup_object('virtual_sdcard', None)
-        if sdcard is not None:
-            files = sdcard.get_file_list()
-            for fname, fsize in files:
-                self.insert_item(self.manager.menuitem_from(
-                    'command', name=repr(fname), gcode='M23 /%s' % str(fname)))
-
-
-menu_items = {
-    'disabled': MenuDisabled,
-    'command': MenuCommand,
-    'input': MenuInput,
-    'list': MenuList,
-    'vsdlist': MenuVSDList
-}
-
-
-TIMER_DELAY = 1.0
-
-
-class MenuManager:
-    def __init__(self, config, display):
-        self.running = False
-        self.menuitems = {}
-        self.menustack = []
-        self.children = {}
-        self.display = display
-        self.printer = config.get_printer()
-        self.pconfig = self.printer.lookup_object('configfile')
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode_queue = []
-        self.context = {}
-        self.root = None
-        self._root = config.get('menu_root', '__main')
-        self.cols, self.rows = self.display.get_dimensions()
-        self.timeout = config.getint('menu_timeout', 0)
-        self.timer = 0
-        # reverse container navigation
-        self._reverse_navigation = config.getboolean(
-            'menu_reverse_navigation', False)
-        # load printer objects
-        self.gcode_macro = self.printer.load_object(config, 'gcode_macro')
-        # register itself for printer callbacks
-        self.printer.add_object('menu', self)
-        self.printer.register_event_handler("klippy:ready", self.handle_ready)
-        # register for key events
-        menu_keys.MenuKeys(config, self.key_event)
-        # Load local config file in same directory as current module
-        self.load_config(os.path.dirname(__file__), 'menu.cfg')
-        # Load items from main config
-        self.load_menuitems(config)
-        # Load menu root
-        self.root = self.lookup_menuitem(self._root)
-        # send init event
-        self.send_event('init', self)
-
-    def handle_ready(self):
-        # start timer
-        reactor = self.printer.get_reactor()
-        reactor.register_timer(self.timer_event, reactor.NOW)
-
-    def timer_event(self, eventtime):
-        self.timeout_check(eventtime)
-        return eventtime + TIMER_DELAY
-
-    def timeout_check(self, eventtime):
-        if (self.is_running() and self.timeout > 0
-                and isinstance(self.root, MenuContainer)):
-            if self.timer >= self.timeout:
-                self.exit()
-            else:
-                self.timer += 1
-        else:
-            self.timer = 0
-
-    def send_event(self, event, *args):
-        return self.printer.send_event("menu:" + str(event), *args)
-
-    def is_running(self):
-        return self.running
-
-    def begin(self, eventtime):
-        self.menustack = []
-        self.timer = 0
-        if isinstance(self.root, MenuContainer):
-            # send begin event
-            self.send_event('begin', self)
-            self.update_context(eventtime)
-            if isinstance(self.root, MenuContainer):
-                self.root.init_selection()
-            self.stack_push(self.root)
-            self.running = True
-            return
-        elif self.root is not None:
-            logging.error("Invalid root, menu stopped!")
-        self.running = False
-
-    def get_status(self, eventtime):
-        return {
-            'timeout': self.timeout,
-            'running': self.running,
-            'rows': self.rows,
-            'cols': self.cols
-        }
-
-    def _action_back(self, force=False, update=True):
-        self.back(force, update)
-        return ""
-
-    def _action_exit(self, force=False):
-        self.exit(force)
-        return ""
-
-    def get_context(self, cxt=None):
-        context = dict(self.context)
-        if isinstance(cxt, dict):
-            context.update(cxt)
-        return context
-
-    def update_context(self, eventtime):
-        # menu default jinja2 context
-        self.context = self.gcode_macro.create_template_context(eventtime)
-        self.context['menu'] = {
-            'eventtime': eventtime,
-            'back': self._action_back,
-            'exit': self._action_exit
-        }
-
-    def stack_push(self, container):
-        if not isinstance(container, MenuContainer):
-            raise error("Wrong type, expected MenuContainer")
-        container.populate()
-        top = self.stack_peek()
-        if top is not None:
-            if isinstance(top, MenuList):
-                top.run_script('leave')
-        if isinstance(container, MenuList):
-            container.run_script('enter')
-        if not container.is_editing():
-            container.update_items()
-            container.init_selection()
-        self.menustack.append(container)
-
-    def stack_pop(self, update=True):
-        container = None
-        if self.stack_size() > 0:
-            container = self.menustack.pop()
-            if not isinstance(container, MenuContainer):
-                raise error("Wrong type, expected MenuContainer")
-            top = self.stack_peek()
-            if top is not None:
-                if not isinstance(container, MenuContainer):
-                    raise error("Wrong type, expected MenuContainer")
-                if not top.is_editing() and update is True:
-                    top.update_items()
-                    top.init_selection()
-                if isinstance(container, MenuList):
-                    container.run_script('leave')
-                if isinstance(top, MenuList):
-                    top.run_script('enter')
-            else:
-                if isinstance(container, MenuList):
-                    container.run_script('leave')
-        return container
-
-    def stack_size(self):
-        return len(self.menustack)
-
-    def stack_peek(self, lvl=0):
-        container = None
-        if self.stack_size() > lvl:
-            container = self.menustack[self.stack_size() - lvl - 1]
-        return container
-
-    def screen_update_event(self, eventtime):
-        # screen update
-        if not self.is_running():
-            return False
-        # draw menu
-        self.update_context(eventtime)
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            container.heartbeat(eventtime)
-            container.draw_container(self.rows, eventtime)
-        return True
-
-    def up(self, fast_rate=False):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuInput) and current.is_editing():
-                current.dec_value(fast_rate)
-            else:
-                if self._reverse_navigation is True:
-                    container.select_next()  # reverse
-                else:
-                    container.select_prev()  # normal
-
-    def down(self, fast_rate=False):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuInput) and current.is_editing():
-                current.inc_value(fast_rate)
-            else:
-                if self._reverse_navigation is True:
-                    container.select_prev()  # reverse
-                else:
-                    container.select_next()  # normal
-
-    def back(self, force=False, update=True):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuInput) and current.is_editing():
-                if force is True:
-                    current.stop_editing()
-                else:
-                    return
-            parent = self.stack_peek(1)
-            if isinstance(parent, MenuContainer):
-                self.stack_pop(update)
-                index = parent.index_of(container, True)
-                if index is not None:
-                    parent.select_at(index)
-                elif parent.selected_item() is None:
-                    parent.init_selection()
-
-            else:
-                self.stack_pop()
-                self.running = False
-
-    def exit(self, force=False):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if (not force and isinstance(current, MenuInput)
-                    and current.is_editing()):
-                return
-            if isinstance(container, MenuList):
-                container.run_script('leave')
-            self.send_event('exit', self)
-            self.running = False
-
-    def push_container(self, menu):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            if (isinstance(menu, MenuContainer)
-                    and not container.is_editing()
-                    and menu is not container):
-                self.stack_push(menu)
-                return True
-        return False
-
-    def press(self, event='click'):
-        container = self.stack_peek()
-        if self.running and isinstance(container, MenuContainer):
-            self.timer = 0
-            current = container.selected_item()
-            if isinstance(current, MenuContainer):
-                self.stack_push(current)
-            elif isinstance(current, MenuInput):
-                if current.is_editing():
-                    current.run_script('gcode', event=event)
-                current.run_script(event)
-            elif isinstance(current, MenuCommand):
-                current.run_script('gcode', event=event)
-                current.run_script(event)
-            else:
-                # current is None, no selection. passthru to container
-                container.run_script(event)
-
-    def queue_gcode(self, script):
-        if not script:
-            return
-        if not self.gcode_queue:
-            reactor = self.printer.get_reactor()
-            reactor.register_callback(self.dispatch_gcode)
-        self.gcode_queue.append(script)
-
-    def dispatch_gcode(self, eventtime):
-        while self.gcode_queue:
-            script = self.gcode_queue[0]
-            try:
-                self.gcode.run_script(script)
-            except Exception:
-                logging.exception("Script running error")
-            self.gcode_queue.pop(0)
-
-    def menuitem_from(self, type, **kwargs):
-        if type not in menu_items:
-            raise error("Choice '%s' for option '%s'"
-                        " is not a valid choice" % (type, menu_items))
-        return menu_items[type](self, None, **kwargs)
-
-    def add_menuitem(self, name, item):
-        existing_item = False
-        if name in self.menuitems:
-            existing_item = True
-            logging.info(
-                "Declaration of '%s' hides "
-                "previous menuitem declaration" % (name,))
-        self.menuitems[name] = item
-        if isinstance(item, MenuElement):
-            parent = item.get_ns('..')
-            if parent and not existing_item:
-                if item.index is not None:
-                    self.children.setdefault(parent, []).insert(
-                        item.index, item.get_ns())
-                else:
-                    self.children.setdefault(parent, []).append(
-                        item.get_ns())
-
-    def lookup_menuitem(self, name, default=sentinel):
-        if name is None:
-            return None
-        if name in self.menuitems:
-            return self.menuitems[name]
-        if default is sentinel:
-            raise self.printer.config_error(
-                "Unknown menuitem '%s'" % (name,))
-        return default
-
-    def lookup_children(self, ns):
-        if ns in self.children:
-            return list(self.children[ns])
-        return list()
-
-    def load_config(self, *args):
-        cfg = None
-        filename = os.path.join(*args)
-        try:
-            cfg = self.pconfig.read_config(filename)
-        except Exception:
-            raise self.printer.config_error(
-                "Cannot load config '%s'" % (filename,))
-        if cfg:
-            self.load_menuitems(cfg)
-        return cfg
-
-    def load_menuitems(self, config):
-        for cfg in config.get_prefix_sections('menu '):
-            type = cfg.get('type')
-            if type not in menu_items:
-                raise error("Choice '%s' for option '%s'"
-                            " is not a valid choice" % (type, menu_items))
-            item = menu_items[type](self, cfg)
-            self.add_menuitem(item.get_ns(), item)
-
-    def _click_callback(self, eventtime, event):
-        if self.is_running():
-            self.press(event)
-        else:
-            # lets start and populate the menu items
-            self.begin(eventtime)
-
-    def key_event(self, key, eventtime):
-        if key == 'click':
-            self._click_callback(eventtime, key)
-        elif key == 'long_click':
-            self._click_callback(eventtime, key)
-        elif key == 'up':
-            self.up(False)
-        elif key == 'fast_up':
-            self.up(True)
-        elif key == 'down':
-            self.down(False)
-        elif key == 'fast_down':
-            self.down(True)
-        elif key == 'back':
-            self.back()
-        self.display.request_redraw()
-
-    # Collection of manager class helper methods
-
-    @classmethod
-    def stripliterals(cls, s):
-        """Literals are beginning or ending by the double or single quotes"""
-        s = str(s)
-        if (s.startswith('"') and s.endswith('"')) or \
-                (s.startswith("'") and s.endswith("'")):
-            s = s[1:-1]
-        return s
-
-    @classmethod
-    def aslatin(cls, s):
-        if isinstance(s, str):
-            return s
-        elif isinstance(s, unicode):
-            return unicode(s).encode('latin-1', 'ignore')
-        else:
-            return str(s)
-
-    @classmethod
-    def asflat(cls, s):
-        return cls.stripliterals(''.join(cls.aslatin(s).splitlines()))
deleted file mode 100644
--- a/klippy/extras/display/menu_keys.py
+++ /dev/null
@@ -1,108 +0,0 @@
-# -*- coding: utf-8 -*-
-# Support for menu button press tracking
-#
-# Copyright (C) 2018  Janar St <janar.soot@gmail.com>
-# Copyright (C) 2020  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-LONG_PRESS_DURATION = 0.800
-TIMER_DELAY = .200
-
-class MenuKeys:
-    def __init__(self, config, callback):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        self.callback = callback
-        buttons = self.printer.load_object(config, "buttons")
-        # Register rotary encoder
-        encoder_pins = config.get('encoder_pins', None)
-        encoder_steps_per_detent = config.getchoice('encoder_steps_per_detent',
-                                                    {2: 2, 4: 4}, 4)
-        if encoder_pins is not None:
-            try:
-                pin1, pin2 = encoder_pins.split(',')
-            except:
-                raise config.error("Unable to parse encoder_pins")
-            buttons.register_rotary_encoder(pin1.strip(), pin2.strip(),
-                                            self.encoder_cw_callback,
-                                            self.encoder_ccw_callback,
-                                            encoder_steps_per_detent)
-        self.encoder_fast_rate = config.getfloat('encoder_fast_rate',
-                                                 .030, above=0.)
-        self.last_encoder_cw_eventtime = 0
-        self.last_encoder_ccw_eventtime = 0
-        # Register click button
-        self.is_short_click = False
-        self.click_timer = self.reactor.register_timer(self.long_click_event)
-        self.register_button(config, 'click_pin', self.click_callback, False)
-        # Register other buttons
-        self.register_button(config, 'back_pin', self.back_callback)
-        self.register_button(config, 'up_pin', self.up_callback)
-        self.register_button(config, 'down_pin', self.down_callback)
-        self.register_button(config, 'kill_pin', self.kill_callback)
-
-    def register_button(self, config, name, callback, push_only=True):
-        pin = config.get(name, None)
-        if pin is None:
-            return
-        buttons = self.printer.lookup_object("buttons")
-        if config.get('analog_range_' + name, None) is None:
-            if push_only:
-                buttons.register_button_push(pin, callback)
-            else:
-                buttons.register_buttons([pin], callback)
-            return
-        amin, amax = config.getfloatlist('analog_range_' + name, count=2)
-        pullup = config.getfloat('analog_pullup_resistor', 4700., above=0.)
-        if push_only:
-            buttons.register_adc_button_push(pin, amin, amax, pullup, callback)
-        else:
-            buttons.register_adc_button(pin, amin, amax, pullup, callback)
-
-    # Rotary encoder callbacks
-    def encoder_cw_callback(self, eventtime):
-        fast_rate = ((eventtime - self.last_encoder_cw_eventtime)
-                     <= self.encoder_fast_rate)
-        self.last_encoder_cw_eventtime = eventtime
-        if fast_rate:
-            self.callback('fast_up', eventtime)
-        else:
-            self.callback('up', eventtime)
-
-    def encoder_ccw_callback(self, eventtime):
-        fast_rate = ((eventtime - self.last_encoder_ccw_eventtime)
-                     <= self.encoder_fast_rate)
-        self.last_encoder_ccw_eventtime = eventtime
-        if fast_rate:
-            self.callback('fast_down', eventtime)
-        else:
-            self.callback('down', eventtime)
-
-    # Click handling
-    def long_click_event(self, eventtime):
-        self.is_short_click = False
-        self.callback('long_click', eventtime)
-        return self.reactor.NEVER
-
-    def click_callback(self, eventtime, state):
-        if state:
-            self.is_short_click = True
-            self.reactor.update_timer(self.click_timer,
-                                      eventtime + LONG_PRESS_DURATION)
-        elif self.is_short_click:
-            self.reactor.update_timer(self.click_timer, self.reactor.NEVER)
-            self.callback('click', eventtime)
-
-    # Other button callbacks
-    def back_callback(self, eventtime):
-        self.callback('back', eventtime)
-
-    def up_callback(self, eventtime):
-        self.callback('up', eventtime)
-
-    def down_callback(self, eventtime):
-        self.callback('down', eventtime)
-
-    def kill_callback(self, eventtime):
-        self.printer.invoke_shutdown("Shutdown due to kill button!")
deleted file mode 100644
--- a/klippy/extras/display/st7920.py
+++ /dev/null
@@ -1,257 +0,0 @@
-# Support for ST7920 (128x64 graphics) LCD displays
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from .. import bus
-from . import font8x14
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-# Spec says 72us, but faster is possible in practice
-ST7920_CMD_DELAY  = .000020
-ST7920_SYNC_DELAY = .000045
-
-TextGlyphs = { 'right_arrow': b'\x1a' }
-CharGlyphs = { 'degrees': bytearray(font8x14.VGA_FONT[0xf8]) }
-
-class DisplayBase:
-    def __init__(self):
-        # framebuffers
-        self.text_framebuffer = bytearray(b' '*64)
-        self.glyph_framebuffer = bytearray(128)
-        self.graphics_framebuffers = [bytearray(32) for i in range(32)]
-        self.all_framebuffers = [
-            # Text framebuffer
-            (self.text_framebuffer, bytearray(b'~'*64), 0x80),
-            # Glyph framebuffer
-            (self.glyph_framebuffer, bytearray(b'~'*128), 0x40),
-            # Graphics framebuffers
-            ] + [(self.graphics_framebuffers[i], bytearray(b'~'*32), i)
-                 for i in range(32)]
-        self.cached_glyphs = {}
-        self.icons = {}
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, fb_id in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 5 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for pos, count in diffs:
-                count += pos & 0x01
-                count += count & 0x01
-                pos = pos & ~0x01
-                chip_pos = pos >> 1
-                if fb_id < 0x40:
-                    # Graphics framebuffer update
-                    self.send([0x80 + fb_id, 0x80 + chip_pos], is_extended=True)
-                else:
-                    self.send([fb_id + chip_pos])
-                self.send(new_data[pos:pos+count], is_data=True)
-            old_data[:] = new_data
-    def init(self):
-        cmds = [0x24, # Enter extended mode
-                0x40, # Clear vertical scroll address
-                0x02, # Enable CGRAM access
-                0x26, # Enable graphics
-                0x22, # Leave extended mode
-                0x02, # Home the display
-                0x06, # Set positive update direction
-                0x0c] # Enable display and hide cursor
-        self.send(cmds)
-        self.flush()
-    def cache_glyph(self, glyph_name, base_glyph_name, glyph_id):
-        icon = self.icons.get(glyph_name)
-        base_icon = self.icons.get(base_glyph_name)
-        if icon is None or base_icon is None:
-            return
-        all_bits = zip(icon[0], icon[1], base_icon[0], base_icon[1])
-        for i, (ic1, ic2, b1, b2) in enumerate(all_bits):
-            x1, x2 = ic1 ^ b1, ic2 ^ b2
-            pos = glyph_id*32 + i*2
-            self.glyph_framebuffer[pos:pos+2] = [x1, x2]
-            self.all_framebuffers[1][1][pos:pos+2] = [x1 ^ 1, x2 ^ 1]
-        self.cached_glyphs[glyph_name] = (base_glyph_name, (0, glyph_id*2))
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            icon = glyph_data.get('icon16x16')
-            if icon is not None:
-                self.icons[glyph_name] = icon
-        # Setup animated glyphs
-        self.cache_glyph('fan2', 'fan1', 0)
-        self.cache_glyph('bed_heat2', 'bed_heat1', 1)
-    def write_text(self, x, y, data):
-        if x + len(data) > 16:
-            data = data[:16 - min(x, 16)]
-        pos = [0, 32, 16, 48][y] + x
-        self.text_framebuffer[pos:pos+len(data)] = data
-    def write_graphics(self, x, y, data):
-        if x >= 16 or y >= 4 or len(data) != 16:
-            return
-        gfx_fb = y * 16
-        if gfx_fb >= 32:
-            gfx_fb -= 32
-            x += 16
-        for i, bits in enumerate(data):
-            self.graphics_framebuffers[gfx_fb + i][x] = bits
-    def write_glyph(self, x, y, glyph_name):
-        glyph_id = self.cached_glyphs.get(glyph_name)
-        if glyph_id is not None and x & 1 == 0:
-            # Render cached icon using character generator
-            glyph_name = glyph_id[0]
-            self.write_text(x, y, glyph_id[1])
-        icon = self.icons.get(glyph_name)
-        if icon is not None:
-            # Draw icon in graphics mode
-            self.write_graphics(x, y, icon[0])
-            self.write_graphics(x + 1, y, icon[1])
-            return 2
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        font = CharGlyphs.get(glyph_name)
-        if font is not None:
-            # Draw single width character
-            self.write_graphics(x, y, font)
-            return 1
-        return 0
-    def clear(self):
-        self.text_framebuffer[:] = b' '*64
-        zeros = bytearray(32)
-        for gfb in self.graphics_framebuffers:
-            gfb[:] = zeros
-    def get_dimensions(self):
-        return (16, 4)
-
-# Display driver for stock ST7920 displays
-class ST7920(DisplayBase):
-    def __init__(self, config):
-        printer = config.get_printer()
-        # pin config
-        ppins = printer.lookup_object('pins')
-        pins = [ppins.lookup_pin(config.get(name + '_pin'))
-                for name in ['cs', 'sclk', 'sid']]
-        mcu = None
-        for pin_params in pins:
-            if mcu is not None and pin_params['chip'] != mcu:
-                raise ppins.error("st7920 all pins must be on same mcu")
-            mcu = pin_params['chip']
-        self.pins = [pin_params['pin'] for pin_params in pins]
-        # prepare send functions
-        self.mcu = mcu
-        self.oid = self.mcu.create_oid()
-        self.mcu.register_config_callback(self.build_config)
-        self.send_data_cmd = self.send_cmds_cmd = None
-        self.is_extended = False
-        # init display base
-        DisplayBase.__init__(self)
-    def build_config(self):
-        # configure send functions
-        self.mcu.add_config_cmd(
-            "config_st7920 oid=%u cs_pin=%s sclk_pin=%s sid_pin=%s"
-            " sync_delay_ticks=%d cmd_delay_ticks=%d" % (
-                self.oid, self.pins[0], self.pins[1], self.pins[2],
-                self.mcu.seconds_to_clock(ST7920_SYNC_DELAY),
-                self.mcu.seconds_to_clock(ST7920_CMD_DELAY)))
-        cmd_queue = self.mcu.alloc_command_queue()
-        self.send_cmds_cmd = self.mcu.lookup_command(
-            "st7920_send_cmds oid=%c cmds=%*s", cq=cmd_queue)
-        self.send_data_cmd = self.mcu.lookup_command(
-            "st7920_send_data oid=%c data=%*s", cq=cmd_queue)
-    def send(self, cmds, is_data=False, is_extended=False):
-        cmd_type = self.send_cmds_cmd
-        if is_data:
-            cmd_type = self.send_data_cmd
-        elif self.is_extended != is_extended:
-            add_cmd = 0x22
-            if is_extended:
-                add_cmd = 0x26
-            cmds = [add_cmd] + cmds
-            self.is_extended = is_extended
-        cmd_type.send([self.oid, cmds], reqclock=BACKGROUND_PRIORITY_CLOCK)
-        #logging.debug("st7920 %d %s", is_data, repr(cmds))
-
-# Helper code for toggling the en pin on startup
-class EnableHelper:
-    def __init__(self, pin_desc, spi):
-        self.en_pin = bus.MCU_bus_digital_out(spi.get_mcu(), pin_desc,
-                                              spi.get_command_queue())
-    def init(self):
-        mcu = self.en_pin.get_mcu()
-        curtime = mcu.get_printer().get_reactor().monotonic()
-        print_time = mcu.estimated_print_time(curtime)
-        # Toggle enable pin
-        minclock = mcu.print_time_to_clock(print_time + .100)
-        self.en_pin.update_digital_out(0, minclock=minclock)
-        minclock = mcu.print_time_to_clock(print_time + .200)
-        self.en_pin.update_digital_out(1, minclock=minclock)
-        # Force a delay to any subsequent commands on the command queue
-        minclock = mcu.print_time_to_clock(print_time + .300)
-        self.en_pin.update_digital_out(1, minclock=minclock)
-
-# Display driver for displays that emulate the ST7920 in software.
-# These displays rely on the CS pin to be toggled in order to initialize the
-# SPI correctly. This display driver uses a software SPI with an unused pin
-# as the MISO pin.
-class EmulatedST7920(DisplayBase):
-    def __init__(self, config):
-        # create software spi
-        ppins = config.get_printer().lookup_object('pins')
-        sw_pin_names = ['spi_software_%s_pin' % (name,)
-                        for name in ['miso', 'mosi', 'sclk']]
-        sw_pin_params = [ppins.lookup_pin(config.get(name), share_type=name)
-                         for name in sw_pin_names]
-        mcu = None
-        for pin_params in sw_pin_params:
-            if mcu is not None and pin_params['chip'] != mcu:
-                raise ppins.error("%s: spi pins must be on same mcu" % (
-                    config.get_name(),))
-            mcu = pin_params['chip']
-        sw_pins = tuple([pin_params['pin'] for pin_params in sw_pin_params])
-        speed = config.getint('spi_speed', 1000000, minval=100000)
-        self.spi = bus.MCU_SPI(mcu, None, None, 0, speed, sw_pins)
-        # create enable helper
-        self.en_helper = EnableHelper(config.get("en_pin"), self.spi)
-        self.en_set = False
-        # init display base
-        self.is_extended = False
-        DisplayBase.__init__(self)
-    def send(self, cmds, is_data=False, is_extended=False):
-        # setup sync byte and check for exten mode switch
-        sync_byte = 0xfa
-        if not is_data:
-            sync_byte = 0xf8
-            if self.is_extended != is_extended:
-                add_cmd = 0x22
-                if is_extended:
-                    add_cmd = 0x26
-                cmds = [add_cmd] + cmds
-                self.is_extended = is_extended
-        # copy data to ST7920 data format
-        spi_data = [0] * (2 * len(cmds) + 1)
-        spi_data[0] = sync_byte
-        i = 1
-        for b in cmds:
-            spi_data[i] = b & 0xF0
-            spi_data[i + 1] = (b & 0x0F) << 4
-            i = i + 2
-        # check if enable pin has been set
-        if not self.en_set:
-            self.en_helper.init()
-            self.en_set = True
-        # send data
-        self.spi.spi_send(spi_data, reqclock=BACKGROUND_PRIORITY_CLOCK)
-        #logging.debug("st7920 %s", repr(spi_data))
deleted file mode 100644
--- a/klippy/extras/display/uc1701.py
+++ /dev/null
@@ -1,240 +0,0 @@
-# Support for UC1701 (and similar) 128x64 graphics LCD displays
-#
-# Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-# Copyright (C) 2018  Eric Callahan  <arksine.code@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from .. import bus
-from . import font8x14
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-TextGlyphs = { 'right_arrow': b'\x1a', 'degrees': b'\xf8' }
-
-class DisplayBase:
-    def __init__(self, io, columns=128, x_offset=0):
-        self.send = io.send
-        # framebuffers
-        self.columns = columns
-        self.x_offset = x_offset
-        self.vram = [bytearray(self.columns) for i in range(8)]
-        self.all_framebuffers = [(self.vram[i], bytearray(b'~'*self.columns), i)
-                                 for i in range(8)]
-        # Cache fonts and icons in display byte order
-        self.font = [self._swizzle_bits(bytearray(c))
-                     for c in font8x14.VGA_FONT]
-        self.icons = {}
-    def flush(self):
-        # Find all differences in the framebuffers and send them to the chip
-        for new_data, old_data, page in self.all_framebuffers:
-            if new_data == old_data:
-                continue
-            # Find the position of all changed bytes in this framebuffer
-            diffs = [[i, 1] for i, (n, o) in enumerate(zip(new_data, old_data))
-                     if n != o]
-            # Batch together changes that are close to each other
-            for i in range(len(diffs)-2, -1, -1):
-                pos, count = diffs[i]
-                nextpos, nextcount = diffs[i+1]
-                if pos + 5 >= nextpos and nextcount < 16:
-                    diffs[i][1] = nextcount + (nextpos - pos)
-                    del diffs[i+1]
-            # Transmit changes
-            for col_pos, count in diffs:
-                # Set Position registers
-                ra = 0xb0 | (page & 0x0F)
-                ca_msb = 0x10 | ((col_pos >> 4) & 0x0F)
-                ca_lsb = col_pos & 0x0F
-                self.send([ra, ca_msb, ca_lsb])
-                # Send Data
-                self.send(new_data[col_pos:col_pos+count], is_data=True)
-            old_data[:] = new_data
-    def _swizzle_bits(self, data):
-        # Convert from "rows of pixels" format to "columns of pixels"
-        top = bot = 0
-        for row in range(8):
-            spaced = (data[row] * 0x8040201008040201) & 0x8080808080808080
-            top |= spaced >> (7 - row)
-            spaced = (data[row + 8] * 0x8040201008040201) & 0x8080808080808080
-            bot |= spaced >> (7 - row)
-        bits_top = [(top >> s) & 0xff for s in range(0, 64, 8)]
-        bits_bot = [(bot >> s) & 0xff for s in range(0, 64, 8)]
-        return (bytearray(bits_top), bytearray(bits_bot))
-    def set_glyphs(self, glyphs):
-        for glyph_name, glyph_data in glyphs.items():
-            icon = glyph_data.get('icon16x16')
-            if icon is not None:
-                top1, bot1 = self._swizzle_bits(icon[0])
-                top2, bot2 = self._swizzle_bits(icon[1])
-                self.icons[glyph_name] = (top1 + top2, bot1 + bot2)
-    def write_text(self, x, y, data):
-        if x + len(data) > 16:
-            data = data[:16 - min(x, 16)]
-        pix_x = x * 8
-        pix_x += self.x_offset
-        page_top = self.vram[y * 2]
-        page_bot = self.vram[y * 2 + 1]
-        for c in bytearray(data):
-            bits_top, bits_bot = self.font[c]
-            page_top[pix_x:pix_x+8] = bits_top
-            page_bot[pix_x:pix_x+8] = bits_bot
-            pix_x += 8
-    def write_graphics(self, x, y, data):
-        if x >= 16 or y >= 4 or len(data) != 16:
-            return
-        bits_top, bits_bot = self._swizzle_bits(data)
-        pix_x = x * 8
-        pix_x += self.x_offset
-        page_top = self.vram[y * 2]
-        page_bot = self.vram[y * 2 + 1]
-        for i in range(8):
-            page_top[pix_x + i] ^= bits_top[i]
-            page_bot[pix_x + i] ^= bits_bot[i]
-    def write_glyph(self, x, y, glyph_name):
-        icon = self.icons.get(glyph_name)
-        if icon is not None and x < 15:
-            # Draw icon in graphics mode
-            pix_x = x * 8
-            pix_x += self.x_offset
-            page_idx = y * 2
-            self.vram[page_idx][pix_x:pix_x+16] = icon[0]
-            self.vram[page_idx + 1][pix_x:pix_x+16] = icon[1]
-            return 2
-        char = TextGlyphs.get(glyph_name)
-        if char is not None:
-            # Draw character
-            self.write_text(x, y, char)
-            return 1
-        return 0
-    def clear(self):
-        zeros = bytearray(self.columns)
-        for page in self.vram:
-            page[:] = zeros
-    def get_dimensions(self):
-        return (16, 4)
-
-# IO wrapper for "4 wire" spi bus (spi bus with an extra data/control line)
-class SPI4wire:
-    def __init__(self, config, data_pin_name):
-        self.spi = bus.MCU_SPI_from_config(config, 0, default_speed=10000000)
-        dc_pin = config.get(data_pin_name)
-        self.mcu_dc = bus.MCU_bus_digital_out(self.spi.get_mcu(), dc_pin,
-                                              self.spi.get_command_queue())
-    def send(self, cmds, is_data=False):
-        self.mcu_dc.update_digital_out(is_data,
-                                       reqclock=BACKGROUND_PRIORITY_CLOCK)
-        self.spi.spi_send(cmds, reqclock=BACKGROUND_PRIORITY_CLOCK)
-
-# IO wrapper for i2c bus
-class I2C:
-    def __init__(self, config, default_addr):
-        self.i2c = bus.MCU_I2C_from_config(config, default_addr=default_addr,
-                                           default_speed=400000)
-    def send(self, cmds, is_data=False):
-        if is_data:
-            hdr = 0x40
-        else:
-            hdr = 0x00
-        cmds = bytearray(cmds)
-        cmds.insert(0, hdr)
-        self.i2c.i2c_write(cmds, reqclock=BACKGROUND_PRIORITY_CLOCK)
-
-# Helper code for toggling a reset pin on startup
-class ResetHelper:
-    def __init__(self, pin_desc, io_bus):
-        self.mcu_reset = None
-        if pin_desc is None:
-            return
-        self.mcu_reset = bus.MCU_bus_digital_out(io_bus.get_mcu(), pin_desc,
-                                                 io_bus.get_command_queue())
-    def init(self):
-        if self.mcu_reset is None:
-            return
-        mcu = self.mcu_reset.get_mcu()
-        curtime = mcu.get_printer().get_reactor().monotonic()
-        print_time = mcu.estimated_print_time(curtime)
-        # Toggle reset
-        minclock = mcu.print_time_to_clock(print_time + .100)
-        self.mcu_reset.update_digital_out(0, minclock=minclock)
-        minclock = mcu.print_time_to_clock(print_time + .200)
-        self.mcu_reset.update_digital_out(1, minclock=minclock)
-        # Force a delay to any subsequent commands on the command queue
-        minclock = mcu.print_time_to_clock(print_time + .300)
-        self.mcu_reset.update_digital_out(1, minclock=minclock)
-
-# The UC1701 is a "4-wire" SPI display device
-class UC1701(DisplayBase):
-    def __init__(self, config):
-        io = SPI4wire(config, "a0_pin")
-        DisplayBase.__init__(self, io)
-        self.contrast = config.getint('contrast', 40, minval=0, maxval=63)
-        self.reset = ResetHelper(config.get("rst_pin", None), io.spi)
-    def init(self):
-        self.reset.init()
-        init_cmds = [0xE2, # System reset
-                     0x40, # Set display to start at line 0
-                     0xA0, # Set SEG direction
-                     0xC8, # Set COM Direction
-                     0xA2, # Set Bias = 1/9
-                     0x2C, # Boost ON
-                     0x2E, # Voltage regulator on
-                     0x2F, # Voltage follower on
-                     0xF8, # Set booster ratio
-                     0x00, # Booster ratio value (4x)
-                     0x23, # Set resistor ratio (3)
-                     0x81, # Set Electronic Volume
-                     self.contrast, # Electronic Volume value
-                     0xAC, # Set static indicator off
-                     0x00, # NOP
-                     0xA6, # Disable Inverse
-                     0xAF] # Set display enable
-        self.send(init_cmds)
-        self.send([0xA5]) # display all
-        self.send([0xA4]) # normal display
-        self.flush()
-
-# The SSD1306 supports both i2c and "4-wire" spi
-class SSD1306(DisplayBase):
-    def __init__(self, config, columns=128, x_offset=0):
-        cs_pin = config.get("cs_pin", None)
-        if cs_pin is None:
-            io = I2C(config, 60)
-            io_bus = io.i2c
-        else:
-            io = SPI4wire(config, "dc_pin")
-            io_bus = io.spi
-        self.reset = ResetHelper(config.get("reset_pin", None), io_bus)
-        DisplayBase.__init__(self, io, columns, x_offset)
-        self.contrast = config.getint('contrast', 239, minval=0, maxval=255)
-        self.vcomh = config.getint('vcomh', 0, minval=0, maxval=63)
-        self.invert = config.getboolean('invert', False)
-    def init(self):
-        self.reset.init()
-        init_cmds = [
-            0xAE,       # Display off
-            0xD5, 0x80, # Set oscillator frequency
-            0xA8, 0x3f, # Set multiplex ratio
-            0xD3, 0x00, # Set display offset
-            0x40,       # Set display start line
-            0x8D, 0x14, # Charge pump setting
-            0x20, 0x02, # Set Memory addressing mode
-            0xA1,       # Set Segment re-map
-            0xC8,       # Set COM output scan direction
-            0xDA, 0x12, # Set COM pins hardware configuration
-            0x81, self.contrast, # Set contrast control
-            0xD9, 0xA1, # Set pre-charge period
-            0xDB, self.vcomh, # Set VCOMH deselect level
-            0x2E,       # Deactivate scroll
-            0xA4,       # Output ram to display
-            0xA7 if self.invert else 0xA6, # Set normal/invert
-            0xAF,       # Display on
-        ]
-        self.send(init_cmds)
-        self.flush()
-
-# the SH1106 is SSD1306 compatible with up to 132 columns
-class SH1106(SSD1306):
-    def __init__(self, config):
-        x_offset = config.getint('x_offset', 0, minval=0, maxval=3)
-        SSD1306.__init__(self, config, 132, x_offset=x_offset)
deleted file mode 100644
--- a/klippy/extras/ds18b20.py
+++ /dev/null
@@ -1,80 +0,0 @@
-# Support for 1-wire based temperature sensors
-#
-# Copyright (C) 2020 Alan Lord <alanslists@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-import mcu
-
-DS18_REPORT_TIME = 3.0
-# Temperature can be sampled at any time but conversion time is ~750ms, so
-# setting the time too low will not make the reports come faster.
-DS18_MIN_REPORT_TIME = 1.0
-DS18_MAX_CONSECUTIVE_ERRORS = 4
-
-class DS18B20:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.sensor_id = bytearray(config.get("serial_no").encode())
-        self.temp = self.min_temp = self.max_temp = 0.0
-        self._report_clock = 0
-        self.report_time = config.getfloat(
-            'ds18_report_time',
-            DS18_REPORT_TIME,
-            minval=DS18_MIN_REPORT_TIME
-        )
-        self._mcu = mcu.get_printer_mcu(self.printer, config.get('sensor_mcu'))
-        self.oid = self._mcu.create_oid()
-        self._mcu.register_response(self._handle_ds18b20_response,
-            "ds18b20_result", self.oid)
-        self._mcu.register_config_callback(self._build_config)
-
-    def _build_config(self):
-        sid = "".join(["%02x" % (x,) for x in self.sensor_id])
-        self._mcu.add_config_cmd(
-            "config_ds18b20 oid=%d serial=%s max_error_count=%d"
-            % (self.oid, sid, DS18_MAX_CONSECUTIVE_ERRORS))
-
-        clock = self._mcu.get_query_slot(self.oid)
-        self._report_clock = self._mcu.seconds_to_clock(self.report_time)
-        self._mcu.add_config_cmd("query_ds18b20 oid=%d clock=%u rest_ticks=%u"
-            " min_value=%d max_value=%d" % (
-                self.oid, clock, self._report_clock,
-                self.min_temp * 1000, self.max_temp * 1000), is_init=True)
-
-    def _handle_ds18b20_response(self, params):
-        temp = params['value'] / 1000.0
-
-        if params["fault"]:
-            logging.info("ds18b20 reports fault %d (temp=%0.1f)",
-                         params["fault"], temp)
-            return
-
-        next_clock      = self._mcu.clock32_to_clock64(params['next_clock'])
-        last_read_clock = next_clock - self._report_clock
-        last_read_time  = self._mcu.clock_to_print_time(last_read_clock)
-        self._callback(last_read_time, temp)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def fault(self, msg):
-        self.printer.invoke_async_shutdown(msg)
-
-    def get_report_time_delta(self):
-        return self.report_time
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-        }
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("DS18B20", DS18B20)
deleted file mode 100644
--- a/klippy/extras/htu21d.py
+++ /dev/null
@@ -1,248 +0,0 @@
-# HTU21D(F)/Si7013/Si7020/Si7021/SHT21 i2c based temperature sensors support
-#
-# Copyright (C) 2020  Lucio Tarantino <lucio.tarantino@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-######################################################################
-# NOTE: The implementation requires write support of length 0
-#       before reading on the i2c bus of the mcu.
-#
-# Compatible Sensors:
-#       HTU21D - Tested on Linux MCU.
-#       Si7013 - Untested
-#       Si7020 - Untested
-#       Si7021 - Tested on Pico MCU
-#       SHT21  - Untested
-#
-######################################################################
-
-HTU21D_I2C_ADDR= 0x40
-
-HTU21D_COMMANDS = {
-    'HTU21D_TEMP'       :0xE3,
-    'HTU21D_HUMID'      :0xE5,
-    'HTU21D_TEMP_NH'    :0xF3,
-    'HTU21D_HUMID_NH'   :0xF5,
-    'WRITE'             :0xE6,
-    'READ'              :0xE7,
-    'RESET'             :0xFE,
-    'SERIAL'            :[0xFA,0x0F,0xFC,0xC9],
-    'FIRMWARE_READ'     :[0x84,0xB8]
-
-}
-
-HTU21D_RESOLUTION_MASK = 0x7E;
-HTU21D_RESOLUTIONS = {
-    'TEMP14_HUM12':int('00000000',2),
-    'TEMP13_HUM10':int('10000000',2),
-    'TEMP12_HUM08':int('00000001',2),
-    'TEMP11_HUM11':int('10000001',2)
-}
-
-# Device with conversion time for tmp/resolution bit
-# The format is:
-#  <CHIPNAME>:{id:<ID>, ..<RESOlUTION>:[<temp time>,<humidity time>].. }
-HTU21D_DEVICES = {
-    'SI7013':{'id':0x0D,
-        'TEMP14_HUM12':[.11,.12],
-        'TEMP13_HUM10':[ .7, .5],
-        'TEMP12_HUM08':[ .4, .4],
-        'TEMP11_HUM11':[ .3, .7]},
-    'SI7020':{'id':0x14,
-        'TEMP14_HUM12':[.11,.12],
-        'TEMP13_HUM10':[ .7, .5],
-        'TEMP12_HUM08':[ .4, .4],
-        'TEMP11_HUM11':[ .3, .7]},
-    'SI7021':{'id':0x15,
-        'TEMP14_HUM12':[.11,.12],
-        'TEMP13_HUM10':[ .7, .5],
-        'TEMP12_HUM08':[ .4, .4],
-        'TEMP11_HUM11':[ .3, .7]},
-    'SHT21': {'id':0x31,
-        'TEMP14_HUM12':[.85,.29],
-        'TEMP13_HUM10':[.43, .9],
-        'TEMP12_HUM08':[.22, .4],
-        'TEMP11_HUM11':[.11,.15]},
-    'HTU21D':{'id':0x32,
-        'TEMP14_HUM12':[.50,.16],
-        'TEMP13_HUM10':[.25, .5],
-        'TEMP12_HUM08':[.13, .3],
-        'TEMP11_HUM11':[.12, .8]}
-}
-#temperature coefficient for RH compensation at range 0C..80C,
-#  for HTU21D & SHT21 only
-HTU21D_TEMP_COEFFICIENT= -0.15
-#crc8 polynomial for 16bit value, CRC8 -> x^8 + x^5 + x^4 + 1
-HTU21D_CRC8_POLYNOMINAL= 0x13100
-
-class HTU21D:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.reactor = self.printer.get_reactor()
-        self.i2c = bus.MCU_I2C_from_config(
-            config, default_addr=HTU21D_I2C_ADDR, default_speed=100000)
-        self.hold_master_mode = config.getboolean('htu21d_hold_master',False)
-        self.resolution = config.get('htu21d_resolution','TEMP12_HUM08')
-        self.report_time = config.getint('htu21d_report_time',30,minval=5)
-        if self.resolution not in HTU21D_RESOLUTIONS:
-            raise config.error("Invalid HTU21D Resolution. Valid are %s"
-                % '|'.join(HTU21D_RESOLUTIONS.keys()))
-        self.deviceId = config.get('sensor_type')
-        self.temp = self.min_temp = self.max_temp = self.humidity = 0.
-        self.sample_timer = self.reactor.register_timer(self._sample_htu21d)
-        self.printer.add_object("htu21d " + self.name, self)
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self._init_htu21d()
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return self.report_time
-
-    def _init_htu21d(self):
-        # Device Soft Reset
-        self.i2c.i2c_write([HTU21D_COMMANDS['RESET']])
-        # Wait 15ms after reset
-        self.reactor.pause(self.reactor.monotonic() + .15)
-
-        # Read ChipId
-        params = self.i2c.i2c_read([HTU21D_COMMANDS['SERIAL'][2],
-                                    HTU21D_COMMANDS['SERIAL'][3]], 3)
-        response = bytearray(params['response'])
-        rdevId = response[0] << 8
-        rdevId |= response[1]
-        checksum = response[2]
-        if self._chekCRC8(rdevId) != checksum:
-            logging.warn("htu21d: Reading deviceId !Checksum error!")
-        rdevId = rdevId >> 8
-        deviceId_list = list(
-            filter(
-              lambda elem: HTU21D_DEVICES[elem]['id'] == rdevId,HTU21D_DEVICES)
-            )
-        if len(deviceId_list) != 0:
-            logging.info("htu21d: Found Device Type %s" % deviceId_list[0])
-        else:
-            logging.warn("htu21d: Unknown Device ID %#x " % rdevId)
-
-        if(self.deviceId != deviceId_list[0]):
-            logging.warn(
-                "htu21d: Found device %s. Forcing to type %s as config.",
-                 deviceId_list[0],self.deviceId)
-
-        # Set Resolution
-        params = self.i2c.i2c_read([HTU21D_COMMANDS['READ']], 1)
-        response = bytearray(params['response'])
-        registerData = response[0] & HTU21D_RESOLUTION_MASK
-        registerData |= HTU21D_RESOLUTIONS[self.resolution]
-        self.i2c.i2c_write([HTU21D_COMMANDS['WRITE']],registerData)
-        logging.info("htu21d: Setting resolution to %s " % self.resolution)
-
-    def _sample_htu21d(self, eventtime):
-        try:
-            # Read Temeprature
-            if self.hold_master_mode:
-                params = self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_TEMP']])
-            else:
-                params = self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_TEMP_NH']])
-
-            # Wait
-            self.reactor.pause(self.reactor.monotonic()
-            + HTU21D_DEVICES[self.deviceId][self.resolution][0])
-
-
-            params = self.i2c.i2c_read([],3)
-
-            response = bytearray(params['response'])
-            rtemp  = response[0] << 8
-            rtemp |= response[1]
-            if self._chekCRC8(rtemp) != response[2]:
-                logging.warn("htu21d: Checksum error on Temperature reading!")
-            else:
-                self.temp = (0.002681 * float(rtemp) - 46.85)
-                logging.debug("htu21d: Temperature %.2f " % self.temp)
-
-            # Read Humidity
-            if self.hold_master_mode:
-                self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_HUMID']])
-            else:
-                self.i2c.i2c_write([HTU21D_COMMANDS['HTU21D_HUMID_NH']])
-
-            # Wait
-            self.reactor.pause(self.reactor.monotonic()
-            + HTU21D_DEVICES[self.deviceId][self.resolution][1])
-
-            params = self.i2c.i2c_read([],3)
-
-            response = bytearray(params['response'])
-            rhumid = response[0] << 8
-            rhumid|= response[1]
-            if self._chekCRC8(rhumid) != response[2]:
-                logging.warn("htu21d: Checksum error on Humidity reading!")
-            else:
-                #clear status bits,
-                # humidity always returns xxxxxx10 in the LSB field
-                rhumid   ^= 0x02;
-                self.humidity = (0.001907 * float(rhumid) - 6)
-                if (self.humidity < 0):
-                    #due to RH accuracy, measured value might be
-                    # slightly less than 0 or more 100
-                    self.humidity = 0
-                elif (self.humidity > 100):
-                    self.humidity = 100
-                # Only for HTU21D & SHT21.
-                # Calculates temperature compensated Humidity, %RH
-                if( self.deviceId in ['SHT21','HTU21D']
-                    and self.temp > 0 and self.temp < 80):
-                    logging.debug("htu21d: Do temp compensation..")
-                    self.humidity = self.humidity
-                    + (25.0 - self.temp) * HTU21D_TEMP_COEFFICIENT;
-                logging.debug("htu21d: Humidity %.2f " % self.humidity)
-        except Exception:
-            logging.exception("htu21d: Error reading data")
-            self.temp = self.humidity = .0
-            return self.reactor.NEVER
-
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "HTU21D temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-
-        measured_time = self.reactor.monotonic()
-        print_time = self.i2c.get_mcu().estimated_print_time(measured_time)
-        self._callback(print_time, self.temp)
-        return measured_time + self.report_time
-
-    def _chekCRC8(self,data):
-        for bit in range(0,16):
-            if (data & 0x8000):
-                data = (data << 1) ^ HTU21D_CRC8_POLYNOMINAL;
-            else:
-                data <<= 1
-        data = data >> 8
-        return data
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-            'humidity': self.humidity,
-        }
-
-
-def load_config(config):
-    # Register sensor
-    pheater = config.get_printer().lookup_object("heaters")
-    for stype in HTU21D_DEVICES:
-        pheater.add_sensor_factory(stype, HTU21D)
deleted file mode 100644
--- a/klippy/extras/led.py
+++ /dev/null
@@ -1,232 +0,0 @@
-# Support for PWM driven LEDs
-#
-# Copyright (C) 2019-2022  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, ast
-from .display import display
-
-# Time between each led template update
-RENDER_TIME = 0.500
-
-# Helper code for common LED initialization and control
-class LEDHelper:
-    def __init__(self, config, update_func, led_count=1):
-        self.printer = config.get_printer()
-        self.update_func = update_func
-        self.led_count = led_count
-        self.need_transmit = False
-        # Initial color
-        red = config.getfloat('initial_RED', 0., minval=0., maxval=1.)
-        green = config.getfloat('initial_GREEN', 0., minval=0., maxval=1.)
-        blue = config.getfloat('initial_BLUE', 0., minval=0., maxval=1.)
-        white = config.getfloat('initial_WHITE', 0., minval=0., maxval=1.)
-        self.led_state = [(red, green, blue, white)] * led_count
-        # Register commands
-        name = config.get_name().split()[-1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("SET_LED", "LED", name, self.cmd_SET_LED,
-                                   desc=self.cmd_SET_LED_help)
-    def get_led_count(self):
-        return self.led_count
-    def set_color(self, index, color):
-        if index is None:
-            new_led_state = [color] * self.led_count
-            if self.led_state == new_led_state:
-                return
-        else:
-            if self.led_state[index - 1] == color:
-                return
-            new_led_state = list(self.led_state)
-            new_led_state[index - 1] = color
-        self.led_state = new_led_state
-        self.need_transmit = True
-    def check_transmit(self, print_time):
-        if not self.need_transmit:
-            return
-        self.need_transmit = False
-        try:
-            self.update_func(self.led_state, print_time)
-        except self.printer.command_error as e:
-            logging.exception("led update transmit error")
-    cmd_SET_LED_help = "Set the color of an LED"
-    def cmd_SET_LED(self, gcmd):
-        # Parse parameters
-        red = gcmd.get_float('RED', 0., minval=0., maxval=1.)
-        green = gcmd.get_float('GREEN', 0., minval=0., maxval=1.)
-        blue = gcmd.get_float('BLUE', 0., minval=0., maxval=1.)
-        white = gcmd.get_float('WHITE', 0., minval=0., maxval=1.)
-        index = gcmd.get_int('INDEX', None, minval=1, maxval=self.led_count)
-        transmit = gcmd.get_int('TRANSMIT', 1)
-        sync = gcmd.get_int('SYNC', 1)
-        color = (red, green, blue, white)
-        # Update and transmit data
-        def lookahead_bgfunc(print_time):
-            self.set_color(index, color)
-            if transmit:
-                self.check_transmit(print_time)
-        if sync:
-            #Sync LED Update with print time and send
-            toolhead = self.printer.lookup_object('toolhead')
-            toolhead.register_lookahead_callback(lookahead_bgfunc)
-        else:
-            #Send update now (so as not to wake toolhead and reset idle_timeout)
-            lookahead_bgfunc(None)
-    def get_status(self, eventtime=None):
-        return {'color_data': self.led_state}
-
-# Main LED tracking code
-class PrinterLED:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.led_helpers = {}
-        self.active_templates = {}
-        self.render_timer = None
-        # Load templates
-        dtemplates = display.lookup_display_templates(config)
-        self.templates = dtemplates.get_display_templates()
-        gcode_macro = self.printer.lookup_object("gcode_macro")
-        self.create_template_context = gcode_macro.create_template_context
-        # Register handlers
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_command("SET_LED_TEMPLATE", self.cmd_SET_LED_TEMPLATE,
-                               desc=self.cmd_SET_LED_TEMPLATE_help)
-    def setup_helper(self, config, update_func, led_count=1):
-        led_helper = LEDHelper(config, update_func, led_count)
-        name = config.get_name().split()[-1]
-        self.led_helpers[name] = led_helper
-        return led_helper
-    def _activate_timer(self):
-        if self.render_timer is not None or not self.active_templates:
-            return
-        reactor = self.printer.get_reactor()
-        self.render_timer = reactor.register_timer(self._render, reactor.NOW)
-    def _activate_template(self, led_helper, index, template, lparams):
-        key = (led_helper, index)
-        if template is not None:
-            uid = (template,) + tuple(sorted(lparams.items()))
-            self.active_templates[key] = (uid, template, lparams)
-            return
-        if key in self.active_templates:
-            del self.active_templates[key]
-    def _render(self, eventtime):
-        if not self.active_templates:
-            # Nothing to do - unregister timer
-            reactor = self.printer.get_reactor()
-            reactor.register_timer(self.render_timer)
-            self.render_timer = None
-            return reactor.NEVER
-        # Setup gcode_macro template context
-        context = self.create_template_context(eventtime)
-        def render(name, **kwargs):
-            return self.templates[name].render(context, **kwargs)
-        context['render'] = render
-        # Render all templates
-        need_transmit = {}
-        rendered = {}
-        template_info = self.active_templates.items()
-        for (led_helper, index), (uid, template, lparams) in template_info:
-            color = rendered.get(uid)
-            if color is None:
-                try:
-                    text = template.render(context, **lparams)
-                    parts = [max(0., min(1., float(f)))
-                             for f in text.split(',', 4)]
-                except Exception as e:
-                    logging.exception("led template render error")
-                    parts = []
-                if len(parts) < 4:
-                    parts += [0.] * (4 - len(parts))
-                rendered[uid] = color = tuple(parts)
-            need_transmit[led_helper] = 1
-            led_helper.set_color(index, color)
-        context.clear() # Remove circular references for better gc
-        # Transmit pending changes
-        for led_helper in need_transmit.keys():
-            led_helper.check_transmit(None)
-        return eventtime + RENDER_TIME
-    cmd_SET_LED_TEMPLATE_help = "Assign a display_template to an LED"
-    def cmd_SET_LED_TEMPLATE(self, gcmd):
-        led_name = gcmd.get("LED")
-        led_helper = self.led_helpers.get(led_name)
-        if led_helper is None:
-            raise gcmd.error("Unknown LED '%s'" % (led_name,))
-        led_count = led_helper.get_led_count()
-        index = gcmd.get_int("INDEX", None, minval=1, maxval=led_count)
-        template = None
-        lparams = {}
-        tpl_name = gcmd.get("TEMPLATE")
-        if tpl_name:
-            template = self.templates.get(tpl_name)
-            if template is None:
-                raise gcmd.error("Unknown display_template '%s'" % (tpl_name,))
-            tparams = template.get_params()
-            for p, v in gcmd.get_command_parameters().items():
-                if not p.startswith("PARAM_"):
-                    continue
-                p = p.lower()
-                if p not in tparams:
-                    raise gcmd.error("Invalid display_template parameter: %s"
-                                     % (p,))
-                try:
-                    lparams[p] = ast.literal_eval(v)
-                except ValueError as e:
-                    raise gcmd.error("Unable to parse '%s' as a literal" % (v,))
-        if index is not None:
-            self._activate_template(led_helper, index, template, lparams)
-        else:
-            for i in range(led_count):
-                self._activate_template(led_helper, i+1, template, lparams)
-        self._activate_timer()
-
-PIN_MIN_TIME = 0.100
-MAX_SCHEDULE_TIME = 5.0
-
-# Handler for PWM controlled LEDs
-class PrinterPWMLED:
-    def __init__(self, config):
-        self.printer = printer = config.get_printer()
-        # Configure pwm pins
-        ppins = printer.lookup_object('pins')
-        cycle_time = config.getfloat('cycle_time', 0.010, above=0.,
-                                     maxval=MAX_SCHEDULE_TIME)
-        hardware_pwm = config.getboolean('hardware_pwm', False)
-        self.pins = []
-        for i, name in enumerate(("red", "green", "blue", "white")):
-            pin_name = config.get(name + '_pin', None)
-            if pin_name is None:
-                continue
-            mcu_pin = ppins.setup_pin('pwm', pin_name)
-            mcu_pin.setup_max_duration(0.)
-            mcu_pin.setup_cycle_time(cycle_time, hardware_pwm)
-            self.pins.append((i, mcu_pin))
-        if not self.pins:
-            raise config.error("No LED pin definitions found in '%s'"
-                               % (config.get_name(),))
-        self.last_print_time = 0.
-        # Initialize color data
-        pled = printer.load_object(config, "led")
-        self.led_helper = pled.setup_helper(config, self.update_leds, 1)
-        self.prev_color = color = self.led_helper.get_status()['color_data'][0]
-        for idx, mcu_pin in self.pins:
-            mcu_pin.setup_start_value(color[idx], 0.)
-    def update_leds(self, led_state, print_time):
-        if print_time is None:
-            eventtime = self.printer.get_reactor().monotonic()
-            mcu = self.pins[0][1].get_mcu()
-            print_time = mcu.estimated_print_time(eventtime) + PIN_MIN_TIME
-        print_time = max(print_time, self.last_print_time + PIN_MIN_TIME)
-        color = led_state[0]
-        for idx, mcu_pin in self.pins:
-            if self.prev_color[idx] != color[idx]:
-                mcu_pin.set_pwm(print_time, color[idx])
-                self.last_print_time = print_time
-        self.prev_color = color
-    def get_status(self, eventtime=None):
-        return self.led_helper.get_status(eventtime)
-
-def load_config(config):
-    return PrinterLED(config)
-
-def load_config_prefix(config):
-    return PrinterPWMLED(config)
deleted file mode 100644
--- a/klippy/extras/lm75.py
+++ /dev/null
@@ -1,108 +0,0 @@
-# Support for I2C based LM75/LM75A temperature sensors
-#
-# Copyright (C) 2020  Boleslaw Ciesielski <combolek@users.noreply.github.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-LM75_CHIP_ADDR = 0x48
-LM75_I2C_SPEED = 100000
-LM75_REGS = {
-    'TEMP'   : 0x00,
-    'CONF'   : 0x01,
-    'THYST'  : 0x02,
-    'TOS'    : 0x03,
-    'PRODID' : 0x07    # TI LM75A chips only?
-}
-LM75_REPORT_TIME = .8
-# Temperature can be sampled at any time but the read aborts
-# the current conversion. Conversion time is 300ms so make
-# sure not to read too often.
-LM75_MIN_REPORT_TIME = .5
-
-class LM75:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.reactor = self.printer.get_reactor()
-        self.i2c = bus.MCU_I2C_from_config(config, LM75_CHIP_ADDR,
-                                           LM75_I2C_SPEED)
-        self.mcu = self.i2c.get_mcu()
-        self.report_time = config.getfloat('lm75_report_time', LM75_REPORT_TIME,
-                                           minval=LM75_MIN_REPORT_TIME)
-        self.temp = self.min_temp = self.max_temp = 0.0
-        self.sample_timer = self.reactor.register_timer(self._sample_lm75)
-        self.printer.add_object("lm75 " + self.name, self)
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self._init_lm75()
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return self.report_time
-
-    def degrees_from_sample(self, x):
-        # The temp sample is encoded in the top 9 bits of a 16-bit
-        # value. Resolution is 0.5 degrees C.
-        return x[0] + (x[1] >> 7) * 0.5
-
-    def _init_lm75(self):
-        # Check and report the chip ID but ignore errors since many
-        # chips don't have it
-        try:
-            prodid = self.read_register('PRODID', 1)[0]
-            logging.info("lm75: Chip ID %#x" % prodid)
-        except:
-            pass
-
-    def _sample_lm75(self, eventtime):
-        try:
-            sample = self.read_register('TEMP', 2)
-            self.temp = self.degrees_from_sample(sample)
-        except Exception:
-            logging.exception("lm75: Error reading data")
-            self.temp = 0.0
-            return self.reactor.NEVER
-
-        if self.temp < self.min_temp or self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "LM75 temperature %0.1f outside range of %0.1f:%.01f"
-                % (self.temp, self.min_temp, self.max_temp))
-
-        measured_time = self.reactor.monotonic()
-        self._callback(self.mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + self.report_time
-
-    def read_register(self, reg_name, read_len):
-        # read a single register
-        regs = [LM75_REGS[reg_name]]
-        params = self.i2c.i2c_read(regs, read_len)
-        return bytearray(params['response'])
-
-    def write_register(self, reg_name, data):
-        if type(data) is not list:
-            data = [data]
-        reg = LM75_REGS[reg_name]
-        data.insert(0, reg)
-        self.i2c.i2c_write(data)
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-        }
-
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("LM75", LM75)
deleted file mode 100644
--- a/klippy/extras/mcp4018.py
+++ /dev/null
@@ -1,97 +0,0 @@
-# MCP4018 digipot support (via bit-banging)
-#
-# Copyright (C) 2019  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class SoftwareI2C:
-    def __init__(self, config, addr):
-        self.addr = addr << 1
-        self.update_pin_cmd = None
-        # Lookup pins
-        ppins = config.get_printer().lookup_object('pins')
-        scl_pin = config.get('scl_pin')
-        scl_params = ppins.lookup_pin(scl_pin, share_type='sw_scl')
-        self.mcu = scl_params['chip']
-        self.scl_pin = scl_params['pin']
-        self.scl_main = scl_params.get('class')
-        if self.scl_main is None:
-            self.scl_main = scl_params['class'] = self
-            self.scl_oid = self.mcu.create_oid()
-            self.cmd_queue = self.mcu.alloc_command_queue()
-            self.mcu.register_config_callback(self.build_config)
-        else:
-            self.scl_oid = self.scl_main.scl_oid
-            self.cmd_queue = self.scl_main.cmd_queue
-        sda_params = ppins.lookup_pin(config.get('sda_pin'))
-        self.sda_oid = self.mcu.create_oid()
-        if sda_params['chip'] != self.mcu:
-            raise ppins.error("%s: scl_pin and sda_pin must be on same mcu" % (
-                config.get_name(),))
-        self.mcu.add_config_cmd("config_digital_out oid=%d pin=%s"
-                                " value=%d default_value=%d max_duration=%d" % (
-                                    self.sda_oid, sda_params['pin'], 1, 1, 0))
-    def get_mcu(self):
-        return self.mcu
-    def build_config(self):
-        self.mcu.add_config_cmd("config_digital_out oid=%d pin=%s value=%d"
-                                " default_value=%d max_duration=%d" % (
-                                    self.scl_oid, self.scl_pin, 1, 1, 0))
-        self.update_pin_cmd = self.mcu.lookup_command(
-            "update_digital_out oid=%c value=%c", cq=self.cmd_queue)
-    def i2c_write(self, msg, minclock=0, reqclock=0):
-        msg = [self.addr] + msg
-        send = self.scl_main.update_pin_cmd.send
-        # Send ack
-        send([self.sda_oid, 0], minclock=minclock, reqclock=reqclock)
-        send([self.scl_oid, 0], minclock=minclock, reqclock=reqclock)
-        # Send bytes
-        sda_last = 0
-        for data in msg:
-            # Transmit 8 data bits
-            for i in range(8):
-                sda_next = not not (data & (0x80 >> i))
-                if sda_last != sda_next:
-                    sda_last = sda_next
-                    send([self.sda_oid, sda_last],
-                         minclock=minclock, reqclock=reqclock)
-                send([self.scl_oid, 1], minclock=minclock, reqclock=reqclock)
-                send([self.scl_oid, 0], minclock=minclock, reqclock=reqclock)
-            # Transmit clock for ack
-            send([self.scl_oid, 1], minclock=minclock, reqclock=reqclock)
-            send([self.scl_oid, 0], minclock=minclock, reqclock=reqclock)
-        # Send stop
-        if sda_last:
-            send([self.sda_oid, 0], minclock=minclock, reqclock=reqclock)
-        send([self.scl_oid, 1], minclock=minclock, reqclock=reqclock)
-        send([self.sda_oid, 1], minclock=minclock, reqclock=reqclock)
-
-class mcp4018:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.i2c = SoftwareI2C(config, 0x2f)
-        self.scale = config.getfloat('scale', 1., above=0.)
-        self.start_value = config.getfloat('wiper',
-                                           minval=0., maxval=self.scale)
-        config.get_printer().register_event_handler("klippy:connect",
-                                                    self.handle_connect)
-        # Register commands
-        self.name = config.get_name().split()[1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("SET_DIGIPOT", "DIGIPOT", self.name,
-                                   self.cmd_SET_DIGIPOT,
-                                   desc=self.cmd_SET_DIGIPOT_help)
-    def handle_connect(self):
-        self.set_dac(self.start_value)
-    def set_dac(self, value):
-        val = int(value * 127. / self.scale + .5)
-        self.i2c.i2c_write([val])
-    cmd_SET_DIGIPOT_help = "Set digipot value"
-    def cmd_SET_DIGIPOT(self, gcmd):
-        wiper = gcmd.get_float('WIPER', minval=0., maxval=self.scale)
-        if wiper is not None:
-            self.set_dac(wiper)
-            gcmd.respond_info("New value for DIGIPOT = %s, wiper = %.2f"
-                               % (self.name, wiper))
-def load_config_prefix(config):
-    return mcp4018(config)
deleted file mode 100644
--- a/klippy/extras/mcp4451.py
+++ /dev/null
@@ -1,30 +0,0 @@
-# MCP4451 digipot code
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus
-
-WiperRegisters = [0x00, 0x01, 0x06, 0x07]
-
-class mcp4451:
-    def __init__(self, config):
-        self.i2c = bus.MCU_I2C_from_config(config)
-        i2c_addr = self.i2c.get_i2c_address()
-        if i2c_addr < 44 or i2c_addr > 47:
-            raise config.error("mcp4451 address must be between 44 and 47")
-        scale = config.getfloat('scale', 1., above=0.)
-        # Configure registers
-        self.set_register(0x04, 0xff)
-        self.set_register(0x0a, 0xff)
-        for i in range(4):
-            val = config.getfloat('wiper_%d' % (i,), None,
-                                  minval=0., maxval=scale)
-            if val is not None:
-                val = int(val * 255. / scale + .5)
-                self.set_register(WiperRegisters[i], val)
-    def set_register(self, reg, value):
-        self.i2c.i2c_write([(reg << 4) | ((value >> 8) & 0x03), value])
-
-def load_config_prefix(config):
-    return mcp4451(config)
deleted file mode 100644
--- a/klippy/extras/mcp4728.py
+++ /dev/null
@@ -1,23 +0,0 @@
-# MCP4728 dac code
-#
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus
-
-class mcp4728:
-    def __init__(self, config):
-        self.i2c = bus.MCU_I2C_from_config(config, default_addr=0x60)
-        scale = config.getfloat('scale', 1., above=0.)
-        # Configure registers
-        for i, name in enumerate('abcd'):
-            val = config.getfloat('channel_%s' % (name,), None,
-                                  minval=0., maxval=scale)
-            if val is not None:
-                self.set_dac(i, int(val * 4095. / scale + .5))
-    def set_dac(self, dac, value):
-        self.i2c.i2c_write([0x40 | (dac << 1),
-                            ((value >> 8) & 0x0f) | 0x80, value & 0xff])
-
-def load_config_prefix(config):
-    return mcp4728(config)
deleted file mode 100644
--- a/klippy/extras/mpu9250.py
+++ /dev/null
@@ -1,278 +0,0 @@
-# Support for reading acceleration data from an mpu9250 chip
-#
-# Copyright (C) 2022  Harry Beyel <harry3b9@gmail.com>
-# Copyright (C) 2020-2021 Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging, time, collections, threading, multiprocessing, os
-from . import bus, motion_report, adxl345
-
-MPU9250_ADDR =      0x68
-
-MPU_DEV_IDS = {
-    0x74: "mpu-9515",
-    0x73: "mpu-9255",
-    0x71: "mpu-9250",
-    0x70: "mpu-6500",
-    0x68: "mpu-6050",
-    #everything above are normal MPU IDs
-    0x75: "mpu-unknown (DEFECTIVE! USE WITH CAUTION!)",
-    0x69: "mpu-unknown (DEFECTIVE! USE WITH CAUTION!)",
-    }
-
-# MPU9250 registers
-REG_DEVID =         0x75
-REG_FIFO_EN =       0x23
-REG_SMPLRT_DIV =    0x19
-REG_CONFIG =        0x1A
-REG_ACCEL_CONFIG =  0x1C
-REG_ACCEL_CONFIG2 = 0x1D
-REG_USER_CTRL =     0x6A
-REG_PWR_MGMT_1 =    0x6B
-REG_PWR_MGMT_2 =    0x6C
-
-SAMPLE_RATE_DIVS = { 4000:0x00 }
-
-SET_CONFIG =        0x01 # FIFO mode 'stream' style
-SET_ACCEL_CONFIG =  0x10 # 8g full scale
-SET_ACCEL_CONFIG2 = 0x08 # 1046Hz BW, 0.503ms delay 4kHz sample rate
-SET_PWR_MGMT_1_WAKE =     0x00
-SET_PWR_MGMT_1_SLEEP=     0x40
-SET_PWR_MGMT_2_ACCEL_ON = 0x07
-SET_PWR_MGMT_2_OFF  =     0x3F
-
-FREEFALL_ACCEL = 9.80665 * 1000.
-# SCALE = 1/4096 g/LSB @8g scale * Earth gravity in mm/s**2
-SCALE = 0.000244140625 * FREEFALL_ACCEL
-
-FIFO_SIZE = 512
-
-Accel_Measurement = collections.namedtuple(
-    'Accel_Measurement', ('time', 'accel_x', 'accel_y', 'accel_z'))
-
-MIN_MSG_TIME = 0.100
-
-BYTES_PER_SAMPLE = 6
-SAMPLES_PER_BLOCK = 8
-
-# Printer class that controls MPU9250 chip
-class MPU9250:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        adxl345.AccelCommandHelper(config, self)
-        self.query_rate = 0
-        am = {'x': (0, SCALE), 'y': (1, SCALE), 'z': (2, SCALE),
-              '-x': (0, -SCALE), '-y': (1, -SCALE), '-z': (2, -SCALE)}
-        axes_map = config.getlist('axes_map', ('x','y','z'), count=3)
-        if any([a not in am for a in axes_map]):
-            raise config.error("Invalid mpu9250 axes_map parameter")
-        self.axes_map = [am[a.strip()] for a in axes_map]
-        self.data_rate = config.getint('rate', 4000)
-        if self.data_rate not in SAMPLE_RATE_DIVS:
-            raise config.error("Invalid rate parameter: %d" % (self.data_rate,))
-        # Measurement storage (accessed from background thread)
-        self.lock = threading.Lock()
-        self.raw_samples = []
-        # Setup mcu sensor_mpu9250 bulk query code
-        self.i2c = bus.MCU_I2C_from_config(config,
-                                           default_addr=MPU9250_ADDR,
-                                           default_speed=400000)
-        self.mcu = mcu = self.i2c.get_mcu()
-        self.oid = oid = mcu.create_oid()
-        self.query_mpu9250_cmd = self.query_mpu9250_end_cmd = None
-        self.query_mpu9250_status_cmd = None
-        mcu.register_config_callback(self._build_config)
-        mcu.register_response(self._handle_mpu9250_data, "mpu9250_data", oid)
-        # Clock tracking
-        self.last_sequence = self.max_query_duration = 0
-        self.last_limit_count = self.last_error_count = 0
-        self.clock_sync = adxl345.ClockSyncRegression(self.mcu, 640)
-        # API server endpoints
-        self.api_dump = motion_report.APIDumpHelper(
-            self.printer, self._api_update, self._api_startstop, 0.100)
-        self.name = config.get_name().split()[-1]
-        wh = self.printer.lookup_object('webhooks')
-        wh.register_mux_endpoint("mpu9250/dump_mpu9250", "sensor", self.name,
-                                 self._handle_dump_mpu9250)
-    def _build_config(self):
-        cmdqueue = self.i2c.get_command_queue()
-        self.mcu.add_config_cmd("config_mpu9250 oid=%d i2c_oid=%d"
-                           % (self.oid, self.i2c.get_oid()))
-        self.mcu.add_config_cmd("query_mpu9250 oid=%d clock=0 rest_ticks=0"
-                           % (self.oid,), on_restart=True)
-        self.query_mpu9250_cmd = self.mcu.lookup_command(
-            "query_mpu9250 oid=%c clock=%u rest_ticks=%u", cq=cmdqueue)
-        self.query_mpu9250_end_cmd = self.mcu.lookup_query_command(
-            "query_mpu9250 oid=%c clock=%u rest_ticks=%u",
-            "mpu9250_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
-            " buffered=%c fifo=%u limit_count=%hu", oid=self.oid, cq=cmdqueue)
-        self.query_mpu9250_status_cmd = self.mcu.lookup_query_command(
-            "query_mpu9250_status oid=%c",
-            "mpu9250_status oid=%c clock=%u query_ticks=%u next_sequence=%hu"
-            " buffered=%c fifo=%u limit_count=%hu", oid=self.oid, cq=cmdqueue)
-    def read_reg(self, reg):
-        params = self.i2c.i2c_read([reg], 1)
-        return bytearray(params['response'])[0]
-
-    def set_reg(self, reg, val, minclock=0):
-        self.i2c.i2c_write([reg, val & 0xFF], minclock=minclock)
-
-    # Measurement collection
-    def is_measuring(self):
-        return self.query_rate > 0
-    def _handle_mpu9250_data(self, params):
-        with self.lock:
-            self.raw_samples.append(params)
-    def _extract_samples(self, raw_samples):
-        # Load variables to optimize inner loop below
-        (x_pos, x_scale), (y_pos, y_scale), (z_pos, z_scale) = self.axes_map
-        last_sequence = self.last_sequence
-        time_base, chip_base, inv_freq = self.clock_sync.get_time_translation()
-        # Process every message in raw_samples
-        count = seq = 0
-        samples = [None] * (len(raw_samples) * SAMPLES_PER_BLOCK)
-        for params in raw_samples:
-            seq_diff = (last_sequence - params['sequence']) & 0xffff
-            seq_diff -= (seq_diff & 0x8000) << 1
-            seq = last_sequence - seq_diff
-            d = bytearray(params['data'])
-            msg_cdiff = seq * SAMPLES_PER_BLOCK - chip_base
-
-            for i in range(len(d) // BYTES_PER_SAMPLE):
-                d_xyz = d[i*BYTES_PER_SAMPLE:(i+1)*BYTES_PER_SAMPLE]
-                xhigh, xlow, yhigh, ylow, zhigh, zlow = d_xyz
-                # Merge and perform twos-complement
-                rx = ((xhigh << 8) | xlow) - ((xhigh & 0x80) << 9)
-                ry = ((yhigh << 8) | ylow) - ((yhigh & 0x80) << 9)
-                rz = ((zhigh << 8) | zlow) - ((zhigh & 0x80) << 9)
-
-                raw_xyz = (rx, ry, rz)
-                x = round(raw_xyz[x_pos] * x_scale, 6)
-                y = round(raw_xyz[y_pos] * y_scale, 6)
-                z = round(raw_xyz[z_pos] * z_scale, 6)
-                ptime = round(time_base + (msg_cdiff + i) * inv_freq, 6)
-                samples[count] = (ptime, x, y, z)
-                count += 1
-        self.clock_sync.set_last_chip_clock(seq * SAMPLES_PER_BLOCK + i)
-        del samples[count:]
-        return samples
-
-    def _update_clock(self, minclock=0):
-        # Query current state
-        for retry in range(5):
-            params = self.query_mpu9250_status_cmd.send([self.oid],
-                                                        minclock=minclock)
-            fifo = params['fifo'] & 0x1fff
-            if fifo <= FIFO_SIZE:
-                break
-        else:
-            raise self.printer.command_error("Unable to query mpu9250 fifo")
-        mcu_clock = self.mcu.clock32_to_clock64(params['clock'])
-        sequence = (self.last_sequence & ~0xffff) | params['next_sequence']
-        if sequence < self.last_sequence:
-            sequence += 0x10000
-        self.last_sequence = sequence
-        buffered = params['buffered']
-        limit_count = (self.last_limit_count & ~0xffff) | params['limit_count']
-        if limit_count < self.last_limit_count:
-            limit_count += 0x10000
-        self.last_limit_count = limit_count
-        duration = params['query_ticks']
-        if duration > self.max_query_duration:
-            # Skip measurement as a high query time could skew clock tracking
-            self.max_query_duration = max(2 * self.max_query_duration,
-                                          self.mcu.seconds_to_clock(.000005))
-            return
-        self.max_query_duration = 2 * duration
-        msg_count = (sequence * SAMPLES_PER_BLOCK
-                     + buffered // BYTES_PER_SAMPLE + fifo)
-        # The "chip clock" is the message counter plus .5 for average
-        # inaccuracy of query responses and plus .5 for assumed offset
-        # of mpu9250 hw processing time.
-        chip_clock = msg_count + 1
-        self.clock_sync.update(mcu_clock + duration // 2, chip_clock)
-    def _start_measurements(self):
-        if self.is_measuring():
-            return
-        # In case of miswiring, testing MPU9250 device ID prevents treating
-        # noise or wrong signal as a correctly initialized device
-        dev_id = self.read_reg(REG_DEVID)
-        if dev_id not in MPU_DEV_IDS.keys():
-            raise self.printer.command_error(
-                "Invalid mpu id (got %x).\n"
-                "This is generally indicative of connection problems\n"
-                "(e.g. faulty wiring) or a faulty chip."
-                % (dev_id))
-        else:
-            logging.info("Found %s with id %x"% (MPU_DEV_IDS[dev_id], dev_id))
-        # Setup chip in requested query rate
-        self.set_reg(REG_PWR_MGMT_1, SET_PWR_MGMT_1_WAKE)
-        self.set_reg(REG_PWR_MGMT_2, SET_PWR_MGMT_2_ACCEL_ON)
-        time.sleep(20. / 1000) # wait for accelerometer chip wake up
-        self.set_reg(REG_SMPLRT_DIV, SAMPLE_RATE_DIVS[self.data_rate])
-        self.set_reg(REG_CONFIG, SET_CONFIG)
-        self.set_reg(REG_ACCEL_CONFIG, SET_ACCEL_CONFIG)
-        self.set_reg(REG_ACCEL_CONFIG2, SET_ACCEL_CONFIG2)
-
-        # Setup samples
-        with self.lock:
-            self.raw_samples = []
-        # Start bulk reading
-        systime = self.printer.get_reactor().monotonic()
-        print_time = self.mcu.estimated_print_time(systime) + MIN_MSG_TIME
-        reqclock = self.mcu.print_time_to_clock(print_time)
-        rest_ticks = self.mcu.seconds_to_clock(1. / self.data_rate)
-        self.query_rate = self.data_rate
-        self.query_mpu9250_cmd.send([self.oid, reqclock, rest_ticks],
-                                    reqclock=reqclock)
-        logging.info("MPU9250 starting '%s' measurements", self.name)
-        # Initialize clock tracking
-        self.last_sequence = 0
-        self.last_limit_count = self.last_error_count = 0
-        self.clock_sync.reset(reqclock, 0)
-        self.max_query_duration = 1 << 31
-        self._update_clock(minclock=reqclock)
-        self.max_query_duration = 1 << 31
-    def _finish_measurements(self):
-        if not self.is_measuring():
-            return
-        # Halt bulk reading
-        params = self.query_mpu9250_end_cmd.send([self.oid, 0, 0])
-        self.query_rate = 0
-        with self.lock:
-            self.raw_samples = []
-        logging.info("MPU9250 finished '%s' measurements", self.name)
-        self.set_reg(REG_PWR_MGMT_1, SET_PWR_MGMT_1_SLEEP)
-        self.set_reg(REG_PWR_MGMT_2, SET_PWR_MGMT_2_OFF)
-
-    # API interface
-    def _api_update(self, eventtime):
-        self._update_clock()
-        with self.lock:
-            raw_samples = self.raw_samples
-            self.raw_samples = []
-        if not raw_samples:
-            return {}
-        samples = self._extract_samples(raw_samples)
-        if not samples:
-            return {}
-        return {'data': samples, 'errors': self.last_error_count,
-                'overflows': self.last_limit_count}
-    def _api_startstop(self, is_start):
-        if is_start:
-            self._start_measurements()
-        else:
-            self._finish_measurements()
-    def _handle_dump_mpu9250(self, web_request):
-        self.api_dump.add_client(web_request)
-        hdr = ('time', 'x_acceleration', 'y_acceleration', 'z_acceleration')
-        web_request.send({'header': hdr})
-    def start_internal_client(self):
-        cconn = self.api_dump.add_internal_client()
-        return adxl345.AccelQueryHelper(self.printer, cconn)
-
-def load_config(config):
-    return MPU9250(config)
-
-def load_config_prefix(config):
-    return MPU9250(config)
deleted file mode 100644
--- a/klippy/extras/palette2.py
+++ /dev/null
@@ -1,654 +0,0 @@
-# Palette 2 MMU support, Firmware 9.0.9 and newer supported only!
-#
-# Copyright (C) 2021 Clifford Roche <clifford.roche@gmail.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-import logging
-import os
-import serial
-
-from serial import SerialException
-
-try:
-    from queue import Queue, Empty
-except ImportError:
-    from Queue import Queue, Empty
-
-COMMAND_HEARTBEAT = "O99"
-COMMAND_CUT = "O10 D5"
-COMMAND_CLEAR = [
-    "O10 D5",
-    "O10 D0 D0 D0 DFFE1",
-    "O10 D1 D0 D0 DFFE1",
-    "O10 D2 D0 D0 DFFE1",
-    "O10 D3 D0 D0 DFFE1",
-    "O10 D4 D0 D0 D0069"]
-COMMAND_FILENAME = "O51"
-COMMAND_FILENAMES_DONE = "O52"
-COMMAND_FIRMWARE = "O50"
-COMMAND_PING = "O31"
-COMMAND_SMART_LOAD_STOP = "O102 D1"
-
-HEARTBEAT_SEND = 5.
-HEARTBEAT_TIMEOUT = (HEARTBEAT_SEND * 2.) + 1.
-SETUP_TIMEOUT = 10
-
-SERIAL_TIMER = 0.1
-AUTOLOAD_TIMER = 5.
-
-INFO_NOT_CONNECTED = "Palette 2 is not connected, connect first"
-
-
-class Palette2:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        try:
-            self.virtual_sdcard = self.printer.load_object(
-                config, "virtual_sdcard")
-        except config.error:
-            raise self.printer.config_error(
-                "Palette 2 requires [virtual_sdcard] to work,"
-                " please add it to your config!")
-        try:
-            self.pause_resume = self.printer.load_object(
-                config, "pause_resume")
-        except config.error:
-            raise self.printer.config_error(
-                "Palette 2 requires [pause_resume] to work,"
-                " please add it to your config!")
-        self.gcode_move = self.printer.load_object(config, 'gcode_move')
-        self.gcode = self.printer.lookup_object("gcode")
-        self.gcode.register_command(
-            "PALETTE_CONNECT", self.cmd_Connect, desc=self.cmd_Connect_Help)
-        self.gcode.register_command(
-            "PALETTE_DISCONNECT",
-            self.cmd_Disconnect,
-            desc=self.cmd_Disconnect_Help)
-        self.gcode.register_command(
-            "PALETTE_CLEAR", self.cmd_Clear, desc=self.cmd_Clear_Help)
-        self.gcode.register_command(
-            "PALETTE_CUT", self.cmd_Cut, desc=self.cmd_Cut_Help)
-        self.gcode.register_command(
-            "PALETTE_SMART_LOAD",
-            self.cmd_Smart_Load,
-            desc=self.cmd_Smart_Load_Help)
-        self.serial = None
-        self.serial_port = config.get("serial")
-        if not self.serial_port:
-            raise config.error("Invalid serial port specific for Palette 2")
-        self.baud = config.getint("baud", default=115200)
-        self.feedrate_splice = config.getfloat(
-            "feedrate_splice", default=0.8, minval=0., maxval=1.)
-        self.feedrate_normal = config.getfloat(
-            "feedrate_normal", default=1.0, minval=0., maxval=1.)
-        self.auto_load_speed = config.getint("auto_load_speed", 2)
-        self.auto_cancel_variation = config.getfloat(
-            "auto_cancel_variation", default=None, minval=0.01, maxval=0.2)
-
-        # Omega code matchers
-        self.omega_header = [None] * 9
-        omega_handlers = ["O" + str(i) for i in range(33)]
-        for cmd in omega_handlers:
-            func = getattr(self, 'cmd_' + cmd, None)
-            desc = getattr(self, 'cmd_' + cmd + '_help', None)
-            if func:
-                self.gcode.register_command(cmd, func, desc=desc)
-            else:
-                self.gcode.register_command(cmd, self.cmd_OmegaDefault)
-
-        self._reset()
-
-        self.read_timer = None
-        self.read_buffer = ""
-        self.read_queue = Queue()
-        self.write_timer = None
-        self.write_queue = Queue()
-        self.heartbeat_timer = None
-        self.heartbeat = None
-        self.signal_disconnect = False
-
-        self.is_printing = False
-        self.smart_load_timer = None
-
-    def _reset(self):
-        self.files = []
-        self.is_setup_complete = False
-        self.is_splicing = False
-        self.is_loading = False
-        self.remaining_load_length = None
-        self.omega_algorithms = []
-        self.omega_algorithms_counter = 0
-        self.omega_splices = []
-        self.omega_splices_counter = 0
-        self.omega_pings = []
-        self.omega_pongs = []
-        self.omega_current_ping = None
-        self.omega_header = [None] * 9
-        self.omega_header_counter = 0
-        self.omega_last_command = ""
-        self.omega_drivers = []
-
-    def _check_P2(self, gcmd=None):
-        if self.serial:
-            return True
-        if gcmd:
-            gcmd.respond_info(INFO_NOT_CONNECTED)
-        return False
-
-    cmd_Connect_Help = ("Connect to the Palette 2")
-
-    def cmd_Connect(self, gcmd):
-        if self.serial:
-            gcmd.respond_info(
-                "Palette 2 serial port is already active, disconnect first")
-            return
-
-        self.signal_disconnect = False
-        logging.info("Connecting to Palette 2 on port (%s) at (%s)" %
-                     (self.serial_port, self.baud))
-        try:
-            self.serial = serial.Serial(
-                self.serial_port, self.baud, timeout=0, write_timeout=0)
-        except SerialException:
-            gcmd.respond_info("Unable to connect to the Palette 2")
-            return
-
-        with self.write_queue.mutex:
-            self.write_queue.queue.clear()
-        with self.read_queue.mutex:
-            self.read_queue.queue.clear()
-
-        self.read_timer = self.reactor.register_timer(
-            self._run_Read, self.reactor.NOW)
-        self.write_timer = self.reactor.register_timer(
-            self._run_Write, self.reactor.NOW)
-        self.heartbeat_timer = self.reactor.register_timer(
-            self._run_Heartbeat, self.reactor.NOW)
-
-        # Tell the device we're alive
-        self.write_queue.put("\n")
-        self.write_queue.put(COMMAND_FIRMWARE)
-        self._wait_for_heartbeat()
-
-    cmd_Disconnect_Help = ("Disconnect from the Palette 2")
-
-    def cmd_Disconnect(self, gcmd=None):
-        self.gcode.respond_info("Disconnecting from Palette 2")
-        if self.serial:
-            self.serial.close()
-            self.serial = None
-
-        self.reactor.unregister_timer(self.read_timer)
-        self.reactor.unregister_timer(self.write_timer)
-        self.reactor.unregister_timer(self.heartbeat_timer)
-        self.read_timer = None
-        self.write_timer = None
-        self.heartbeat = None
-        self.is_printing = False
-
-    cmd_Clear_Help = ("Clear the input and output of the Palette 2")
-
-    def cmd_Clear(self, gcmd):
-        logging.info("Clearing Palette 2 input and output")
-        if self._check_P2(gcmd):
-            for l in COMMAND_CLEAR:
-                self.write_queue.put(l)
-
-    cmd_Cut_Help = ("Cut the outgoing filament")
-
-    def cmd_Cut(self, gcmd):
-        logging.info("Cutting outgoing filament in Palette 2")
-        if self._check_P2(gcmd):
-            self.write_queue.put(COMMAND_CUT)
-
-    cmd_Smart_Load_Help = ("Automatically load filament through the extruder")
-
-    def cmd_Smart_Load(self, gcmd):
-        if self._check_P2(gcmd):
-            if not self.is_loading:
-                gcmd.respond_info(
-                    "Cannot auto load when the Palette 2 is not ready")
-                return
-            self.p2cmd_O102(params=None)
-
-    def cmd_OmegaDefault(self, gcmd):
-        logging.debug("Omega Code: %s" % (gcmd.get_command()))
-        if self._check_P2(gcmd):
-            self.write_queue.put(gcmd.get_commandline())
-
-    def _wait_for_heartbeat(self):
-        startTs = self.reactor.monotonic()
-        currTs = startTs
-        while self.heartbeat is None or (self.heartbeat < (
-            currTs - SETUP_TIMEOUT) and startTs > (
-                currTs - SETUP_TIMEOUT)):
-            currTs = self.reactor.pause(currTs + 1.)
-
-        if self.heartbeat < (currTs - SETUP_TIMEOUT):
-            self.signal_disconnect = True
-            raise self.printer.command_error(
-                "No response from Palette 2")
-
-    cmd_O1_help = (
-        "Initialize the print, and check connection with the Palette 2")
-
-    def cmd_O1(self, gcmd):
-        logging.info("Initializing print with Pallete 2")
-        if not self._check_P2(gcmd):
-            raise self.printer.command_error(
-                "Cannot initialize print, palette 2 is not connected")
-
-        self.reactor.update_timer(self.heartbeat_timer, self.reactor.NOW)
-        self._wait_for_heartbeat()
-        self.write_queue.put(gcmd.get_commandline())
-        self.gcode.respond_info(
-            "Palette 2 waiting on user to complete setup")
-        self.pause_resume.send_pause_command()
-
-    cmd_O9_help = ("Reset print information")
-
-    def cmd_O9(self, gcmd):
-        logging.info("Print finished, resetting Palette 2 state")
-        if self._check_P2(gcmd):
-            self.write_queue.put(gcmd.get_commandline())
-        self.is_printing = False
-
-    def cmd_O21(self, gcmd):
-        logging.debug("Omega version: %s" % (gcmd.get_commandline()))
-        self._reset()
-        self.omega_header[0] = gcmd.get_commandline()
-        self.is_printing = True
-
-    def cmd_O22(self, gcmd):
-        logging.debug("Omega printer profile: %s" % (gcmd.get_commandline()))
-        self.omega_header[1] = gcmd.get_commandline()
-
-    def cmd_O23(self, gcmd):
-        logging.debug("Omega slicer profile: %s" % (gcmd.get_commandline()))
-        self.omega_header[2] = gcmd.get_commandline()
-
-    def cmd_O24(self, gcmd):
-        logging.debug("Omega PPM: %s" % (gcmd.get_commandline()))
-        self.omega_header[3] = gcmd.get_commandline()
-
-    def cmd_O25(self, gcmd):
-        logging.debug("Omega inputs: %s" % (gcmd.get_commandline()))
-        self.omega_header[4] = gcmd.get_commandline()
-        drives = self.omega_header[4][4:].split()
-        for idx in range(len(drives)):
-            state = drives[idx][:2]
-            if state == "D1":
-                drives[idx] = "U" + str(60 + idx)
-        self.omega_drives = [d for d in drives if d != "D0"]
-        logging.info("Omega drives: %s" % self.omega_drives)
-
-    def cmd_O26(self, gcmd):
-        logging.debug("Omega splices %s" % (gcmd.get_commandline()))
-        self.omega_header[5] = gcmd.get_commandline()
-
-    def cmd_O27(self, gcmd):
-        logging.debug("Omega pings: %s" % (gcmd.get_commandline()))
-        self.omega_header[6] = gcmd.get_commandline()
-
-    def cmd_O28(self, gcmd):
-        logging.debug("Omega MSF NA: %s" % (gcmd.get_commandline()))
-        self.omega_header[7] = gcmd.get_commandline()
-
-    def cmd_O29(self, gcmd):
-        logging.debug("Omega MSF NH: %s" % (gcmd.get_commandline()))
-        self.omega_header[8] = gcmd.get_commandline()
-
-    def cmd_O30(self, gcmd):
-        try:
-            param_drive = gcmd.get_commandline()[5:6]
-            param_distance = gcmd.get_commandline()[8:]
-        except IndexError:
-            gcmd.respond_info(
-                "Incorrect number of arguments for splice command")
-        try:
-            self.omega_splices.append((int(param_drive), param_distance))
-        except ValueError:
-            gcmd.respond_info("Incorrectly formatted splice command")
-        logging.debug("Omega splice command drive %s distance %s" %
-                      (param_drive, param_distance))
-
-    def cmd_O31(self, gcmd):
-        if self._check_P2(gcmd):
-            self.omega_current_ping = gcmd.get_commandline()
-            logging.debug("Omega ping command: %s" %
-                          (gcmd.get_commandline()))
-
-            self.write_queue.put(COMMAND_PING)
-            self.gcode.create_gcode_command("G4", "G4", {"P": "10"})
-
-    def cmd_O32(self, gcmd):
-        logging.debug("Omega algorithm: %s" % (gcmd.get_commandline()))
-        self.omega_algorithms.append(gcmd.get_commandline())
-
-    def p2cmd_O20(self, params):
-        if not self.is_printing:
-            return
-
-        # First print, we can ignore
-        if params[0] == "D5":
-            logging.info("First print on Palette")
-            return
-
-        try:
-            n = int(params[0][1:])
-        except (TypeError, IndexError):
-            logging.error("O20 command has invalid parameters")
-            return
-
-        if n == 0:
-            logging.info("Sending omega header %s" % self.omega_header_counter)
-            self.write_queue.put(self.omega_header[self.omega_header_counter])
-            self.omega_header_counter = self.omega_header_counter + 1
-        elif n == 1:
-            logging.info("Sending splice info %s" % self.omega_splices_counter)
-            splice = self.omega_splices[self.omega_splices_counter]
-            self.write_queue.put("O30 D%d D%s" % (splice[0], splice[1]))
-            self.omega_splices_counter = self.omega_splices_counter + 1
-        elif n == 2:
-            logging.info("Sending current ping info %s" %
-                         self.omega_current_ping)
-            self.write_queue.put(self.omega_current_ping)
-        elif n == 4:
-            logging.info("Sending algorithm info %s" %
-                         self.omega_algorithms_counter)
-            self.write_queue.put(
-                self.omega_algorithms[self.omega_algorithms_counter])
-            self.omega_algorithms_counter = self.omega_algorithms_counter + 1
-        elif n == 8:
-            logging.info("Resending the last command to Palette 2")
-            self.write_queue.put(self.omega_last_command)
-
-    def p2cmd_O34(self, params):
-        if not self.is_printing:
-            return
-
-        def check_ping_variation(last_ping):
-            if self.auto_cancel_variation is not None:
-                ping_max = 100. + (self.auto_cancel_variation * 100.)
-                ping_min = 100. - (self.auto_cancel_variation * 100.)
-                if last_ping < ping_min or last_ping > ping_max:
-                    logging.info("Ping variation is too high, "
-                                 "cancelling print")
-                    self.gcode.run_script("CANCEL_PRINT")
-
-        if len(params) > 2:
-            percent = float(params[1][1:])
-            if params[0] == "D1":
-                number = len(self.omega_pings) + 1
-                d = {"number": number, "percent": percent}
-                logging.info("Ping %d, %d percent" % (number, percent))
-                self.omega_pings.append(d)
-                check_ping_variation(percent)
-            elif params[0] == "D2":
-                number = len(self.omega_pongs) + 1
-                d = {"number": number, "percent": percent}
-                logging.info("Pong %d, %d percent" % (number, percent))
-                self.omega_pongs.append(d)
-
-    def p2cmd_O40(self, params):
-        logging.info("Resume request from Palette 2")
-        self.pause_resume.send_resume_command()
-
-    def p2cmd_O50(self, params):
-        if len(params) > 1:
-            try:
-                fw = params[0][1:]
-                logging.info(
-                    "Palette 2 firmware version %s detected" % fw)
-            except (TypeError, IndexError):
-                logging.error("Unable to parse firmware version")
-
-            if fw < "9.0.9":
-                raise self.printer.command_error(
-                    "Palette 2 firmware version is too old, "
-                    "update to at least 9.0.9")
-        else:
-            self.files = [
-                file for (
-                    file,
-                    size) in self.virtual_sdcard.get_file_list(
-                    check_subdirs=True) if ".mcf.gcode" in file]
-            for file in self.files:
-                self.write_queue.put("%s D%s" % (COMMAND_FILENAME, file))
-            self.write_queue.put(COMMAND_FILENAMES_DONE)
-
-    def p2cmd_O53(self, params):
-        if len(params) > 1 and params[0] == "D1":
-            try:
-                idx = int(params[1][1:], 16)
-                file = self.files[::-1][idx]
-                self.gcode.run_script("SDCARD_PRINT_FILE FILENAME=%s" % file)
-            except (TypeError, IndexError):
-                logging.error("O53 has invalid command parameters")
-
-    def p2cmd_O88(self, params):
-        logging.error("Palette 2 error detected")
-        try:
-            error = int(params[0][1:], 16)
-            logging.error("Palette 2 error code %d" % error)
-        except (TypeError, IndexError):
-            logging.error("Unable to parse Palette 2 error")
-
-    def p2cmd_O97(self, params):
-        def printCancelling(params):
-            logging.info("Print Cancelling")
-            self.gcode.run_script("CLEAR_PAUSE")
-            self.gcode.run_script("CANCEL_PRINT")
-
-        def printCancelled(params):
-            logging.info("Print Cancelled")
-            self._reset()
-
-        def loadingOffsetStart(params):
-            logging.info("Waiting for user to load filament into printer")
-            self.is_loading = True
-
-        def loadingOffset(params):
-            self.remaining_load_length = int(params[1][1:])
-            logging.debug("Loading filamant remaining %d" %
-                          self.remaining_load_length)
-            if self.remaining_load_length >= 0 and self.smart_load_timer:
-                logging.info("Smart load filament is complete")
-                self.reactor.unregister_timer(self.smart_load_timer)
-                self.smart_load_timer = None
-                self.is_loading = False
-
-        def feedrateStart(params):
-            logging.info("Setting feedrate to %f for splice" %
-                         self.feedrate_splice)
-            self.is_splicing = True
-            self.gcode.run_script("M220 S%d" % (self.feedrate_splice * 100))
-
-        def feedrateEnd(params):
-            logging.info("Setting feedrate to %f splice done" %
-                         self.feedrate_normal)
-            self.is_splicing = False
-            self.gcode.run_script("M220 S%d" % (self.feedrate_normal * 100))
-
-        matchers = []
-        if self.is_printing:
-            matchers = matchers + [
-                [printCancelling, 2, "U0", "D2"],
-                [printCancelled, 2, "U0", "D3"],
-                [loadingOffset, 2, "U39"],
-                [loadingOffsetStart, 1, "U39"],
-            ]
-
-        matchers.append([feedrateStart, 3, "U25", "D0"])
-        matchers.append([feedrateEnd, 3, "U25", "D1"])
-        self._param_Matcher(matchers, params)
-
-    def p2cmd_O100(self, params):
-        logging.info("Pause request from Palette 2")
-        self.is_setup_complete = True
-        self.pause_resume.send_pause_command()
-
-    def p2cmd_O102(self, params):
-        toolhead = self.printer.lookup_object("toolhead")
-        if not toolhead.get_extruder().get_heater().can_extrude:
-            self.write_queue.put(COMMAND_SMART_LOAD_STOP)
-            self.gcode.respond_info(
-                "Unable to auto load filament, extruder is below minimum temp")
-            return
-
-        if self.smart_load_timer is None:
-            logging.info("Smart load starting")
-            self.smart_load_timer = self.reactor.register_timer(
-                self._run_Smart_Load, self.reactor.NOW)
-
-    def p2cmd(self, line):
-        t = line.split()
-        ocode = t[0]
-        params = t[1:]
-        params_count = len(params)
-        if params_count:
-            res = [i for i in params if i[0] == "D" or i[0] == "U"]
-            if not all(res):
-                logging.error("Omega parameters are invalid")
-                return
-
-        func = getattr(self, 'p2cmd_' + ocode, None)
-        if func is not None:
-            func(params)
-
-    def _param_Matcher(self, matchers, params):
-        # Match the command with the handling table
-        for matcher in matchers:
-            if len(params) >= matcher[1]:
-                match_params = matcher[2:]
-                res = all([match_params[i] == params[i]
-                           for i in range(len(match_params))])
-                if res:
-                    matcher[0](params)
-                    return True
-        return False
-
-    def _run_Read(self, eventtime):
-        if self.signal_disconnect:
-            self.cmd_Disconnect()
-            return self.reactor.NEVER
-
-        # Do non-blocking reads from serial and try to find lines
-        while True:
-            try:
-                raw_bytes = self.serial.read()
-            except SerialException:
-                logging.error("Unable to communicate with the Palette 2")
-                self.cmd_Disconnect()
-                return self.reactor.NEVER
-            if len(raw_bytes):
-                new_buffer = str(raw_bytes.decode(encoding='UTF-8',
-                                                  errors='ignore'))
-                text_buffer = self.read_buffer + new_buffer
-                while True:
-                    i = text_buffer.find("\n")
-                    if i >= 0:
-                        line = text_buffer[0:i + 1]
-                        self.read_queue.put(line.strip())
-                        text_buffer = text_buffer[i + 1:]
-                    else:
-                        break
-                self.read_buffer = text_buffer
-            else:
-                break
-
-        # Process any decoded lines from the device
-        while not self.read_queue.empty():
-            try:
-                text_line = self.read_queue.get_nowait()
-            except Empty:
-                pass
-
-            heartbeat_strings = [COMMAND_HEARTBEAT, "Connection Okay"]
-            if not any(x in text_line for x in heartbeat_strings):
-                logging.debug("%0.3f P2 -> : %s" % (eventtime, text_line))
-
-            # Received a heartbeat from the device
-            if text_line == COMMAND_HEARTBEAT:
-                self.heartbeat = eventtime
-
-            elif text_line[0] == "O":
-                self.p2cmd(text_line)
-
-        return eventtime + SERIAL_TIMER
-
-    def _run_Heartbeat(self, eventtime):
-        self.write_queue.put(COMMAND_HEARTBEAT)
-        eventtime = self.reactor.pause(eventtime + 5)
-        if self.heartbeat and self.heartbeat < (
-            eventtime - HEARTBEAT_TIMEOUT):
-            logging.error(
-                "P2 has not responded to heartbeat")
-            if not self.is_printing or self.is_setup_complete:
-                self.cmd_Disconnect()
-                return self.reactor.NEVER
-        return eventtime + HEARTBEAT_SEND
-
-    def _run_Write(self, eventtime):
-        while not self.write_queue.empty():
-            try:
-                text_line = self.write_queue.get_nowait()
-            except Empty:
-                continue
-
-            if text_line:
-                self.omega_last_command = text_line
-                l = text_line.strip()
-                if COMMAND_HEARTBEAT not in l:
-                    logging.debug(
-                        "%s -> P2 : %s" %
-                        (self.reactor.monotonic(), l))
-                terminated_line = "%s\n" % (l)
-                try:
-                    self.serial.write(terminated_line.encode())
-                except SerialException:
-                    logging.error("Unable to communicate with the Palette 2")
-                    self.signal_disconnect = True
-                    return self.reactor.NEVER
-                return eventtime + SERIAL_TIMER
-        return eventtime + SERIAL_TIMER
-
-    def _run_Smart_Load(self, eventtime):
-        if not self.is_splicing and self.remaining_load_length < 0:
-            # Make sure toolhead class isn't busy
-            toolhead = self.printer.lookup_object("toolhead")
-            print_time, est_print_time, lookahead_empty = toolhead.check_busy(
-                eventtime)
-            idle_time = est_print_time - print_time
-            if not lookahead_empty or idle_time < 0.5:
-                return eventtime + \
-                       max(0., min(1., print_time - est_print_time))
-
-            extrude = abs(self.remaining_load_length)
-            extrude = min(50, extrude / 2)
-            if extrude <= 10:
-                extrude = 1
-            logging.info("Smart loading %dmm filament with %dmm remaining" % (
-                extrude, abs(self.remaining_load_length)))
-
-            self.gcode.run_script("G92 E0")
-            self.gcode.run_script("G1 E%d F%d" % (
-                extrude, self.auto_load_speed * 60))
-            return self.reactor.NOW
-        return eventtime + AUTOLOAD_TIMER
-
-    def get_status(self, eventtime=None):
-        status = {
-            "ping": None,
-            "remaining_load_length": self.remaining_load_length,
-            "is_splicing": self.is_splicing
-        }
-        if self.omega_pings:
-            status["ping"] = self.omega_pings[-1]
-        return status
-
-
-def load_config(config):
-    return Palette2(config)
deleted file mode 100644
--- a/klippy/extras/pca9533.py
+++ /dev/null
@@ -1,37 +0,0 @@
-# Support for the PCA9533 LED driver ic
-#
-# Copyright (C) 2021  Marc-Andre Denis <marcadenis@msn.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import logging
-from . import bus
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-PCA9533_PWM0=0b010
-PCA9533_PWM1=0b100
-PCA9533_PLS0=0b101
-
-class PCA9533:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.i2c = bus.MCU_I2C_from_config(config, default_addr=98)
-        pled = self.printer.load_object(config, "led")
-        self.led_helper = pled.setup_helper(config, self.update_leds, 1)
-        self.i2c.i2c_write([PCA9533_PWM0, 85])
-        self.i2c.i2c_write([PCA9533_PWM1, 170])
-        self.update_leds(self.led_helper.get_status()['color_data'], None)
-    def update_leds(self, led_state, print_time):
-        rmap = [0, 2, 3, 1, 1]
-        red, green, blue, white = [rmap[int(v * 4.)] for v in led_state[0]]
-        ls0 = (white<<6) | (blue<<4) | (green<<2) | red
-        minclock = 0
-        if print_time is not None:
-            minclock = self.i2c.get_mcu().print_time_to_clock(print_time)
-        self.i2c.i2c_write([PCA9533_PLS0, ls0], minclock=minclock,
-                           reqclock=BACKGROUND_PRIORITY_CLOCK)
-    def get_status(self, eventtime):
-        return self.led_helper.get_status(eventtime)
-
-def load_config_prefix(config):
-    return PCA9533(config)
deleted file mode 100644
--- a/klippy/extras/pca9632.py
+++ /dev/null
@@ -1,74 +0,0 @@
-# Support for the PCA9632 LED driver ic
-#
-# Copyright (C) 2022  Ricardo Alcantara <ricardo@vulcanolabs.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-from . import bus, mcp4018
-
-BACKGROUND_PRIORITY_CLOCK = 0x7fffffff00000000
-
-# Register addresses
-PCA9632_MODE1 = 0x00
-PCA9632_MODE2 = 0x01
-PCA9632_PWM0 = 0x02
-PCA9632_PWM1 = 0x03
-PCA9632_PWM2 = 0x04
-PCA9632_PWM3 = 0x05
-PCA9632_LEDOUT = 0x08
-
-LED_PWM = 0x02
-PCA9632_LED0 = 0x00
-PCA9632_LED1 = 0x02
-PCA9632_LED2 = 0x04
-PCA9632_LED3 = 0x06
-
-class PCA9632:
-    def __init__(self, config):
-        self.printer = printer = config.get_printer()
-        if config.get("scl_pin", None) is not None:
-            self.i2c = mcp4018.SoftwareI2C(config, 98)
-        else:
-            self.i2c = bus.MCU_I2C_from_config(config, default_addr=98)
-        color_order = config.get("color_order", "RGBW")
-        if sorted(color_order) != sorted("RGBW"):
-            raise config.error("Invalid color_order '%s'" % (color_order,))
-        self.color_map = ["RGBW".index(c) for c in color_order]
-        self.prev_regs = {}
-        pled = printer.load_object(config, "led")
-        self.led_helper = pled.setup_helper(config, self.update_leds, 1)
-        printer.register_event_handler("klippy:connect", self.handle_connect)
-    def reg_write(self, reg, val, minclock=0):
-        if self.prev_regs.get(reg) == val:
-            return
-        self.prev_regs[reg] = val
-        self.i2c.i2c_write([reg, val], minclock=minclock,
-                           reqclock=BACKGROUND_PRIORITY_CLOCK)
-    def handle_connect(self):
-        #Configure MODE1
-        self.reg_write(PCA9632_MODE1, 0x00)
-        #Configure MODE2 (DIMMING, INVERT, CHANGE ON STOP,TOTEM)
-        self.reg_write(PCA9632_MODE2, 0x15)
-
-        self.update_leds(self.led_helper.get_status()['color_data'], None)
-    def update_leds(self, led_state, print_time):
-        minclock = 0
-        if print_time is not None:
-            minclock = self.i2c.get_mcu().print_time_to_clock(print_time)
-
-        color = [int(v * 255. + .5) for v in led_state[0]]
-        led0, led1, led2, led3 = [color[idx] for idx in self.color_map]
-        self.reg_write(PCA9632_PWM0, led0, minclock=minclock)
-        self.reg_write(PCA9632_PWM1, led1, minclock=minclock)
-        self.reg_write(PCA9632_PWM2, led2, minclock=minclock)
-        self.reg_write(PCA9632_PWM3, led3, minclock=minclock)
-
-        LEDOUT = (LED_PWM << PCA9632_LED0 if led0 else 0)
-        LEDOUT |= (LED_PWM << PCA9632_LED1 if led1 else 0)
-        LEDOUT |= (LED_PWM << PCA9632_LED2 if led2 else 0)
-        LEDOUT |= (LED_PWM << PCA9632_LED3 if led3 else 0)
-        self.reg_write(PCA9632_LEDOUT, LEDOUT, minclock=minclock)
-    def get_status(self, eventtime):
-        return self.led_helper.get_status(eventtime)
-
-def load_config_prefix(config):
-    return PCA9632(config)
deleted file mode 100644
--- a/klippy/extras/safe_z_home.py
+++ /dev/null
@@ -1,91 +0,0 @@
-# Perform Z Homing at specific XY coordinates.
-#
-# Copyright (C) 2019 Florian Heilmann <Florian.Heilmann@gmx.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class SafeZHoming:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        x_pos, y_pos = config.getfloatlist("home_xy_position", count=2)
-        self.home_x_pos, self.home_y_pos = x_pos, y_pos
-        self.z_hop = config.getfloat("z_hop", default=0.0)
-        self.z_hop_speed = config.getfloat('z_hop_speed', 15., above=0.)
-        zconfig = config.getsection('stepper_z')
-        self.max_z = zconfig.getfloat('position_max', note_valid=False)
-        self.speed = config.getfloat('speed', 50.0, above=0.)
-        self.move_to_previous = config.getboolean('move_to_previous', False)
-        self.printer.load_object(config, 'homing')
-        self.gcode = self.printer.lookup_object('gcode')
-        self.prev_G28 = self.gcode.register_command("G28", None)
-        self.gcode.register_command("G28", self.cmd_G28)
-
-        if config.has_section("homing_override"):
-            raise config.error("homing_override and safe_z_homing cannot"
-                               +" be used simultaneously")
-
-    def cmd_G28(self, gcmd):
-        toolhead = self.printer.lookup_object('toolhead')
-
-        # Perform Z Hop if necessary
-        if self.z_hop != 0.0:
-            # Check if Z axis is homed and its last known position
-            curtime = self.printer.get_reactor().monotonic()
-            kin_status = toolhead.get_kinematics().get_status(curtime)
-            pos = toolhead.get_position()
-
-            if 'z' not in kin_status['homed_axes']:
-                # Always perform the z_hop if the Z axis is not homed
-                pos[2] = 0
-                toolhead.set_position(pos, homing_axes=[2])
-                toolhead.manual_move([None, None, self.z_hop],
-                                     self.z_hop_speed)
-                if hasattr(toolhead.get_kinematics(), "note_z_not_homed"):
-                    toolhead.get_kinematics().note_z_not_homed()
-            elif pos[2] < self.z_hop:
-                # If the Z axis is homed, and below z_hop, lift it to z_hop
-                toolhead.manual_move([None, None, self.z_hop],
-                                     self.z_hop_speed)
-
-        # Determine which axes we need to home
-        need_x, need_y, need_z = [gcmd.get(axis, None) is not None
-                                  for axis in "XYZ"]
-        if not need_x and not need_y and not need_z:
-            need_x = need_y = need_z = True
-
-        # Home XY axes if necessary
-        new_params = {}
-        if need_x:
-            new_params['X'] = '0'
-        if need_y:
-            new_params['Y'] = '0'
-        if new_params:
-            g28_gcmd = self.gcode.create_gcode_command("G28", "G28", new_params)
-            self.prev_G28(g28_gcmd)
-
-        # Home Z axis if necessary
-        if need_z:
-            # Throw an error if X or Y are not homed
-            curtime = self.printer.get_reactor().monotonic()
-            kin_status = toolhead.get_kinematics().get_status(curtime)
-            if ('x' not in kin_status['homed_axes'] or
-                'y' not in kin_status['homed_axes']):
-                raise gcmd.error("Must home X and Y axes first")
-            # Move to safe XY homing position
-            prevpos = toolhead.get_position()
-            toolhead.manual_move([self.home_x_pos, self.home_y_pos], self.speed)
-            # Home Z
-            g28_gcmd = self.gcode.create_gcode_command("G28", "G28", {'Z': '0'})
-            self.prev_G28(g28_gcmd)
-            # Perform Z Hop again for pressure-based probes
-            if self.z_hop:
-                pos = toolhead.get_position()
-                if pos[2] < self.z_hop:
-                    toolhead.manual_move([None, None, self.z_hop],
-                                         self.z_hop_speed)
-            # Move XY back to previous positions
-            if self.move_to_previous:
-                toolhead.manual_move(prevpos[:2], self.speed)
-
-def load_config(config):
-    return SafeZHoming(config)
deleted file mode 100644
--- a/klippy/extras/samd_sercom.py
+++ /dev/null
@@ -1,41 +0,0 @@
-# SAMD Sercom configuration
-#
-# Copyright (C) 2019  Florian Heilmann <Florian.Heilmann@gmx.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-class SamdSERCOM:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-
-        self.sercom = config.get("sercom")
-        self.tx_pin = config.get("tx_pin")
-        self.rx_pin = config.get("rx_pin", None)
-        self.clk_pin = config.get("clk_pin")
-
-        ppins = self.printer.lookup_object("pins")
-        tx_pin_params = ppins.lookup_pin(self.tx_pin)
-        self.mcu = tx_pin_params['chip']
-        self.mcu.add_config_cmd(
-            "set_sercom_pin bus=%s sercom_pin_type=tx pin=%s" % (
-                self.sercom, tx_pin_params['pin']))
-
-        clk_pin_params = ppins.lookup_pin(self.clk_pin)
-        if self.mcu is not clk_pin_params['chip']:
-            raise ppins.error("%s: SERCOM pins must be on same mcu" % (
-                config.get_name(),))
-        self.mcu.add_config_cmd(
-            "set_sercom_pin bus=%s sercom_pin_type=clk pin=%s" % (
-                self.sercom, clk_pin_params['pin']))
-
-        if self.rx_pin:
-            rx_pin_params = ppins.lookup_pin(self.rx_pin)
-            if self.mcu is not rx_pin_params['chip']:
-                raise ppins.error("%s: SERCOM pins must be on same mcu" % (
-                    config.get_name(),))
-            self.mcu.add_config_cmd(
-                "set_sercom_pin bus=%s sercom_pin_type=rx pin=%s" % (
-                    self.sercom, rx_pin_params['pin']))
-
-def load_config_prefix(config):
-    return SamdSERCOM(config)
deleted file mode 100644
--- a/klippy/extras/screws_tilt_adjust.py
+++ /dev/null
@@ -1,127 +0,0 @@
-# Helper script to adjust bed screws tilt using Z probe
-#
-# Copyright (C) 2019  Rui Caridade <rui.mcbc@gmail.com>
-# Copyright (C) 2021  Matthew Lloyd <github@matthewlloyd.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math
-from . import probe
-
-class ScrewsTiltAdjust:
-    def __init__(self, config):
-        self.config = config
-        self.printer = config.get_printer()
-        self.screws = []
-        self.results = []
-        self.max_diff = None
-        self.max_diff_error = False
-        # Read config
-        for i in range(99):
-            prefix = "screw%d" % (i + 1,)
-            if config.get(prefix, None) is None:
-                break
-            screw_coord = config.getfloatlist(prefix, count=2)
-            screw_name = "screw at %.3f,%.3f" % screw_coord
-            screw_name = config.get(prefix + "_name", screw_name)
-            self.screws.append((screw_coord, screw_name))
-        if len(self.screws) < 3:
-            raise config.error("screws_tilt_adjust: Must have "
-                               "at least three screws")
-        self.threads = {'CW-M3': 0, 'CCW-M3': 1, 'CW-M4': 2, 'CCW-M4': 3,
-                        'CW-M5': 4, 'CCW-M5': 5}
-        self.thread = config.getchoice('screw_thread', self.threads,
-                                       default='CW-M3')
-        # Initialize ProbePointsHelper
-        points = [coord for coord, name in self.screws]
-        self.probe_helper = probe.ProbePointsHelper(self.config,
-                                                    self.probe_finalize,
-                                                    default_points=points)
-        self.probe_helper.minimum_points(3)
-        # Register command
-        self.gcode = self.printer.lookup_object('gcode')
-        self.gcode.register_command("SCREWS_TILT_CALCULATE",
-                                    self.cmd_SCREWS_TILT_CALCULATE,
-                                    desc=self.cmd_SCREWS_TILT_CALCULATE_help)
-    cmd_SCREWS_TILT_CALCULATE_help = "Tool to help adjust bed leveling " \
-                                     "screws by calculating the number " \
-                                     "of turns to level it."
-
-    def cmd_SCREWS_TILT_CALCULATE(self, gcmd):
-        self.max_diff = gcmd.get_float("MAX_DEVIATION", None)
-        # Option to force all turns to be in the given direction (CW or CCW)
-        direction = gcmd.get("DIRECTION", default=None)
-        if direction is not None:
-            direction = direction.upper()
-            if direction not in ('CW', 'CCW'):
-                raise gcmd.error(
-                    "Error on '%s': DIRECTION must be either CW or CCW" % (
-                        gcmd.get_commandline(),))
-        self.direction = direction
-        self.probe_helper.start_probe(gcmd)
-
-    def get_status(self, eventtime):
-        return {'error': self.max_diff_error,
-            'results': self.results}
-
-    def probe_finalize(self, offsets, positions):
-        self.results = []
-        self.max_diff_error = False
-        # Factors used for CW-M3, CCW-M3, CW-M4, CCW-M4, CW-M5 and CCW-M5
-        threads_factor = {0: 0.5, 1: 0.5, 2: 0.7, 3: 0.7, 4: 0.8, 5: 0.8}
-        is_clockwise_thread = (self.thread & 1) == 0
-        screw_diff = []
-        # Process the read Z values
-        if self.direction is not None:
-            # Lowest or highest screw is the base position used for comparison
-            use_max = ((is_clockwise_thread and self.direction == 'CW')
-                    or (not is_clockwise_thread and self.direction == 'CCW'))
-            min_or_max = max if use_max else min
-            i_base, z_base = min_or_max(
-                enumerate([pos[2] for pos in positions]), key=lambda v: v[1])
-        else:
-            # First screw is the base position used for comparison
-            i_base, z_base = 0, positions[0][2]
-        # Provide the user some information on how to read the results
-        self.gcode.respond_info("01:20 means 1 full turn and 20 minutes, "
-                                "CW=clockwise, CCW=counter-clockwise")
-        for i, screw in enumerate(self.screws):
-            z = positions[i][2]
-            coord, name = screw
-            if i == i_base:
-                # Show the results
-                self.gcode.respond_info(
-                    "%s : x=%.1f, y=%.1f, z=%.5f" %
-                    (name + ' (base)', coord[0], coord[1], z))
-                self.results.append({'name': name + ' (base)', 'x': coord[0],
-                    'y': coord[1], 'z': z, 'sign': 'CW', 'adjust':'00:00'})
-            else:
-                # Calculate how knob must be adjusted for other positions
-                diff = z_base - z
-                screw_diff.append(abs(diff))
-                if abs(diff) < 0.001:
-                    adjust = 0
-                else:
-                    adjust = diff / threads_factor.get(self.thread, 0.5)
-                if is_clockwise_thread:
-                    sign = "CW" if adjust >= 0 else "CCW"
-                else:
-                    sign = "CCW" if adjust >= 0 else "CW"
-                adjust = abs(adjust)
-                full_turns = math.trunc(adjust)
-                decimal_part = adjust - full_turns
-                minutes = round(decimal_part * 60, 0)
-                # Show the results
-                self.gcode.respond_info(
-                    "%s : x=%.1f, y=%.1f, z=%.5f : adjust %s %02d:%02d" %
-                    (name, coord[0], coord[1], z, sign, full_turns, minutes))
-                self.results.append({'name': name, 'x': coord[0], 'y': coord[1],
-                    'z': z, 'sign': sign,
-                    'adjust':"%02d:%02d" % (full_turns, minutes)})
-        if self.max_diff and any((d > self.max_diff) for d in screw_diff):
-            self.max_diff_error = True
-            raise self.gcode.error(
-                "bed level exceeds configured limits ({}mm)! " \
-                "Adjust screws and restart print.".format(self.max_diff))
-
-def load_config(config):
-    return ScrewsTiltAdjust(config)
deleted file mode 100644
--- a/klippy/extras/servo.py
+++ /dev/null
@@ -1,70 +0,0 @@
-# Support for servos
-#
-# Copyright (C) 2017-2020  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-SERVO_SIGNAL_PERIOD = 0.020
-PIN_MIN_TIME = 0.100
-
-class PrinterServo:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.min_width = config.getfloat('minimum_pulse_width', .001,
-                                         above=0., below=SERVO_SIGNAL_PERIOD)
-        self.max_width = config.getfloat('maximum_pulse_width', .002,
-                                         above=self.min_width,
-                                         below=SERVO_SIGNAL_PERIOD)
-        self.max_angle = config.getfloat('maximum_servo_angle', 180.)
-        self.angle_to_width = (self.max_width - self.min_width) / self.max_angle
-        self.width_to_value = 1. / SERVO_SIGNAL_PERIOD
-        self.last_value = self.last_value_time = 0.
-        initial_pwm = 0.
-        iangle = config.getfloat('initial_angle', None, minval=0., maxval=360.)
-        if iangle is not None:
-            initial_pwm = self._get_pwm_from_angle(iangle)
-        else:
-            iwidth = config.getfloat('initial_pulse_width', 0.,
-                                     minval=0., maxval=self.max_width)
-            initial_pwm = self._get_pwm_from_pulse_width(iwidth)
-        # Setup mcu_servo pin
-        ppins = self.printer.lookup_object('pins')
-        self.mcu_servo = ppins.setup_pin('pwm', config.get('pin'))
-        self.mcu_servo.setup_max_duration(0.)
-        self.mcu_servo.setup_cycle_time(SERVO_SIGNAL_PERIOD)
-        self.mcu_servo.setup_start_value(initial_pwm, 0.)
-        # Register commands
-        servo_name = config.get_name().split()[1]
-        gcode = self.printer.lookup_object('gcode')
-        gcode.register_mux_command("SET_SERVO", "SERVO", servo_name,
-                                   self.cmd_SET_SERVO,
-                                   desc=self.cmd_SET_SERVO_help)
-    def get_status(self, eventtime):
-        return {'value': self.last_value}
-    def _set_pwm(self, print_time, value):
-        if value == self.last_value:
-            return
-        print_time = max(print_time, self.last_value_time + PIN_MIN_TIME)
-        self.mcu_servo.set_pwm(print_time, value)
-        self.last_value = value
-        self.last_value_time = print_time
-    def _get_pwm_from_angle(self, angle):
-        angle = max(0., min(self.max_angle, angle))
-        width = self.min_width + angle * self.angle_to_width
-        return width * self.width_to_value
-    def _get_pwm_from_pulse_width(self, width):
-        if width:
-            width = max(self.min_width, min(self.max_width, width))
-        return width * self.width_to_value
-    cmd_SET_SERVO_help = "Set servo angle"
-    def cmd_SET_SERVO(self, gcmd):
-        print_time = self.printer.lookup_object('toolhead').get_last_move_time()
-        width = gcmd.get_float('WIDTH', None)
-        if width is not None:
-            self._set_pwm(print_time, self._get_pwm_from_pulse_width(width))
-        else:
-            angle = gcmd.get_float('ANGLE')
-            self._set_pwm(print_time, self._get_pwm_from_angle(angle))
-
-def load_config_prefix(config):
-    return PrinterServo(config)
deleted file mode 100644
--- a/klippy/extras/spi_temperature.py
+++ /dev/null
@@ -1,355 +0,0 @@
-# Support for common SPI based thermocouple and RTD temperature sensors
-#
-# Copyright (C) 2018  Petri Honkala <cruwaller@gmail.com>
-# Copyright (C) 2018  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging
-from . import bus
-
-
-######################################################################
-# SensorBase
-######################################################################
-
-REPORT_TIME = 0.300
-MAX_INVALID_COUNT = 3
-
-class SensorBase:
-    def __init__(self, config, chip_type, config_cmd=None, spi_mode=1):
-        self.printer = config.get_printer()
-        self.chip_type = chip_type
-        self._callback = None
-        self.min_sample_value = self.max_sample_value = 0
-        self._report_clock = 0
-        self.spi = bus.MCU_SPI_from_config(
-            config, spi_mode, pin_option="sensor_pin", default_speed=4000000)
-        if config_cmd is not None:
-            self.spi.spi_send(config_cmd)
-        self.mcu = mcu = self.spi.get_mcu()
-        # Reader chip configuration
-        self.oid = oid = mcu.create_oid()
-        mcu.register_response(self._handle_spi_response,
-                              "thermocouple_result", oid)
-        mcu.register_config_callback(self._build_config)
-    def setup_minmax(self, min_temp, max_temp):
-        adc_range = [self.calc_adc(min_temp), self.calc_adc(max_temp)]
-        self.min_sample_value = min(adc_range)
-        self.max_sample_value = max(adc_range)
-    def setup_callback(self, cb):
-        self._callback = cb
-    def get_report_time_delta(self):
-        return REPORT_TIME
-    def _build_config(self):
-        self.mcu.add_config_cmd(
-            "config_thermocouple oid=%u spi_oid=%u thermocouple_type=%s" % (
-                self.oid, self.spi.get_oid(), self.chip_type))
-        clock = self.mcu.get_query_slot(self.oid)
-        self._report_clock = self.mcu.seconds_to_clock(REPORT_TIME)
-        self.mcu.add_config_cmd(
-            "query_thermocouple oid=%u clock=%u rest_ticks=%u"
-            " min_value=%u max_value=%u max_invalid_count=%u" % (
-                self.oid, clock, self._report_clock,
-                self.min_sample_value, self.max_sample_value,
-                MAX_INVALID_COUNT), is_init=True)
-    def _handle_spi_response(self, params):
-        if params['fault']:
-            self.handle_fault(params['value'], params['fault'])
-            return
-        temp = self.calc_temp(params['value'])
-        next_clock      = self.mcu.clock32_to_clock64(params['next_clock'])
-        last_read_clock = next_clock - self._report_clock
-        last_read_time  = self.mcu.clock_to_print_time(last_read_clock)
-        self._callback(last_read_time, temp)
-    def report_fault(self, msg):
-        logging.warn(msg)
-
-
-######################################################################
-# MAX31856 thermocouple
-######################################################################
-
-MAX31856_CR0_REG           = 0x00
-MAX31856_CR0_AUTOCONVERT   = 0x80
-MAX31856_CR0_1SHOT         = 0x40
-MAX31856_CR0_OCFAULT1      = 0x20
-MAX31856_CR0_OCFAULT0      = 0x10
-MAX31856_CR0_CJ            = 0x08
-MAX31856_CR0_FAULT         = 0x04
-MAX31856_CR0_FAULTCLR      = 0x02
-MAX31856_CR0_FILT50HZ      = 0x01
-MAX31856_CR0_FILT60HZ      = 0x00
-
-MAX31856_CR1_REG           = 0x01
-MAX31856_CR1_AVGSEL1       = 0x00
-MAX31856_CR1_AVGSEL2       = 0x10
-MAX31856_CR1_AVGSEL4       = 0x20
-MAX31856_CR1_AVGSEL8       = 0x30
-MAX31856_CR1_AVGSEL16      = 0x70
-
-MAX31856_MASK_REG                          = 0x02
-MAX31856_MASK_COLD_JUNCTION_HIGH_FAULT     = 0x20
-MAX31856_MASK_COLD_JUNCTION_LOW_FAULT      = 0x10
-MAX31856_MASK_THERMOCOUPLE_HIGH_FAULT      = 0x08
-MAX31856_MASK_THERMOCOUPLE_LOW_FAULT       = 0x04
-MAX31856_MASK_VOLTAGE_UNDER_OVER_FAULT     = 0x02
-MAX31856_MASK_THERMOCOUPLE_OPEN_FAULT      = 0x01
-
-MAX31856_CJHF_REG          = 0x03
-MAX31856_CJLF_REG          = 0x04
-MAX31856_LTHFTH_REG        = 0x05
-MAX31856_LTHFTL_REG        = 0x06
-MAX31856_LTLFTH_REG        = 0x07
-MAX31856_LTLFTL_REG        = 0x08
-MAX31856_CJTO_REG          = 0x09
-MAX31856_CJTH_REG          = 0x0A
-MAX31856_CJTL_REG          = 0x0B
-MAX31856_LTCBH_REG         = 0x0C
-MAX31856_LTCBM_REG         = 0x0D
-MAX31856_LTCBL_REG         = 0x0E
-
-MAX31856_SR_REG            = 0x0F
-MAX31856_FAULT_CJRANGE     = 0x80  # Cold Junction out of range
-MAX31856_FAULT_TCRANGE     = 0x40  # Thermocouple out of range
-MAX31856_FAULT_CJHIGH      = 0x20  # Cold Junction High
-MAX31856_FAULT_CJLOW       = 0x10  # Cold Junction Low
-MAX31856_FAULT_TCHIGH      = 0x08  # Thermocouple Low
-MAX31856_FAULT_TCLOW       = 0x04  # Thermocouple Low
-MAX31856_FAULT_OVUV        = 0x02  # Under Over Voltage
-MAX31856_FAULT_OPEN        = 0x01
-
-MAX31856_SCALE = 5
-MAX31856_MULT = 0.0078125
-
-class MAX31856(SensorBase):
-    def __init__(self, config):
-        SensorBase.__init__(self, config, "MAX31856",
-                            self.build_spi_init(config))
-    def handle_fault(self, adc, fault):
-        if fault & MAX31856_FAULT_CJRANGE:
-            self.report_fault("Max31856: Cold Junction Range Fault")
-        if fault & MAX31856_FAULT_TCRANGE:
-            self.report_fault("Max31856: Thermocouple Range Fault")
-        if fault & MAX31856_FAULT_CJHIGH:
-            self.report_fault("Max31856: Cold Junction High Fault")
-        if fault & MAX31856_FAULT_CJLOW:
-            self.report_fault("Max31856: Cold Junction Low Fault")
-        if fault & MAX31856_FAULT_TCHIGH:
-            self.report_fault("Max31856: Thermocouple High Fault")
-        if fault & MAX31856_FAULT_TCLOW:
-            self.report_fault("Max31856: Thermocouple Low Fault")
-        if fault & MAX31856_FAULT_OVUV:
-            self.report_fault("Max31856: Over/Under Voltage Fault")
-        if fault & MAX31856_FAULT_OPEN:
-            self.report_fault("Max31856: Thermocouple Open Fault")
-    def calc_temp(self, adc):
-        adc = adc >> MAX31856_SCALE
-        # Fix sign bit:
-        if adc & 0x40000:
-            adc = ((adc & 0x3FFFF) + 1) * -1
-        temp = MAX31856_MULT * adc
-        return temp
-    def calc_adc(self, temp):
-        adc = int( ( temp / MAX31856_MULT ) + 0.5 ) # convert to ADC value
-        adc = max(0, min(0x3FFFF, adc)) << MAX31856_SCALE
-        return adc
-    def build_spi_init(self, config):
-        cmds = []
-        value = MAX31856_CR0_AUTOCONVERT
-        if config.getboolean('tc_use_50Hz_filter', False):
-            value |= MAX31856_CR0_FILT50HZ
-        cmds.append(0x80 + MAX31856_CR0_REG)
-        cmds.append(value)
-
-        types = {
-            "B" : 0b0000,
-            "E" : 0b0001,
-            "J" : 0b0010,
-            "K" : 0b0011,
-            "N" : 0b0100,
-            "R" : 0b0101,
-            "S" : 0b0110,
-            "T" : 0b0111,
-        }
-        value = config.getchoice('tc_type', types, default="K")
-        averages = {
-            1  : MAX31856_CR1_AVGSEL1,
-            2  : MAX31856_CR1_AVGSEL2,
-            4  : MAX31856_CR1_AVGSEL4,
-            8  : MAX31856_CR1_AVGSEL8,
-            16 : MAX31856_CR1_AVGSEL16
-        }
-        value |= config.getchoice('tc_averaging_count', averages, 1)
-        cmds.append(value)
-
-        value = (MAX31856_MASK_VOLTAGE_UNDER_OVER_FAULT |
-                 MAX31856_MASK_THERMOCOUPLE_OPEN_FAULT)
-        cmds.append(value)
-        return cmds
-
-
-######################################################################
-# MAX31855 thermocouple
-######################################################################
-
-MAX31855_SCALE = 18
-MAX31855_MULT = 0.25
-
-class MAX31855(SensorBase):
-    def __init__(self, config):
-        SensorBase.__init__(self, config, "MAX31855", spi_mode=0)
-    def handle_fault(self, adc, fault):
-        if fault & 0x1:
-            self.report_fault("MAX31855 : Open Circuit")
-        if fault & 0x2:
-            self.report_fault("MAX31855 : Short to GND")
-        if fault & 0x4:
-            self.report_fault("MAX31855 : Short to Vcc")
-    def calc_temp(self, adc):
-        adc = adc >> MAX31855_SCALE
-        # Fix sign bit:
-        if adc & 0x2000:
-            adc = ((adc & 0x1FFF) + 1) * -1
-        temp = MAX31855_MULT * adc
-        return temp
-    def calc_adc(self, temp):
-        adc = int( ( temp / MAX31855_MULT ) + 0.5 ) # convert to ADC value
-        adc = max(0, min(0x1FFF, adc)) << MAX31855_SCALE
-        return adc
-
-
-######################################################################
-# MAX6675 thermocouple
-######################################################################
-
-MAX6675_SCALE = 3
-MAX6675_MULT = 0.25
-
-class MAX6675(SensorBase):
-    def __init__(self, config):
-        SensorBase.__init__(self, config, "MAX6675", spi_mode=0)
-    def handle_fault(self, adc, fault):
-        if fault & 0x02:
-            self.report_fault("Max6675 : Device ID error")
-        if fault & 0x04:
-            self.report_fault("Max6675 : Thermocouple Open Fault")
-    def calc_temp(self, adc):
-        adc = adc >> MAX6675_SCALE
-        # Fix sign bit:
-        if adc & 0x2000:
-            adc = ((adc & 0x1FFF) + 1) * -1
-        temp = MAX6675_MULT * adc
-        return temp
-    def calc_adc(self, temp):
-        adc = int( ( temp / MAX6675_MULT ) + 0.5 ) # convert to ADC value
-        adc = max(0, min(0x1FFF, adc)) << MAX6675_SCALE
-        return adc
-
-
-######################################################################
-# MAX31865 (RTD sensor)
-######################################################################
-
-MAX31865_CONFIG_REG            = 0x00
-MAX31865_RTDMSB_REG            = 0x01
-MAX31865_RTDLSB_REG            = 0x02
-MAX31865_HFAULTMSB_REG         = 0x03
-MAX31865_HFAULTLSB_REG         = 0x04
-MAX31865_LFAULTMSB_REG         = 0x05
-MAX31865_LFAULTLSB_REG         = 0x06
-MAX31865_FAULTSTAT_REG         = 0x07
-
-MAX31865_CONFIG_BIAS           = 0x80
-MAX31865_CONFIG_MODEAUTO       = 0x40
-MAX31865_CONFIG_1SHOT          = 0x20
-MAX31865_CONFIG_3WIRE          = 0x10
-MAX31865_CONFIG_FAULTCLEAR     = 0x02
-MAX31865_CONFIG_FILT50HZ       = 0x01
-
-MAX31865_FAULT_HIGHTHRESH      = 0x80
-MAX31865_FAULT_LOWTHRESH       = 0x40
-MAX31865_FAULT_REFINLOW        = 0x20
-MAX31865_FAULT_REFINHIGH       = 0x10
-MAX31865_FAULT_RTDINLOW        = 0x08
-MAX31865_FAULT_OVUV            = 0x04
-
-MAX31865_ADC_MAX = 1<<15
-
-# Callendar-Van Dusen constants for platinum resistance thermometers (RTD)
-CVD_A = 3.9083e-3
-CVD_B = -5.775e-7
-
-class MAX31865(SensorBase):
-    def __init__(self, config):
-        rtd_nominal_r = config.getfloat('rtd_nominal_r', 100., above=0.)
-        rtd_reference_r = config.getfloat('rtd_reference_r', 430., above=0.)
-        adc_to_resist = rtd_reference_r / float(MAX31865_ADC_MAX)
-        self.adc_to_resist_div_nominal = adc_to_resist / rtd_nominal_r
-        self.config_reg = self.build_spi_init(config)
-        SensorBase.__init__(self, config, "MAX31865", self.config_reg)
-    def handle_fault(self, adc, fault):
-        if fault & 0x80:
-            self.report_fault("Max31865 RTD input is disconnected")
-        if fault & 0x40:
-            self.report_fault("Max31865 RTD input is shorted")
-        if fault & 0x20:
-            self.report_fault(
-                "Max31865 VREF- is greater than 0.85 * VBIAS, FORCE- open")
-        if fault & 0x10:
-            self.report_fault(
-                "Max31865 VREF- is less than 0.85 * VBIAS, FORCE- open")
-        if fault & 0x08:
-            self.report_fault(
-                "Max31865 VRTD- is less than 0.85 * VBIAS, FORCE- open")
-        if fault & 0x04:
-            self.report_fault("Max31865 Overvoltage or undervoltage fault")
-        if not fault & 0xfc:
-            self.report_fault("Max31865 Unspecified error")
-        # Attempt to clear the fault
-        self.spi.spi_send(self.config_reg)
-    def calc_temp(self, adc):
-        adc = adc >> 1 # remove fault bit
-        R_div_nominal = adc * self.adc_to_resist_div_nominal
-        # Resistance (relative to rtd_nominal_r) is calculated using:
-        #  R_div_nominal = 1. + CVD_A * temp + CVD_B * temp**2
-        # Solve for temp using quadratic equation:
-        #  temp = (-b +- sqrt(b**2 - 4ac)) / 2a
-        discriminant = math.sqrt(CVD_A**2 - 4. * CVD_B * (1. - R_div_nominal))
-        temp = (-CVD_A + discriminant) / (2. * CVD_B)
-        return temp
-    def calc_adc(self, temp):
-        # Calculate relative resistance via Callendar-Van Dusen formula:
-        #  resistance = rtd_nominal_r * (1 + CVD_A * temp + CVD_B * temp**2)
-        R_div_nominal = 1. + CVD_A * temp + CVD_B * temp * temp
-        adc = int(R_div_nominal / self.adc_to_resist_div_nominal + 0.5)
-        adc = max(0, min(MAX31865_ADC_MAX, adc))
-        adc = adc << 1 # Add fault bit
-        return adc
-    def build_spi_init(self, config):
-        value = (MAX31865_CONFIG_BIAS |
-                 MAX31865_CONFIG_MODEAUTO |
-                 MAX31865_CONFIG_FAULTCLEAR)
-        if config.getboolean('rtd_use_50Hz_filter', False):
-            value |= MAX31865_CONFIG_FILT50HZ
-        if config.getint('rtd_num_of_wires', 2) == 3:
-            value |= MAX31865_CONFIG_3WIRE
-        cmd = 0x80 + MAX31865_CONFIG_REG
-        return [cmd, value]
-
-
-######################################################################
-# Sensor registration
-######################################################################
-
-Sensors = {
-    "MAX6675": MAX6675,
-    "MAX31855": MAX31855,
-    "MAX31856": MAX31856,
-    "MAX31865": MAX31865,
-}
-
-def load_config(config):
-    # Register sensors
-    pheaters = config.get_printer().load_object(config, "heaters")
-    for name, klass in Sensors.items():
-        pheaters.add_sensor_factory(name, klass)
deleted file mode 100644
--- a/klippy/extras/statistics.py
+++ /dev/null
@@ -1,74 +0,0 @@
-# Support for logging periodic statistics
-#
-# Copyright (C) 2018-2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import os, time, logging
-
-class PrinterSysStats:
-    def __init__(self, config):
-        printer = config.get_printer()
-        self.last_process_time = self.total_process_time = 0.
-        self.last_load_avg = 0.
-        self.last_mem_avail = 0
-        self.mem_file = None
-        try:
-            self.mem_file = open("/proc/meminfo", "r")
-        except:
-            pass
-        printer.register_event_handler("klippy:disconnect", self._disconnect)
-    def _disconnect(self):
-        if self.mem_file is not None:
-            self.mem_file.close()
-            self.mem_file = None
-    def stats(self, eventtime):
-        # Get core usage stats
-        ptime = time.process_time()
-        pdiff = ptime - self.last_process_time
-        self.last_process_time = ptime
-        if pdiff > 0.:
-            self.total_process_time += pdiff
-        self.last_load_avg = os.getloadavg()[0]
-        msg = "sysload=%.2f cputime=%.3f" % (self.last_load_avg,
-                                             self.total_process_time)
-        # Get available system memory
-        if self.mem_file is not None:
-            try:
-                self.mem_file.seek(0)
-                data = self.mem_file.read()
-                for line in data.split('\n'):
-                    if line.startswith("MemAvailable:"):
-                        self.last_mem_avail = int(line.split()[1])
-                        msg = "%s memavail=%d" % (msg, self.last_mem_avail)
-                        break
-            except:
-                pass
-        return (False, msg)
-    def get_status(self, eventtime):
-        return {'sysload': self.last_load_avg,
-                'cputime': self.total_process_time,
-                'memavail': self.last_mem_avail}
-
-class PrinterStats:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        reactor = self.printer.get_reactor()
-        self.stats_timer = reactor.register_timer(self.generate_stats)
-        self.stats_cb = []
-        self.printer.register_event_handler("klippy:ready", self.handle_ready)
-    def handle_ready(self):
-        self.stats_cb = [o.stats for n, o in self.printer.lookup_objects()
-                         if hasattr(o, 'stats')]
-        if self.printer.get_start_args().get('debugoutput') is None:
-            reactor = self.printer.get_reactor()
-            reactor.update_timer(self.stats_timer, reactor.NOW)
-    def generate_stats(self, eventtime):
-        stats = [cb(eventtime) for cb in self.stats_cb]
-        if max([s[0] for s in stats]):
-            logging.info("Stats %.1f: %s", eventtime,
-                         ' '.join([s[1] for s in stats]))
-        return eventtime + 1.
-
-def load_config(config):
-    config.get_printer().add_object('system_stats', PrinterSysStats(config))
-    return PrinterStats(config)
deleted file mode 100644
--- a/klippy/extras/sx1509.py
+++ /dev/null
@@ -1,201 +0,0 @@
-# SX1509 Extra
-#
-# Copyright (C) 2018  Florian Heilmann <Florian.Heilmann@gmx.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import pins
-from . import bus
-
-# Word registers
-REG_RESET = 0x7D
-REG_CLOCK = 0x1E
-REG_MISC = 0x1F
-REG_DIR = 0x0E
-REG_DATA = 0x10
-REG_PULLUP = 0x06
-REG_PULLDOWN = 0x08
-REG_INPUT_DISABLE = 0x00
-REG_ANALOG_DRIVER_ENABLE = 0x20
-
-
-# Byte registers
-REG_I_ON = [0x2A, 0x2D, 0x30, 0x33, 0x36, 0x3B, 0x40, 0x45,
-            0x4A, 0x4D, 0x50, 0x53, 0x56, 0x5B, 0x5F, 0x65]
-class SX1509(object):
-    def __init__(self, config):
-        self._printer = config.get_printer()
-        self._name = config.get_name().split()[1]
-        self._i2c = bus.MCU_I2C_from_config(config, default_speed=400000)
-        self._ppins = self._printer.lookup_object("pins")
-        self._ppins.register_chip("sx1509_" + self._name, self)
-        self._mcu = self._i2c.get_mcu()
-        self._mcu.register_config_callback(self._build_config)
-        self._oid = self._i2c.get_oid()
-        self._last_clock = 0
-        # Set up registers default values
-        self.reg_dict = {REG_DIR : 0xFFFF, REG_DATA : 0,
-                         REG_PULLUP : 0, REG_PULLDOWN : 0,
-                         REG_INPUT_DISABLE : 0, REG_ANALOG_DRIVER_ENABLE : 0}
-        self.reg_i_on_dict = {reg : 0 for reg in REG_I_ON}
-    def _build_config(self):
-        # Reset the chip
-        self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%02x" % (
-            self._oid, REG_RESET, 0x12))
-        self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%02x" % (
-            self._oid, REG_RESET, 0x34))
-        # Enable Oscillator
-        self._mcu.add_config_cmd("i2c_modify_bits oid=%d reg=%02x"
-                                 " clear_set_bits=%02x%02x" % (
-                                     self._oid, REG_CLOCK, 0, (1 << 6)))
-        # Setup Clock Divider
-        self._mcu.add_config_cmd("i2c_modify_bits oid=%d reg=%02x"
-                                 " clear_set_bits=%02x%02x" % (
-                                     self._oid, REG_MISC, 0, (1 << 4)))
-        # Transfer all regs with their initial cached state
-        for _reg, _data in self.reg_dict.items():
-            self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%04x" % (
-                self._oid, _reg, _data), is_init=True)
-    def setup_pin(self, pin_type, pin_params):
-        if pin_type == 'digital_out' and pin_params['pin'][0:4] == "PIN_":
-            return SX1509_digital_out(self, pin_params)
-        elif pin_type == 'pwm' and pin_params['pin'][0:4] == "PIN_":
-            return SX1509_pwm(self, pin_params)
-        raise pins.error("Wrong pin or incompatible type: %s with type %s! " % (
-            pin_params['pin'][0:4], pin_type))
-    def get_mcu(self):
-        return self._mcu
-    def get_oid(self):
-        return self._oid
-    def clear_bits_in_register(self, reg, bitmask):
-        if reg in self.reg_dict:
-            self.reg_dict[reg] &= ~(bitmask)
-        elif reg in self.reg_i_on_dict:
-            self.reg_i_on_dict[reg] &= ~(bitmask)
-    def set_bits_in_register(self, reg, bitmask):
-        if reg in self.reg_dict:
-            self.reg_dict[reg] |= bitmask
-        elif reg in self.reg_i_on_dict:
-            self.reg_i_on_dict[reg] |= bitmask
-    def set_register(self, reg, value):
-        if reg in self.reg_dict:
-            self.reg_dict[reg] = value
-        elif reg in self.reg_i_on_dict:
-            self.reg_i_on_dict[reg] = value
-    def send_register(self, reg, print_time):
-        data = [reg & 0xFF]
-        if reg in self.reg_dict:
-            # Word
-            data += [(self.reg_dict[reg] >> 8) & 0xFF,
-                     self.reg_dict[reg] & 0xFF]
-        elif reg in self.reg_i_on_dict:
-            # Byte
-            data += [self.reg_i_on_dict[reg] & 0xFF]
-        clock = self._mcu.print_time_to_clock(print_time)
-        self._i2c.i2c_write(data, minclock=self._last_clock, reqclock=clock)
-        self._last_clock = clock
-
-class SX1509_digital_out(object):
-    def __init__(self, sx1509, pin_params):
-        self._sx1509 = sx1509
-        self._mcu = sx1509.get_mcu()
-        self._sxpin = int(pin_params['pin'].split('_')[1])
-        self._bitmask = 1 << self._sxpin
-        self._pin = pin_params['pin']
-        self._invert = pin_params['invert']
-        self._mcu.register_config_callback(self._build_config)
-        self._start_value = self._shutdown_value = self._invert
-        self._is_static = False
-        self._max_duration = 2.
-        self._set_cmd = self._clear_cmd = None
-        # Set direction to output
-        self._sx1509.clear_bits_in_register(REG_DIR, self._bitmask)
-    def _build_config(self):
-        if self._max_duration:
-            raise pins.error("SX1509 pins are not suitable for heaters")
-    def get_mcu(self):
-        return self._mcu
-    def setup_max_duration(self, max_duration):
-        self._max_duration = max_duration
-    def setup_start_value(self, start_value, shutdown_value, is_static=False):
-        if is_static and start_value != shutdown_value:
-            raise pins.error("Static pin can not have shutdown value")
-        self._start_value = (not not start_value) ^ self._invert
-        self._shutdown_value = self._invert
-        self._is_static = is_static
-        # We need to set the start value here so the register is
-        # updated before the SX1509 class writes it.
-        if self._start_value:
-            self._sx1509.set_bits_in_register(REG_DATA, self._bitmask)
-        else:
-            self._sx1509.clear_bits_in_register(REG_DATA, self._bitmask)
-    def set_digital(self, print_time, value):
-        if int(value) ^ self._invert:
-            self._sx1509.set_bits_in_register(REG_DATA, self._bitmask)
-        else:
-            self._sx1509.clear_bits_in_register(REG_DATA, self._bitmask)
-        self._sx1509.send_register(REG_DATA, print_time)
-    def set_pwm(self, print_time, value, cycle_time=None):
-        self.set_digital(print_time, value >= 0.5)
-
-class SX1509_pwm(object):
-    def __init__(self, sx1509, pin_params):
-        self._sx1509 = sx1509
-        self._mcu = sx1509.get_mcu()
-        self._sxpin = int(pin_params['pin'].split('_')[1])
-        self._bitmask = 1 << self._sxpin
-        self._i_on_reg = REG_I_ON[self._sxpin]
-        self._pin = pin_params['pin']
-        self._invert = pin_params['invert']
-        self._mcu.register_config_callback(self._build_config)
-        self._start_value = self._shutdown_value = float(self._invert)
-        self._is_static = False
-        self._max_duration = 2.
-        self._hardware_pwm = False
-        self._pwm_max = 0.
-        self._set_cmd = None
-        self._cycle_time = 0.
-        # Set required registers
-        self._sx1509.set_bits_in_register(REG_INPUT_DISABLE, self._bitmask)
-        self._sx1509.clear_bits_in_register(REG_PULLUP, self._bitmask)
-        self._sx1509.clear_bits_in_register(REG_DIR, self._bitmask)
-        self._sx1509.set_bits_in_register(REG_ANALOG_DRIVER_ENABLE,
-                                          self._bitmask)
-        self._sx1509.clear_bits_in_register(REG_DATA, self._bitmask)
-    def _build_config(self):
-        if not self._hardware_pwm:
-            raise pins.error("SX1509_pwm must have hardware_pwm enabled")
-        if self._max_duration:
-            raise pins.error("SX1509 pins are not suitable for heaters")
-        # Send initial value
-        self._sx1509.set_register(self._i_on_reg,
-                                  ~int(255 * self._start_value) & 0xFF)
-        self._mcu.add_config_cmd("i2c_write oid=%d data=%02x%02x" % (
-            self._sx1509.get_oid(),
-            self._i_on_reg,
-            self._sx1509.reg_i_on_dict[self._i_on_reg]
-            ),
-                                 is_init=True)
-    def get_mcu(self):
-        return self._mcu
-    def setup_max_duration(self, max_duration):
-        self._max_duration = max_duration
-    def setup_cycle_time(self, cycle_time, hardware_pwm=False):
-        self._cycle_time = cycle_time
-        self._hardware_pwm = hardware_pwm
-    def setup_start_value(self, start_value, shutdown_value, is_static=False):
-        if is_static and start_value != shutdown_value:
-            raise pins.error("Static pin can not have shutdown value")
-        if self._invert:
-            start_value = 1. - start_value
-            shutdown_value = 1. - shutdown_value
-        self._start_value = max(0., min(1., start_value))
-        self._shutdown_value = max(0., min(1., shutdown_value))
-        self._is_static = is_static
-    def set_pwm(self, print_time, value, cycle_time=None):
-        self._sx1509.set_register(self._i_on_reg, ~int(255 * value)
-                                  if not self._invert
-                                  else int(255 * value) & 0xFF)
-        self._sx1509.send_register(self._i_on_reg, print_time)
-
-def load_config_prefix(config):
-    return SX1509(config)
deleted file mode 100644
--- a/klippy/extras/temperature_host.py
+++ /dev/null
@@ -1,80 +0,0 @@
-# Support for Raspberry Pi temperature sensor
-#
-# Copyright (C) 2020  Al Crate <al3ph@users.noreply.github.com>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-
-import logging
-
-HOST_REPORT_TIME = 1.0
-RPI_PROC_TEMP_FILE = "/sys/class/thermal/thermal_zone0/temp"
-
-class Temperature_HOST:
-    def __init__(self, config):
-        self.printer = config.get_printer()
-        self.reactor = self.printer.get_reactor()
-        self.name = config.get_name().split()[-1]
-        self.path = config.get("sensor_path", RPI_PROC_TEMP_FILE)
-
-        self.temp = self.min_temp = self.max_temp = 0.0
-
-        self.printer.add_object("temperature_host " + self.name, self)
-        if self.printer.get_start_args().get('debugoutput') is not None:
-            return
-        self.sample_timer = self.reactor.register_timer(
-            self._sample_pi_temperature)
-        try:
-            self.file_handle = open(self.path, "r")
-        except:
-            raise config.error("Unable to open temperature file '%s'"
-                               % (self.path,))
-
-        self.printer.register_event_handler("klippy:connect",
-                                            self.handle_connect)
-
-    def handle_connect(self):
-        self.reactor.update_timer(self.sample_timer, self.reactor.NOW)
-
-    def setup_minmax(self, min_temp, max_temp):
-        self.min_temp = min_temp
-        self.max_temp = max_temp
-
-    def setup_callback(self, cb):
-        self._callback = cb
-
-    def get_report_time_delta(self):
-        return HOST_REPORT_TIME
-
-    def _sample_pi_temperature(self, eventtime):
-        try:
-            self.file_handle.seek(0)
-            self.temp = float(self.file_handle.read())/1000.0
-        except Exception:
-            logging.exception("temperature_host: Error reading data")
-            self.temp = 0.0
-            return self.reactor.NEVER
-
-        if self.temp < self.min_temp:
-            self.printer.invoke_shutdown(
-                "HOST temperature %0.1f below minimum temperature of %0.1f."
-                % (self.temp, self.min_temp,))
-        if self.temp > self.max_temp:
-            self.printer.invoke_shutdown(
-                "HOST temperature %0.1f above maximum temperature of %0.1f."
-                % (self.temp, self.max_temp,))
-
-        mcu = self.printer.lookup_object('mcu')
-        measured_time = self.reactor.monotonic()
-        self._callback(mcu.estimated_print_time(measured_time), self.temp)
-        return measured_time + HOST_REPORT_TIME
-
-    def get_status(self, eventtime):
-        return {
-            'temperature': round(self.temp, 2),
-        }
-
-
-def load_config(config):
-    # Register sensor
-    pheaters = config.get_printer().load_object(config, "heaters")
-    pheaters.add_sensor_factory("temperature_host", Temperature_HOST)
deleted file mode 100644
--- a/klippy/extras/tmc2660.py
+++ /dev/null
@@ -1,274 +0,0 @@
-# TMC2660 configuration
-#
-# Copyright (C) 2018-2019  Florian Heilmann <Florian.Heilmann@gmx.net>
-# Copyright (C) 2019-2021  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging
-from . import bus, tmc, tmc2130
-
-Registers = {
-    "DRVCONF": 0xE, "SGCSCONF": 0xC, "SMARTEN": 0xA,
-    "CHOPCONF": 0x8, "DRVCTRL": 0x0
-}
-
-ReadRegisters = [ "READRSP@RDSEL0", "READRSP@RDSEL1", "READRSP@RDSEL2" ]
-
-Fields = {}
-
-Fields["DRVCTRL"] = {
-    "mres": 0x0f,
-    "dedge": 0x01 << 8,
-    "intpol": 0x01 << 9,
-}
-
-Fields["CHOPCONF"] = {
-    "toff": 0x0f,
-    "hstrt": 0x7 << 4,
-    "hend": 0x0f << 7,
-    "hdec": 0x03 << 11,
-    "rndtf": 0x01 << 13,
-    "chm": 0x01 << 14,
-    "tbl": 0x03 << 15
-}
-
-Fields["SMARTEN"] = {
-    "semin" : 0x0f,
-    "seup": 0x03 << 5,
-    "semax": 0x0f << 8,
-    "sedn": 0x03 << 13,
-    "seimin": 0x01 << 15
-}
-
-Fields["SGCSCONF"] = {
-    "cs": 0x1f,
-    "sgt": 0x7F << 8,
-    "sfilt": 0x01 << 16
-}
-
-Fields["DRVCONF"] = {
-    "rdsel": 0x03 << 4,
-    "vsense": 0x01 << 6,
-    "sdoff": 0x01 << 7,
-    "ts2g": 0x03 << 8,
-    "diss2g": 0x01 << 10,
-    "slpl": 0x03 << 12,
-    "slph": 0x03 << 14,
-    "tst": 0x01 << 16
-}
-
-Fields["READRSP@RDSEL0"] = {
-    "stallguard": 0x01 << 4,
-    "ot": 0x01 << 5,
-    "otpw": 0x01 << 6,
-    "s2ga": 0x01 << 7,
-    "s2gb": 0x01 << 8,
-    "ola": 0x01 << 9,
-    "olb": 0x01 << 10,
-    "stst": 0x01 << 11,
-    "mstep": 0x3ff << 14
-}
-
-Fields["READRSP@RDSEL1"] = {
-    "stallguard": 0x01 << 4,
-    "ot": 0x01 << 5,
-    "otpw": 0x01 << 6,
-    "s2ga": 0x01 << 7,
-    "s2gb": 0x01 << 8,
-    "ola": 0x01 << 9,
-    "olb": 0x01 << 10,
-    "stst": 0x01 << 11,
-    "sg_result": 0x3ff << 14
-}
-
-Fields["READRSP@RDSEL2"] = {
-    "stallguard": 0x01 << 4,
-    "ot": 0x01 << 5,
-    "otpw": 0x01 << 6,
-    "s2ga": 0x01 << 7,
-    "s2gb": 0x01 << 8,
-    "ola": 0x01 << 9,
-    "olb": 0x01 << 10,
-    "stst": 0x01 << 11,
-    "se": 0x1f << 14,
-    "sg_result@rdsel2": 0x1f << 19
-}
-
-SignedFields = ["sgt"]
-
-FieldFormatters = dict(tmc2130.FieldFormatters)
-FieldFormatters.update({
-    "chm": (lambda v: "1(constant toff)" if v else "0(spreadCycle)"),
-    "vsense": (lambda v: "1(165mV)" if v else "0(305mV)"),
-    "sdoff": (lambda v: "1(Step/Dir disabled!)" if v else ""),
-    "diss2g": (lambda v: "1(Short to GND disabled!)" if v else ""),
-    "se": (lambda v: ("%d" % v) if v else "0(Reset?)"),
-})
-
-
-######################################################################
-# TMC stepper current config helper
-######################################################################
-
-MAX_CURRENT = 2.400
-
-class TMC2660CurrentHelper:
-    def __init__(self, config, mcu_tmc):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.mcu_tmc = mcu_tmc
-        self.fields = mcu_tmc.get_fields()
-        self.current = config.getfloat('run_current', minval=0.1,
-                                       maxval=MAX_CURRENT)
-        self.sense_resistor = config.getfloat('sense_resistor')
-        vsense, cs = self._calc_current(self.current)
-        self.fields.set_field("cs", cs)
-        self.fields.set_field("vsense", vsense)
-
-        # Register ready/printing handlers
-        self.idle_current_percentage = config.getint(
-            'idle_current_percent', default=100, minval=0, maxval=100)
-        if self.idle_current_percentage < 100:
-            self.printer.register_event_handler("idle_timeout:printing",
-                                                self._handle_printing)
-            self.printer.register_event_handler("idle_timeout:ready",
-                                                self._handle_ready)
-
-    def _calc_current_bits(self, current, vsense):
-        vref = 0.165 if vsense else 0.310
-        sr = self.sense_resistor
-        cs = int(32. * sr * current * math.sqrt(2.) / vref + .5) - 1
-        return max(0, min(31, cs))
-
-    def _calc_current_from_bits(self, cs, vsense):
-        vref = 0.165 if vsense else 0.310
-        return (cs + 1) * vref / (32. * self.sense_resistor * math.sqrt(2.))
-
-    def _calc_current(self, run_current):
-        vsense = True
-        irun = self._calc_current_bits(run_current, True)
-        if irun == 31:
-            cur = self._calc_current_from_bits(irun, True)
-            if cur < run_current:
-                irun2 = self._calc_current_bits(run_current, False)
-                cur2 = self._calc_current_from_bits(irun2, False)
-                if abs(run_current - cur2) < abs(run_current - cur):
-                    vsense = False
-                    irun = irun2
-        return vsense, irun
-
-    def _handle_printing(self, print_time):
-        print_time -= 0.100 # Schedule slightly before deadline
-        self.printer.get_reactor().register_callback(
-            (lambda ev: self._update_current(self.current, print_time)))
-
-    def _handle_ready(self, print_time):
-        current = self.current * float(self.idle_current_percentage) / 100.
-        self.printer.get_reactor().register_callback(
-            (lambda ev: self._update_current(current, print_time)))
-
-    def _update_current(self, current, print_time):
-        vsense, cs = self._calc_current(current)
-        val = self.fields.set_field("cs", cs)
-        self.mcu_tmc.set_register("SGCSCONF", val, print_time)
-        # Only update VSENSE if we need to
-        if vsense != self.fields.get_field("vsense"):
-            val = self.fields.set_field("vsense", vsense)
-            self.mcu_tmc.set_register("DRVCONF", val, print_time)
-
-    def get_current(self):
-        return self.current, None, None, MAX_CURRENT
-
-    def set_current(self, run_current, hold_current, print_time):
-        self.current = run_current
-        self._update_current(run_current, print_time)
-
-
-######################################################################
-# TMC2660 SPI
-######################################################################
-
-# Helper code for working with TMC2660 devices via SPI
-class MCU_TMC2660_SPI:
-    def __init__(self, config, name_to_reg, fields):
-        self.printer = config.get_printer()
-        self.mutex = self.printer.get_reactor().mutex()
-        self.spi = bus.MCU_SPI_from_config(config, 0, default_speed=4000000)
-        self.name_to_reg = name_to_reg
-        self.fields = fields
-    def get_fields(self):
-        return self.fields
-    def get_register(self, reg_name):
-        new_rdsel = ReadRegisters.index(reg_name)
-        reg = self.name_to_reg["DRVCONF"]
-        if self.printer.get_start_args().get('debugoutput') is not None:
-            return 0
-        with self.mutex:
-            old_rdsel = self.fields.get_field("rdsel")
-            val = self.fields.set_field("rdsel", new_rdsel)
-            msg = [((val >> 16) | reg) & 0xff, (val >> 8) & 0xff, val & 0xff]
-            if new_rdsel != old_rdsel:
-                # Must set RDSEL value first
-                self.spi.spi_send(msg)
-            params = self.spi.spi_transfer(msg)
-        pr = bytearray(params['response'])
-        return (pr[0] << 16) | (pr[1] << 8) | pr[2]
-    def set_register(self, reg_name, val, print_time=None):
-        minclock = 0
-        if print_time is not None:
-            minclock = self.spi.get_mcu().print_time_to_clock(print_time)
-        reg = self.name_to_reg[reg_name]
-        msg = [((val >> 16) | reg) & 0xff, (val >> 8) & 0xff, val & 0xff]
-        with self.mutex:
-            self.spi.spi_send(msg, minclock)
-
-
-######################################################################
-# TMC2660 printer object
-######################################################################
-
-class TMC2660:
-    def __init__(self, config):
-        # Setup mcu communication
-        self.fields = tmc.FieldHelper(Fields, SignedFields, FieldFormatters)
-        self.fields.set_field("sdoff", 0) # Access DRVCTRL in step/dir mode
-        self.mcu_tmc = MCU_TMC2660_SPI(config, Registers, self.fields)
-        # Register commands
-        current_helper = TMC2660CurrentHelper(config, self.mcu_tmc)
-        cmdhelper = tmc.TMCCommandHelper(config, self.mcu_tmc, current_helper)
-        cmdhelper.setup_register_dump(ReadRegisters)
-        self.get_phase_offset = cmdhelper.get_phase_offset
-        self.get_status = cmdhelper.get_status
-
-        # CHOPCONF
-        set_config_field = self.fields.set_config_field
-        set_config_field(config, "tbl", 2)
-        set_config_field(config, "rndtf", 0)
-        set_config_field(config, "hdec", 0)
-        set_config_field(config, "chm", 0)
-        set_config_field(config, "hend", 3)
-        set_config_field(config, "hstrt", 3)
-        set_config_field(config, "toff", 4)
-        if not self.fields.get_field("chm"):
-            if (self.fields.get_field("hstrt") +
-                self.fields.get_field("hend")) > 15:
-                raise config.error("driver_HEND + driver_HSTRT must be <= 15")
-        # SMARTEN
-        set_config_field(config, "seimin", 0)
-        set_config_field(config, "sedn", 0)
-        set_config_field(config, "semax", 0)
-        set_config_field(config, "seup", 0)
-        set_config_field(config, "semin", 0)
-
-        # SGSCONF
-        set_config_field(config, "sfilt", 0)
-        set_config_field(config, "sgt", 0)
-
-        # DRVCONF
-        set_config_field(config, "slph", 0)
-        set_config_field(config, "slpl", 0)
-        set_config_field(config, "diss2g", 0)
-        set_config_field(config, "ts2g", 3)
-
-def load_config_prefix(config):
-    return TMC2660(config)
deleted file mode 100644
--- a/klippy/extras/tmc5160.py
+++ /dev/null
@@ -1,362 +0,0 @@
-# TMC5160 configuration
-#
-# Copyright (C) 2018-2019  Kevin O'Connor <kevin@koconnor.net>
-#
-# This file may be distributed under the terms of the GNU GPLv3 license.
-import math, logging
-from . import bus, tmc, tmc2130
-
-TMC_FREQUENCY=12000000.
-
-Registers = {
-    "GCONF":            0x00,
-    "GSTAT":            0x01,
-    "IFCNT":            0x02,
-    "SLAVECONF":        0x03,
-    "IOIN":             0x04,
-    "X_COMPARE":        0x05,
-    "OTP_READ":         0x07,
-    "FACTORY_CONF":     0x08,
-    "SHORT_CONF":       0x09,
-    "DRV_CONF":         0x0A,
-    "GLOBALSCALER":     0x0B,
-    "OFFSET_READ":      0x0C,
-    "IHOLD_IRUN":       0x10,
-    "TPOWERDOWN":       0x11,
-    "TSTEP":            0x12,
-    "TPWMTHRS":         0x13,
-    "TCOOLTHRS":        0x14,
-    "THIGH":            0x15,
-    "RAMPMODE":         0x20,
-    "XACTUAL":          0x21,
-    "VACTUAL":          0x22,
-    "VSTART":           0x23,
-    "A1":               0x24,
-    "V1":               0x25,
-    "AMAX":             0x26,
-    "VMAX":             0x27,
-    "DMAX":             0x28,
-    "D1":               0x2A,
-    "VSTOP":            0x2B,
-    "TZEROWAIT":        0x2C,
-    "XTARGET":          0x2D,
-    "VDCMIN":           0x33,
-    "SW_MODE":          0x34,
-    "RAMP_STAT":        0x35,
-    "XLATCH":           0x36,
-    "ENCMODE":          0x38,
-    "X_ENC":            0x39,
-    "ENC_CONST":        0x3A,
-    "ENC_STATUS":       0x3B,
-    "ENC_LATCH":        0x3C,
-    "ENC_DEVIATION":    0x3D,
-    "MSLUT0":           0x60,
-    "MSLUT1":           0x61,
-    "MSLUT2":           0x62,
-    "MSLUT3":           0x63,
-    "MSLUT4":           0x64,
-    "MSLUT5":           0x65,
-    "MSLUT6":           0x66,
-    "MSLUT7":           0x67,
-    "MSLUTSEL":         0x68,
-    "MSLUTSTART":       0x69,
-    "MSCNT":            0x6A,
-    "MSCURACT":         0x6B,
-    "CHOPCONF":         0x6C,
-    "COOLCONF":         0x6D,
-    "DCCTRL":           0x6E,
-    "DRV_STATUS":       0x6F,
-    "PWMCONF":          0x70,
-    "PWM_SCALE":        0x71,
-    "PWM_AUTO":         0x72,
-    "LOST_STEPS":       0x73,
-}
-
-ReadRegisters = [
-    "GCONF", "CHOPCONF", "GSTAT", "DRV_STATUS", "FACTORY_CONF", "IOIN",
-    "LOST_STEPS", "MSCNT", "MSCURACT", "OTP_READ", "PWM_SCALE",
-    "PWM_AUTO", "TSTEP"
-]
-
-Fields = {}
-Fields["COOLCONF"] = {
-    "semin":                    0x0F << 0,
-    "seup":                     0x03 << 5,
-    "semax":                    0x0F << 8,
-    "sedn":                     0x03 << 13,
-    "seimin":                   0x01 << 15,
-    "sgt":                      0x7F << 16,
-    "sfilt":                    0x01 << 24
-}
-Fields["CHOPCONF"] = {
-    "toff":                     0x0F << 0,
-    "hstrt":                    0x07 << 4,
-    "hend":                     0x0F << 7,
-    "fd3":                      0x01 << 11,
-    "disfdcc":                  0x01 << 12,
-    "chm":                      0x01 << 14,
-    "tbl":                      0x03 << 15,
-    "vhighfs":                  0x01 << 18,
-    "vhighchm":                 0x01 << 19,
-    "tpfd":                     0x0F << 20, # midrange resonances
-    "mres":                     0x0F << 24,
-    "intpol":                   0x01 << 28,
-    "dedge":                    0x01 << 29,
-    "diss2g":                   0x01 << 30,
-    "diss2vs":                  0x01 << 31
-}
-Fields["DRV_STATUS"] = {
-    "sg_result":                0x3FF << 0,
-    "s2vsa":                    0x01 << 12,
-    "s2vsb":                    0x01 << 13,
-    "stealth":                  0x01 << 14,
-    "fsactive":                 0x01 << 15,
-    "csactual":                 0xFF << 16,
-    "stallguard":               0x01 << 24,
-    "ot":                       0x01 << 25,
-    "otpw":                     0x01 << 26,
-    "s2ga":                     0x01 << 27,
-    "s2gb":                     0x01 << 28,
-    "ola":                      0x01 << 29,
-    "olb":                      0x01 << 30,
-    "stst":                     0x01 << 31
-}
-Fields["FACTORY_CONF"] = {
-    "factory_conf":             0x1F << 0
-}
-Fields["GCONF"] = {
-    "recalibrate":              0x01 << 0,
-    "faststandstill":           0x01 << 1,
-    "en_pwm_mode":              0x01 << 2,
-    "multistep_filt":           0x01 << 3,
-    "shaft":                    0x01 << 4,
-    "diag0_error":              0x01 << 5,
-    "diag0_otpw":               0x01 << 6,
-    "diag0_stall":              0x01 << 7,
-    "diag1_stall":              0x01 << 8,
-    "diag1_index":              0x01 << 9,
-    "diag1_onstate":            0x01 << 10,
-    "diag1_steps_skipped":      0x01 << 11,
-    "diag0_int_pushpull":       0x01 << 12,
-    "diag1_poscomp_pushpull":   0x01 << 13,
-    "small_hysteresis":         0x01 << 14,
-    "stop_enable":              0x01 << 15,
-    "direct_mode":              0x01 << 16,
-    "test_mode":                0x01 << 17
-}
-Fields["GSTAT"] = {
-    "reset":                    0x01 << 0,
-    "drv_err":                  0x01 << 1,
-    "uv_cp":                    0x01 << 2
-}
-Fields["GLOBALSCALER"] = {
-    "globalscaler":             0xFF << 0
-}
-Fields["IHOLD_IRUN"] = {
-    "ihold":                    0x1F << 0,
-    "irun":                     0x1F << 8,
-    "iholddelay":               0x0F << 16
-}
-Fields["IOIN"] = {
-    "refl_step":                0x01 << 0,
-    "refr_dir":                 0x01 << 1,
-    "encb_dcen_cfg4":           0x01 << 2,
-    "enca_dcin_cfg5":           0x01 << 3,
-    "drv_enn":                  0x01 << 4,
-    "enc_n_dco_cfg6":           0x01 << 5,
-    "sd_mode":                  0x01 << 6,
-    "swcomp_in":                0x01 << 7,
-    "version":                  0xFF << 24
-}
-Fields["LOST_STEPS"] = {
-    "lost_steps":               0xfffff << 0
-}
-Fields["MSLUT0"] = { "mslut0": 0xffffffff }
-Fields["MSLUT1"] = { "mslut1": 0xffffffff }
-Fields["MSLUT2"] = { "mslut2": 0xffffffff }
-Fields["MSLUT3"] = { "mslut3": 0xffffffff }
-Fields["MSLUT4"] = { "mslut4": 0xffffffff }
-Fields["MSLUT5"] = { "mslut5": 0xffffffff }
-Fields["MSLUT6"] = { "mslut6": 0xffffffff }
-Fields["MSLUT7"] = { "mslut7": 0xffffffff }
-Fields["MSLUTSEL"] = {
-    "x3":                       0xFF << 24,
-    "x2":                       0xFF << 16,
-    "x1":                       0xFF << 8,
-    "w3":                       0x03 << 6,
-    "w2":                       0x03 << 4,
-    "w1":                       0x03 << 2,
-    "w0":                       0x03 << 0,
-}
-Fields["MSLUTSTART"] = {
-    "start_sin":                0xFF << 0,
-    "start_sin90":              0xFF << 16,
-}
-Fields["MSCNT"] = {
-    "mscnt":                    0x3ff << 0
-}
-Fields["MSCURACT"] = {
-    "cur_a":                    0x1ff << 0,
-    "cur_b":                    0x1ff << 16
-}
-Fields["OTP_READ"] = {
-    "otp_fclktrim":             0x1f << 0,
-    "otp_s2_level":             0x01 << 5,
-    "otp_bbm":                  0x01 << 6,
-    "otp_tbl":                  0x01 << 7
-}
-Fields["PWM_AUTO"] = {
-    "pwm_ofs_auto":             0xff << 0,
-    "pwm_grad_auto":            0xff << 16
-}
-Fields["PWMCONF"] = {
-    "pwm_ofs":                  0xFF << 0,
-    "pwm_grad":                 0xFF << 8,
-    "pwm_freq":                 0x03 << 16,
-    "pwm_autoscale":            0x01 << 18,
-    "pwm_autograd":             0x01 << 19,
-    "freewheel":                0x03 << 20,
-    "pwm_reg":                  0x0F << 24,
-    "pwm_lim":                  0x0F << 28
-}
-Fields["PWM_SCALE"] = {
-    "pwm_scale_sum":            0xff << 0,
-    "pwm_scale_auto":           0x1ff << 16
-}
-Fields["TPOWERDOWN"] = {
-    "tpowerdown":               0xff << 0
-}
-Fields["TPWMTHRS"] = {
-    "tpwmthrs":                 0xfffff << 0
-}
-Fields["TCOOLTHRS"] = {
-    "tcoolthrs":                0xfffff << 0
-}
-Fields["TSTEP"] = {
-    "tstep":                    0xfffff << 0
-}
-
-SignedFields = ["cur_a", "cur_b", "sgt", "xactual", "vactual", "pwm_scale_auto"]
-
-FieldFormatters = dict(tmc2130.FieldFormatters)
-
-
-######################################################################
-# TMC stepper current config helper
-######################################################################
-
-VREF = 0.325
-MAX_CURRENT = 3.000
-
-class TMC5160CurrentHelper:
-    def __init__(self, config, mcu_tmc):
-        self.printer = config.get_printer()
-        self.name = config.get_name().split()[-1]
-        self.mcu_tmc = mcu_tmc
-        self.fields = mcu_tmc.get_fields()
-        run_current = config.getfloat('run_current',
-                                      above=0., maxval=MAX_CURRENT)
-        hold_current = config.getfloat('hold_current', MAX_CURRENT,
-                                       above=0., maxval=MAX_CURRENT)
-        self.req_hold_current = hold_current
-        self.sense_resistor = config.getfloat('sense_resistor', 0.075, above=0.)
-        self._set_globalscaler(run_current)
-        irun, ihold = self._calc_current(run_current, hold_current)
-        self.fields.set_field("ihold", ihold)
-        self.fields.set_field("irun", irun)
-    def _set_globalscaler(self, current):
-        globalscaler = int((current * 256. * math.sqrt(2.)
-                            * self.sense_resistor / VREF) + .5)
-        globalscaler = max(32, globalscaler)
-        if globalscaler >= 256:
-            globalscaler = 0
-        self.fields.set_field("globalscaler", globalscaler)
-    def _calc_current_bits(self, current):
-        globalscaler = self.fields.get_field("globalscaler")
-        if not globalscaler:
-            globalscaler = 256
-        cs = int((current * 256. * 32. * math.sqrt(2.) * self.sense_resistor)
-                 / (globalscaler * VREF)
-                 - 1. + .5)
-        return max(0, min(31, cs))
-    def _calc_current(self, run_current, hold_current):
-        irun = self._calc_current_bits(run_current)
-        ihold = self._calc_current_bits(min(hold_current, run_current))
-        return irun, ihold
-    def _calc_current_from_field(self, field_name):
-        globalscaler = self.fields.get_field("globalscaler")
-        if not globalscaler:
-            globalscaler = 256
-        bits = self.fields.get_field(field_name)
-        return (globalscaler * (bits + 1) * VREF
-                / (256. * 32. * math.sqrt(2.) * self.sense_resistor))
-    def get_current(self):
-        run_current = self._calc_current_from_field("irun")
-        hold_current = self._calc_current_from_field("ihold")
-        return run_current, hold_current, self.req_hold_current, MAX_CURRENT
-    def set_current(self, run_current, hold_current, print_time):
-        self.req_hold_current = hold_current
-        irun, ihold = self._calc_current(run_current, hold_current)
-        self.fields.set_field("ihold", ihold)
-        val = self.fields.set_field("irun", irun)
-        self.mcu_tmc.set_register("IHOLD_IRUN", val, print_time)
-
-
-######################################################################
-# TMC5160 printer object
-######################################################################
-
-class TMC5160:
-    def __init__(self, config):
-        # Setup mcu communication
-        self.fields = tmc.FieldHelper(Fields, SignedFields, FieldFormatters)
-        self.mcu_tmc = tmc2130.MCU_TMC_SPI(config, Registers, self.fields)
-        # Allow virtual pins to be created
-        tmc.TMCVirtualPinHelper(config, self.mcu_tmc)
-        # Register commands
-        current_helper = TMC5160CurrentHelper(config, self.mcu_tmc)
-        cmdhelper = tmc.TMCCommandHelper(config, self.mcu_tmc, current_helper)
-        cmdhelper.setup_register_dump(ReadRegisters)
-        self.get_phase_offset = cmdhelper.get_phase_offset
-        self.get_status = cmdhelper.get_status
-        # Setup basic register values
-        tmc.TMCWaveTableHelper(config, self.mcu_tmc)
-        tmc.TMCStealthchopHelper(config, self.mcu_tmc, TMC_FREQUENCY)
-        #   CHOPCONF
-        set_config_field = self.fields.set_config_field
-        set_config_field(config, "toff", 3)
-        set_config_field(config, "hstrt", 5)
-        set_config_field(config, "hend", 2)
-        set_config_field(config, "fd3", 0)
-        set_config_field(config, "disfdcc", 0)
-        set_config_field(config, "chm", 0)
-        set_config_field(config, "tbl", 2)
-        set_config_field(config, "vhighfs", 0)
-        set_config_field(config, "vhighchm", 0)
-        set_config_field(config, "tpfd", 4)
-        set_config_field(config, "diss2g", 0)
-        set_config_field(config, "diss2vs", 0)
-        #   COOLCONF
-        set_config_field(config, "semin", 0)    # page 52
-        set_config_field(config, "seup", 0)
-        set_config_field(config, "semax", 0)
-        set_config_field(config, "sedn", 0)
-        set_config_field(config, "seimin", 0)
-        set_config_field(config, "sgt", 0)
-        set_config_field(config, "sfilt", 0)
-        #   IHOLDIRUN
-        set_config_field(config, "iholddelay", 6)
-        #   PWMCONF
-        set_config_field(config, "pwm_ofs", 30)
-        set_config_field(config, "pwm_grad", 0)
-        set_config_field(config, "pwm_freq", 0)
-        set_config_field(config, "pwm_autoscale", True)
-        set_config_field(config, "pwm_autograd", True)
-        set_config_field(config, "freewheel", 0)
-        set_config_field(config, "pwm_reg", 4)
-        set_config_field(config, "pwm_lim", 12)
-        #   TPOWERDOWN
-        set_config_field(config, "tpowerdown", 10)
-
-def load_config_prefix(config):
-    return TMC5160(config)
